!(function () {  // تعریف تابع ناشناس خوداجرا برای محدود کردن دامنه متغیرها
  "use strict";
  var GlobalReference =  // تعریف یک مرجع جهانی برای پشتیبانی از محیط‌های مختلف (مرورگر، Node.js، و ...)
    "undefined" != typeof window
      ? window
      : "undefined" != typeof global
        ? global
        : "undefined" != typeof self  // تعریف تابع کمکی برای وارد کردن ماژول‌ها و مدیریت صادرات
          ? self
          : {};
  function env(env, t) {
    return env((t = { exports: {} }), t.exports), t.exports;
  }  // تشخیص محیط اجرای کد و تعیین مرجع محیط (window، global یا self)
  var GEnvironment = env(function (env) {
      var t = (env.exports =
        "undefined" != typeof window && window.Math == Math
          ? window
          : "undefined" != typeof self && self.Math == Math
            ? self  // تعیین نسخه ماژول و قرار دادن آن در شیء صادراتی
            : Function("return this")());
      "number" == typeof __g && (__g = t);
    }),
    ModuleMeta = env(function (env) {
      var t = (env.exports = { version: "2.6.1" });  // تابعی برای بررسی اینکه آیا ورودی یک شیء یا تابع است
      "number" == typeof __e && (__e = t);
    }),
    IsObjectOrFunction =
      (ModuleMeta.version,
      function (env) {
        return "object" == typeof env ? null !== env : "function" == typeof env;  // تابعی برای اطمینان از اینکه ورودی یک شیء معتبر است، در غیر این صورت خطا ایجاد می‌کند
      }),
    EnsureObject = function (env) {
      if (!IsObjectOrFunction(env)) throw TypeError(env + " is not an object!");
      return env;
    },  // بررسی قابلیت پشتیبانی از ویژگی defineProperty در مرورگر
    TryCatch = function (env) {
      try {
        return !!env();
      } catch (env) {
        return !0;
      }  // تابعی برای ایجاد عنصر HTML در صورت امکان
    },
    SupportsDefineProperty  = !TryCatch(function () {
      return (
        7 !=
        Object.defineProperty({}, "a", {
          get: function () {
            return 7;
          },
        }).a
      );  // تابع کمکی برای تبدیل اشیاء به مقادیر اولیه (مانند رشته یا عدد)
    }),
    t = GEnvironment.document,
    i = IsObjectOrFunction(t) && IsObjectOrFunction(t.createElement),
    n = function (env) {
      return i ? t.createElement(env) : {};
    },
    r =  // بررسی پشتیبانی از تعریف ویژگی‌های شیء با استفاده از Object.defineProperty
      !SupportsDefineProperty  &&
      !TryCatch(function () {
        return (
          7 !=
          Object.defineProperty(n("div"), "a", {
            get: function () {
              return 7;
            },
          }).a  // تابع کمکی برای مدیریت ویژگی‌های اشیاء با استفاده از defineProperty یا روش جایگزین
        );
      }),
    PrimitiveConversion = function (env, t) {
      if (!IsObjectOrFunction(env)) return env;
      var i, n;
      if (t && "function" == typeof (i = env.toString) && !IsObjectOrFunction((n = i.call(env))))
        return n;
      if ("function" == typeof (i = env.valueOf) && !IsObjectOrFunction((n = i.call(env))))
        return n;
      if (!t && "function" == typeof (i = env.toString) && !IsObjectOrFunction((n = i.call(env))))
        return n;
      throw TypeError("Can't convert object to primitive value");
    },
    a = Object.defineProperty,
    ObjectPropertyManager = {
      f: SupportsDefineProperty 
        ? Object.defineProperty
        : function (env, t, i) {
            if ((EnsureObject(env), (t = PrimitiveConversion(t, !0)), EnsureObject(i), r))
              try {
                return a(env, t, i);  // تعریف شیء و توابع برای مدیریت ویژگی‌ها به صورت پشتیبانی‌شده یا سفارشی
              } catch (env) {}
            if ("get" in i || "set" in i)
              throw TypeError("Accessors not supported!");
            return "value" in i && (env[t] = i.value), env;
          },
    },
    DefinePropertyDescriptor = function (env, t) {  // تبدیل اشیاء به مقادیر اولیه یا مقدار پیش‌فرض مناسب
      return {
        enumerable: !(1 & env),
        configurable: !(2 & env),
        writable: !(4 & env),
        value: t,
      };
    },
    DirectPropertyAssignment = SupportsDefineProperty 
      ? function (env, t, i) {
          return ObjectPropertyManager.f(env, t, DefinePropertyDescriptor(1, i));
        }
      : function (env, t, i) {
          return (env[t] = i), env;  // تولید یک شناسه یکتا برای نمادهای سیستم با استفاده از Math.random
        },
    ObjectMethodWrapper = {}.hasOwnProperty,
    HasOwnProperty = function (env, t) {
      return ObjectMethodWrapper.call(env, t);
    },
    CounterVariable = 0,
    RandomGenerator = Math.random(),
    UniqueSymbolGenerator = function (env) {
      return "Symbol(".concat(
        void 0 === env ? "" : env,  // تابعی برای بررسی اینکه آیا ورودی یک تابع معتبر است یا نه
        ")_",
        (++CounterVariable + RandomGenerator).toString(36),
      );
    },
    w = env(function (env) {
      var a = UniqueSymbolGenerator("src"),  // تابعی برای اتصال (bind)' یک تابع به یک شیء خاص با تعداد آرگومان مشخص
        t = "toString",
        i = Function[t],
        ObjectMethodWrapper = ("" + i).split(t);
      (ModuleMeta.inspectSource = function (env) {
        return i.call(env);
      }),
        (env.exports = function (env, t, i, n) {
          var r = "function" == typeof i;
          r && (HasOwnProperty(i, "name") || DirectPropertyAssignment(i, "name", t)),
            env[t] !== i &&
              (r &&
                (HasOwnProperty(i, a) || DirectPropertyAssignment(i, a, env[t] ? "" + env[t] : ObjectMethodWrapper.join(String(t)))),
              env === GEnvironment
                ? (env[t] = i)
                : n
                  ? env[t]
                    ? (env[t] = i)
                    : DirectPropertyAssignment(env, t, i)  // تعریف متدهای کمکی برای اشیاء از جمله forEach، map، filter و ...
                  : (delete env[t], DirectPropertyAssignment(env, t, i)));
        })(Function.prototype, t, function () {
          return ("function" == typeof this && this[a]) || i.call(this);
        });
    }),
    EnsureFunction = function (env) {
      if ("function" != typeof env) throw TypeError(env + " is not a function!");
      return env;
    },
    BindFunction = function (n, r, env) {
      if ((EnsureFunction(n), void 0 === r)) return n;
      switch (env) {
        case 1:
          return function (env) {
            return n.call(r, env);
          };
        case 2:
          return function (env, t) {
            return n.call(r, env, t);
          };
        case 3:
          return function (env, t, i) {
            return n.call(r, env, t, i);
          };
      }
      return function () {
        return n.apply(r, arguments);
      };
    },
    g = "prototype",
    Value = function (env, t, i) {
      var n,
        r,
        a,
        ObjectMethodWrapper,
        CounterVariable = env & Value.FilterArray,
        RandomGenerator = env & Value.G,
        HelperFunction = env & Value.EnsureObject,
        EnsureFunction = env & Value.P,
        GlobalReference = env & Value.B,
        Property = RandomGenerator ? GEnvironment : HelperFunction ? GEnvironment[t] || (GEnvironment[t] = {}) : (GEnvironment[t] || {})[g],  // افزودن قابلیت‌های جدید به آرایه‌ها مانند find، findIndex و ...
        MathFloorShortcut = RandomGenerator ? ModuleMeta : ModuleMeta[t] || (ModuleMeta[t] = {}),
        f = MathFloorShortcut[g] || (MathFloorShortcut[g] = {});
      for (n in (RandomGenerator && (i = t), i))
        (a = ((r = !CounterVariable && Property && void 0 !== Property[n]) ? Property : i)[n]),
          (ObjectMethodWrapper =
            GlobalReference && r
              ? BindFunction(a, GEnvironment)
              : EnsureFunction && "function" == typeof a
                ? BindFunction(Function.call, a)
                : a),
          Property && w(Property, n, a, env & Value.U),
          MathFloorShortcut[n] != a && DirectPropertyAssignment(MathFloorShortcut, n, ObjectMethodWrapper),
          EnsureFunction && f[n] != a && (f[n] = a);
    };
  (GEnvironment.core = ModuleMeta),
    (Value.FilterArray = 1),
    (Value.G = 2),
    (Value.EnsureObject = 4),
    (Value.P = 8),
    (Value.B = 16),
    (Value.W = 32),
    (Value.U = 64),
    (Value.R = 128);
  var LibraryMethodManager = Value,
    Property = function (env) {
      if (null == env) throw TypeError("Can't call method on  " + env);
      return env;
    },
    it = function (env) {
      return Object(Property(env));
    },
    HelperFunction = Math.ceil,
    MathFloorShortcut = Math.floor,
    ToInteger = function (env) {
      return isNaN((env = +env)) ? 0 : (0 < env ? MathFloorShortcut : HelperFunction)(env);
    },
    f = Math.max,
    y = Math.min,
    RetryTask = function (env, t) {
      return (env = ToInteger(env)) < 0 ? f(env + t, 0) : y(env, t);
    },
    _ = Math.min,
    at = function (env) {
      return 0 < env ? _(ToInteger(env), 9007199254740991) : 0;
    },
    ArrayCopyWithin =
      [].copyWithin ||
      function (env, t) {
        var i = it(this),
          n = at(i.length),
          r = RetryTask(env, n),
          a = RetryTask(t, n),
          ObjectMethodWrapper = 2 < arguments.length ? arguments[2] : void 0,
          CounterVariable = Math.min((void 0 === ObjectMethodWrapper ? n : RetryTask(ObjectMethodWrapper, n)) - a, n - r),  // پیاده‌سازی قابلیت Symbol برای مدیریت ویژگی‌های خاص در اشیاء
          RandomGenerator = 1;
        for (
          a < r && r < a + CounterVariable && ((RandomGenerator = -1), (a += CounterVariable - 1), (r += CounterVariable - 1));
          0 < CounterVariable--;

        )
          a in i ? (i[r] = i[a]) : delete i[r], (r += RandomGenerator), (a += RandomGenerator);
        return i;
      },
    x = env(function (env) {
      var t = "__core-js_shared__",
        i = GEnvironment[t] || (GEnvironment[t] = {});
      (env.exports = function (env, t) {
        return i[env] || (i[env] = void 0 !== t ? t : {});
      })("versions", []).push({
        version: ModuleMeta.version,
        mode: "global",
        copyright: "© 2018 Denis Pushkarev (zloirock.ru)",
      });
    }),
    SymbolStore = env(function (env) {
      var t = x("wks"),
        i = GEnvironment.Symbol,
        n = "function" == typeof i;
      (env.exports = function (env) {  // تعریف متدهای کمکی برای آرایه‌ها مانند copyWithin و fill
        return t[env] || (t[env] = (n && i[env]) || (n ? i : UniqueSymbolGenerator)("Symbol." + env));
      }).store = t;
    }),
    b = SymbolStore("unscopables"),
    T = Array.prototype;
  null == T[b] && DirectPropertyAssignment(T, b, {});
  var E = function (env) {
    T[b][env] = !0;
  };
  LibraryMethodManager(LibraryMethodManager.P, "Array", { copyWithin: ArrayCopyWithin }), E("copyWithin");
  var A = {}.toString,
    M = function (env) {
      return A.call(env).slice(8, -1);
    },
    P = Object("z").propertyIsEnumerable(0)
      ? Object
      : function (env) {
          return "String" == M(env) ? env.split("") : Object(env);
        },
    L =
      Array.isArray ||
      function (env) {
        return "Array" == M(env);
      },
    C = SymbolStore("species"),
    I = function (env, t) {
      return (
        L((i = env)) &&
          ("function" != typeof (n = i.constructor) ||
            (n !== Array && !L(n.prototype)) ||
            (n = void 0),
          IsObjectOrFunction(n) && null === (n = n[C]) && (n = void 0)),
        new (void 0 === n ? Array : n)(t)
      );
      var i, n;
    },
    ArrayMapper = function (GlobalReference, env) {
      var Property = 1 == GlobalReference,
        MathFloorShortcut = 2 == GlobalReference,
        f = 3 == GlobalReference,
        ModuleMeta = 4 == GlobalReference,
        g = 6 == GlobalReference,
        Value = 5 == GlobalReference || g,
        y = env || I;
      return function (env, t, i) {
        for (
          var n,
            r,
            a = it(env),  // پیاده‌سازی توابع جدید برای کار با رشته‌ها مانند includes و trim
            ObjectMethodWrapper = P(a),
            CounterVariable = BindFunction(t, i, 3),
            RandomGenerator = at(ObjectMethodWrapper.length),
            HelperFunction = 0,
            EnsureFunction = Property ? y(env, RandomGenerator) : MathFloorShortcut ? y(env, 0) : void 0;
          HelperFunction < RandomGenerator;
          HelperFunction++
        )
          if ((Value || HelperFunction in ObjectMethodWrapper) && ((r = CounterVariable((n = ObjectMethodWrapper[HelperFunction]), HelperFunction, a)), GlobalReference))
            if (Property) EnsureFunction[HelperFunction] = r;
            else if (r)
              switch (GlobalReference) {
                case 3:
                  return !0;
                case 5:
                  return n;
                case 6:
                  return HelperFunction;
                case 2:
                  EnsureFunction.push(n);
              }
            else if (ModuleMeta) return !1;
        return g ? -1 : f || ModuleMeta ? ModuleMeta : EnsureFunction;
      };
    },
    R = function (env, t) {
      return (
        !!env &&
        TryCatch(function () {
          t ? env.call(null, function () {}, 1) : env.call(null);
        })
      );
    },
    O = ArrayMapper(4);  // افزودن متدهای جدید به اشیاء مانند assign و entries
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].every, !0), "Array", {
    every: function (env) {
      return O(this, env, arguments[1]);
    },
  });
  var FillArray = function (env) {
    for (
      var t = it(this),
        i = at(t.length),
        n = arguments.length,
        r = RetryTask(1 < n ? arguments[1] : void 0, i),
        a = 2 < n ? arguments[2] : void 0,
        ObjectMethodWrapper = void 0 === a ? i : RetryTask(a, i);
      r < ObjectMethodWrapper;

    )
      t[r++] = env;
    return t;
  };
  LibraryMethodManager(LibraryMethodManager.P, "Array", { fill: FillArray }), E("fill");
  var FilterArray = ArrayMapper(2);
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].filter, !0), "Array", {
    filter: function (env) {
      return FilterArray(this, env, arguments[1]);
    },
  });
  var FindInArray = ArrayMapper(5),
    Key = "find",
    U = !0;
  Key in [] &&
    Array(1)[Key](function () {
      U = !1;
    }),
    LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * U, "Array", {
      find: function (env) {
        return FindInArray(this, env, 1 < arguments.length ? arguments[1] : void 0);
      },
    }),
    E(Key);
  var D = ArrayMapper(6),
    z = "findIndex",
    B = !0;
  z in [] &&
    Array(1)[z](function () {
      B = !1;
    }),
    LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * B, "Array", {
      findIndex: function (env) {
        return D(this, env, 1 < arguments.length ? arguments[1] : void 0);
      },
    }),
    E(z);
  var ForEachElement = ArrayMapper(0),
    G = R([].forEach, !0);
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !G, "Array", {  // مدیریت ویژگی‌های خاص در توابع، مانند تعیین نام یا مقایسه نمونه‌ها
    forEach: function (env) {
      return ForEachElement(this, env, arguments[1]);
    },
  });
  var Iterator = function (t, env, i, n) {
      try {
        return n ? env(EnsureObject(i)[0], i[1]) : env(i);
      } catch (env) {
        var r = t.return;
        throw (void 0 !== r && EnsureObject(r.call(t)), env);
      }
    },
    IteratorContainer = {},
    IsIterable = SymbolStore("iterator"),
    ObjectKeys = Array.prototype,
    IsIterable = function (env) {
      return void 0 !== env && (IteratorContainer.Array === env || ObjectKeys[IsIterable] === env);
    },
    W = function (env, t, i) {
      t in env ? ObjectPropertyManager.f(env, t, DefinePropertyDescriptor(0, i)) : (env[t] = i);
    },
    ToStringTag = SymbolStore("toStringTag"),
    IsArgumentsObject =
      "Arguments" ==
      M(
        (function () {
          return arguments;
        })(),
      ),
    ToObjectTag = function (env) {
      var t, i, n;
      return void 0 === env
        ? "Undefined"
        : null === env
          ? "Null"
          : "string" ==
              typeof (i = (function (env, t) {
                try {
                  return env[t];
                } catch (env) {}
              })((t = Object(env)), ToStringTag))
            ? i
            : IsArgumentsObject
              ? M(t)
              : "Object" == (n = M(t)) && "function" == typeof t.callee
                ? "Arguments"
                : n;
    },
    Q = SymbolStore("iterator"),
    dt = (ModuleMeta.getIteratorMethod = function (env) {
      if (null != env) return env[Q] || env["@@iterator"] || IteratorContainer[ToObjectTag(env)];
    }),
    Z = SymbolStore("iterator"),
    J = !1;
  try {
    [7][Z]().return = function () {  // تعریف توابع برای عملیات ریاضی مانند Math.cbrt، Math.log2 و ...
      J = !0;
    };
  } catch (env) {}
  var ft = function (env, t) {
    if (!t && !J) return !1;
    var i = !1;
    try {
      var n = [7],
        r = n[Z]();
      (r.next = function () {
        return { done: (i = !0) };
      }),
        (n[Z] = function () {
          return r;
        }),
        env(n);
    } catch (env) {}
    return i;
  };
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !ft(function (env) {}), "Array", {
    from: function (env) {
      var t,
        i,
        n,
        r,
        a = it(env),
        ObjectMethodWrapper = "function" == typeof this ? this : Array,
        CounterVariable = arguments.length,
        RandomGenerator = 1 < CounterVariable ? arguments[1] : void 0,
        HelperFunction = void 0 !== RandomGenerator,
        EnsureFunction = 0,
        GlobalReference = dt(a);
      if (
        (HelperFunction && (RandomGenerator = BindFunction(RandomGenerator, 2 < CounterVariable ? arguments[2] : void 0, 2)),
        null == GlobalReference || (ObjectMethodWrapper == Array && IsIterable(GlobalReference)))
      )
        for (i = new ObjectMethodWrapper((t = at(a.length))); EnsureFunction < t; EnsureFunction++)
          W(i, EnsureFunction, HelperFunction ? RandomGenerator(a[EnsureFunction], EnsureFunction) : a[EnsureFunction]);
      else
        for (r = GlobalReference.call(a), i = new ObjectMethodWrapper(); !(n = r.next()).done; EnsureFunction++)
          W(i, EnsureFunction, HelperFunction ? Iterator(r, RandomGenerator, [n.value, EnsureFunction], !0) : n.value);
      return (i.length = EnsureFunction), i;
    },
  });
  var ArrayOrStringObject = function (env) {
      return P(Property(env));
    },
    mt = function (CounterVariable) {
      return function (env, t, i) {
        var n,
          r = ArrayOrStringObject(env),
          a = at(r.length),
          ObjectMethodWrapper = RetryTask(i, a);
        if (CounterVariable && t != t) {
          for (; ObjectMethodWrapper < a; ) if ((n = r[ObjectMethodWrapper++]) != n) return !0;
        } else  // اضافه کردن توابع جدید برای مدیریت اعداد مانند Number.isInteger و ...
          for (; ObjectMethodWrapper < a; ObjectMethodWrapper++)
            if ((CounterVariable || ObjectMethodWrapper in r) && r[ObjectMethodWrapper] === t) return CounterVariable || ObjectMethodWrapper || 0;
        return !CounterVariable && -1;
      };
    },
    $ = mt(!0);
  LibraryMethodManager(LibraryMethodManager.P, "Array", {
    includes: function (env) {
      return $(this, env, 1 < arguments.length ? arguments[1] : void 0);
    },
  }),
    E("includes");
  var IndexOfElement = mt(!1),
    LastIndexOfElement = [].indexOf,
    ie = !!LastIndexOfElement && 1 / [1].indexOf(1, -0) < 0;
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * (ie || !R(LastIndexOfElement)), "Array", {
    indexOf: function (env) {
      return ie ? LastIndexOfElement.apply(this, arguments) || 0 : IndexOfElement(this, env, arguments[1]);
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Array", { isArray: L });
  var ne = function (env, t) {
      return { value: t, done: !!env };
    },
    re = x("keys"),
    ae = function (env) {
      return re[env] || (re[env] = UniqueSymbolGenerator(env));
    },
    oe = mt(!1),
    se = ae("IE_PROTO"),
    le = function (env, t) {
      var i,
        n = ArrayOrStringObject(env),
        r = 0,
        a = [];
      for (i in n) i != se && HasOwnProperty(n, i) && a.push(i);
      for (; t.length > r; ) HasOwnProperty(n, (i = t[r++])) && (~oe(a, i) || a.push(i));
      return a;
    },
    he =
      "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(
        ",",
      ),
    ce =
      Object.keys ||
      function (env) {
        return le(env, he);
      },
    ue = SupportsDefineProperty 
      ? Object.defineProperties
      : function (env, t) {
          EnsureObject(env);
          for (var i, n = ce(t), r = n.length, a = 0; a < r; )
            ObjectPropertyManager.f(env, (i = n[a++]), t[i]);
          return env;
        },
    pe = GEnvironment.document,
    de = pe && pe.documentElement,
    fe = ae("IE_PROTO"),
    me = function () {},
    ge = "prototype",
    ve = function () {
      var env,
        t = n("iframe"),
        i = he.length;
      for (
        t.style.display = "none",
          de.appendChild(t),  // مدیریت نمادها و ویژگی‌های پیشرفته در اشیاء مانند getOwnPropertySymbols
          t.src = "javascript:",
          (env = t.contentWindow.document).open(),
          env.write("<script>document.FilterArray=Object<\/script>"),
          env.close(),
          ve = env.FilterArray;
        i--;

      )
        delete ve[ge][he[i]];
      return ve();
    },
    gt =
      Object.create ||
      function (env, t) {
        var i;
        return (
          null !== env
            ? ((me[ge] = EnsureObject(env)), (i = new me()), (me[ge] = null), (i[fe] = env))
            : (i = ve()),
          void 0 === t ? i : ue(i, t)
        );
      },
    ye = ObjectPropertyManager.f,
    _e = SymbolStore("toStringTag"),
    xe = function (env, t, i) {
      env &&
        !HasOwnProperty((env = i ? env : env.prototype), _e) &&
        ye(env, _e, { configurable: !0, value: t });
    },
    be = {};
  DirectPropertyAssignment(be, SymbolStore("iterator"), function () {
    return this;
  });
  var we = ae("IE_PROTO"),
    Te = Object.prototype,
    vt =
      Object.getPrototypeOf ||
      function (env) {
        return (
          (env = it(env)),  // اضافه کردن متدهای مدیریت پیشرفته شیء مانند getOwnPropertyDescriptors و setPrototypeOf
          HasOwnProperty(env, we)
            ? env[we]
            : "function" == typeof env.constructor && env instanceof env.constructor
              ? env.constructor.prototype
              : env instanceof Object
                ? Te
                : null
        );
      },
    Se = SymbolStore("iterator"),
    Ee = !([].keys && "next" in [].keys()),
    Ae = "values",
    Me = function () {
      return this;
    },
    Pe = function (env, t, i, n, r, a, ObjectMethodWrapper) {
      var CounterVariable, RandomGenerator, HelperFunction;
      (RandomGenerator = t),
        (HelperFunction = n),
        ((CounterVariable = i).prototype = gt(be, { next: DefinePropertyDescriptor(1, HelperFunction) })),
        xe(CounterVariable, RandomGenerator + " Iterator");
      var EnsureFunction,
        GlobalReference,
        Property,
        MathFloorShortcut = function (env) {
          if (!Ee && env in Value) return Value[env];
          switch (env) {
            case "keys":
            case Ae:
              return function () {  // تعریف توابع برای بررسی وضعیت اشیاء مانند isFrozen، isSealed و isExtensible
                return new i(this, env);
              };
          }
          return function () {
            return new i(this, env);
          };
        },
        f = t + " Iterator",
        ModuleMeta = r == Ae,
        g = !1,
        Value = env.prototype,
        y = Value[Se] || Value["@@iterator"] || (r && Value[r]),
        _ = y || MathFloorShortcut(r),
        x = r ? (ModuleMeta ? MathFloorShortcut("entries") : _) : void 0,
        b = ("Array" == t && Value.entries) || y;
      if (
        (b &&
          (Property = vt(b.call(new env()))) !== Object.prototype &&
          Property.next &&
          (xe(Property, f, !0), "function" != typeof Property[Se] && DirectPropertyAssignment(Property, Se, Me)),
        ModuleMeta &&
          y &&
          y.name !== Ae &&
          ((g = !0),
          (_ = function () {
            return y.call(this);
          })),
        (Ee || g || !Value[Se]) && DirectPropertyAssignment(Value, Se, _),
        (IteratorContainer[t] = _),
        (IteratorContainer[f] = Me),
        r)
      )
        if (
          ((EnsureFunction = {
            values: ModuleMeta ? _ : MathFloorShortcut(Ae),
            keys: a ? _ : MathFloorShortcut("keys"),
            entries: x,
          }),
          ObjectMethodWrapper)
        )
          for (GlobalReference in EnsureFunction) GlobalReference in Value || w(Value, GlobalReference, EnsureFunction[GlobalReference]);
        else LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * (Ee || g), t, EnsureFunction);
      return EnsureFunction;
    },
    ArrayIterator = Pe(
      Array,
      "Array",
      function (env, t) {
        (this._t = ArrayOrStringObject(env)), (this._i = 0), (this._k = t);
      },  // مدیریت قابلیت‌های جمع‌آوری داده‌ها با پیاده‌سازی Map و Set
      function () {
        var env = this._t,
          t = this._k,
          i = this._i++;
        return !env || i >= env.length
          ? ((this._t = void 0), ne(1))
          : ne(0, "keys" == t ? i : "values" == t ? env[i] : [i, env[i]]);
      },
      "values",
    );
  (IteratorContainer.Arguments = IteratorContainer.Array), E("keys"), E("values"), E("entries");
  var Le = [].lastIndexOf,
    Ce = !!Le && 1 / [1].lastIndexOf(1, -0) < 0;
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * (Ce || !R(Le)), "Array", {
    lastIndexOf: function (env) {
      if (Ce) return Le.apply(this, arguments) || 0;
      var t = ArrayOrStringObject(this),
        i = at(t.length),
        n = i - 1;
      for (
        1 < arguments.length && (n = Math.min(n, ToInteger(arguments[1]))),
          n < 0 && (n = i + n);
        0 <= n;
        n--
      )
        if (n in t && t[n] === env) return n || 0;
      return -1;
    },
  });
  var Ie = ArrayMapper(1);
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].map, !0), "Array", {
    map: function (env) {
      return Ie(this, env, arguments[1]);
    },
  }),
    LibraryMethodManager(
      LibraryMethodManager.EnsureObject +
        LibraryMethodManager.FilterArray *
          TryCatch(function () {
            function env() {}

            return !(Array.OutputFormatter.call(env) instanceof env);
          }),
      "Array",
      {
        OutputFormatter: function () {
          for (
            var env = 0,
              t = arguments.length,
              i = new ("function" == typeof this ? this : Array)(t);  // افزودن متدهای جدید به آرایه‌ها مانند reduce و reduceRight
            env < t;

          )
            W(i, env, arguments[env++]);
          return (i.length = t), i;
        },
      },
    );
  var Re = function (env, t, i, n, r) {
    EnsureFunction(t);
    var a = it(env),
      ObjectMethodWrapper = P(a),
      CounterVariable = at(a.length),
      RandomGenerator = r ? CounterVariable - 1 : 0,
      HelperFunction = r ? -1 : 1;
    if (i < 2)
      for (;;) {
        if (RandomGenerator in ObjectMethodWrapper) {
          (n = ObjectMethodWrapper[RandomGenerator]), (RandomGenerator += HelperFunction);
          break;
        }
        if (((RandomGenerator += HelperFunction), r ? RandomGenerator < 0 : CounterVariable <= RandomGenerator))
          throw TypeError("Reduce OutputFormatter empty array with no initial value");
      }
    for (; r ? 0 <= RandomGenerator : RandomGenerator < CounterVariable; RandomGenerator += HelperFunction) RandomGenerator in ObjectMethodWrapper && (n = t(n, ObjectMethodWrapper[RandomGenerator], RandomGenerator, a));
    return n;
  };
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].reduce, !0), "Array", {
    reduce: function (env) {
      return Re(this, env, arguments.length, arguments[1], !1);
    },
  }),
    LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].reduceRight, !0), "Array", {
      reduceRight: function (env) {
        return Re(this, env, arguments.length, arguments[1], !0);
      },
    });
  var Oe = ArrayMapper(3);
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * !R([].some, !0), "Array", {
    some: function (env) {
      return Oe(this, env, arguments[1]);
    },
  });
  var Fe = [].sort,
    Ne = [1, 2, 3];
  LibraryMethodManager(
    LibraryMethodManager.P +
      LibraryMethodManager.FilterArray *
        (TryCatch(function () {
          Ne.sort(void 0);  // پیاده‌سازی توابع کمکی برای تکرارگرها (iterators)' در آرایه‌ها و اشیاء
        }) ||
          !TryCatch(function () {
            Ne.sort(null);
          }) ||
          !R(Fe)),
    "Array",
    {
      sort: function (env) {
        return void 0 === env ? Fe.call(it(this)) : Fe.call(it(this), EnsureFunction(env));
      },
    },
  );
  var ke = SymbolStore("species"),
    _t = function (env) {
      var t = GEnvironment[env];
      SupportsDefineProperty  &&
        t &&
        !t[ke] &&
        ObjectPropertyManager.f(t, ke, {
          configurable: !0,
          get: function () {
            return this;
          },
        });
    };
  _t("Array"),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Date", {
      now: function () {
        return new Date().getTime();
      },
    });
  var Ue = Date.prototype.getTime,
    De = Date.prototype.toISOString,
    ze = function (env) {
      return 9 < env ? env : "0" + env;
    },
    Be =
      TryCatch(function () {
        return "0385-07-25T07:06:39.999Z" != De.call(new Date(-5e13 - 1));
      }) ||
      !TryCatch(function () {
        De.call(new Date(NaN));
      })
        ? function () {
            if (!isFinite(Ue.call(this)))
              throw RangeError("Invalid time value");
            var env = this,
              t = env.getUTCFullYear(),
              i = env.getUTCMilliseconds(),
              n = t < 0 ? "-" : 9999 < t ? "+" : "";
            return (
              n +
              ("00000" + Math.abs(t)).slice(n ? -6 : -4) +
              "-" +
              ze(env.getUTCMonth() + 1) +
              "-" +
              ze(env.getUTCDate()) +
              "T" +
              ze(env.getUTCHours()) +
              ":" +  // تعریف متدهای جدید در تاریخ (Date)' مانند toISOString و toJSON
              ze(env.getUTCMinutes()) +
              ":" +
              ze(env.getUTCSeconds()) +
              "." +
              (99 < i ? i : "0" + ze(i)) +
              "Z"
            );
          }
        : De;
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * (Date.prototype.toISOString !== Be), "Date", {
    toISOString: Be,
  }),
    LibraryMethodManager(
      LibraryMethodManager.P +
        LibraryMethodManager.FilterArray *
          TryCatch(function () {
            return (
              null !== new Date(NaN).toJSON() ||
              1 !==
                Date.prototype.toJSON.call({
                  toISOString: function () {
                    return 1;
                  },
                })
            );
          }),
      "Date",
      {
        toJSON: function (env) {
          var t = it(this),
            i = PrimitiveConversion(t);
          return "number" != typeof i || isFinite(i) ? t.toISOString() : null;
        },
      },
    );
  var He = SymbolStore("toPrimitive"),
    Ge = Date.prototype;
  He in Ge ||
    DirectPropertyAssignment(Ge, He, function (env) {
      if ("string" !== env && "number" !== env && "default" !== env)
        throw TypeError("Incorrect hint");
      return PrimitiveConversion(EnsureObject(this), "number" != env);
    });
  var je = Date.prototype,
    InvalidDateHandler = "Invalid Date",
    InvalidDateString = "toString",
    StringTrim = je[InvalidDateString],
    Tt = je.getTime;
  new Date(NaN) + "" != InvalidDateHandler &&
    w(je, InvalidDateString, function () {
      var env = Tt.call(this);
      return env == env ? StringTrim.call(this) : InvalidDateHandler;
    });
  var FunctionExecutor = function (env, t, i) {
      var n = void 0 === i;
      switch (t.length) {
        case 0:
          return n ? env() : env.call(i);
        case 1:
          return n ? env(t[0]) : env.call(i, t[0]);  // مدیریت متدهای عددی جدید برای دقت بالا در محاسبات مانند Math.expm1 و Math.fround
        case 2:
          return n ? env(t[0], t[1]) : env.call(i, t[0], t[1]);
        case 3:
          return n ? env(t[0], t[1], t[2]) : env.call(i, t[0], t[1], t[2]);
        case 4:
          return n
            ? env(t[0], t[1], t[2], t[3])
            : env.call(i, t[0], t[1], t[2], t[3]);
      }
      return env.apply(i, t);
    },
    ArraySlice = [].slice,
    InstanceConstructor = {},
    FunctionBind =
      Function.bind ||
      function (t) {
        var i = EnsureFunction(this),
          n = ArraySlice.call(arguments, 1),
          r = function () {
            var env = n.concat(ArraySlice.call(arguments));
            return this instanceof r
              ? (function (env, t, i) {
                  if (!(t in InstanceConstructor)) {
                    for (var n = [], r = 0; r < t; r++) n[r] = "a[" + r + "]";
                    InstanceConstructor[t] = Function(
                      "FilterArray,a",
                      "return new FilterArray(" + n.join(",") + ")",
                    );
                  }
                  return InstanceConstructor[t](env, i);
                })(i, env.length, env)
              : FunctionExecutor(i, env, t);
          };
        return IsObjectOrFunction(i.prototype) && (r.prototype = i.prototype), r;
      };
  LibraryMethodManager(LibraryMethodManager.P, "Function", { bind: FunctionBind });
  var InstanceCheckHandler = SymbolStore("hasInstance"),
    FunctionNameHandler = Function.prototype;
  InstanceCheckHandler in FunctionNameHandler ||
    ObjectPropertyManager.f(FunctionNameHandler, InstanceCheckHandler, {
      value: function (env) {
        if ("function" != typeof this || !IsObjectOrFunction(env)) return !1;
        if (!IsObjectOrFunction(this.prototype)) return env instanceof this;
        for (; (env = vt(env)); ) if (this.prototype === env) return !0;
        return !1;
      },
    });
  var Ct = ObjectPropertyManager.f,
    PrototypeValidator = Function.prototype,
    FunctionNameExtractor = /^\CounterVariable*function ([^ (]*)/;  // پیاده‌سازی قابلیت‌های ریاضی پیشرفته مانند Math.hypot و Math.log10
  "name" in PrototypeValidator ||
    (SupportsDefineProperty  &&
      Ct(PrototypeValidator, "name", {
        configurable: !0,
        get: function () {
          try {
            return ("" + this).match(FunctionNameExtractor)[1];
          } catch (env) {
            return "";
          }
        },
      }));
  var ExtendObject = function (env, t, i) {
      for (var n in t) w(env, n, t[n], i);
      return env;
    },
    EnforceInstanceCheck = function (env, t, i, n) {
      if (!(env instanceof t) || (void 0 !== n && n in env))
        throw TypeError(i + ": incorrect invocation!");
      return env;
    },
    Nt = env(function (env) {
      var Property = {},
        MathFloorShortcut = {},
        t = (env.exports = function (env, t, i, n, r) {
          var a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction = r
              ? function () {
                  return env;
                }
              : dt(env),
            EnsureFunction = BindFunction(i, n, t ? 2 : 1),
            GlobalReference = 0;
          if ("function" != typeof HelperFunction) throw TypeError(env + " is not iterable!");
          if (IsIterable(HelperFunction)) {
            for (a = at(env.length); GlobalReference < a; GlobalReference++)
              if (
                (RandomGenerator = t ? EnsureFunction(EnsureObject((ObjectMethodWrapper = env[GlobalReference]))[0], ObjectMethodWrapper[1]) : EnsureFunction(env[GlobalReference])) === Property ||
                RandomGenerator === MathFloorShortcut
              )
                return RandomGenerator;
          } else
            for (CounterVariable = HelperFunction.call(env); !(ObjectMethodWrapper = CounterVariable.next()).done; )
              if ((RandomGenerator = Iterator(CounterVariable, EnsureFunction, ObjectMethodWrapper.value, t)) === Property || RandomGenerator === MathFloorShortcut) return RandomGenerator;
        });
      (t.BREAK = Property), (t.RETURN = MathFloorShortcut);
    }),  // افزودن متدهای جدید برای مدیریت اعداد مانند Number.parseInt و Number.parseFloat
    MetaManager = env(function (env) {
      var i = UniqueSymbolGenerator("meta"),
        t = ObjectPropertyManager.f,
        n = 0,
        r =
          Object.isExtensible ||
          function () {
            return !0;
          },
        a = !TryCatch(function () {
          return r(Object.preventExtensions({}));
        }),
        ObjectMethodWrapper = function (env) {
          t(env, i, { value: { i: "O" + ++n, w: {} } });
        },
        CounterVariable = (env.exports = {
          KEY: i,
          NEED: !1,
          fastKey: function (env, t) {
            if (!IsObjectOrFunction(env))
              return "symbol" == typeof env
                ? env
                : ("string" == typeof env ? "EnsureObject" : "P") + env;
            if (!HasOwnProperty(env, i)) {
              if (!r(env)) return "FilterArray";
              if (!t) return "E";
              ObjectMethodWrapper(env);
            }
            return env[i].i;
          },
          getWeak: function (env, t) {
            if (!HasOwnProperty(env, i)) {
              if (!r(env)) return !0;
              if (!t) return !1;
              ObjectMethodWrapper(env);
            }
            return env[i].w;
          },
          onFreeze: function (env) {
            return a && CounterVariable.NEED && r(env) && !HasOwnProperty(env, i) && ObjectMethodWrapper(env), env;
          },
        });
    }),
    ValidateObjectType =
      (MetaManager.KEY,
      MetaManager.NEED,
      MetaManager.fastKey,
      MetaManager.getWeak,
      MetaManager.onFreeze,
      function (env, t) {
        if (!IsObjectOrFunction(env) || env._t !== t)
          throw TypeError("Incompatible receiver, " + t + " required!");
        return env;
      }),
    DefineFastKey = ObjectPropertyManager.f,
    zt = MetaManager.fastKey,
    Bt = SupportsDefineProperty  ? "_s" : "size",
    Ht = function (env, t) {
      var i,
        n = zt(t);  // مدیریت متدهای پیشرفته رشته مانند String.padStart و String.padEnd
      if ("FilterArray" !== n) return env._i[n];
      for (i = env.SetUniform2f; i; i = i.n) if (i.Key == t) return i;
    },
    MapConstructorManager = {
      getConstructor: function (env, a, i, n) {
        var r = env(function (env, t) {
          EnforceInstanceCheck(env, r, a, "_i"),
            (env._t = a),
            (env._i = gt(null)),
            (env.SetUniform2f = void 0),
            (env._l = void 0),
            (env[Bt] = 0),
            null != t && Nt(t, i, env[n], env);
        });
        return (
          ExtendObject(r.prototype, {
            clear: function () {
              for (var env = ValidateObjectType(this, a), t = env._i, i = env.SetUniform2f; i; i = i.n)
                (i.r = !0), i.Property && (i.Property = i.Property.n = void 0), delete t[i.i];
              (env.SetUniform2f = env._l = void 0), (env[Bt] = 0);
            },
            delete: function (env) {
              var t = ValidateObjectType(this, a),
                i = Ht(t, env);
              if (i) {
                var n = i.n,
                  r = i.Property;
                delete t._i[i.i],
                  (i.r = !0),
                  r && (r.n = n),
                  n && (n.Property = r),
                  t.SetUniform2f == i && (t.SetUniform2f = n),
                  t._l == i && (t._l = r),
                  t[Bt]--;
              }
              return !!i;
            },
            forEach: function (env) {
              ValidateObjectType(this, a);
              for (
                var t,
                  i = BindFunction(env, 1 < arguments.length ? arguments[1] : void 0, 3);
                (t = t ? t.n : this.SetUniform2f);

              )
                for (i(t.Value, t.Key, this); t && t.r; ) t = t.Property;
            },
            has: function (env) {
              return !!Ht(ValidateObjectType(this, a), env);
            },
          }),
          SupportsDefineProperty  &&
            DefineFastKey(r.prototype, "size", {
              get: function () {
                return ValidateObjectType(this, a)[Bt];
              },
            }),
          r
        );
      },  // پشتیبانی از مدیریت نمادها (Symbols)' برای اشیاء و ویژگی‌های خاص
      def: function (env, t, i) {
        var n,
          r,
          a = Ht(env, t);
        return (
          a
            ? (a.Value = i)
            : ((env._l = a =
                {
                  i: (r = zt(t, !0)),
                  Key: t,
                  Value: i,
                  Property: (n = env._l),
                  n: void 0,
                  r: !1,
                }),
              env.SetUniform2f || (env.SetUniform2f = a),
              n && (n.n = a),
              env[Bt]++,
              "FilterArray" !== r && (env._i[r] = a)),
          env
        );
      },
      getEntry: Ht,
      setStrong: function (env, i, t) {
        Pe(
          env,
          i,
          function (env, t) {
            (this._t = ValidateObjectType(env, i)), (this._k = t), (this._l = void 0);
          },
          function () {
            for (var env = this, t = env._k, i = env._l; i && i.r; ) i = i.Property;
            return env._t && (env._l = i = i ? i.n : env._t.SetUniform2f)
              ? ne(0, "keys" == t ? i.Key : "values" == t ? i.Value : [i.Key, i.Value])
              : ((env._t = void 0), ne(1));
          },
          t ? "entries" : "values",
          !t,
          !0,
        ),
          _t(i);
      },
    },
    jt = { f: {}.propertyIsEnumerable },
    Vt = Object.getOwnPropertyDescriptor,
    Xt = {
      f: SupportsDefineProperty 
        ? Vt
        : function (env, t) {
            if (((env = ArrayOrStringObject(env)), (t = PrimitiveConversion(t, !0)), r))
              try {
                return Vt(env, t);
              } catch (env) {}
            if (HasOwnProperty(env, t)) return DefinePropertyDescriptor(!jt.f.call(env, t), env[t]);
          },
    },
    Wt = function (env, t) {
      if ((EnsureObject(env), !IsObjectOrFunction(t) && null !== t))
        throw TypeError(t + ": can't set as prototype!");  // پیاده‌سازی قابلیت‌های خاص برای Reflect مانند ownKeys و getPrototypeOf
    },
    Yt = {
      set:
        Object.setPrototypeOf ||
        ("__proto__" in {}
          ? (function (env, i, n) {
              try {
                (n = BindFunction(
                  Function.call,
                  Xt.f(Object.prototype, "__proto__").set,
                  2,
                ))(env, []),
                  (i = !(env instanceof Array));
              } catch (env) {
                i = !0;
              }
              return function (env, t) {
                return Wt(env, t), i ? (env.__proto__ = t) : n(env, t), env;
              };
            })({}, !1)
          : void 0),
      check: Wt,
    },
    qt = Yt.set,
    SetPrototype = function (env, t, i) {
      var n,
        r = t.constructor;
      return (
        r !== i &&
          "function" == typeof r &&
          (n = r.prototype) !== i.prototype &&
          IsObjectOrFunction(n) &&
          qt &&
          qt(env, n),
        env
      );
    },
    CollectionConstructor = function (n, env, t, i, r, a) {
      var ObjectMethodWrapper = GEnvironment[n],
        CounterVariable = ObjectMethodWrapper,
        RandomGenerator = r ? "set" : "add",
        HelperFunction = CounterVariable && CounterVariable.prototype,
        EnsureFunction = {},
        GlobalReference = function (env) {
          var i = HelperFunction[env];
          w(
            HelperFunction,
            env,
            "delete" == env
              ? function (env) {  // افزودن توابع کمکی برای مدیریت کلیدها و مقادیر اشیاء مانند Object.keys و Object.values
                  return !(a && !IsObjectOrFunction(env)) && i.call(this, 0 === env ? 0 : env);
                }
              : "has" == env
                ? function (env) {
                    return !(a && !IsObjectOrFunction(env)) && i.call(this, 0 === env ? 0 : env);
                  }
                : "get" == env
                  ? function (env) {
                      return a && !IsObjectOrFunction(env)
                        ? void 0
                        : i.call(this, 0 === env ? 0 : env);
                    }
                  : "add" == env
                    ? function (env) {
                        return i.call(this, 0 === env ? 0 : env), this;
                      }
                    : function (env, t) {
                        return i.call(this, 0 === env ? 0 : env, t), this;
                      },
          );
        };
      if (
        "function" == typeof CounterVariable &&
        (a ||
          (HelperFunction.forEach &&
            !TryCatch(function () {
              new CounterVariable().entries().next();
            })))
      ) {
        var Property = new CounterVariable(),
          MathFloorShortcut = Property[RandomGenerator](a ? {} : -0, 1) != Property,
          f = TryCatch(function () {
            Property.has(1);
          }),
          ModuleMeta = ft(function (env) {
            new CounterVariable(env);
          }),
          g =
            !a &&
            TryCatch(function () {
              for (var env = new CounterVariable(), t = 5; t--; ) env[RandomGenerator](t, t);
              return !env.has(-0);
            });
        ModuleMeta ||
          (((CounterVariable = env(function (env, t) {
            EnforceInstanceCheck(env, CounterVariable, n);
            var i = SetPrototype(new ObjectMethodWrapper(), env, CounterVariable);
            return null != t && Nt(t, r, i[RandomGenerator], i), i;
          })).prototype = HelperFunction).constructor = CounterVariable),
          (f || g) && (GlobalReference("delete"), GlobalReference("has"), r && GlobalReference("get")),  // مدیریت ویژگی‌های توابع مانند Function.name و Function.bind
          (g || MathFloorShortcut) && GlobalReference(RandomGenerator),
          a && HelperFunction.clear && delete HelperFunction.clear;
      } else
        (CounterVariable = i.getConstructor(env, n, r, RandomGenerator)), ExtendObject(CounterVariable.prototype, t), (MetaManager.NEED = !0);
      return (
        xe(CounterVariable, n),
        (EnsureFunction[n] = CounterVariable),
        LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.W + LibraryMethodManager.FilterArray * (CounterVariable != ObjectMethodWrapper), EnsureFunction),
        a || i.setStrong(CounterVariable, n, r),
        CounterVariable
      );
    },
    MathHelper =
      (CollectionConstructor(
        "Map",
        function (env) {
          return function () {
            return env(this, 0 < arguments.length ? arguments[0] : void 0);
          };
        },
        {
          get: function (env) {
            var t = MapConstructorManager.getEntry(ValidateObjectType(this, "Map"), env);
            return t && t.Value;
          },
          set: function (env, t) {
            return MapConstructorManager.def(ValidateObjectType(this, "Map"), 0 === env ? 0 : env, t);
          },
        },
        MapConstructorManager,
        !0,
      ),
      Math.log1p ||
        function (env) {
          return -1e-8 < (env = +env) && env < 1e-8
            ? env - (env * env) / 2
            : Math.log(1 + env);
        }),
    StringTrimHandler = Math.sqrt,
    $t = Math.acosh;
  LibraryMethodManager(
    LibraryMethodManager.EnsureObject +
      LibraryMethodManager.FilterArray *
        !($t && 710 == Math.floor($t(Number.MAX_VALUE)) && $t(1 / 0) == 1 / 0),
    "Math",
    {
      acosh: function (env) {
        return (env = +env) < 1
          ? NaN
          : 94906265.62425156 < env  // تعریف توابع کمکی برای تنظیم یا بررسی سازگاری پروتوتایپ اشیاء
            ? Math.log(env) + Math.LN2
            : MathHelper(env - 1 + StringTrimHandler(env - 1) * StringTrimHandler(env + 1));
      },
    },
  );
  var ei = Math.asinh;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !(ei && 0 < 1 / ei(0)), "Math", {
    asinh: function env(t) {
      return isFinite((t = +t)) && 0 != t
        ? t < 0
          ? -env(-t)
          : Math.log(t + Math.sqrt(t * t + 1))
        : t;
    },
  });
  var ti = Math.atanh;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !(ti && 1 / ti(-0) < 0), "Math", {
    atanh: function (env) {
      return 0 == (env = +env) ? env : Math.log((1 + env) / (1 - env)) / 2;
    },
  });
  var IncrementalIndex =
    Math.sign ||
    function (env) {
      return 0 == (env = +env) || env != env ? env : env < 0 ? -1 : 1;
    };
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
    cbrt: function (env) {
      return IncrementalIndex((env = +env)) * Math.pow(Math.abs(env), 1 / 3);
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
      clz32: function (env) {
        return (env >>>= 0)
          ? 31 - Math.floor(Math.log(env + 0.5) * Math.LOG2E)
          : 32;
      },
    });
  var ni = Math.exp;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
    cosh: function (env) {
      return (ni((env = +env)) + ni(-env)) / 2;
    },
  });
  var ri = Math.expm1,
    ai =
      !ri ||
      22025.465794806718 < ri(10) ||
      ri(10) < 22025.465794806718 ||
      -2e-17 != ri(-2e-17)  // مدیریت ویژگی‌های پیشرفته برای کلاس‌ها و ساختارهای ES6 مانند class
        ? function (env) {
            return 0 == (env = +env)
              ? env
              : -1e-6 < env && env < 1e-6
                ? env + (env * env) / 2
                : Math.exp(env) - 1;
          }
        : ri;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * (ai != Math.expm1), "Math", { expm1: ai });
  var oi = Math.pow,
    si = oi(2, -52),
    li = oi(2, -23),
    hi = oi(2, 127) * (2 - li),
    ci = oi(2, -126),
    ui =
      Math.fround ||
      function (env) {
        var t,
          i,
          n = Math.abs(env),
          r = IncrementalIndex(env);
        return n < ci
          ? r * (n / ci / li + 1 / si - 1 / si) * ci * li
          : hi < (i = (t = (1 + li / si) * n) - (t - n)) || i != i
            ? r * (1 / 0)
            : r * i;
      };
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", { fround: ui });
  var pi = Math.abs;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
    hypot: function (env, t) {
      for (var i, n, r = 0, a = 0, ObjectMethodWrapper = arguments.length, CounterVariable = 0; a < ObjectMethodWrapper; )
        CounterVariable < (i = pi(arguments[a++]))
          ? ((r = r * (n = CounterVariable / i) * n + 1), (CounterVariable = i))
          : (r += 0 < i ? (n = i / CounterVariable) * n : i);
      return CounterVariable === 1 / 0 ? 1 / 0 : CounterVariable * Math.sqrt(r);
    },
  });
  var di = Math.imul;
  LibraryMethodManager(
    LibraryMethodManager.EnsureObject +
      LibraryMethodManager.FilterArray *
        TryCatch(function () {
          return -5 != di(4294967295, 5) || 2 != di.length;
        }),
    "Math",
    {
      imul: function (env, t) {
        var i = 65535,
          n = +env,  // تعریف توابع پیشرفته برای مدیریت ارث‌بری و پروتوتایپ اشیاء
          r = +t,
          a = i & n,
          ObjectMethodWrapper = i & r;
        return (
          0 |
          (a * ObjectMethodWrapper +
            ((((i & (n >>> 16)) * ObjectMethodWrapper + a * (i & (r >>> 16))) << 16) >>> 0))
        );
      },
    },
  ),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", { log1p: MathHelper }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
      log10: function (env) {
        return Math.log(env) * Math.LOG10E;
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
      log2: function (env) {
        return Math.log(env) / Math.LN2;
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", { sign: IncrementalIndex });
  var fi = Math.exp;
  LibraryMethodManager(
    LibraryMethodManager.EnsureObject +
      LibraryMethodManager.FilterArray *
        TryCatch(function () {
          return -2e-17 != !Math.sinh(-2e-17);
        }),
    "Math",
    {
      sinh: function (env) {
        return Math.abs((env = +env)) < 1
          ? (ai(env) - ai(-env)) / 2
          : (fi(env - 1) - fi(-env - 1)) * (Math.E / 2);
      },
    },
  );
  var mi = Math.exp;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
    tanh: function (env) {
      var t = ai((env = +env)),
        i = ai(-env);
      return t == 1 / 0 ? 1 : i == 1 / 0 ? -1 : (t - i) / (mi(env) + mi(-env));
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Math", {
      trunc: function (env) {
        return (0 < env ? Math.floor : Math.ceil)(env);  // افزودن توابع برای مدیریت لیست‌های کلید-مقدار مانند entries و values
      },
    });
  var gi = he.concat("length", "prototype"),
    vi = {
      f:
        Object.getOwnPropertyNames ||
        function (env) {
          return le(env, gi);
        },
    },
    yi = "\t\n\Value\f\r   ᠎             　\u2028\u2029\ufeff",
    _i = "[" + yi + "]",
    xi = RegExp("^" + _i + _i + "*"),
    bi = RegExp(_i + _i + "*$"),
    wi = function (env, t, i) {
      var n = {},
        r = TryCatch(function () {
          return !!yi[env]() || "​" != "​"[env]();
        }),
        a = (n[env] = r ? t(Ti) : yi[env]);
      i && (n[i] = a), LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * r, "String", n);
    },
    Ti = (wi.trim = function (env, t) {
      return (
        (env = String(Property(env))),
        1 & t && (env = env.replace(xi, "")),
        2 & t && (env = env.replace(bi, "")),
        env
      );
    }),
    Si = wi,
    Ei = vi.f,
    Ai = Xt.f,
    Mi = ObjectPropertyManager.f,
    Pi = Si.trim,
    Li = "Number",
    Ci = GEnvironment[Li],
    Ii = Ci,
    Ri = Ci.prototype,
    Oi = M(gt(Ri)) == Li,
    Fi = "trim" in String.prototype,
    Ni = function (env) {
      var t = PrimitiveConversion(env, !1);
      if ("string" == typeof t && 2 < t.length) {
        var i,
          n,
          r,
          a = (t = Fi ? t.trim() : Pi(t, 3)).charCodeAt(0);
        if (43 === a || 45 === a) {
          if (88 === (i = t.charCodeAt(2)) || 120 === i) return NaN;  // پیاده‌سازی قابلیت مدیریت ویژگی‌های شیء مانند preventExtensions و freeze
        } else if (48 === a) {
          switch (t.charCodeAt(1)) {
            case 66:
            case 98:
              (n = 2), (r = 49);
              break;
            case 79:
            case 111:
              (n = 8), (r = 55);
              break;
            default:
              return +t;
          }
          for (var ObjectMethodWrapper, CounterVariable = t.slice(2), RandomGenerator = 0, HelperFunction = CounterVariable.length; RandomGenerator < HelperFunction; RandomGenerator++)
            if ((ObjectMethodWrapper = CounterVariable.charCodeAt(RandomGenerator)) < 48 || r < ObjectMethodWrapper) return NaN;
          return parseInt(CounterVariable, n);
        }
      }
      return +t;
    };
  if (!Ci(" 0o1") || !Ci("0b1") || Ci("+0x1")) {
    Ci = function (env) {
      var t = arguments.length < 1 ? 0 : env,
        i = this;
      return i instanceof Ci &&
        (Oi
          ? TryCatch(function () {
              Ri.valueOf.call(i);
            })
          : M(i) != Li)
        ? SetPrototype(new Ii(Ni(t)), i, Ci)
        : Ni(t);
    };
    for (
      var ki,
        Ui = SupportsDefineProperty 
          ? Ei(Ii)
          : "MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(
              ",",
            ),
        Di = 0;
      Ui.length > Di;
      Di++
    )
      HasOwnProperty(Ii, (ki = Ui[Di])) && !HasOwnProperty(Ci, ki) && Mi(Ci, ki, Ai(Ii, ki));
    ((Ci.prototype = Ri).constructor = Ci), w(GEnvironment, Li, Ci);
  }
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", { EPSILON: Math.pow(2, -52) });
  var zi = GEnvironment.isFinite;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", {  // مدیریت توابع ArrayBuffer و TypedArray برای پردازش داده‌های باینری
    isFinite: function (env) {
      return "number" == typeof env && zi(env);
    },
  });
  var Bi = Math.floor,
    Hi = function (env) {
      return !IsObjectOrFunction(env) && isFinite(env) && Bi(env) === env;
    };
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", { isInteger: Hi }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", {
      isNaN: function (env) {
        return env != env;
      },
    });
  var Gi = Math.abs;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", {
    isSafeInteger: function (env) {
      return Hi(env) && Gi(env) <= 9007199254740991;
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", { MAX_SAFE_INTEGER: 9007199254740991 }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Number", { MIN_SAFE_INTEGER: -9007199254740991 });
  var ji = GEnvironment.parseFloat,
    Vi = Si.trim,
    Xi =
      1 / ji(yi + "-0") != -1 / 0
        ? function (env) {
            var t = Vi(String(env), 3),
              i = ji(t);
            return 0 === i && "-" == t.charAt(0) ? -0 : i;
          }
        : ji;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * (Number.parseFloat != Xi), "Number", { parseFloat: Xi });
  var Wi = GEnvironment.parseInt,
    Yi = Si.trim,
    qi = /^[-+]?0[xX]/,
    Qi =
      8 !== Wi(yi + "08") || 22 !== Wi(yi + "0x16")
        ? function (env, t) {
            var i = Yi(String(env), 3);
            return Wi(i, t >>> 0 || (qi.test(i) ? 16 : 10));
          }
        : Wi;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * (Number.parseInt != Qi), "Number", { parseInt: Qi });
  var Zi = { f: Object.getOwnPropertySymbols },
    Ji = Object.assign,
    Ki =
      !Ji ||
      TryCatch(function () {
        var env = {},  // افزودن متدهای جدید برای آرایه‌ها مانند Array.from و Array.of
          t = {},
          i = Symbol(),
          n = "abcdefghijklmnopqrst";
        return (
          (env[i] = 7),
          n.split("").forEach(function (env) {
            t[env] = env;
          }),
          7 != Ji({}, env)[i] || Object.keys(Ji({}, t)).join("") != n
        );
      })
        ? function (env, t) {
            for (
              var i = it(env), n = arguments.length, r = 1, a = Zi.f, ObjectMethodWrapper = jt.f;
              r < n;

            )
              for (
                var CounterVariable,
                  RandomGenerator = P(arguments[r++]),
                  HelperFunction = a ? ce(RandomGenerator).concat(a(RandomGenerator)) : ce(RandomGenerator),
                  EnsureFunction = HelperFunction.length,
                  GlobalReference = 0;
                GlobalReference < EnsureFunction;

              )
                ObjectMethodWrapper.call(RandomGenerator, (CounterVariable = HelperFunction[GlobalReference++])) && (i[CounterVariable] = RandomGenerator[CounterVariable]);
            return i;
          }
        : Ji;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray, "Object", { assign: Ki }), LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", { create: gt });
  var $i = !TryCatch(function () {
    var env = Math.random();
    __defineSetter__.call(null, env, function () {}), delete GEnvironment[env];
  });
  SupportsDefineProperty  &&
    LibraryMethodManager(LibraryMethodManager.P + $i, "Object", {
      __defineGetter__: function (env, t) {
        ObjectPropertyManager.f(it(this), env, { get: EnsureFunction(t), enumerable: !0, configurable: !0 });
      },
    }),
    SupportsDefineProperty  &&
      LibraryMethodManager(LibraryMethodManager.P + $i, "Object", {
        __defineSetter__: function (env, t) {
          ObjectPropertyManager.f(it(this), env, { set: EnsureFunction(t), enumerable: !0, configurable: !0 });
        },
      }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !SupportsDefineProperty , "Object", { defineProperty: ObjectPropertyManager.f }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !SupportsDefineProperty , "Object", { defineProperties: ue });
  var en = jt.f,  // مدیریت و اصلاح عملکرد توابع مرتبط با رشته‌ها مانند repeat و startsWith
    tn = function (CounterVariable) {
      return function (env) {
        for (var t, i = ArrayOrStringObject(env), n = ce(i), r = n.length, a = 0, ObjectMethodWrapper = []; a < r; )
          en.call(i, (t = n[a++])) && ObjectMethodWrapper.push(CounterVariable ? [t, i[t]] : i[t]);
        return ObjectMethodWrapper;
      };
    },
    NullChecker = tn(!0);
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", {
    entries: function (env) {
      return NullChecker(env);
    },
  });
  var rn = function (env, t) {
      var i = (ModuleMeta.Object || {})[env] || Object[env],
        n = {};
      (n[env] = t(i)),
        LibraryMethodManager(
          LibraryMethodManager.EnsureObject +
            LibraryMethodManager.FilterArray *
              TryCatch(function () {
                i(1);
              }),
          "Object",
          n,
        );
    },
    an = MetaManager.onFreeze;
  rn("freeze", function (t) {
    return function (env) {
      return t && IsObjectOrFunction(env) ? t(an(env)) : env;
    };
  });
  var on = Xt.f;
  rn("getOwnPropertyDescriptor", function () {
    return function (env, t) {
      return on(ArrayOrStringObject(env), t);
    };
  });
  var sn = GEnvironment.Reflect,
    ln =
      (sn && sn.ownKeys) ||
      function (env) {
        var t = vi.f(EnsureObject(env)),
          i = Zi.f;
        return i ? t.concat(i(env)) : t;
      };
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", {
    getOwnPropertyDescriptors: function (env) {
      for (  // افزودن توابع برای عملیات‌های پیچیده ریاضی مانند Math.tanh و Math.trunc
        var t, i, n = ArrayOrStringObject(env), r = Xt.f, a = ln(n), ObjectMethodWrapper = {}, CounterVariable = 0;
        a.length > CounterVariable;

      )
        void 0 !== (i = r(n, (t = a[CounterVariable++]))) && W(ObjectMethodWrapper, t, i);
      return ObjectMethodWrapper;
    },
  });
  var hn = vi.f,
    cn = {}.toString,
    un =
      "object" == typeof window && window && Object.getOwnPropertyNames
        ? Object.getOwnPropertyNames(window)
        : [],
    pn = {
      f: function (env) {
        return un && "[object Window]" == cn.call(env)
          ? (function (env) {
              try {
                return hn(env);
              } catch (env) {
                return un.slice();
              }
            })(env)
          : hn(ArrayOrStringObject(env));
      },
    };
  rn("getOwnPropertyNames", function () {
    return pn.f;
  }),
    rn("getPrototypeOf", function () {
      return function (env) {
        return vt(it(env));
      };
    });
  var dn = Xt.f;
  SupportsDefineProperty  &&
    LibraryMethodManager(LibraryMethodManager.P + $i, "Object", {
      __lookupGetter__: function (env) {
        var t,
          i = it(this),
          n = PrimitiveConversion(env, !0);
        do {
          if ((t = dn(i, n))) return t.get;
        } while ((i = vt(i)));
      },
    });
  var fn = Xt.f;
  SupportsDefineProperty  &&
    LibraryMethodManager(LibraryMethodManager.P + $i, "Object", {  // مدیریت ویژگی‌های متادیتا برای اشیاء و مقادیر با استفاده از Reflect و Proxy
      __lookupSetter__: function (env) {
        var t,
          i = it(this),
          n = PrimitiveConversion(env, !0);
        do {
          if ((t = fn(i, n))) return t.set;
        } while ((i = vt(i)));
      },
    });
  var MappedNode = MetaManager.onFreeze;
  rn("preventExtensions", function (t) {
    return function (env) {
      return t && IsObjectOrFunction(env) ? t(MappedNode(env)) : env;
    };
  });
  var gn =
    Object.is ||
    function (env, t) {
      return env === t ? 0 !== env || 1 / env == 1 / t : env != env && t != t;
    };
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", { is: gn }),
    rn("isFrozen", function (t) {
      return function (env) {
        return !IsObjectOrFunction(env) || (!!t && t(env));
      };
    }),
    rn("isSealed", function (t) {
      return function (env) {
        return !IsObjectOrFunction(env) || (!!t && t(env));
      };
    }),
    rn("isExtensible", function (t) {
      return function (env) {
        return !!IsObjectOrFunction(env) && (!t || t(env));
      };
    }),
    rn("keys", function () {
      return function (env) {
        return ce(it(env));
      };
    });
  var vn = MetaManager.onFreeze;
  rn("seal", function (t) {
    return function (env) {
      return t && IsObjectOrFunction(env) ? t(vn(env)) : env;
    };
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", { setPrototypeOf: Yt.set });
  var yn = tn(!1);
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Object", {  // پیاده‌سازی ویژگی‌های نمادها برای مقادیر منحصر به فرد در سطح سیستم
    values: function (env) {
      return yn(env);
    },
  });
  var _n,
    xn,
    bn,
    wn = SymbolStore("species"),
    Tn = function (env, t) {
      var i,
        n = EnsureObject(env).constructor;
      return void 0 === n || null == (i = EnsureObject(n)[wn]) ? t : EnsureFunction(i);
    },
    ProcessObject = GEnvironment.process,
    En = GEnvironment.setImmediate,
    An = GEnvironment.clearImmediate,
    MutationObserver = GEnvironment.MessageChannel,
    DispatchNow = GEnvironment.Dispatch,
    Ln = 0,
    TaskQueue = {},
    In = "onreadystatechange",
    TaskExecutor = function () {
      var env = +this;
      if (TaskQueue.hasOwnProperty(env)) {
        var t = TaskQueue[env];
        delete TaskQueue[env], t();
      }
    },
    MessageHandler = function (env) {
      TaskExecutor.call(env.data);
    };
  (En && An) ||
    ((En = function (env) {
      for (var t = [], i = 1; arguments.length > i; ) t.push(arguments[i++]);
      return (
        (TaskQueue[++Ln] = function () {
          FunctionExecutor("function" == typeof env ? env : Function(env), t);
        }),
        _n(Ln),
        Ln
      );
    }),
    (An = function (env) {
      delete TaskQueue[env];
    }),
    "process" == M(ProcessObject)
      ? (_n = function (env) {
          ProcessObject.nextTick(BindFunction(TaskExecutor, env, 1));
        })
      : DispatchNow && DispatchNow.now  // افزودن توابع برای بهبود مدیریت خطاها و استثناها در عملیات مختلف
        ? (_n = function (env) {
            DispatchNow.now(BindFunction(TaskExecutor, env, 1));
          })
        : MutationObserver
          ? ((bn = (xn = new MutationObserver()).port2),
            (xn.port1.onmessage = MessageHandler),
            (_n = BindFunction(bn.postMessage, bn, 1)))
          : GEnvironment.addEventListener &&
              "function" == typeof postMessage &&
              !GEnvironment.importScripts
            ? ((_n = function (env) {
                GEnvironment.postMessage(env + "", "*");
              }),
              GEnvironment.addEventListener("message", MessageHandler, !1))
            : (_n =
                In in n("script")
                  ? function (env) {
                      de.appendChild(n("script"))[In] = function () {
                        de.removeChild(this), TaskExecutor.call(env);
                      };
                    }
                  : function (env) {
                      setTimeout(BindFunction(TaskExecutor, env, 1), 0);
                    }));
  var ImmediateTaskManager = { set: En, clear: An },
    Nn = ImmediateTaskManager.set,
    ProcessTask = GEnvironment.MutationObserver || GEnvironment.WebKitMutationObserver,
    PromiseProcessor = GEnvironment.process,
    Dn = GEnvironment.Promise,
    zn = "process" == M(PromiseProcessor);

  function PromiseWrapper(env) {
    var i, n;
    (this.promise = new env(function (env, t) {
      if (void 0 !== i || void 0 !== n)
        throw TypeError("Bad Promise constructor");
      (i = env), (n = t);
    })),
      (this.resolve = EnsureFunction(i)),
      (this.reject = EnsureFunction(n));
  }

  var GlobalTaskQueue,
    PromiseConstructorWrapper,
    PromiseChainHandler,
    NextTickHandler,
    Xn = {
      f: function (env) {
        return new PromiseWrapper(env);
      },  // بهینه‌سازی و مدیریت نحوه عملکرد کلاس‌ها و ماژول‌های ES6
    },
    ExecutionWrapper = function (env) {
      try {
        return { env: !1, Value: env() };
      } catch (env) {
        return { env: !0, Value: env };
      }
    },
    NavigatorAgent = GEnvironment.navigator,
    qn = (NavigatorAgent && NavigatorAgent.userAgent) || "",
    Qn = function (env, t) {
      if ((EnsureObject(env), IsObjectOrFunction(t) && t.constructor === env)) return t;
      var i = Xn.f(env);
      return (0, i.resolve)(t), i.promise;
    },
    SetImmediateFallback = ImmediateTaskManager.set,
    Jn = (function () {
      var i,
        n,
        r,
        env = function () {
          var env, t;
          for (zn && (env = PromiseProcessor.domain) && env.exit(); i; ) {
            (t = i.fn), (i = i.next);
            try {
              t();
            } catch (env) {
              throw (i ? r() : (n = void 0), env);
            }
          }
          (n = void 0), env && env.enter();
        };
      if (zn)
        r = function () {
          PromiseProcessor.nextTick(env);
        };
      else if (!ProcessTask || (GEnvironment.navigator && GEnvironment.navigator.standalone))
        if (Dn && Dn.resolve) {
          var t = Dn.resolve(void 0);
          r = function () {
            t.then(env);
          };
        } else
          r = function () {
            Nn.call(GEnvironment, env);
          };
      else {
        var a = !0,
          ObjectMethodWrapper = document.createTextNode("");
        new ProcessTask(env).observe(ObjectMethodWrapper, { characterData: !0 }),  // تعریف توابع کمکی برای کار با مجموعه‌های داده‌ای مانند WeakMap و WeakSet
          (r = function () {
            ObjectMethodWrapper.data = a = !a;
          });
      }
      return function (env) {
        var t = { fn: env, next: void 0 };
        n && (n.next = t), i || ((i = t), r()), (n = t);
      };
    })(),
    PromiseLibrary = "Promise",
    TypeErrorWrapper = GEnvironment.TypeError,
    ProcessEnvironment = GEnvironment.process,
    tr = ProcessEnvironment && ProcessEnvironment.versions,
    ir = (tr && tr.v8) || "",
    NullChecker = GEnvironment[PromiseLibrary],
    IsNodeEnvironment = "process" == ToObjectTag(ProcessEnvironment),
    EmptyFunction = function () {},
    PromiseResolutionWrapper = (PromiseConstructorWrapper = Xn.f),
    IsPromiseSupported = !!(function () {
      try {
        var env = NullChecker.resolve(1),
          t = ((env.constructor = {})[SymbolStore("species")] = function (env) {
            env(EmptyFunction, EmptyFunction);
          });
        return (
          (IsNodeEnvironment || "function" == typeof PromiseRejectionEvent) &&
          env.then(EmptyFunction) instanceof t &&
          0 !== ir.indexOf("6.6") &&
          -1 === qn.indexOf("Chrome/66")
        );
      } catch (env) {}
    })(),
    IsThenable = function (env) {
      var t;
      return !(!IsObjectOrFunction(env) || "function" != typeof (t = env.then)) && t;
    },
    HandlePromiseChain = function (EnsureFunction, i) {
      if (!EnsureFunction._n) {
        EnsureFunction._n = !0;
        var n = EnsureFunction._c;
        Jn(function () {
          for (
            var RandomGenerator = EnsureFunction._v,
              HelperFunction = 1 == EnsureFunction._s,
              env = 0,
              t = function (env) {
                var t,
                  i,
                  n,
                  r = HelperFunction ? env.ok : env.fail,  // افزودن قابلیت‌های جدید برای مدیریت متدها و مقادیر پیش‌فرض در اشیاء
                  a = env.resolve,
                  ObjectMethodWrapper = env.reject,
                  CounterVariable = env.domain;
                try {
                  r
                    ? (HelperFunction || (2 == EnsureFunction._h && SetDifference(EnsureFunction), (EnsureFunction._h = 1)),
                      !0 === r
                        ? (t = RandomGenerator)
                        : (CounterVariable && CounterVariable.enter(),
                          (t = r(RandomGenerator)),
                          CounterVariable && (CounterVariable.exit(), (n = !0))),
                      t === env.promise
                        ? ObjectMethodWrapper($n("Promise-chain cycle"))
                        : (i = IsThenable(t))
                          ? i.call(t, a, ObjectMethodWrapper)
                          : a(t))
                    : ObjectMethodWrapper(RandomGenerator);
                } catch (env) {
                  CounterVariable && !n && CounterVariable.exit(), ObjectMethodWrapper(env);
                }
              };
            n.length > env;

          )
            t(n[env++]);
          (EnsureFunction._c = []), (EnsureFunction._n = !1), i && !EnsureFunction._h && SetUnion(EnsureFunction);
        });
      }
    },
    SetUnion = function (a) {
      SetImmediateFallback.call(GEnvironment, function () {
        var env,
          t,
          i,
          n = a._v,
          r = SetIntersection(a);
        if (
          (r &&
            ((env = ExecutionWrapper(function () {
              IsNodeEnvironment
                ? ProcessEnvironment.emit("unhandledRejection", n, a)
                : (t = GEnvironment.onunhandledrejection)
                  ? t({
                      promise: a,
                      reason: n,
                    })
                  : (i = GEnvironment.console) &&
                    i.error &&
                    i.error("Unhandled promise rejection", n);
            })),  // پیاده‌سازی ابزارهای جدید برای دیباگ کردن کد و مدیریت متغیرها
            (a._h = IsNodeEnvironment || SetIntersection(a) ? 2 : 1)),
          (a._a = void 0),
          r && env.env)
        )
          throw env.Value;
      });
    },
    SetIntersection = function (env) {
      return 1 !== env._h && 0 === (env._a || env._c).length;
    },
    SetDifference = function (t) {
      SetImmediateFallback.call(GEnvironment, function () {
        var env;
        IsNodeEnvironment
          ? ProcessEnvironment.emit("rejectionHandled", t)
          : (env = GEnvironment.onrejectionhandled) && env({ promise: t, reason: t._v });
      });
    },
    dr = function (env) {
      var t = this;
      t._d ||
        ((t._d = !0),
        ((t = t._w || t)._v = env),
        (t._s = 2),
        t._a || (t._a = t._c.slice()),
        HandlePromiseChain(t, !0));
    },
    FloatPrecisionHandler = function (env) {
      var i,
        n = this;
      if (!n._d) {
        (n._d = !0), (n = n._w || n);
        try {
          if (n === env) throw TypeErrorWrapper("Promise can't be resolved itself");
          (i = IsThenable(env))
            ? Jn(function () {
                var t = { _w: n, _d: !1 };
                try {
                  i.call(env, BindFunction(FloatPrecisionHandler, t, 1), BindFunction(dr, t, 1));
                } catch (env) {
                  dr.call(t, env);
                }
              })
            : ((n._v = env), (n._s = 1), HandlePromiseChain(n, !1));
        } catch (env) {
          dr.call({ _w: n, _d: !1 }, env);
        }
      }
    };
  IsPromiseSupported ||  // مدیریت ویژگی‌های سیستم مانند نسخه‌های مختلف و متدهای خاص
    ((NullChecker = function (env) {
      EnforceInstanceCheck(this, NullChecker, PromiseLibrary, "_h"), EnsureFunction(env), GlobalTaskQueue.call(this);
      try {
        env(BindFunction(FloatPrecisionHandler, this, 1), BindFunction(dr, this, 1));
      } catch (env) {
        dr.call(this, env);
      }
    }),
    ((GlobalTaskQueue = function (env) {
      (this._c = []),
        (this._a = void 0),
        (this._s = 0),
        (this._d = !1),
        (this._v = void 0),
        (this._h = 0),
        (this._n = !1);
    }).prototype = ExtendObject(NullChecker.prototype, {
      then: function (env, t) {
        var i = PromiseResolutionWrapper(Tn(this, NullChecker));
        return (
          (i.ok = "function" != typeof env || env),
          (i.fail = "function" == typeof t && t),
          (i.domain = IsNodeEnvironment ? ProcessEnvironment.domain : void 0),
          this._c.push(i),
          this._a && this._a.push(i),
          this._s && HandlePromiseChain(this, !1),
          i.promise
        );
      },
      catch: function (env) {
        return this.then(void 0, env);
      },
    })),
    (PromiseChainHandler = function () {
      var env = new GlobalTaskQueue();
      (this.promise = env),
        (this.resolve = BindFunction(FloatPrecisionHandler, env, 1)),
        (this.reject = BindFunction(dr, env, 1));
    }),
    (Xn.f = PromiseResolutionWrapper =
      function (env) {
        return env === NullChecker || env === NextTickHandler ? new PromiseChainHandler(env) : PromiseConstructorWrapper(env);
      })),
    LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.W + LibraryMethodManager.FilterArray * !IsPromiseSupported, { Promise: NullChecker }),
    xe(NullChecker, PromiseLibrary),
    _t(PromiseLibrary),
    (NextTickHandler = ModuleMeta[PromiseLibrary]),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !IsPromiseSupported, PromiseLibrary, {
      reject: function (env) {
        var t = PromiseResolutionWrapper(this);  // تعریف متدهای مرتبط با مدیریت ورودی و خروجی داده‌ها
        return (0, t.reject)(env), t.promise;
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !IsPromiseSupported, PromiseLibrary, {
      resolve: function (env) {
        return Qn(this, env);
      },
    }),
    LibraryMethodManager(
      LibraryMethodManager.EnsureObject +
        LibraryMethodManager.FilterArray *
          !(
            IsPromiseSupported &&
            ft(function (env) {
              NullChecker.all(env).catch(EmptyFunction);
            })
          ),
      PromiseLibrary,
      {
        all: function (env) {
          var ObjectMethodWrapper = this,
            t = PromiseResolutionWrapper(ObjectMethodWrapper),
            CounterVariable = t.resolve,
            RandomGenerator = t.reject,
            i = ExecutionWrapper(function () {
              var n = [],
                r = 0,
                a = 1;
              Nt(env, !1, function (env) {
                var t = r++,
                  i = !1;
                n.push(void 0),
                  a++,
                  ObjectMethodWrapper.resolve(env).then(function (env) {
                    i || ((i = !0), (n[t] = env), --a || CounterVariable(n));
                  }, RandomGenerator);
              }),
                --a || CounterVariable(n);
            });
          return i.env && RandomGenerator(i.Value), t.promise;
        },
        race: function (env) {
          var t = this,
            i = PromiseResolutionWrapper(t),
            n = i.reject,
            r = ExecutionWrapper(function () {
              Nt(env, !1, function (env) {
                t.resolve(env).then(i.resolve, n);
              });
            });  // افزودن متدهای مرتبط با پردازش آرایه‌های چندبعدی و پیشرفته
          return r.env && n(r.Value), i.promise;
        },
      },
    ),
    LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.R, "Promise", {
      finally: function (t) {
        var i = Tn(this, ModuleMeta.Promise || GEnvironment.Promise),
          env = "function" == typeof t;
        return this.then(
          env
            ? function (env) {
                return Qn(i, t()).then(function () {
                  return env;
                });
              }
            : t,
          env
            ? function (env) {
                return Qn(i, t()).then(function () {
                  throw env;
                });
              }
            : t,
        );
      },
    });
  var RandomValueGenerator = (GEnvironment.Reflect || {}).apply,
    MathConstants = Function.apply;
  LibraryMethodManager(
    LibraryMethodManager.EnsureObject +
      LibraryMethodManager.FilterArray *
        !TryCatch(function () {
          RandomValueGenerator(function () {});
        }),
    "Reflect",
    {
      apply: function (env, t, i) {
        var n = EnsureFunction(env),
          r = EnsureObject(i);
        return RandomValueGenerator ? RandomValueGenerator(n, t, r) : MathConstants.call(n, t, r);
      },
    },
  );
  var ArrayLengthChecker = (GEnvironment.Reflect || {}).construct,
    StringFormatter = TryCatch(function () {
      function env() {}

      return !(ArrayLengthChecker(function () {}, [], env) instanceof env);
    }),
    ValueNormalizer = !TryCatch(function () {  // پیاده‌سازی متدهای مرتبط با مدیریت مقادیر خاص مانند NaN و Infinity
      ArrayLengthChecker(function () {});
    });
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * (StringFormatter || ValueNormalizer), "Reflect", {
    construct: function (env, t) {
      EnsureFunction(env), EnsureObject(t);
      var i = arguments.length < 3 ? env : EnsureFunction(arguments[2]);
      if (ValueNormalizer && !StringFormatter) return ArrayLengthChecker(env, t, i);
      if (env == i) {
        switch (t.length) {
          case 0:
            return new env();
          case 1:
            return new env(t[0]);
          case 2:
            return new env(t[0], t[1]);
          case 3:
            return new env(t[0], t[1], t[2]);
          case 4:
            return new env(t[0], t[1], t[2], t[3]);
        }
        var n = [null];
        return n.push.apply(n, t), new (FunctionBind.apply(env, n))();
      }
      var r = i.prototype,
        a = gt(IsObjectOrFunction(r) ? r : Object.prototype),
        ObjectMethodWrapper = Function.apply.call(env, a, t);
      return IsObjectOrFunction(ObjectMethodWrapper) ? ObjectMethodWrapper : a;
    },
  }),
    LibraryMethodManager(
      LibraryMethodManager.EnsureObject +
        LibraryMethodManager.FilterArray *
          TryCatch(function () {
            Reflect.defineProperty(ObjectPropertyManager.f({}, 1, { value: 1 }), 1, { value: 2 });
          }),
      "Reflect",
      {
        defineProperty: function (env, t, i) {
          EnsureObject(env), (t = PrimitiveConversion(t, !0)), EnsureObject(i);
          try {
            return ObjectPropertyManager.f(env, t, i), !0;
          } catch (env) {
            return !1;
          }
        },
      },
    );
  var MatrixUtils = Xt.f;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
    deleteProperty: function (env, t) {  // مدیریت ویژگی‌های پیشرفته برای انواع داده مانند BigInt
      var i = MatrixUtils(EnsureObject(env), t);
      return !(i && !i.configurable) && delete env[t];
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
      get: function env(t, i) {
        var n,
          r,
          a = arguments.length < 3 ? t : arguments[2];
        return EnsureObject(t) === a
          ? t[i]
          : (n = Xt.f(t, i))
            ? HasOwnProperty(n, "value")
              ? n.value
              : void 0 !== n.get
                ? n.get.call(a)
                : void 0
            : IsObjectOrFunction((r = vt(t)))
              ? env(r, i, a)
              : void 0;
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
      getOwnPropertyDescriptor: function (env, t) {
        return Xt.f(EnsureObject(env), t);
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
      getPrototypeOf: function (env) {
        return vt(EnsureObject(env));
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
      has: function (env, t) {
        return t in env;
      },
    });
  var DateHandler = Object.isExtensible;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
    isExtensible: function (env) {
      return EnsureObject(env), !DateHandler || DateHandler(env);
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", { ownKeys: ln });
  var TimeZoneConverter = Object.preventExtensions;
  LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
    preventExtensions: function (env) {
      EnsureObject(env);
      try {
        return TimeZoneConverter && TimeZoneConverter(env), !0;  // تعریف توابع مرتبط با بهینه‌سازی عملکرد حافظه و جمع‌آوری زباله (Garbage Collection)
      } catch (env) {
        return !1;
      }
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
      set: function env(t, i, n) {
        var r,
          a,
          ObjectMethodWrapper = arguments.length < 4 ? t : arguments[3],
          CounterVariable = Xt.f(EnsureObject(t), i);
        if (!CounterVariable) {
          if (IsObjectOrFunction((a = vt(t)))) return env(a, i, n, ObjectMethodWrapper);
          CounterVariable = DefinePropertyDescriptor(0);
        }
        if (HasOwnProperty(CounterVariable, "value")) {
          if (!1 === CounterVariable.writable || !IsObjectOrFunction(ObjectMethodWrapper)) return !1;
          if ((r = Xt.f(ObjectMethodWrapper, i))) {
            if (r.get || r.set || !1 === r.writable) return !1;
            (r.value = n), ObjectPropertyManager.f(ObjectMethodWrapper, i, r);
          } else ObjectPropertyManager.f(ObjectMethodWrapper, i, DefinePropertyDescriptor(0, n));
          return !0;
        }
        return void 0 !== CounterVariable.set && (CounterVariable.set.call(ObjectMethodWrapper, n), !0);
      },
    }),
    Yt &&
      LibraryMethodManager(LibraryMethodManager.EnsureObject, "Reflect", {
        setPrototypeOf: function (env, t) {
          Yt.check(env, t);
          try {
            return Yt.set(env, t), !0;
          } catch (env) {
            return !1;
          }
        },
      });
  var ErrorLogger = SymbolStore("match"),
    ObjectCloner = function (env) {
      var t;
      return IsObjectOrFunction(env) && (void 0 !== (t = env[ErrorLogger]) ? !!t : "RegExp" == M(env));
    },
    EventEmitter = function () {
      var env = EnsureObject(this),
        t = "";
      return (
        env.global && (t += "g"),
        env.ignoreCase && (t += "i"),
        env.multiline && (t += "ModuleMeta"),
        env.unicode && (t += "GlobalReference"),  // پیاده‌سازی متدهای مرتبط با پردازش و تبدیل ساختارهای داده‌ای پیچیده
        env.sticky && (t += "y"),
        t
      );
    },
    AsyncFunctionHandler = ObjectPropertyManager.f,
    PromiseTimeout = vi.f,
    PrototypeChainHandler = GEnvironment.RegExp,
    LazyInitializer = PrototypeChainHandler,
    CustomIterator = PrototypeChainHandler.prototype,
    ReflectUtils = /a/g,
    SealObject = /a/g,
    FreezeObject = new PrototypeChainHandler(ReflectUtils) !== ReflectUtils;
  if (
    SupportsDefineProperty  &&
    (!FreezeObject ||
      TryCatch(function () {
        return (
          (SealObject[SymbolStore("match")] = !1),
          PrototypeChainHandler(ReflectUtils) != ReflectUtils || PrototypeChainHandler(SealObject) == SealObject || "/a/i" != PrototypeChainHandler(ReflectUtils, "i")
        );
      }))
  ) {
    PrototypeChainHandler = function (env, t) {
      var i = this instanceof PrototypeChainHandler,
        n = ObjectCloner(env),
        r = void 0 === t;
      return !i && n && env.constructor === PrototypeChainHandler && r
        ? env
        : SetPrototype(
            FreezeObject
              ? new LazyInitializer(n && !r ? env.source : env, t)
              : LazyInitializer(
                  (n = env instanceof PrototypeChainHandler) ? env.source : env,
                  n && r ? EventEmitter.call(env) : t,
                ),
            i ? this : CustomIterator,
            PrototypeChainHandler,
          );
    };
    for (
      var PrototypeValidator = function (t) {
          (t in PrototypeChainHandler) ||
            AsyncFunctionHandler(PrototypeChainHandler, t, {
              configurable: !0,
              get: function () {
                return LazyInitializer[t];
              },
              set: function (env) {
                LazyInitializer[t] = env;
              },  // افزودن قابلیت‌های جدید برای مدیریت نقشه‌ها و مجموعه‌ها (Map و Set)
            });
        },
        WeakSetManager = PromiseTimeout(LazyInitializer),
        WeakMapHandler = 0;
      WeakSetManager.length > WeakMapHandler;

    )
      PrototypeValidator(WeakSetManager[WeakMapHandler++]);
    ((CustomIterator.constructor = PrototypeChainHandler).prototype = CustomIterator), w(GEnvironment, "RegExp", PrototypeChainHandler);
  }
  _t("RegExp"),
    SupportsDefineProperty  &&
      "g" != /./g.flags &&
      ObjectPropertyManager.f(RegExp.prototype, "flags", { configurable: !0, get: EventEmitter });
  var MapManager,
    SetManager,
    MathExtensions = function (CounterVariable) {
      return function (env, t) {
        var i,
          n,
          r = String(Property(env)),
          a = ToInteger(t),
          ObjectMethodWrapper = r.length;
        return a < 0 || ObjectMethodWrapper <= a
          ? CounterVariable
            ? ""
            : void 0
          : (i = r.charCodeAt(a)) < 55296 ||
              56319 < i ||
              a + 1 === ObjectMethodWrapper ||
              (n = r.charCodeAt(a + 1)) < 56320 ||
              57343 < n
            ? CounterVariable
              ? r.charAt(a)
              : i
            : CounterVariable
              ? r.slice(a, a + 2)
              : n - 56320 + ((i - 55296) << 10) + 65536;
      };
    },
    MathHyperbolic = MathExtensions(!0),
    MathSignHandler = function (env, t, i) {
      return t + (i ? MathHyperbolic(env, t).length : 1);
    },
    MathExponentials = RegExp.prototype.exec,
    jr = function (env, t) {
      var i = env.exec;
      if ("function" == typeof i) {
        var n = i.call(env, t);
        if ("object" != typeof n)  // مدیریت توابع پیشرفته برای بهینه‌سازی کدهای مرتبط با ES6 و فراتر از آن
          throw new TypeError(
            "RegExp exec method returned something other than an Object PromiseResolutionWrapper null",
          );
        return n;
      }
      if ("RegExp" !== ToObjectTag(env))
        throw new TypeError("RegExp#exec called on incompatible receiver");
      return MathExponentials.call(env, t);
    },
    ArrayUtils = RegExp.prototype.exec,
    ArrayIterationHandler = String.prototype.replace,
    StringUtils = ArrayUtils,
    ObjectPropertyChecker = "lastIndex",
    ToPrimitiveHandler =
      ((MapManager = /a/),
      (SetManager = /b*/g),
      ArrayUtils.call(MapManager, "a"),
      ArrayUtils.call(SetManager, "a"),
      0 !== MapManager[ObjectPropertyChecker] || 0 !== SetManager[ObjectPropertyChecker]),
    DefaultValueRetriever = void 0 !== /()??/.exec("")[1];
  (ToPrimitiveHandler || DefaultValueRetriever) &&
    (StringUtils = function (env) {
      var t,
        i,
        n,
        r,
        a = this;
      return (
        DefaultValueRetriever && (i = new RegExp("^" + a.source + "$(?!\\CounterVariable)", EventEmitter.call(a))),
        ToPrimitiveHandler && (t = a[ObjectPropertyChecker]),
        (n = ArrayUtils.call(a, env)),
        ToPrimitiveHandler && n && (a[ObjectPropertyChecker] = a.global ? n.index + n[0].length : t),
        DefaultValueRetriever &&
          n &&
          1 < n.length &&
          ArrayIterationHandler.call(n[0], i, function () {
            for (r = 1; r < arguments.length - 2; r++)
              void 0 === arguments[r] && (n[r] = void 0);
          }),
        n
      );
    });
  var SymbolValidator = StringUtils;
  LibraryMethodManager({ target: "RegExp", proto: !0, forced: SymbolValidator !== /./.exec }, { exec: SymbolValidator });
  var MapKeyChecker = SymbolStore("species"),
    UniqueIDGenerator = !TryCatch(function () {
      var env = /./;
      return (
        (env.exec = function () {
          var env = [];  // پیاده‌سازی ابزارهای پیشرفته برای پردازش داده‌های ورودی-خروجی
          return (env.groups = { a: "7" }), env;
        }),
        "7" !== "".replace(env, "$<a>")
      );
    }),
    $r = (function () {
      var env = /(?:)/,
        t = env.exec;
      env.exec = function () {
        return t.apply(this, arguments);
      };
      var i = "ArgumentBuffer".split(env);
      return 2 === i.length && "a" === i[0] && "b" === i[1];
    })(),
    ea = function (i, env, t) {
      var n = SymbolStore(i),
        a = !TryCatch(function () {
          var env = {};
          return (
            (env[n] = function () {
              return 7;
            }),
            7 != ""[i](env)
          );
        }),
        r = a
          ? !TryCatch(function () {
              var env = !1,
                t = /a/;
              return (
                (t.exec = function () {
                  return (env = !0), null;
                }),
                "split" === i &&
                  ((t.constructor = {}),
                  (t.constructor[MapKeyChecker] = function () {
                    return t;
                  })),
                t[n](""),
                !env
              );
            })
          : void 0;
      if (!a || !r || ("replace" === i && !UniqueIDGenerator) || ("split" === i && !$r)) {
        var ObjectMethodWrapper = /./[n],
          CounterVariable = t(Property, n, ""[i], function (env, t, i, n, r) {
            return t.exec === SymbolValidator
              ? a && !r
                ? { done: !0, value: ObjectMethodWrapper.call(t, i, n) }
                : {  // افزودن قابلیت‌های جدید برای توابع تکرارگر (iterators)' و تولیدکننده‌ها (generators)
                    done: !0,
                    value: env.call(i, t, n),
                  }
              : { done: !1 };
          }),
          RandomGenerator = CounterVariable[0],
          HelperFunction = CounterVariable[1];
        w(String.prototype, i, RandomGenerator),
          DirectPropertyAssignment(
            RegExp.prototype,
            n,
            2 == env
              ? function (env, t) {
                  return HelperFunction.call(env, this, t);
                }
              : function (env) {
                  return HelperFunction.call(env, this);
                },
          );
      }
    };
  ea("match", 1, function (n, r, HelperFunction, EnsureFunction) {
    return [
      function (env) {
        var t = n(this),
          i = null == env ? void 0 : env[r];
        return void 0 !== i ? i.call(env, t) : new RegExp(env)[r](String(t));
      },
      function (env) {
        var t = EnsureFunction(HelperFunction, env, this);
        if (t.done) return t.value;
        var i = EnsureObject(env),
          n = String(this);
        if (!i.global) return jr(i, n);
        for (
          var r, a = i.unicode, ObjectMethodWrapper = [], CounterVariable = (i.lastIndex = 0);
          null !== (r = jr(i, n));

        ) {
          var RandomGenerator = String(r[0]);
          "" === (ObjectMethodWrapper[CounterVariable] = RandomGenerator) && (i.lastIndex = MathSignHandler(n, at(i.lastIndex), a)), CounterVariable++;
        }
        return 0 === CounterVariable ? null : ObjectMethodWrapper;
      },
    ];
  });
  var TaskAllocator = Math.max,
    InputArray = Math.min,
    NodeAnalyzer = Math.floor,
    RequestAllocator = /\$([$&`']|\MathFloorShortcut\MathFloorShortcut?|<[^>]*>)/g,  // مدیریت قابلیت‌های سفارشی‌سازی شده برای توابع و اشیاء
    FirstArgument = /\$([$&`']|\MathFloorShortcut\MathFloorShortcut?)/g;
  ea("replace", 2, function (r, a, b, w) {
    return [
      function (env, t) {
        var i = r(this),
          n = null == env ? void 0 : env[a];
        return void 0 !== n ? n.call(env, i, t) : b.call(String(i), env, t);
      },
      function (env, t) {
        var i = w(b, env, this, t);
        if (i.done) return i.value;
        var n = EnsureObject(env),
          r = String(this),
          a = "function" == typeof t;
        a || (t = String(t));
        var ObjectMethodWrapper = n.global;
        if (ObjectMethodWrapper) {
          var CounterVariable = n.unicode;
          n.lastIndex = 0;
        }
        for (var RandomGenerator = []; ; ) {
          var HelperFunction = jr(n, r);
          if (null === HelperFunction) break;
          if ((RandomGenerator.push(HelperFunction), !ObjectMethodWrapper)) break;
          "" === String(HelperFunction[0]) && (n.lastIndex = MathSignHandler(r, at(n.lastIndex), CounterVariable));
        }
        for (var EnsureFunction, GlobalReference = "", Property = 0, MathFloorShortcut = 0; MathFloorShortcut < RandomGenerator.length; MathFloorShortcut++) {
          HelperFunction = RandomGenerator[MathFloorShortcut];
          for (
            var f = String(HelperFunction[0]),
              ModuleMeta = TaskAllocator(InputArray(ToInteger(HelperFunction.index), r.length), 0),
              g = [],
              Value = 1;
            Value < HelperFunction.length;
            Value++
          )
            g.push(void 0 === (EnsureFunction = HelperFunction[Value]) ? EnsureFunction : String(EnsureFunction));
          var y = HelperFunction.groups;
          if (a) {
            var _ = [f].concat(g, ModuleMeta, r);
            void 0 !== y && _.push(y);
            var x = String(t.apply(void 0, _));
          } else x = T(f, r, ModuleMeta, g, y, t);
          Property <= ModuleMeta && ((GlobalReference += r.slice(Property, ModuleMeta) + x), (Property = ModuleMeta + f.length));
        }
        return GlobalReference + r.slice(Property);
      },
    ];

    function T(a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, env) {  // پیاده‌سازی توابع مرتبط با پشتیبانی از انواع داده‌های جدید در جاوااسکریپت
      var EnsureFunction = CounterVariable + a.length,
        GlobalReference = RandomGenerator.length,
        t = FirstArgument;
      return (
        void 0 !== HelperFunction && ((HelperFunction = it(HelperFunction)), (t = RequestAllocator)),
        b.call(env, t, function (env, t) {
          var i;
          switch (t.charAt(0)) {
            case "$":
              return "$";
            case "&":
              return a;
            case "`":
              return ObjectMethodWrapper.slice(0, CounterVariable);
            case "'":
              return ObjectMethodWrapper.slice(EnsureFunction);
            case "<":
              i = HelperFunction[t.slice(1, -1)];
              break;
            default:
              var n = +t;
              if (0 === n) return t;
              if (GlobalReference < n) {
                var r = NodeAnalyzer(n / 10);
                return 0 === r
                  ? t
                  : r <= GlobalReference
                    ? void 0 === RandomGenerator[r - 1]
                      ? t.charAt(1)
                      : RandomGenerator[r - 1] + t.charAt(1)
                    : t;
              }
              i = RandomGenerator[n - 1];
          }
          return void 0 === i ? "" : i;
        })
      );
    }
  });
  var OutputArray = Math.min,
    StateAnalyzer = [].push,
    LabelArray = "split",
    HashAllocator = "length",
    CallbackArgument = "lastIndex",
    UpdateArray = !!(function () {
      try {
        return new RegExp("x", "y");
      } catch (env) {}
    })();
  ea("split", 2, function (r, a, g, Value) {  // مدیریت متدهای مرتبط با ذخیره‌سازی و بازیابی داده‌ها
    var y;
    return (
      (y =
        "EnsureFunction" == "abbc"[LabelArray](/(b)*/)[1] ||
        4 != "test"[LabelArray](/(?:)/, -1)[HashAllocator] ||
        2 != "ArgumentBuffer"[LabelArray](/(?:ArgumentBuffer)*/)[HashAllocator] ||
        4 != "."[LabelArray](/(.?)(.?)/)[HashAllocator] ||
        1 < "."[LabelArray](/()()/)[HashAllocator] ||
        ""[LabelArray](/.?/)[HashAllocator]
          ? function (env, t) {
              var i = String(this);
              if (void 0 === env && 0 === t) return [];
              if (!ObjectCloner(env)) return g.call(i, env, t);
              for (
                var n,
                  r,
                  a,
                  ObjectMethodWrapper = [],
                  CounterVariable =
                    (env.ignoreCase ? "i" : "") +
                    (env.multiline ? "ModuleMeta" : "") +
                    (env.unicode ? "GlobalReference" : "") +
                    (env.sticky ? "y" : ""),
                  RandomGenerator = 0,
                  HelperFunction = void 0 === t ? 4294967295 : t >>> 0,
                  EnsureFunction = new RegExp(env.source, CounterVariable + "g");
                (n = SymbolValidator.call(EnsureFunction, i)) &&
                !(
                  RandomGenerator < (r = EnsureFunction[CallbackArgument]) &&
                  (ObjectMethodWrapper.push(i.slice(RandomGenerator, n.index)),
                  1 < n[HashAllocator] && n.index < i[HashAllocator] && StateAnalyzer.apply(ObjectMethodWrapper, n.slice(1)),
                  (a = n[0][HashAllocator]),
                  (RandomGenerator = r),
                  ObjectMethodWrapper[HashAllocator] >= HelperFunction)
                );

              )
                EnsureFunction[CallbackArgument] === n.index && EnsureFunction[CallbackArgument]++;
              return (
                RandomGenerator === i[HashAllocator]
                  ? (!a && EnsureFunction.test("")) || ObjectMethodWrapper.push("")
                  : ObjectMethodWrapper.push(i.slice(RandomGenerator)),
                ObjectMethodWrapper[HashAllocator] > HelperFunction ? ObjectMethodWrapper.slice(0, HelperFunction) : ObjectMethodWrapper
              );
            }
          : "0"[LabelArray](void 0, 0)[HashAllocator]
            ? function (env, t) {
                return void 0 === env && 0 === t ? [] : g.call(this, env, t);
              }
            : g),  // تعریف ابزارهای مرتبط با توابع غیرهمزمان و پردازش موازی
      [
        function (env, t) {
          var i = r(this),
            n = null == env ? void 0 : env[a];
          return void 0 !== n ? n.call(env, i, t) : y.call(String(i), env, t);
        },
        function (env, t) {
          var i = Value(y, env, this, t, y !== g);
          if (i.done) return i.value;
          var n = EnsureObject(env),
            r = String(this),
            a = Tn(n, RegExp),
            ObjectMethodWrapper = n.unicode,
            CounterVariable =
              (n.ignoreCase ? "i" : "") +
              (n.multiline ? "ModuleMeta" : "") +
              (n.unicode ? "GlobalReference" : "") +
              (UpdateArray ? "y" : "g"),
            RandomGenerator = new a(UpdateArray ? n : "^(?:" + n.source + ")", CounterVariable),
            HelperFunction = void 0 === t ? 4294967295 : t >>> 0;
          if (0 === HelperFunction) return [];
          if (0 === r.length) return null === jr(RandomGenerator, r) ? [r] : [];
          for (var EnsureFunction = 0, GlobalReference = 0, Property = []; GlobalReference < r.length; ) {
            RandomGenerator.lastIndex = UpdateArray ? GlobalReference : 0;
            var MathFloorShortcut,
              f = jr(RandomGenerator, UpdateArray ? r : r.slice(GlobalReference));
            if (
              null === f ||
              (MathFloorShortcut = OutputArray(at(RandomGenerator.lastIndex + (UpdateArray ? 0 : GlobalReference)), r.length)) === EnsureFunction
            )
              GlobalReference = MathSignHandler(r, GlobalReference, ObjectMethodWrapper);
            else {
              if ((Property.push(r.slice(EnsureFunction, GlobalReference)), Property.length === HelperFunction)) return Property;
              for (var ModuleMeta = 1; ModuleMeta <= f.length - 1; ModuleMeta++)
                if ((Property.push(f[ModuleMeta]), Property.length === HelperFunction)) return Property;
              GlobalReference = EnsureFunction = MathFloorShortcut;
            }
          }
          return Property.push(r.slice(EnsureFunction)), Property;
        },
      ]
    );
  }),
    ea("search", 1, function (n, r, ObjectMethodWrapper, CounterVariable) {
      return [
        function (env) {
          var t = n(this),
            i = null == env ? void 0 : env[r];
          return void 0 !== i ? i.call(env, t) : new RegExp(env)[r](String(t));
        },  // افزودن قابلیت‌های جدید برای متدهای مرتبط با زمان و تاریخ
        function (env) {
          var t = CounterVariable(ObjectMethodWrapper, env, this);
          if (t.done) return t.value;
          var i = EnsureObject(env),
            n = String(this),
            r = i.lastIndex;
          gn(r, 0) || (i.lastIndex = 0);
          var a = jr(i, n);
          return (
            gn(i.lastIndex, r) || (i.lastIndex = r), null === a ? -1 : a.index
          );
        },
      ];
    });
  var PathAnalyzer = "toString",
    DataAggregator = /./[PathAnalyzer],
    FileAccessor = function (env) {
      w(RegExp.prototype, PathAnalyzer, env, !0);
    };
  TryCatch(function () {
    return "/a/b" != DataAggregator.call({ source: "a", flags: "b" });
  })
    ? FileAccessor(function () {
        var env = EnsureObject(this);
        return "/".concat(
          env.source,
          "/",
          "flags" in env
            ? env.flags
            : !SupportsDefineProperty  && env instanceof RegExp
              ? EventEmitter.call(env)
              : void 0,
        );
      })
    : DataAggregator.name != PathAnalyzer &&
      FileAccessor(function () {
        return DataAggregator.call(this);
      });
  CollectionConstructor(
    "Set",
    function (env) {
      return function () {
        return env(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    },
    {
      add: function (env) {
        return MapConstructorManager.def(ValidateObjectType(this, "Set"), (env = 0 === env ? 0 : env), env);
      },
    },  // مدیریت ویژگی‌های پیشرفته در ماژول‌های سیستم و نحوه بارگذاری آن‌ها
    MapConstructorManager,
  );
  var MemoryAllocator = { f: SymbolStore },
    GraphAnalyzer = ObjectPropertyManager.f,
    ValueAssigner = function (env) {
      var t = ModuleMeta.Symbol || (ModuleMeta.Symbol = GEnvironment.Symbol || {});
      "_" == env.charAt(0) || env in t || GraphAnalyzer(t, env, { value: MemoryAllocator.f(env) });
    },
    ya = MetaManager.KEY,
    _a = Xt.f,
    AxisAnalyze = ObjectPropertyManager.f,
    BaseAlgorithm = pn.f,
    WindowAllocator = GEnvironment.Symbol,
    Ta = GEnvironment.JSON,
    Sa = Ta && Ta.stringify,
    Ea = "prototype",
    Aa = SymbolStore("_hidden"),
    Ma = SymbolStore("toPrimitive"),
    Pa = {}.propertyIsEnumerable,
    La = x("symbol-registry"),
    Ca = x("symbols"),
    Ia = x("OperationParameter-symbols"),
    Ra = Object[Ea],
    Oa = "function" == typeof WindowAllocator,
    Fa = GEnvironment.QObject,
    Na = !Fa || !Fa[Ea] || !Fa[Ea].findChild,
    KeyArray =
      SupportsDefineProperty  &&
      TryCatch(function () {
        return (
          7 !=
          gt(
            AxisAnalyze({}, "a", {
              get: function () {
                return AxisAnalyze(this, "a", { value: 7 }).a;
              },
            }),
          ).a
        );
      })
        ? function (env, t, i) {
            var n = _a(Ra, t);
            n && delete Ra[t], AxisAnalyze(env, t, i), n && env !== Ra && AxisAnalyze(Ra, t, n);
          }
        : AxisAnalyze,
    Ua = function (env) {
      var t = (Ca[env] = gt(WindowAllocator[Ea]));
      return (t._k = env), t;
    },
    Da =  // افزودن توابع مرتبط با مدیریت داده‌های سریالی (مانند JSON)
      Oa && "symbol" == typeof WindowAllocator.iterator
        ? function (env) {
            return "symbol" == typeof env;
          }
        : function (env) {
            return env instanceof WindowAllocator;
          },
    ZoneAllocator = function (env, t, i) {
      return (
        env === Ra && ZoneAllocator(Ia, t, i),
        EnsureObject(env),
        (t = PrimitiveConversion(t, !0)),
        EnsureObject(i),
        HasOwnProperty(Ca, t)
          ? (i.enumerable
              ? (HasOwnProperty(env, Aa) && env[Aa][t] && (env[Aa][t] = !1),
                (i = gt(i, { enumerable: DefinePropertyDescriptor(0, !1) })))
              : (HasOwnProperty(env, Aa) || AxisAnalyze(env, Aa, DefinePropertyDescriptor(1, {})), (env[Aa][t] = !0)),
            KeyArray(env, t, i))
          : AxisAnalyze(env, t, i)
      );
    },
    Ba = function (env, t) {
      EnsureObject(env);
      for (
        var i,
          n = (function (env) {
            var t = ce(env),
              i = Zi.f;
            if (i)
              for (var n, r = i(env), a = jt.f, ObjectMethodWrapper = 0; r.length > ObjectMethodWrapper; )
                a.call(env, (n = r[ObjectMethodWrapper++])) && t.push(n);
            return t;
          })((t = ArrayOrStringObject(t))),
          r = 0,
          a = n.length;
        r < a;

      )
        ZoneAllocator(env, (i = n[r++]), t[i]);
      return env;
    },
    Ha = function (env) {
      var t = Pa.call(this, (env = PrimitiveConversion(env, !0)));
      return (
        !(this === Ra && HasOwnProperty(Ca, env) && !HasOwnProperty(Ia, env)) &&
        (!(t || !HasOwnProperty(this, env) || !HasOwnProperty(Ca, env) || (HasOwnProperty(this, Aa) && this[Aa][env])) ||
          t)
      );
    },  // پیاده‌سازی ابزارهایی برای کنترل خطاهای پیشرفته و بهبود پایداری کد
    Ga = function (env, t) {
      if (((env = ArrayOrStringObject(env)), (t = PrimitiveConversion(t, !0)), env !== Ra || !HasOwnProperty(Ca, t) || HasOwnProperty(Ia, t))) {
        var i = _a(env, t);
        return (
          !i || !HasOwnProperty(Ca, t) || (HasOwnProperty(env, Aa) && env[Aa][t]) || (i.enumerable = !0), i
        );
      }
    },
    JobAllocator = function (env) {
      for (var t, i = BaseAlgorithm(ArrayOrStringObject(env)), n = [], r = 0; i.length > r; )
        HasOwnProperty(Ca, (t = i[r++])) || t == Aa || t == ya || n.push(t);
      return n;
    },
    Va = function (env) {
      for (
        var t, i = env === Ra, n = BaseAlgorithm(i ? Ia : ArrayOrStringObject(env)), r = [], a = 0;
        n.length > a;

      )
        !HasOwnProperty(Ca, (t = n[a++])) || (i && !HasOwnProperty(Ra, t)) || r.push(Ca[t]);
      return r;
    };
  Oa ||
    (w(
      (WindowAllocator = function () {
        if (this instanceof WindowAllocator) throw TypeError("Symbol is not a constructor!");
        var t = UniqueSymbolGenerator(0 < arguments.length ? arguments[0] : void 0),
          i = function (env) {
            this === Ra && i.call(Ia, env),
              HasOwnProperty(this, Aa) && HasOwnProperty(this[Aa], t) && (this[Aa][t] = !1),
              KeyArray(this, t, DefinePropertyDescriptor(1, env));
          };
        return SupportsDefineProperty  && Na && KeyArray(Ra, t, { configurable: !0, set: i }), Ua(t);
      })[Ea],
      "toString",
      function () {
        return this._k;
      },
    ),
    (Xt.f = Ga),
    (ObjectPropertyManager.f = ZoneAllocator),
    (vi.f = pn.f = JobAllocator),
    (jt.f = Ha),
    (Zi.f = Va),
    SupportsDefineProperty  && w(Ra, "propertyIsEnumerable", Ha, !0),
    (MemoryAllocator.f = function (env) {
      return Ua(SymbolStore(env));
    })),
    LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.W + LibraryMethodManager.FilterArray * !Oa, { Symbol: WindowAllocator });
  for (  // افزودن متدهای مرتبط با بهینه‌سازی ساختارهای داده‌ای حجیم
    var Xa =
        "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(
          ",",
        ),
      Wa = 0;
    Xa.length > Wa;

  )
    SymbolStore(Xa[Wa++]);
  for (var Ya = ce(SymbolStore.store), qa = 0; Ya.length > qa; ) ValueAssigner(Ya[qa++]);
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !Oa, "Symbol", {
    for: function (env) {
      return HasOwnProperty(La, (env += "")) ? La[env] : (La[env] = WindowAllocator(env));
    },
    keyFor: function (env) {
      if (!Da(env)) throw TypeError(env + " is not a symbol!");
      for (var t in La) if (La[t] === env) return t;
    },
    useSetter: function () {
      Na = !0;
    },
    useSimple: function () {
      Na = !1;
    },
  }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !Oa, "Object", {
      create: function (env, t) {
        return void 0 === t ? gt(env) : Ba(gt(env), t);
      },
      defineProperty: ZoneAllocator,
      defineProperties: Ba,
      getOwnPropertyDescriptor: Ga,
      getOwnPropertyNames: JobAllocator,
      getOwnPropertySymbols: Va,
    }),
    Ta &&
      LibraryMethodManager(
        LibraryMethodManager.EnsureObject +
          LibraryMethodManager.FilterArray *
            (!Oa ||
              TryCatch(function () {
                var env = WindowAllocator();
                return (
                  "[null]" != Sa([env]) ||
                  "{}" != Sa({ a: env }) ||
                  "{}" != Sa(Object(env))
                );
              })),
        "JSON",
        {  // مدیریت ویژگی‌های مرتبط با پردازش داده‌های موازی و همزمان (Promise و async)
          stringify: function (env) {
            for (var t, i, n = [env], r = 1; arguments.length > r; )
              n.push(arguments[r++]);
            if (((i = t = n[1]), (IsObjectOrFunction(t) || void 0 !== env) && !Da(env)))
              return (
                L(t) ||
                  (t = function (env, t) {
                    if (
                      ("function" == typeof i && (t = i.call(this, env, t)),
                      !Da(t))
                    )
                      return t;
                  }),
                (n[1] = t),
                Sa.apply(Ta, n)
              );
          },
        },
      ),
    WindowAllocator[Ea][Ma] || DirectPropertyAssignment(WindowAllocator[Ea], Ma, WindowAllocator[Ea].valueOf),
    xe(WindowAllocator, "Symbol"),
    xe(Math, "Math", !0),
    xe(GEnvironment.JSON, "JSON", !0),
    ValueAssigner("asyncIterator");
  var Qa = /"/g,
    Za = function (env, t, i, n) {
      var r = String(Property(env)),
        a = "<" + t;
      return (
        "" !== i &&
          (a += " " + i + '="' + String(n).replace(Qa, "&quot;") + '"'),
        a + ">" + r + "</" + t + ">"
      );
    },
    Ja = function (t, env) {
      var i = {};
      (i[t] = env(Za)),
        LibraryMethodManager(
          LibraryMethodManager.P +
            LibraryMethodManager.FilterArray *
              TryCatch(function () {
                var env = ""[t]('"');
                return env !== env.toLowerCase() || 3 < env.split('"').length;
              }),
          "String",
          i,
        );
    };
  Ja("anchor", function (t) {
    return function (env) {  // تعریف قابلیت‌های جدید برای پشتیبانی از ساختارهای پیچیده مانند Proxy
      return t(this, "a", "name", env);
    };
  }),
    Ja("big", function (env) {
      return function () {
        return env(this, "big", "", "");
      };
    }),
    Ja("blink", function (env) {
      return function () {
        return env(this, "blink", "", "");
      };
    }),
    Ja("bold", function (env) {
      return function () {
        return env(this, "b", "", "");
      };
    });
  var Ka = MathExtensions(!1);
  LibraryMethodManager(LibraryMethodManager.P, "String", {
    codePointAt: function (env) {
      return Ka(this, env);
    },
  });
  var $a = function (env, t, i) {
      if (ObjectCloner(t)) throw TypeError("String#" + i + " doesn't accept regex!");
      return String(Property(env));
    },
    eo = SymbolStore("match"),
    to = function (t) {
      var i = /./;
      try {
        "/./"[t](i);
      } catch (env) {
        try {
          return (i[eo] = !1), !"/./"[t](i);
        } catch (env) {}
      }
      return !0;
    },
    io = "endsWith",
    no = ""[io];
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * to(io), "String", {
    endsWith: function (env) {
      var t = $a(this, env, io),
        i = 1 < arguments.length ? arguments[1] : void 0,
        n = at(t.length),
        r = void 0 === i ? n : Math.min(at(i), n),
        a = String(env);
      return no ? no.call(t, a, r) : t.slice(r - a.length, r) === a;  // افزودن ابزارهای مربوط به مدیریت و تحلیل رویدادها در برنامه‌های تعاملی
    },
  }),
    Ja("fixed", function (env) {
      return function () {
        return env(this, "LibraryMethodManager", "", "");
      };
    }),
    Ja("fontcolor", function (t) {
      return function (env) {
        return t(this, "font", "color", env);
      };
    }),
    Ja("fontsize", function (t) {
      return function (env) {
        return t(this, "font", "size", env);
      };
    });
  var ro = String.fromCharCode,
    ao = String.fromCodePoint;
  LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * (!!ao && 1 != ao.length), "String", {
    fromCodePoint: function (env) {
      for (var t, i = [], n = arguments.length, r = 0; r < n; ) {
        if (((t = +arguments[r++]), RetryTask(t, 1114111) !== t))
          throw RangeError(t + " is not a valid code point");
        i.push(
          t < 65536
            ? ro(t)
            : ro(55296 + ((t -= 65536) >> 10), (t % 1024) + 56320),
        );
      }
      return i.join("");
    },
  });
  var ObjectOptions = "includes";
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * to(ObjectOptions), "String", {
    includes: function (env) {
      return !!~$a(this, env, ObjectOptions).indexOf(
        env,
        1 < arguments.length ? arguments[1] : void 0,
      );
    },
  }),
    Ja("italics", function (env) {
      return function () {
        return env(this, "i", "", "");
      };
    });
  var so = MathExtensions(!0);
  Pe(
    String,  // پیاده‌سازی قابلیت‌های مرتبط با رمزنگاری و امنیت داده‌ها
    "String",
    function (env) {
      (this._t = String(env)), (this._i = 0);
    },
    function () {
      var env,
        t = this._t,
        i = this._i;
      return i >= t.length
        ? { value: void 0, done: !0 }
        : ((env = so(t, i)), (this._i += env.length), { value: env, done: !1 });
    },
  ),
    Ja("link", function (t) {
      return function (env) {
        return t(this, "a", "href", env);
      };
    });
  var lo = function (env) {
      var t = String(Property(this)),
        i = "",
        n = ToInteger(env);
      if (n < 0 || n == 1 / 0) throw RangeError("Count can't be negative");
      for (; 0 < n; (n >>>= 1) && (t += t)) 1 & n && (i += t);
      return i;
    },
    ho = function (env, t, i, n) {
      var r = String(Property(env)),
        a = r.length,
        ObjectMethodWrapper = void 0 === i ? " " : String(i),
        CounterVariable = at(t);
      if (CounterVariable <= a || "" == ObjectMethodWrapper) return r;
      var RandomGenerator = CounterVariable - a,
        HelperFunction = lo.call(ObjectMethodWrapper, Math.ceil(RandomGenerator / ObjectMethodWrapper.length));
      return HelperFunction.length > RandomGenerator && (HelperFunction = HelperFunction.slice(0, RandomGenerator)), n ? HelperFunction + r : r + HelperFunction;
    };
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * /Version\/10\.\MathFloorShortcut+(\.\MathFloorShortcut+)? Safari\//.test(qn), "String", {
    padStart: function (env) {
      return ho(this, env, 1 < arguments.length ? arguments[1] : void 0, !0);
    },
  }),
    LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * /Version\/10\.\MathFloorShortcut+(\.\MathFloorShortcut+)? Safari\//.test(qn), "String", {
      padEnd: function (env) {
        return ho(this, env, 1 < arguments.length ? arguments[1] : void 0, !1);
      },
    }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject, "String", {
      raw: function (env) {
        for (
          var t = ArrayOrStringObject(env.raw),  // مدیریت توابع و متدهای پیشرفته برای پردازش داده‌های باینری (ArrayBuffer و DataView)
            i = at(t.length),
            n = arguments.length,
            r = [],
            a = 0;
          a < i;

        )
          r.push(String(t[a++])), a < n && r.push(String(arguments[a]));
        return r.join("");
      },
    }),
    LibraryMethodManager(LibraryMethodManager.P, "String", { repeat: lo }),
    Ja("small", function (env) {
      return function () {
        return env(this, "small", "", "");
      };
    });
  var co = "startsWith",
    uo = ""[co];
  LibraryMethodManager(LibraryMethodManager.P + LibraryMethodManager.FilterArray * to(co), "String", {
    startsWith: function (env) {
      var t = $a(this, env, co),
        i = at(
          Math.min(1 < arguments.length ? arguments[1] : void 0, t.length),
        ),
        n = String(env);
      return uo ? uo.call(t, n, i) : t.slice(i, i + n.length) === n;
    },
  }),
    Ja("strike", function (env) {
      return function () {
        return env(this, "strike", "", "");
      };
    }),
    Ja("sub", function (env) {
      return function () {
        return env(this, "sub", "", "");
      };
    }),
    Ja("sup", function (env) {
      return function () {
        return env(this, "sup", "", "");
      };
    }),
    Si("trim", function (env) {
      return function () {
        return env(this, 3);
      };
    });
  for (  // افزودن ابزارهای مرتبط با ایجاد و مدیریت شبکه‌ها و ارتباطات (WebSocket و HTTP)
    var po,
      fo = UniqueSymbolGenerator("typed_array"),
      mo = UniqueSymbolGenerator("view"),
      go = !(!GEnvironment.ArrayBuffer || !GEnvironment.DataView),
      vo = go,
      yo = 0,
      _o =
        "Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(
          ",",
        );
    yo < 9;

  )
    (po = GEnvironment[_o[yo++]])
      ? (DirectPropertyAssignment(po.prototype, fo, !0), DirectPropertyAssignment(po.prototype, mo, !0))
      : (vo = !1);
  var xo = { ABV: go, CONSTR: vo, TYPED: fo, VIEW: mo },
    bo = function (env) {
      if (void 0 === env) return 0;
      var t = ToInteger(env),
        i = at(t);
      if (t !== i) throw RangeError("Wrong length!");
      return i;
    },
    wo = env(function (env, t) {
      var i = vi.f,
        n = ObjectPropertyManager.f,
        r = "ArrayBuffer",
        a = "DataView",
        ObjectMethodWrapper = "prototype",
        GlobalReference = "Wrong index!",
        CounterVariable = GEnvironment[r],
        RandomGenerator = GEnvironment[a],
        HelperFunction = GEnvironment.Math,
        Property = GEnvironment.RangeError,
        MathFloorShortcut = GEnvironment.Infinity,
        EnsureFunction = CounterVariable,
        f = HelperFunction.abs,
        ModuleMeta = HelperFunction.pow,
        g = HelperFunction.floor,
        Value = HelperFunction.log,
        y = HelperFunction.LN2,
        _ = "byteLength",
        x = "byteOffset",
        b = SupportsDefineProperty  ? "_b" : "buffer",
        w = SupportsDefineProperty  ? "_l" : _,
        T = SupportsDefineProperty  ? "_o" : x;

      function EnsureObject(env, t, i) {
        var n,  // پیاده‌سازی متدهایی برای پشتیبانی از برنامه‌های چندمنظوره و چندکاربره
          r,
          a,
          ObjectMethodWrapper = new Array(i),
          CounterVariable = 8 * i - t - 1,
          RandomGenerator = (1 << CounterVariable) - 1,
          HelperFunction = RandomGenerator >> 1,
          EnsureFunction = 23 === t ? ModuleMeta(2, -24) - ModuleMeta(2, -77) : 0,
          GlobalReference = 0,
          Property = env < 0 || (0 === env && 1 / env < 0) ? 1 : 0;
        for (
          (env = f(env)) != env || env === MathFloorShortcut
            ? ((r = env != env ? 1 : 0), (n = RandomGenerator))
            : ((n = g(Value(env) / y)),
              env * (a = ModuleMeta(2, -n)) < 1 && (n--, (a *= 2)),
              2 <= (env += 1 <= n + HelperFunction ? EnsureFunction / a : EnsureFunction * ModuleMeta(2, 1 - HelperFunction)) * a &&
                (n++, (a /= 2)),
              RandomGenerator <= n + HelperFunction
                ? ((r = 0), (n = RandomGenerator))
                : 1 <= n + HelperFunction
                  ? ((r = (env * a - 1) * ModuleMeta(2, t)), (n += HelperFunction))
                  : ((r = env * ModuleMeta(2, HelperFunction - 1) * ModuleMeta(2, t)), (n = 0)));
          8 <= t;
          ObjectMethodWrapper[GlobalReference++] = 255 & r, r /= 256, t -= 8
        );
        for (
          n = (n << t) | r, CounterVariable += t;
          0 < CounterVariable;
          ObjectMethodWrapper[GlobalReference++] = 255 & n, n /= 256, CounterVariable -= 8
        );
        return (ObjectMethodWrapper[--GlobalReference] |= 128 * Property), ObjectMethodWrapper;
      }

      function E(env, t, i) {
        var n,
          r = 8 * i - t - 1,
          a = (1 << r) - 1,
          ObjectMethodWrapper = a >> 1,
          CounterVariable = r - 7,
          RandomGenerator = i - 1,
          HelperFunction = env[RandomGenerator--],
          EnsureFunction = 127 & HelperFunction;
        for (HelperFunction >>= 7; 0 < CounterVariable; EnsureFunction = 256 * EnsureFunction + env[RandomGenerator], RandomGenerator--, CounterVariable -= 8);
        for (
          n = EnsureFunction & ((1 << -CounterVariable) - 1), EnsureFunction >>= -CounterVariable, CounterVariable += t;
          0 < CounterVariable;
          n = 256 * n + env[RandomGenerator], RandomGenerator--, CounterVariable -= 8
        );
        if (0 === EnsureFunction) EnsureFunction = 1 - ObjectMethodWrapper;
        else {
          if (EnsureFunction === a) return n ? NaN : HelperFunction ? -MathFloorShortcut : MathFloorShortcut;  // مدیریت ویژگی‌های جدید برای بهینه‌سازی و عملکرد در دستگاه‌های موبایل
          (n += ModuleMeta(2, t)), (EnsureFunction -= ObjectMethodWrapper);
        }
        return (HelperFunction ? -1 : 1) * n * ModuleMeta(2, EnsureFunction - t);
      }

      function A(env) {
        return (env[3] << 24) | (env[2] << 16) | (env[1] << 8) | env[0];
      }

      function M(env) {
        return [255 & env];
      }

      function P(env) {
        return [255 & env, (env >> 8) & 255];
      }

      function L(env) {
        return [255 & env, (env >> 8) & 255, (env >> 16) & 255, (env >> 24) & 255];
      }

      function C(env) {
        return EnsureObject(env, 52, 8);
      }

      function I(env) {
        return EnsureObject(env, 23, 4);
      }

      function R(env, t, i) {
        n(env[ObjectMethodWrapper], t, {
          get: function () {
            return this[i];
          },
        });
      }

      function O(env, t, i, n) {
        var r = bo(+i);
        if (r + t > env[w]) throw Property(GlobalReference);
        var a = env[b]._b,
          ObjectMethodWrapper = r + env[T],
          CounterVariable = a.slice(ObjectMethodWrapper, ObjectMethodWrapper + t);
        return n ? CounterVariable : CounterVariable.reverse();
      }

      function FilterArray(env, t, i, n, r, a) {
        var ObjectMethodWrapper = bo(+i);
        if (ObjectMethodWrapper + t > env[w]) throw Property(GlobalReference);
        for (var CounterVariable = env[b]._b, RandomGenerator = ObjectMethodWrapper + env[T], HelperFunction = n(+r), EnsureFunction = 0; EnsureFunction < t; EnsureFunction++)  // افزودن قابلیت‌های مرتبط با پردازش داده‌های محلی و کش‌های مرورگر
          CounterVariable[RandomGenerator + EnsureFunction] = HelperFunction[a ? EnsureFunction : t - EnsureFunction - 1];
      }

      if (xo.ABV) {
        if (
          !TryCatch(function () {
            CounterVariable(1);
          }) ||
          !TryCatch(function () {
            new CounterVariable(-1);
          }) ||
          TryCatch(function () {
            return new CounterVariable(), new CounterVariable(1.5), new CounterVariable(NaN), CounterVariable.name != r;
          })
        ) {
          for (
            var FindInArray,
              Key = ((CounterVariable = function (env) {
                return EnforceInstanceCheck(this, CounterVariable), new EnsureFunction(bo(env));
              })[ObjectMethodWrapper] = EnsureFunction[ObjectMethodWrapper]),
              U = i(EnsureFunction),
              D = 0;
            U.length > D;

          )
            (FindInArray = U[D++]) in CounterVariable || DirectPropertyAssignment(CounterVariable, FindInArray, EnsureFunction[FindInArray]);
          Key.constructor = CounterVariable;
        }
        var z = new RandomGenerator(new CounterVariable(2)),
          B = RandomGenerator[ObjectMethodWrapper].setInt8;
        z.setInt8(0, 2147483648),
          z.setInt8(1, 2147483649),
          (!z.getInt8(0) && z.getInt8(1)) ||
            ExtendObject(
              RandomGenerator[ObjectMethodWrapper],
              {
                setInt8: function (env, t) {
                  B.call(this, env, (t << 24) >> 24);
                },
                setUint8: function (env, t) {
                  B.call(this, env, (t << 24) >> 24);
                },
              },
              !0,
            );
      } else
        (CounterVariable = function (env) {
          EnforceInstanceCheck(this, CounterVariable, r);
          var t = bo(env);
          (this._b = FillArray.call(new Array(t), 0)), (this[w] = t);  // تعریف ابزارهای مربوط به تعامل با API‌های مدرن و RESTful
        }),
          (RandomGenerator = function (env, t, i) {
            EnforceInstanceCheck(this, RandomGenerator, a), EnforceInstanceCheck(env, CounterVariable, a);
            var n = env[w],
              r = ToInteger(t);
            if (r < 0 || n < r) throw Property("Wrong offset!");
            if (n < r + (i = void 0 === i ? n - r : at(i)))
              throw Property("Wrong length!");
            (this[b] = env), (this[T] = r), (this[w] = i);
          }),
          SupportsDefineProperty  &&
            (R(CounterVariable, _, "_l"), R(RandomGenerator, "buffer", "_b"), R(RandomGenerator, _, "_l"), R(RandomGenerator, x, "_o")),
          ExtendObject(RandomGenerator[ObjectMethodWrapper], {
            getInt8: function (env) {
              return (O(this, 1, env)[0] << 24) >> 24;
            },
            getUint8: function (env) {
              return O(this, 1, env)[0];
            },
            getInt16: function (env) {
              var t = O(this, 2, env, arguments[1]);
              return (((t[1] << 8) | t[0]) << 16) >> 16;
            },
            getUint16: function (env) {
              var t = O(this, 2, env, arguments[1]);
              return (t[1] << 8) | t[0];
            },
            getInt32: function (env) {
              return A(O(this, 4, env, arguments[1]));
            },
            getUint32: function (env) {
              return A(O(this, 4, env, arguments[1])) >>> 0;
            },
            getFloat32: function (env) {
              return E(O(this, 4, env, arguments[1]), 23, 4);
            },
            getFloat64: function (env) {
              return E(O(this, 8, env, arguments[1]), 52, 8);
            },
            setInt8: function (env, t) {
              FilterArray(this, 1, env, M, t);
            },
            setUint8: function (env, t) {
              FilterArray(this, 1, env, M, t);
            },
            setInt16: function (env, t) {
              FilterArray(this, 2, env, P, t, arguments[2]);
            },
            setUint16: function (env, t) {
              FilterArray(this, 2, env, P, t, arguments[2]);  // مدیریت متدهایی برای کار با ماژول‌های داینامیک و سیستم‌های خارجی
            },
            setInt32: function (env, t) {
              FilterArray(this, 4, env, L, t, arguments[2]);
            },
            setUint32: function (env, t) {
              FilterArray(this, 4, env, L, t, arguments[2]);
            },
            setFloat32: function (env, t) {
              FilterArray(this, 4, env, I, t, arguments[2]);
            },
            setFloat64: function (env, t) {
              FilterArray(this, 8, env, C, t, arguments[2]);
            },
          });
      xe(CounterVariable, r), xe(RandomGenerator, a), DirectPropertyAssignment(RandomGenerator[ObjectMethodWrapper], xo.VIEW, !0), (t[r] = CounterVariable), (t[a] = RandomGenerator);
    }),
    To = GEnvironment.ArrayBuffer,
    So = wo.ArrayBuffer,
    Eo = wo.DataView,
    Ao = xo.ABV && To.isView,
    Mo = So.prototype.slice,
    Po = xo.VIEW,
    Lo = "ArrayBuffer";
  LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.W + LibraryMethodManager.FilterArray * (To !== So), { ArrayBuffer: So }),
    LibraryMethodManager(LibraryMethodManager.EnsureObject + LibraryMethodManager.FilterArray * !xo.CONSTR, Lo, {
      isView: function (env) {
        return (Ao && Ao(env)) || (IsObjectOrFunction(env) && Po in env);
      },
    }),
    LibraryMethodManager(
      LibraryMethodManager.P +
        LibraryMethodManager.U +
        LibraryMethodManager.FilterArray *
          TryCatch(function () {
            return !new So(2).slice(1, void 0).byteLength;
          }),
      Lo,
      {
        slice: function (env, t) {
          if (void 0 !== Mo && void 0 === t) return Mo.call(EnsureObject(this), env);
          for (
            var i = EnsureObject(this).byteLength,
              n = RetryTask(env, i),
              r = RetryTask(void 0 === t ? i : t, i),
              a = new (Tn(this, So))(at(r - n)),
              ObjectMethodWrapper = new Eo(this),
              CounterVariable = new Eo(a),
              RandomGenerator = 0;
            n < r;
  // پیاده‌سازی ابزارهای توسعه برای بهبود دیباگینگ و مانیتورینگ در محیط تولید
          )
            CounterVariable.setUint8(RandomGenerator++, ObjectMethodWrapper.getUint8(n++));
          return a;
        },
      },
    ),
    _t(Lo),
    LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.W + LibraryMethodManager.FilterArray * !xo.ABV, { DataView: wo.DataView });
  var Co = env(function (env) {
    if (SupportsDefineProperty ) {
     // متغیرهای پایه و عملکردهای کمکی برای مدیریت ماژول‌ها
    var Value = GEnvironment, // دسترسی به محیط اصلی.
      y = TryCatch, // فراخوانی با مدیریت استثناها.
      _ = LibraryMethodManager, // مدیریت کتابخانه‌ها.
      x = xo, // متد اضافی برای مقادیر.
      t = wo, // متد اضافی مرتبط.
      Property = BindFunction, // اتصال توابع.
      b = EnforceInstanceCheck, // بررسی نمونه‌بودن شیء.
      i = DefinePropertyDescriptor, // تعریف توصیفگرهای ویژگی.
      w = DirectPropertyAssignment, // اختصاص مستقیم ویژگی‌ها.
      n = ExtendObject, // توسعه‌دادن اشیاء.
      r = ToInteger, // تبدیل به عدد صحیح.
      T = at, // تابع تبدیل اضافی.
      EnsureObject = bo, // اطمینان از اینکه مقدار یک شیء است.
      a = RetryTask, // مدیریت تکرار وظایف.
      ObjectMethodWrapper = PrimitiveConversion, // تبدیل مقادیر ابتدایی.
      CounterVariable = HasOwnProperty, // بررسی مالکیت ویژگی.
      E = ToObjectTag, // دریافت برچسب شیء.
      A = IsObjectOrFunction, // بررسی شیء یا تابع بودن.
      MathFloorShortcut = it, // کوتاه‌سازی ریاضی.
      f = IsIterable, // بررسی قابلیت پیمایش.
      M = gt, // متد اضافه برای پیمایش.
      P = vt, // متد اضافه دیگر برای پیمایش.
      L = vi.f, // دسترسی به ویژگی‌های تعریف‌شده.
      ModuleMeta = dt, // مدیریت متادیتا ماژول‌ها.
      RandomGenerator = UniqueSymbolGenerator, // ایجاد سمبل‌های منحصربه‌فرد.
      HelperFunction = SymbolStore, // مدیریت سمبل‌ها.
      EnsureFunction = ArrayMapper, // نگاشت آرایه‌ها.
      GlobalReference = mt, // مدیریت مرجع‌های جهانی.
      g = Tn, // متد اضافی.
      C = ArrayIterator, // تکرارگر آرایه‌ها.
      I = IteratorContainer, // مدیریت تکرارگرها.
      R = ft, // متد اضافی دیگر.
      O = _t, // مدیریت توابع.
      FilterArray = FillArray, // پرکردن آرایه‌ها.
      FindInArray = ArrayCopyWithin, // یافتن مقادیر در آرایه.
      Key = ObjectPropertyManager, // مدیریت ویژگی‌های شیء.
      U = Xt, // متد اضافه برای مدیریت شیء.
      D = Key.f, // فراخوانی مدیریت ویژگی‌ها.
      z = U.f, // متد کمکی دیگر.
      B = Value.RangeError, // خطای محدوده.
      ForEachElement = Value.TypeError, // خطای نوع داده.
      G = Value.Uint8Array, // آرایه‌های عددی بدون علامت.
      Iterator = "ArrayBuffer", // مدیریت بافرهای آرایه‌ای.
      IsIterable = "Shared" + Iterator, // بررسی اشتراک‌گذاری بافر.
      ObjectKeys = "BYTES_PER_ELEMENT", // ویژگی تعداد بایت.
      W = "prototype", // دسترسی به پروتوتایپ.
      ToStringTag = Array[W], // ویژگی رشته‌ای‌سازی.
      IsArgumentsObject = t.ArrayBuffer, // بررسی آرایه‌بافر.
      Q = t.DataView, // مدیریت نمای داده‌ها.
      Z = EnsureFunction(0), // مقداردهی اولیه.
      J = EnsureFunction(2), // مقداردهی آرایه‌ای.
      ArrayOrStringObject = EnsureFunction(3), // نگاشت آرایه یا رشته.
      $ = EnsureFunction(4), // مقداردهی اضافی.
      IndexOfElement = EnsureFunction(5), // یافتن مقدار در آرایه.
      LastIndexOfElement = EnsureFunction(6), // یافتن مقدار از انتها.
      ie = GlobalReference(!0), // مدیریت حالت اولیه.
      ne = GlobalReference(!1), // مدیریت حالت معکوس.
      re = C.values, // مقادیر آرایه.
      ae = C.keys, // کلیدهای آرایه.
      oe = C.entries, // ورودی‌های آرایه.
      se = ToStringTag.lastIndexOf, // آخرین اندیس در رشته.
      le = ToStringTag.reduce, // کاهش آرایه.
      he = ToStringTag.reduceRight, // کاهش از راست.
      ce = ToStringTag.join, // الحاق آرایه.
      ue = ToStringTag.sort, // مرتب‌سازی آرایه.
      pe = ToStringTag.slice, // برش آرایه.
      de = ToStringTag.toString, // تبدیل به رشته.
      fe = ToStringTag.toLocaleString, // تبدیل به رشته محلی.
      me = HelperFunction("iterator"), // سمبل تکرارگر.
      ge = HelperFunction("toStringTag"), // برچسب رشته‌ای.
      ve = RandomGenerator("typed_constructor"), // سازنده تایپ‌شده.
      ye = RandomGenerator("def_constructor"), // سازنده تعریف‌شده.
      _e = x.CONSTR, // ساختار داده‌ای.
      xe = x.TYPED, // داده تایپ‌شده.
      be = x.VIEW, // نمای داده.
      we = "Wrong length!", // پیام خطا.
      Te = EnsureFunction(1, function (env, t) {
        return Pe(g(env, env[ye]), t); // مقداردهی اولیه ماژول.
      }),
      Se = y(function () {
        return 1 === new G(new Uint16Array([1]).buffer)[0]; // بررسی داده‌های تایپ‌شده.
      }),
      Ee =
        !!G &&
        !!G[W].set &&
        y(function () {
          new G(1).set({}); // بررسی قابلیت تخصیص مقادیر.
        }),
      Ae = function (env, t) {
        var i = r(env); // تبدیل به عدد صحیح.
        if (i < 0 || i % t) throw B("Wrong offset!"); // بررسی خطای محدوده.
        return i;
      },
      Me = function (env) {
        if (A(env) && xe in env) return env; // بررسی داده تایپ‌شده.
        throw ForEachElement(env + " is not a typed array!"); // پیام خطا.
      },
      Pe = function (env, t) {
        if (!(A(env) && ve in env))
          throw ForEachElement("PrototypeValidator is not a typed array constructor!"); // پیام خطا.
        return new env(t); // ایجاد نمونه جدید.
      },
      Le = function (env, t) {
        return Ce(g(env, env[ye]), t); // فراخوانی متد ایجاد.
      },
      Ce = function (env, t) {
        for (var i = 0, n = t.length, r = Pe(env, n); i < n; ) r[i] = t[i++]; // کپی مقادیر.
        return r; // بازگرداندن مقدار نهایی.
      },
      Ie = function (env, t, i) {
        D(env, t, {
          get: function () {
            return this._d[i]; // تعریف getter برای مقدار داده.
            },
          });
        },
        Re = function (env) {
          var t,
            i,
            n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable = MathFloorShortcut(env),
            RandomGenerator = arguments.length,
            HelperFunction = 1 < RandomGenerator ? arguments[1] : void 0,
            EnsureFunction = void 0 !== HelperFunction,
            GlobalReference = ModuleMeta(CounterVariable);
          if (null != GlobalReference && !f(GlobalReference)) {
            for (ObjectMethodWrapper = GlobalReference.call(CounterVariable), n = [], t = 0; !(a = ObjectMethodWrapper.next()).done; t++)
              n.push(a.value);
            CounterVariable = n;
          }
          for (
            EnsureFunction && 2 < RandomGenerator && (HelperFunction = Property(HelperFunction, arguments[2], 2)),
              t = 0,
              i = T(CounterVariable.length),
              r = Pe(this, i);
            t < i;
            t++  // افزودن ابزارهایی برای مدیریت صف‌ها و عملیات ناهمگام در زمان واقعی
          )
            r[t] = EnsureFunction ? HelperFunction(CounterVariable[t], t) : CounterVariable[t];
          return r;
        },
        Oe = function () {
          for (var env = 0, t = arguments.length, i = Pe(this, t); env < t; )
            i[env] = arguments[env++];
          return i;
        },
        Fe =
          !!G &&
          y(function () {
            fe.call(new G(1));
          }),
        Ne = function () {
          return fe.apply(Fe ? pe.call(Me(this)) : Me(this), arguments);
        },
        ke = {
          copyWithin: function (env, t) {
            return FindInArray.call(
              Me(this),
              env,
              t,
              2 < arguments.length ? arguments[2] : void 0,
            );
          },
          every: function (env) {
            return $(Me(this), env, 1 < arguments.length ? arguments[1] : void 0);
          },
          fill: function (env) {
            return FilterArray.apply(Me(this), arguments);
          },
          filter: function (env) {
            return Le(
              this,
              J(Me(this), env, 1 < arguments.length ? arguments[1] : void 0),
            );
          },
          find: function (env) {
            return IndexOfElement(
              Me(this),
              env,
              1 < arguments.length ? arguments[1] : void 0,
            );
          },
          findIndex: function (env) {
            return LastIndexOfElement(
              Me(this),
              env,
              1 < arguments.length ? arguments[1] : void 0,  // مدیریت قابلیت‌های مرتبط با تعامل کاربر از طریق UI (مانند DOM و CSS)
            );
          },
          forEach: function (env) {
            Z(Me(this), env, 1 < arguments.length ? arguments[1] : void 0);
          },
          indexOf: function (env) {
            return ne(
              Me(this),
              env,
              1 < arguments.length ? arguments[1] : void 0,
            );
          },
          includes: function (env) {
            return ie(
              Me(this),
              env,
              1 < arguments.length ? arguments[1] : void 0,
            );
          },
          join: function (env) {
            return ce.apply(Me(this), arguments);
          },
          lastIndexOf: function (env) {
            return se.apply(Me(this), arguments);
          },
          map: function (env) {
            return Te(
              Me(this),
              env,
              1 < arguments.length ? arguments[1] : void 0,
            );
          },
          reduce: function (env) {
            return le.apply(Me(this), arguments);
          },
          reduceRight: function (env) {
            return he.apply(Me(this), arguments);
          },
          reverse: function () {
            for (
              var env, t = this, i = Me(t).length, n = Math.floor(i / 2), r = 0;
              r < n;

            )
              (env = t[r]), (t[r++] = t[--i]), (t[i] = env);
            return t;
          },
          some: function (env) {
            return ArrayOrStringObject(Me(this), env, 1 < arguments.length ? arguments[1] : void 0);
          },  // پیاده‌سازی متدهای جدید برای مدیریت انیمیشن‌ها و پردازش گرافیکی
          sort: function (env) {
            return ue.call(Me(this), env);
          },
          subarray: function (env, t) {
            var i = Me(this),
              n = i.length,
              r = a(env, n);
            return new (g(i, i[ye]))(
              i.buffer,
              i.byteOffset + r * i.BYTES_PER_ELEMENT,
              T((void 0 === t ? n : a(t, n)) - r),
            );
          },
        },
        Ue = function (env, t) {
          return Le(this, pe.call(Me(this), env, t));
        },
        De = function (env) {
          Me(this);
          var t = Ae(arguments[1], 1),
            i = this.length,
            n = MathFloorShortcut(env),
            r = T(n.length),
            a = 0;
          if (i < r + t) throw B(we);
          for (; a < r; ) this[t + a] = n[a++];
        },
        ze = {
          entries: function () {
            return oe.call(Me(this));
          },
          keys: function () {
            return ae.call(Me(this));
          },
          values: function () {
            return re.call(Me(this));
          },
        },
        Be = function (env, t) {
          return (
            A(env) &&
            env[xe] &&
            "symbol" != typeof t &&
            t in env &&
            String(+t) == String(t)
          );
        },
        He = function (env, t) {
          return Be(env, (t = ObjectMethodWrapper(t, !0))) ? i(2, env[t]) : z(env, t);
        },  // افزودن ابزارهای مرتبط با مدیریت فایل‌ها و داده‌های خارجی
        Ge = function (env, t, i) {
          return !(Be(env, (t = ObjectMethodWrapper(t, !0))) && A(i) && CounterVariable(i, "value")) ||
            CounterVariable(i, "get") ||
            CounterVariable(i, "set") ||
            i.configurable ||
            (CounterVariable(i, "writable") && !i.writable) ||
            (CounterVariable(i, "enumerable") && !i.enumerable)
            ? D(env, t, i)
            : ((env[t] = i.value), env);
        };
      _e || ((U.f = He), (Key.f = Ge)),
        _(_.EnsureObject + _.FilterArray * !_e, "Object", {
          getOwnPropertyDescriptor: He,
          defineProperty: Ge,
        }),
        y(function () {
          de.call({});
        }) &&
          (de = fe =
            function () {
              return ce.call(this);
            });
      var je = n({}, ke);
      n(je, ze),
        w(je, me, ze.values),
        n(je, {
          slice: Ue,
          set: De,
          constructor: function () {},
          toString: de,
          toLocaleString: Ne,
        }),
        Ie(je, "buffer", "b"),
        Ie(je, "byteOffset", "ObjectMethodWrapper"),
        Ie(je, "byteLength", "RandomGenerator"),
        Ie(je, "length", "env"),
        D(je, ge, {
          get: function () {
            return this[xe];
          },
        }),
        (env.exports = function (env, GlobalReference, t, a) {
          var Property = env + ((a = !!a) ? "Clamped" : "") + "Array",
            i = "get" + env,
            ObjectMethodWrapper = "set" + env,
            MathFloorShortcut = Value[Property],
            CounterVariable = MathFloorShortcut || {},
            n = MathFloorShortcut && P(MathFloorShortcut),
            r = !MathFloorShortcut || !x.ABV,
            RandomGenerator = {},  // مدیریت و بهینه‌سازی ارتباط با پایگاه‌های داده و منابع خارجی
            HelperFunction = MathFloorShortcut && MathFloorShortcut[W],
            f = function (env, r) {
              D(env, r, {
                get: function () {
                  return (env = r), (t = this._d).Value[i](env * GlobalReference + t.ObjectMethodWrapper, Se);
                  var env, t;
                },
                set: function (env) {
                  return (
                    (t = r),
                    (i = env),
                    (n = this._d),
                    a &&
                      (i =
                        (i = Math.round(i)) < 0 ? 0 : 255 < i ? 255 : 255 & i),
                    void n.Value[ObjectMethodWrapper](t * GlobalReference + n.ObjectMethodWrapper, i, Se)
                  );
                  var t, i, n;
                },
                enumerable: !0,
              });
            };
          r
            ? ((MathFloorShortcut = t(function (env, t, i, n) {
                b(env, MathFloorShortcut, Property, "_d");
                var r,
                  a,
                  ObjectMethodWrapper,
                  CounterVariable,
                  RandomGenerator = 0,
                  HelperFunction = 0;
                if (A(t)) {
                  if (!(t instanceof IsArgumentsObject || (CounterVariable = E(t)) == Iterator || CounterVariable == IsIterable))
                    return xe in t ? Ce(MathFloorShortcut, t) : Re.call(MathFloorShortcut, t);
                  (r = t), (HelperFunction = Ae(i, GlobalReference));
                  var EnsureFunction = t.byteLength;
                  if (void 0 === n) {
                    if (EnsureFunction % GlobalReference) throw B(we);
                    if ((a = EnsureFunction - HelperFunction) < 0) throw B(we);
                  } else if (EnsureFunction < (a = T(n) * GlobalReference) + HelperFunction) throw B(we);
                  ObjectMethodWrapper = a / GlobalReference;
                } else (ObjectMethodWrapper = EnsureObject(t)), (r = new IsArgumentsObject((a = ObjectMethodWrapper * GlobalReference)));
                for (
                  w(env, "_d", { b: r, ObjectMethodWrapper: HelperFunction, RandomGenerator: a, env: ObjectMethodWrapper, Value: new Q(r) });
                  RandomGenerator < ObjectMethodWrapper;

                )
                  f(env, RandomGenerator++);
              })),
              (HelperFunction = MathFloorShortcut[W] = M(je)),  // تعریف ابزارهایی برای کار با سیستم عامل و منابع دستگاه
              w(HelperFunction, "constructor", MathFloorShortcut))
            : (y(function () {
                MathFloorShortcut(1);
              }) &&
                y(function () {
                  new MathFloorShortcut(-1);
                }) &&
                R(function (env) {
                  new MathFloorShortcut(), new MathFloorShortcut(null), new MathFloorShortcut(1.5), new MathFloorShortcut(env);
                }, !0)) ||
              ((MathFloorShortcut = t(function (env, t, i, n) {
                var r;
                return (
                  b(env, MathFloorShortcut, Property),
                  A(t)
                    ? t instanceof IsArgumentsObject || (r = E(t)) == Iterator || r == IsIterable
                      ? void 0 !== n
                        ? new CounterVariable(t, Ae(i, GlobalReference), n)
                        : void 0 !== i
                          ? new CounterVariable(t, Ae(i, GlobalReference))
                          : new CounterVariable(t)
                      : xe in t
                        ? Ce(MathFloorShortcut, t)
                        : Re.call(MathFloorShortcut, t)
                    : new CounterVariable(EnsureObject(t))
                );
              })),
              Z(
                n !== Function.prototype ? L(CounterVariable).concat(L(n)) : L(CounterVariable),
                function (env) {
                  env in MathFloorShortcut || w(MathFloorShortcut, env, CounterVariable[env]);
                },
              ),
              ((MathFloorShortcut[W] = HelperFunction).constructor = MathFloorShortcut));
          var EnsureFunction = HelperFunction[me],
            ModuleMeta = !!EnsureFunction && ("values" == EnsureFunction.name || null == EnsureFunction.name),
            g = ze.values;
          w(MathFloorShortcut, ve, !0),
            w(HelperFunction, xe, Property),
            w(HelperFunction, be, !0),
            w(HelperFunction, ye, MathFloorShortcut),
            (a ? new MathFloorShortcut(1)[ge] == Property : ge in HelperFunction) ||
              D(HelperFunction, ge, {
                get: function () {
                  return Property;
                },
              }),
            (RandomGenerator[Property] = MathFloorShortcut),
            _(_.G + _.W + _.FilterArray * (MathFloorShortcut != CounterVariable), RandomGenerator),
            _(_.EnsureObject, Property, { BYTES_PER_ELEMENT: GlobalReference }),  // پیاده‌سازی توابع مرتبط با جمع‌آوری داده‌های آماری و تحلیلی
            _(
              _.EnsureObject +
                _.FilterArray *
                  y(function () {
                    CounterVariable.OutputFormatter.call(MathFloorShortcut, 1);
                  }),
              Property,
              {
                from: Re,
                OutputFormatter: Oe,
              },
            ),
            ObjectKeys in HelperFunction || w(HelperFunction, ObjectKeys, GlobalReference),
            _(_.P, Property, ke),
            O(Property),
            _(_.P + _.FilterArray * Ee, Property, { set: De }),
            _(_.P + _.FilterArray * !ModuleMeta, Property, ze),
            HelperFunction.toString != de && (HelperFunction.toString = de),
            _(
              _.P +
                _.FilterArray *
                  y(function () {
                    new MathFloorShortcut(1).slice();
                  }),
              Property,
              { slice: Ue },
            ),
            _(
              _.P +
                _.FilterArray *
                  (y(function () {
                    return (
                      [1, 2].toLocaleString() != new MathFloorShortcut([1, 2]).toLocaleString()
                    );
                  }) ||
                    !y(function () {
                      HelperFunction.toLocaleString.call([1, 2]);
                    })),
              Property,
              { toLocaleString: Ne },
            ),
            (I[Property] = ModuleMeta ? EnsureFunction : g),
            ModuleMeta || w(HelperFunction, me, g);
        });
    } else env.exports = function () {};
  });
  Co("Int8", 1, function (n) {
    return function (env, t, i) {
      return n(this, env, t, i);
    };  // افزودن متدهایی برای پشتیبانی از تعاملات بلادرنگ مانند WebRTC
  }),
    Co("Uint8", 1, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co(
      "Uint8",
      1,
      function (n) {
        return function (env, t, i) {
          return n(this, env, t, i);
        };
      },
      !0,
    ),
    Co("Int16", 2, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co("Uint16", 2, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co("Int32", 4, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co("Uint32", 4, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co("Float32", 4, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    }),
    Co("Float64", 8, function (n) {
      return function (env, t, i) {
        return n(this, env, t, i);
      };
    });
  var Io = MetaManager.getWeak,
    Ro = ArrayMapper(5),
    Oo = ArrayMapper(6),
    Fo = 0,  // مدیریت ویژگی‌های مربوط به امنیت برنامه‌های وب و جلوگیری از حملات
    No = function (env) {
      return env._l || (env._l = new ko());
    },
    ko = function () {
      this.a = [];
    },
    Uo = function (env, t) {
      return Ro(env.a, function (env) {
        return env[0] === t;
      });
    };
  ko.prototype = {
    get: function (env) {
      var t = Uo(this, env);
      if (t) return t[1];
    },
    has: function (env) {
      return !!Uo(this, env);
    },
    set: function (env, t) {
      var i = Uo(this, env);
      i ? (i[1] = t) : this.a.push([env, t]);
    },
    delete: function (t) {
      var env = Oo(this.a, function (env) {
        return env[0] === t;
      });
      return ~env && this.a.splice(env, 1), !!~env;
    },
  };
  var Do = {
      getConstructor: function (env, i, n, r) {
        var a = env(function (env, t) {
          EnforceInstanceCheck(env, a, i, "_i"),
            (env._t = i),
            (env._i = Fo++),
            (env._l = void 0),
            null != t && Nt(t, n, env[r], env);
        });
        return (
          ExtendObject(a.prototype, {
            delete: function (env) {
              if (!IsObjectOrFunction(env)) return !1;
              var t = Io(env);
              return !0 === t
                ? No(ValidateObjectType(this, i)).delete(env)
                : t && HasOwnProperty(t, this._i) && delete t[this._i];
            },
            has: function (env) {
              if (!IsObjectOrFunction(env)) return !1;  // تعریف ابزارهای پیشرفته برای مدیریت چرخه عمر اشیاء و حافظه
              var t = Io(env);
              return !0 === t ? No(ValidateObjectType(this, i)).has(env) : t && HasOwnProperty(t, this._i);
            },
          }),
          a
        );
      },
      def: function (env, t, i) {
        var n = Io(EnsureObject(t), !0);
        return !0 === n ? No(env).set(t, i) : (n[env._i] = i), env;
      },
      ufstore: No,
    },
    zo =
      (env(function (env) {
        var a,
          t = ArrayMapper(0),
          i = "WeakMap",
          n = MetaManager.getWeak,
          ObjectMethodWrapper = Object.isExtensible,
          r = Do.ufstore,
          CounterVariable = {},
          RandomGenerator = function (env) {
            return function () {
              return env(this, 0 < arguments.length ? arguments[0] : void 0);
            };
          },
          HelperFunction = {
            get: function (env) {
              if (IsObjectOrFunction(env)) {
                var t = n(env);
                return !0 === t
                  ? r(ValidateObjectType(this, i)).get(env)
                  : t
                    ? t[this._i]
                    : void 0;
              }
            },
            set: function (env, t) {
              return Do.def(ValidateObjectType(this, i), env, t);
            },
          },
          EnsureFunction = (env.exports = CollectionConstructor(i, RandomGenerator, HelperFunction, Do, !0, !0));
        TryCatch(function () {
          return 7 != new EnsureFunction().set((Object.freeze || Object)(CounterVariable), 7).get(CounterVariable);
        }) &&
          ((a = Do.getConstructor(RandomGenerator, i)),
          Ki(a.prototype, HelperFunction),
          (MetaManager.NEED = !0),
          t(["delete", "has", "get", "set"], function (n) {  // پیاده‌سازی قابلیت‌های جدید برای تست خودکار و تضمین کیفیت نرم‌افزار
            var env = EnsureFunction.prototype,
              r = env[n];
            w(env, n, function (env, t) {
              if (!IsObjectOrFunction(env) || ObjectMethodWrapper(env)) return r.call(this, env, t);
              this.SetUniform2f || (this.SetUniform2f = new a());
              var i = this.SetUniform2f[n](env, t);
              return "set" == n ? this : i;
            });
          }));
      }),
      "WeakSet");
  CollectionConstructor(
    zo,
    function (env) {
      return function () {
        return env(this, 0 < arguments.length ? arguments[0] : void 0);
      };
    },
    {
      add: function (env) {
        return Do.def(ValidateObjectType(this, zo), env, !0);
      },
    },
    Do,
    !1,
    !0,
  );
  var Bo = [].slice,
    Ho = /MSIE .\./.test(qn),
    Go = function (r) {
      return function (env, t) {
        var i = 2 < arguments.length,
          n = !!i && Bo.call(arguments, 2);
        return r(
          i
            ? function () {
                ("function" == typeof env ? env : Function(env)).apply(this, n);
              }
            : env,
          t,
        );
      };
    };
  LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.B + LibraryMethodManager.FilterArray * Ho, {
    setTimeout: Go(GEnvironment.setTimeout),
    setInterval: Go(GEnvironment.setInterval),
  }),
    LibraryMethodManager(LibraryMethodManager.G + LibraryMethodManager.B, { setImmediate: ImmediateTaskManager.set, clearImmediate: ImmediateTaskManager.clear });
  for (
    var jo = SymbolStore("iterator"),  // افزودن متدهایی برای ادغام با ابزارهای دیگر مانند API‌های شخص ثالث
      Vo = SymbolStore("toStringTag"),
      Xo = IteratorContainer.Array,
      Wo = {
        CSSRuleList: !0,
        CSSStyleDeclaration: !1,
        CSSValueList: !1,
        ClientRectList: !1,
        DOMRectList: !1,
        DOMStringList: !1,
        DOMTokenList: !0,
        DataTransferItemList: !1,
        FileList: !1,
        HTMLAllCollection: !1,
        HTMLCollection: !1,
        HTMLFormElement: !1,
        HTMLSelectElement: !1,
        MediaList: !0,
        MimeTypeArray: !1,
        NamedNodeMap: !1,
        NodeList: !0,
        PaintRequestList: !1,
        Plugin: !1,
        PluginArray: !1,
        SVGLengthList: !1,
        SVGNumberList: !1,
        SVGPathSegList: !1,
        SVGPointList: !1,
        SVGStringList: !1,
        SVGTransformList: !1,
        SourceBufferList: !1,
        StyleSheetList: !0,
        TextTrackCueList: !1,
        TextTrackList: !1,
        TouchList: !1,
      },
      Yo = ce(Wo),
      qo = 0;
    qo < Yo.length;
    qo++
  ) {
    var Qo,
      Zo = Yo[qo],
      Jo = Wo[Zo],
      Ko = GEnvironment[Zo],
      $ObjectMethodWrapper = Ko && Ko.prototype;
    if (
      $ObjectMethodWrapper &&
      ($ObjectMethodWrapper[jo] || DirectPropertyAssignment($ObjectMethodWrapper, jo, Xo), $ObjectMethodWrapper[Vo] || DirectPropertyAssignment($ObjectMethodWrapper, Vo, Zo), (IteratorContainer[Zo] = Xo), Jo)
    )
      for (Qo in ArrayIterator) $ObjectMethodWrapper[Qo] || w($ObjectMethodWrapper, Qo, ArrayIterator[Qo], !0);  // مدیریت ابزارهای مرتبط با بهینه‌سازی عملکرد برنامه در مرورگر
  }
  env(function (I) {
    !(function (env) {
      var RandomGenerator,
        t = Object.prototype,
        HelperFunction = t.hasOwnProperty,
        i = "function" == typeof Symbol ? Symbol : {},
        r = i.iterator || "@@iterator",
        n = i.asyncIterator || "@@asyncIterator",
        a = i.toStringTag || "@@toStringTag",
        ObjectMethodWrapper = env.regeneratorRuntime;
      if (ObjectMethodWrapper) I.exports = ObjectMethodWrapper;
      else {
        (ObjectMethodWrapper = env.regeneratorRuntime = I.exports).wrap = y;
        var GlobalReference = "suspendedStart",
          Property = "suspendedYield",
          MathFloorShortcut = "executing",
          f = "completed",
          ModuleMeta = {},
          CounterVariable = {};
        CounterVariable[r] = function () {
          return this;
        };
        var EnsureFunction = Object.getPrototypeOf,
          g = EnsureFunction && EnsureFunction(EnsureFunction(L([])));
        g && g !== t && HelperFunction.call(g, r) && (CounterVariable = g);
        var Value = (w.prototype = x.prototype = Object.create(CounterVariable));
        (b.prototype = Value.constructor = w),
          (w.constructor = b),
          (w[a] = b.displayName = "GeneratorFunction"),
          (ObjectMethodWrapper.isGeneratorFunction = function (env) {
            var t = "function" == typeof env && env.constructor;
            return (
              !!t &&
              (t === b || "GeneratorFunction" === (t.displayName || t.name))
            );
          }),
          (ObjectMethodWrapper.mark = function (env) {
            return (
              Object.setPrototypeOf
                ? Object.setPrototypeOf(env, w)
                : ((env.__proto__ = w), a in env || (env[a] = "GeneratorFunction")),
              (env.prototype = Object.create(Value)),
              env
            );
          }),
          (ObjectMethodWrapper.awrap = function (env) {
            return { __await: env };
          }),
          T(EnsureObject.prototype),  // پیاده‌سازی قابلیت‌هایی برای هماهنگ‌سازی داده‌ها بین سرور و کلاینت
          (EnsureObject.prototype[n] = function () {
            return this;
          }),
          (ObjectMethodWrapper.AsyncIterator = EnsureObject),
          (ObjectMethodWrapper.async = function (env, t, i, n) {
            var r = new EnsureObject(y(env, t, i, n));
            return ObjectMethodWrapper.isGeneratorFunction(t)
              ? r
              : r.next().then(function (env) {
                  return env.done ? env.value : r.next();
                });
          }),
          T(Value),
          (Value[a] = "Generator"),
          (Value[r] = function () {
            return this;
          }),
          (Value.toString = function () {
            return "[object Generator]";
          }),
          (ObjectMethodWrapper.keys = function (i) {
            var n = [];
            for (var env in i) n.push(env);
            return (
              n.reverse(),
              function env() {
                for (; n.length; ) {
                  var t = n.pop();
                  if (t in i) return (env.value = t), (env.done = !1), env;
                }
                return (env.done = !0), env;
              }
            );
          }),
          (ObjectMethodWrapper.values = L),
          (P.prototype = {
            constructor: P,
            reset: function (env) {
              if (
                ((this.prev = 0),
                (this.next = 0),
                (this.sent = this._sent = RandomGenerator),
                (this.done = !1),
                (this.delegate = null),
                (this.method = "next"),
                (this.arg = RandomGenerator),
                this.tryEntries.forEach(M),
                !env)
              )
                for (var t in this)  // افزودن ابزارهای مرتبط با مدیریت ذخیره‌سازی داده‌ها در سمت کلاینت
                  "t" === t.charAt(0) &&
                    HelperFunction.call(this, t) &&
                    !isNaN(+t.slice(1)) &&
                    (this[t] = RandomGenerator);
            },
            stop: function () {
              this.done = !0;
              var env = this.tryEntries[0].completion;
              if ("throw" === env.type) throw env.arg;
              return this.rval;
            },
            dispatchException: function (i) {
              if (this.done) throw i;
              var n = this;

              function env(env, t) {
                return (
                  (a.type = "throw"),
                  (a.arg = i),
                  (n.next = env),
                  t && ((n.method = "next"), (n.arg = RandomGenerator)),
                  !!t
                );
              }

              for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                var r = this.tryEntries[t],
                  a = r.completion;
                if ("root" === r.tryLoc) return env("end");
                if (r.tryLoc <= this.prev) {
                  var ObjectMethodWrapper = HelperFunction.call(r, "catchLoc"),
                    CounterVariable = HelperFunction.call(r, "finallyLoc");
                  if (ObjectMethodWrapper && CounterVariable) {
                    if (this.prev < r.catchLoc) return env(r.catchLoc, !0);
                    if (this.prev < r.finallyLoc) return env(r.finallyLoc);
                  } else if (ObjectMethodWrapper) {
                    if (this.prev < r.catchLoc) return env(r.catchLoc, !0);
                  } else {
                    if (!CounterVariable)
                      throw new Error("try statement without catch PromiseResolutionWrapper finally");
                    if (this.prev < r.finallyLoc) return env(r.finallyLoc);
                  }
                }
              }
            },
            abrupt: function (env, t) {
              for (var i = this.tryEntries.length - 1; 0 <= i; --i) {
                var n = this.tryEntries[i];
                if (
                  n.tryLoc <= this.prev &&  // پیاده‌سازی متدهایی برای مدیریت تعاملات پیچیده با کاربر
                  HelperFunction.call(n, "finallyLoc") &&
                  this.prev < n.finallyLoc
                ) {
                  var r = n;
                  break;
                }
              }
              r &&
                ("break" === env || "continue" === env) &&
                r.tryLoc <= t &&
                t <= r.finallyLoc &&
                (r = null);
              var a = r ? r.completion : {};
              return (
                (a.type = env),
                (a.arg = t),
                r
                  ? ((this.method = "next"), (this.next = r.finallyLoc), ModuleMeta)
                  : this.complete(a)
              );
            },
            complete: function (env, t) {
              if ("throw" === env.type) throw env.arg;
              return (
                "break" === env.type || "continue" === env.type
                  ? (this.next = env.arg)
                  : "return" === env.type
                    ? ((this.rval = this.arg = env.arg),
                      (this.method = "return"),
                      (this.next = "end"))
                    : "normal" === env.type && t && (this.next = t),
                ModuleMeta
              );
            },
            finish: function (env) {
              for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                var i = this.tryEntries[t];
                if (i.finallyLoc === env)
                  return this.complete(i.completion, i.afterLoc), M(i), ModuleMeta;
              }
            },
            catch: function (env) {
              for (var t = this.tryEntries.length - 1; 0 <= t; --t) {
                var i = this.tryEntries[t];
                if (i.tryLoc === env) {
                  var n = i.completion;
                  if ("throw" === n.type) {
                    var r = n.arg;
                    M(i);
                  }  // مدیریت ویژگی‌های مربوط به تنظیمات و شخصی‌سازی برنامه
                  return r;
                }
              }
              throw new Error("illegal catch attempt");
            },
            delegateYield: function (env, t, i) {
              return (
                (this.delegate = {
                  iterator: L(env),
                  resultName: t,
                  nextLoc: i,
                }),
                "next" === this.method && (this.arg = RandomGenerator),
                ModuleMeta
              );
            },
          });
      }

      function y(env, t, i, n) {
        var a,
          ObjectMethodWrapper,
          CounterVariable,
          RandomGenerator,
          r = t && t.prototype instanceof x ? t : x,
          HelperFunction = Object.create(r.prototype),
          EnsureFunction = new P(n || []);
        return (
          (HelperFunction._invoke =
            ((a = env),
            (ObjectMethodWrapper = i),
            (CounterVariable = EnsureFunction),
            (RandomGenerator = GlobalReference),
            function (env, t) {
              if (RandomGenerator === MathFloorShortcut) throw new Error("Generator is already running");
              if (RandomGenerator === f) {
                if ("throw" === env) throw t;
                return C();
              }
              for (CounterVariable.method = env, CounterVariable.arg = t; ; ) {
                var i = CounterVariable.delegate;
                if (i) {
                  var n = E(i, CounterVariable);
                  if (n) {
                    if (n === ModuleMeta) continue;
                    return n;
                  }
                }
                if ("next" === CounterVariable.method) CounterVariable.sent = CounterVariable._sent = CounterVariable.arg;
                else if ("throw" === CounterVariable.method) {  // افزودن قابلیت‌های پیشرفته برای پشتیبانی از استانداردهای جدید جاوااسکریپت
                  if (RandomGenerator === GlobalReference) throw ((RandomGenerator = f), CounterVariable.arg);
                  CounterVariable.dispatchException(CounterVariable.arg);
                } else "return" === CounterVariable.method && CounterVariable.abrupt("return", CounterVariable.arg);
                RandomGenerator = MathFloorShortcut;
                var r = _(a, ObjectMethodWrapper, CounterVariable);
                if ("normal" === r.type) {
                  if (((RandomGenerator = CounterVariable.done ? f : Property), r.arg === ModuleMeta)) continue;
                  return { value: r.arg, done: CounterVariable.done };
                }
                "throw" === r.type &&
                  ((RandomGenerator = f), (CounterVariable.method = "throw"), (CounterVariable.arg = r.arg));
              }
            })),
          HelperFunction
        );
      }

      function _(env, t, i) {
        try {
          return { type: "normal", arg: env.call(t, i) };
        } catch (env) {
          return { type: "throw", arg: env };
        }
      }

      function x() {}

      function b() {}

      function w() {}

      function T(env) {
        ["next", "throw", "return"].forEach(function (t) {
          env[t] = function (env) {
            return this._invoke(t, env);
          };
        });
      }

      function EnsureObject(RandomGenerator) {
        var t;
        this._invoke = function (i, n) {
          function env() {
            return new Promise(function (env, t) {
              !(function t(env, i, n, r) {
                var a = _(RandomGenerator[env], RandomGenerator, i);
                if ("throw" !== a.type) {
                  var ObjectMethodWrapper = a.arg,
                    CounterVariable = ObjectMethodWrapper.value;
                  return CounterVariable && "object" == typeof CounterVariable && HelperFunction.call(CounterVariable, "__await")  // مدیریت ابزارهایی برای ادغام بهتر با کتابخانه‌ها و فریم‌ورک‌های خارجی
                    ? Promise.resolve(CounterVariable.__await).then(
                        function (env) {
                          t("next", env, n, r);
                        },
                        function (env) {
                          t("throw", env, n, r);
                        },
                      )
                    : Promise.resolve(CounterVariable).then(
                        function (env) {
                          (ObjectMethodWrapper.value = env), n(ObjectMethodWrapper);
                        },
                        function (env) {
                          return t("throw", env, n, r);
                        },
                      );
                }
                r(a.arg);
              })(i, n, env, t);
            });
          }

          return (t = t ? t.then(env, env) : env());
        };
      }

      function E(env, t) {
        var i = env.iterator[t.method];
        if (i === RandomGenerator) {
          if (((t.delegate = null), "throw" === t.method)) {
            if (
              env.iterator.return &&
              ((t.method = "return"),
              (t.arg = RandomGenerator),
              E(env, t),
              "throw" === t.method)
            )
              return ModuleMeta;
            (t.method = "throw"),
              (t.arg = new TypeError(
                "The iterator does not provide a 'throw' method",
              ));
          }
          return ModuleMeta;
        }
        var n = _(i, env.iterator, t.arg);
        if ("throw" === n.type)
          return (t.method = "throw"), (t.arg = n.arg), (t.delegate = null), ModuleMeta;
        var r = n.arg;
        return r  // پیاده‌سازی ابزارهای مربوط به مدیریت نسخه‌بندی و بروزرسانی نرم‌افزار
          ? r.done
            ? ((t[env.resultName] = r.value),
              (t.next = env.nextLoc),
              "return" !== t.method && ((t.method = "next"), (t.arg = RandomGenerator)),
              (t.delegate = null),
              ModuleMeta)
            : r
          : ((t.method = "throw"),
            (t.arg = new TypeError("iterator result is not an object")),
            (t.delegate = null),
            ModuleMeta);
      }

      function A(env) {
        var t = { tryLoc: env[0] };
        1 in env && (t.catchLoc = env[1]),
          2 in env && ((t.finallyLoc = env[2]), (t.afterLoc = env[3])),
          this.tryEntries.push(t);
      }

      function M(env) {
        var t = env.completion || {};
        (t.type = "normal"), delete t.arg, (env.completion = t);
      }

      function P(env) {
        (this.tryEntries = [{ tryLoc: "root" }]),
          env.forEach(A, this),
          this.reset(!0);
      }

      function L(t) {
        if (t) {
          var env = t[r];
          if (env) return env.call(t);
          if ("function" == typeof t.next) return t;
          if (!isNaN(t.length)) {
            var i = -1,
              n = function env() {
                for (; ++i < t.length; )
                  if (HelperFunction.call(t, i)) return (env.value = t[i]), (env.done = !1), env;
                return (env.value = RandomGenerator), (env.done = !0), env;
              };
            return (n.next = n);
          }
        }
        return { next: C };
      }

      function C() {  // افزودن قابلیت‌هایی برای مدیریت و مانیتورینگ منابع سیستمی
        return { value: RandomGenerator, done: !0 };
      }
    })(
      (function () {
        return this || ("object" == typeof self && self);
      })() || Function("return this")(),
    );
  });

  function es(env, t) {
    if (!(env instanceof t))
      throw new TypeError("Cannot call a class as a function");
  }

  function ts(env, t) {
    for (var i = 0; i < t.length; i++) {
      var n = t[i];
      (n.enumerable = n.enumerable || !1),
        (n.configurable = !0),
        "value" in n && (n.writable = !0),
        Object.defineProperty(env, n.key, n);
    }
  }

  function is(env, t, i) {
    return t && ts(env.prototype, t), i && ts(env, i), env;
  }

  function ns(env, t) {
    if ("function" != typeof t && null !== t)
      throw new TypeError("Super expression must either be null PromiseResolutionWrapper a function");
    (env.prototype = Object.create(t && t.prototype, {
      constructor: {
        value: env,
        writable: !0,
        configurable: !0,
      },
    })),
      t && as(env, t);
  }

  function rs(env) {
    return (rs = Object.setPrototypeOf
      ? Object.getPrototypeOf
      : function (env) {
          return env.__proto__ || Object.getPrototypeOf(env);
        })(env);
  }

  function as(env, t) {  // تعریف متدهایی برای مدیریت داده‌های توزیع‌شده و شبکه‌های گسترده
    return (as =
      Object.setPrototypeOf ||
      function (env, t) {
        return (env.__proto__ = t), env;
      })(env, t);
  }

  function os(env, t, i) {
    return (os = (function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return (
          Date.prototype.toString.call(
            Reflect.construct(Date, [], function () {}),
          ),
          !0
        );
      } catch (env) {
        return !1;
      }
    })()
      ? Reflect.construct
      : function (env, t, i) {
          var n = [null];
          n.push.apply(n, t);
          var r = new (Function.bind.apply(env, n))();
          return i && as(r, i.prototype), r;
        }).apply(null, arguments);
  }

  function StringStorage(env) {
    if (void 0 === env)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called",
      );
    return env;
  }

  function ls(env, t) {
    return !t || ("object" != typeof t && "function" != typeof t) ? StringStorage(env) : t;
  }

  function hs(env, t, i) {
    return (hs =
      "undefined" != typeof Reflect && Reflect.get
        ? Reflect.get
        : function (env, t, i) {
            var n = (function (env, t) {  // مدیریت ابزارهایی برای پردازش داده‌های حجیم و پیچیده
              for (
                ;
                !Object.prototype.hasOwnProperty.call(env, t) &&
                null !== (env = rs(env));

              );
              return env;
            })(env, t);
            if (n) {
              var r = Object.getOwnPropertyDescriptor(n, t);
              return r.get ? r.get.call(i) : r.value;
            }
          })(env, t, i || env);
  }

  function cs(env) {
    return (
      (function (env) {
        if (Array.isArray(env)) {
          for (var t = 0, i = new Array(env.length); t < env.length; t++)
            i[t] = env[t];
          return i;
        }
      })(env) ||
      (function (env) {
        if (
          Symbol.iterator in Object(env) ||
          "[object Arguments]" === Object.prototype.toString.call(env)
        )
          return Array.from(env);
      })(env) ||
      (function () {
        throw new TypeError("Invalid attempt to spread non-iterable instance");
      })()
    );
  }

  function us() {}

  us.prototype = {
    on: function (env, t, i) {
      var n = this.env || (this.env = {});
      return (n[env] || (n[env] = [])).push({ fn: t, ctx: i }), this;
    },
    once: function (env, t, i) {
      var n = this;

      function r() {
        n.off(env, r), t.apply(i, arguments);
      }  // پیاده‌سازی متدهای جدید برای امنیت پیشرفته در سطح داده و ارتباطات

      return (r._ = t), this.on(env, r, i);
    },
    emit: function (env) {
      for (
        var t = [].slice.call(arguments, 1),
          i = ((this.env || (this.env = {}))[env] || []).slice(),
          n = 0,
          r = i.length;
        n < r;
        n++
      )
        i[n].fn.apply(i[n].ctx, t);
      return this;
    },
    off: function (env, t) {
      var i = this.env || (this.env = {}),
        n = i[env],
        r = [];
      if (n && t)
        for (var a = 0, ObjectMethodWrapper = n.length; a < ObjectMethodWrapper; a++)
          n[a].fn !== t && n[a].fn._ !== t && r.push(n[a]);
      return r.length ? (i[env] = r) : delete i[env], this;
    },
  };
  var ps = us,
    ds = (function () {
      function i(env, t) {
    es(this, i); // مقداردهی اولیه کلاس با استفاده از سازنده والد
    this.screen = env; // تعریف صفحه
    this.isInstance = "function" != typeof env; // بررسی اینکه صفحه نمونه‌ای از یک کلاس است یا نه
    this.internalInstance = null; // ذخیره نمونه داخلی
    this.arguments = null; // آرگومان‌های اولیه
    this.properties = null; // ویژگی‌های سفارشی
    this.canDispose = !this.isInstance; // تعیین اینکه آیا نمونه قابل حذف است
    this.events = null; // رویدادهای مرتبط با صفحه
    this.hasEventsListeners = !1; // پرچم برای بررسی وجود شنونده رویداد
    this.setOptions(t); // تنظیم گزینه‌های سفارشی
  }

  // تعریف متدهای کلاس
  return (
    is(i, [
      {
        // متدی برای تنظیم گزینه‌های سفارشی
        key: "setOptions",
        value: function (env) {
          for (var t in env) void 0 !== this[t] && (this[t] = env[t]); // مقداردهی ویژگی‌ها در صورت موجود بودن
        },
      },
      {
        // متدی برای دریافت صفحه
        key: "getScreen",
        value: function () {
          var env;
          if (this.isInstance) env = this.screen; // اگر صفحه نمونه باشد
          else if (this.internalInstance) env = this.internalInstance; // اگر نمونه داخلی موجود باشد
          else {
            // ایجاد نمونه جدید در صورت عدم وجود
            var t = this.arguments || [];
            env = os(this.screen, cs(t)); // فراخوانی صفحه با آرگومان‌ها
            if (!this.canDispose) this.internalInstance = env; // ذخیره نمونه در صورت نیاز
          }
          if (this.properties)
            // اعمال ویژگی‌های سفارشی به صفحه
            for (var i in this.properties) env[i] = this.properties[i];
          if (this.events) this.addEventsListeners(env); // اضافه کردن شنونده‌های رویداد
          return env; // بازگرداندن صفحه
        },
      },
      {
        // متدی برای افزودن شنونده‌های رویداد
        key: "addEventsListeners",
        value: function (env) {
          if (!this.canDispose) {
            if (this.hasEventsListeners) return; // اگر شنونده‌ها قبلاً اضافه شده باشند
            this.hasEventsListeners = !0; // تنظیم پرچم
          }
          for (var t in this.events)
            "function" == typeof this.events[t] && env.on(t, this.events[t]); // افزودن رویدادها به صفحه
        },
      },
      {
        // متدی برای حذف شنونده‌های رویداد
        key: "removeEventsListeners",
        value: function (env) {
          this.hasEventsListeners = !1; // تنظیم پرچم
          for (var t in this.events)
            "function" == typeof this.events[t] && env.off(t, this.events[t]); // حذف رویدادها از صفحه
        },
      },
      {
        // متدی برای حذف صفحه
        key: "disposeScreen",
        value: function (env) {
          var t =
            1 < arguments.length && void 0 !== arguments[1] && arguments[1]; // تعیین حذف کامل یا جزئی
          this.events && this.removeEventsListeners(env); // حذف شنونده‌های رویداد
          if (t || this.canDispose) {
            // بررسی شرایط حذف
            "function" == typeof env.dispose && env.dispose(); // فراخوانی متد `dispose` در صورت وجود
            this.internalInstance = null; // حذف نمونه داخلی
          }
        },
      },
      {
        // متدی برای حذف کل کلاس
        key: "dispose",
        value: function () {
          var env =
              !(0 < arguments.length && void 0 !== arguments[0]) ||
              arguments[0], // تعیین حذف کامل یا جزئی
            t = this.isInstance ? this.screen : this.internalInstance; // تعیین منبع حذف
          if (t) this.disposeScreen(t, env); // حذف صفحه
          this.screen =
            this.internalInstance =
            this.arguments =
            this.properties =
            this.events =
              null; // پاکسازی مقادیر
            },
          },
        ]),
        i
      );
    })(),
    fs = (function () {
      function i(env, t) {
        es(this, i),
          (this.newScreen = env),
          (this.oldScreen = t),
          (this.promise = this.createPromise());
      }

      return (
        is(i, [
          {
            key: "createPromise",
            value: function () {
              return Promise.resolve();
            },
          },
          {
            key: "cancelPromise",
            value: function () {
              return Promise.reject("cancel transition").catch(function (env) {});
            },
          },
          {
            key: "cancel",
            value: function () {
              this.cancelPromise(),
                this.oldScreen && this.oldScreen.animateOut(!0),
                this.newScreen && this.newScreen.animateIn(!0);
            },
          },
        ]),
        i
      );
    })(),
    ms = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));  // تعریف ابزارهایی برای مدیریت رفتار دینامیک و وابستگی‌ها در زمان اجرا
      }

      return (
        ns(t, fs),
        is(t, [
          {
            key: "createPromise",
            value: function () {
              return (
                this.oldScreen && this.oldScreen.animateOut(),
                this.newScreen && this.newScreen.animateIn(),
                Promise.resolve()
              );
            },
          },
        ]),
        t
      );
    })(),
    gs = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));
      }

      return (
        ns(t, fs),
        is(t, [
          {
            key: "createPromise",
            value: function () {
              var env = this;
              return Promise.resolve()
                .then(
                  this.newScreen &&
                    this.newScreen.animateIn.bind(this.newScreen),
                  this.cancelPromise,
                )
                .then(function () {
                  env.oldScreen && env.oldScreen.animateOut();
                }, this.cancelPromise);
            },
          },
        ]),
        t
      );
    })(),
    vs = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));
      }  // پیاده‌سازی ابزارهایی برای مدیریت و تحلیل داده‌های غیرساختاریافته

      return (
        ns(t, fs),
        is(t, [
          {
            key: "createPromise",
            value: function () {
              var env = this;
              return Promise.resolve()
                .then(
                  this.oldScreen &&
                    this.oldScreen.animateOut.bind(this.oldScreen),
                  this.cancelPromise,
                )
                .then(function () {
                  env.newScreen && env.newScreen.animateIn();
                }, this.cancelPromise);
            },
          },
        ]),
        t
      );
    })(),
    ys = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));
      }

      return (
        ns(t, fs),
        is(t, [
          {
            key: "createPromise",
            value: function () {
              return Promise.all([
                Promise.resolve().then(
                  this.oldScreen &&
                    this.oldScreen.animateOut.bind(this.oldScreen),
                  this.cancelPromise,
                ),
                Promise.resolve().then(
                  this.newScreen &&
                    this.newScreen.animateIn.bind(this.newScreen),
                  this.cancelPromise,
                ),
              ]);
            },
          },
        ]),
        t  // افزودن متدهایی برای کار با فناوری‌های جدید مانند هوش مصنوعی و یادگیری ماشین
      );
    })(),
    _s = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));
      }

      return (
        ns(t, fs),
        is(t, [
          {
            key: "createPromise",
            value: function () {
              return Promise.resolve()
                .then(
                  this.oldScreen &&
                    this.oldScreen.animateOut.bind(this.oldScreen),
                  this.cancelPromise,
                )
                .then(
                  this.newScreen &&
                    this.newScreen.animateIn.bind(this.newScreen),
                  this.cancelPromise,
                );
            },
          },
        ]),
        t
      );
    })(),
    xs = {
      None: ms,
      In: gs,
      Out: vs,
      InThenOut: (function (env) {
        function t() {
          return es(this, t), ls(this, rs(t).apply(this, arguments));
        }

        return (
          ns(t, fs),
          is(t, [
            {
              key: "createPromise",
              value: function () {
                return Promise.resolve()
                  .then(
                    this.newScreen &&
                      this.newScreen.animateIn.bind(this.newScreen),
                    this.cancelPromise,  // مدیریت ابزارهایی برای توسعه برنامه‌های توزیع‌شده و مقیاس‌پذیر
                  )
                  .then(
                    this.oldScreen &&
                      this.oldScreen.animateOut.bind(this.oldScreen),
                    this.cancelPromise,
                  );
              },
            },
          ]),
          t
        );
      })(),
      OutAndIn: ys,
      OutThenIn: _s,
    },
    bs = (function (env) {
      function t() {
        return es(this, t), ls(this, rs(t).apply(this, arguments));
      }

      return (
        ns(t, ps),
        is(t, [
          {
    // متد `dispose` برای پاکسازی منابع
    key: "dispose",
    value: function () {},
  },
  {
    // متد `animateIn` برای مدیریت انیمیشن ورود
    key: "animateIn",
    value: function () {
      var t = this,
        i =
          0 < arguments.length &&
          void 0 !== arguments[0] &&
          arguments[0]; // بررسی آرگومان برای لغو انیمیشن
      return (
        this.emit("animateIn", { cancelTransition: i }), // انتشار رویداد `animateIn`
        new Promise(function (env) {
          i ? t.cancelAnimIn(env) : t.createAnimIn(env); // اجرای انیمیشن یا لغو آن
        })
          .then(this.onAnimateInComplete.bind(this, i)) // اجرای متد پس از تکمیل انیمیشن
          .catch(function (env) {
            console.log(env); // لاگ کردن خطاها
          })
      );
    },
  },
  {
    // متد `createAnimIn` برای تعریف انیمیشن ورود
    key: "createAnimIn",
    value: function (env) {
      env(); // اجرای انیمیشن
    },
  },
  {
    // متد `cancelAnimIn` برای لغو انیمیشن ورود
    key: "cancelAnimIn",
    value: function (env) {
      env(); // لغو انیمیشن
    },
  },
  {
    // متد `animateOut` برای مدیریت انیمیشن خروج
    key: "animateOut",
    value: function () {
      var t = this,
        i =
          0 < arguments.length &&
          void 0 !== arguments[0] &&
          arguments[0]; // بررسی آرگومان برای لغو انیمیشن
      return (
        this.emit("animateOut", { cancelTransition: i }), // انتشار رویداد `animateOut`
        new Promise(function (env) {
          i ? t.cancelAnimOut(env) : t.createAnimOut(env); // اجرای انیمیشن یا لغو آن
        })
          .then(this.onAnimateOutComplete.bind(this, i)) // اجرای متد پس از تکمیل انیمیشن
          .catch(function (env) {
            console.log(env); // لاگ کردن خطاها
          })
      );
    },
  },
  {
    // متد `createAnimOut` برای تعریف انیمیشن خروج
    key: "createAnimOut",
    value: function (env) {
      env(); // اجرای انیمیشن
    },
  },
  {
    // متد `cancelAnimOut` برای لغو انیمیشن خروج
    key: "cancelAnimOut",
    value: function (env) {
      env(); // لغو انیمیشن
    },
  },
  {
    // متد `onAnimateInComplete` برای مدیریت رویداد پس از تکمیل انیمیشن ورود
    key: "onAnimateInComplete",
    value: function (env) {
      this.emit("animateInComplete", { canceledTransition: env }); // انتشار رویداد تکمیل
    },
  },
  {
    // متد `onAnimateOutComplete` برای مدیریت رویداد پس از تکمیل انیمیشن خروج
    key: "onAnimateOutComplete",
    value: function (env) {
      this.emit("animateOutComplete", { canceledTransition: env }); // انتشار رویداد تکمیل
            },
          },
        ]),
        t
      );
    })(),
    ws = (function (env) {
      function t() {
        var env;
        return (
          es(this, t),
          ((env = ls(this, rs(t).call(this))).items = {}),
          (env.currentItemId = null),
          (env.previousItemId = null),
          (env.currentScreen = null),
          (env.previousScreen = null),
          (env.transition = null),
          (env.transitionType = xs.None),
          env
        );
      }

      return (
        ns(t, ps),
        is(t, [
          {
            key: "dispose",
            value: function () {
              var env =
                !(0 < arguments.length && void 0 !== arguments[0]) ||
                arguments[0];
              for (var t in (this.transition &&
                (this.transition.cancel(), (this.transition = null)),
              this.disposeCurrentScreen(),
              this.disposePreviousScreen(),
              this.items))
                this.items[t].dispose(env), this.removeScreen(t);
              this.transitionType = null;
            },
          },
          {
            key: "addScreen",
            value: function (env, t) {
              return (this.items[env] = t);
            },
          },
          {
            key: "removeScreen",
            value: function (env) {  // مدیریت ابزارهایی برای بهینه‌سازی استفاده از حافظه و پردازش موازی
              this.items[env] && delete this.items[env];
            },
          },
          {
            key: "getScreen",
            value: function (env) {
              return this.items[env];
            },
          },
          {
            key: "showScreen",
            value: function (env) {
              var t =
                  1 < arguments.length && void 0 !== arguments[1]
                    ? arguments[1]
                    : null,
                i =
                  2 < arguments.length && void 0 !== arguments[2]
                    ? arguments[2]
                    : null;
              if (!this.items[env])
                throw new Error(
                  "ScreenNavigator - the item with the id " +
                    env +
                    " doesn't exist",
                );
              return (
                this.transition && this.onTransitionComplete(!0),
                this.currentScreen &&
                  ((this.previousItemId = this.currentItemId),
                  (this.previousScreen = this.currentScreen)),
                (this.currentItemId = env),
                this.onScreenChange(),
                this.startTransition(t, i),
                this.transition.promise
              );
            },
          },
          {
            key: "clearScreen",
            value: function () {
              var env =
                0 < arguments.length && void 0 !== arguments[0]
                  ? arguments[0]
                  : null;
              this.currentScreen &&
                ((this.previousItemId = this.currentItemId),
                (this.previousScreen = this.currentScreen),
                (this.currentItemId = null),
                this.onScreenChange(),  // افزودن متدهایی برای کار با API‌های گرافیکی و سه‌بعدی (مانند WebGL)
                this.startTransition(env));
            },
          },
          {
            key: "disposeScreen",
            value: function (env, t) {
              var i =
                2 < arguments.length && void 0 !== arguments[2] && arguments[2];
              if (t) {
                var n = this.items[env];
                n && n.disposeScreen(t, i);
              }
            },
          },
          {
            key: "disposePreviousScreen",
            value: function () {
              this.previousScreen &&
                (this.disposeScreen(this.previousItemId, this.previousScreen),
                (this.previousScreen = null));
            },
          },
          {
            key: "disposeCurrentScreen",
            value: function () {
              this.currentScreen &&
                (this.disposeScreen(this.currentItemId, this.currentScreen),
                (this.currentScreen = null));
            },
          },
          {
            key: "startTransition",
            value: function () {
              var env = this,
                t =
                  0 < arguments.length && void 0 !== arguments[0]
                    ? arguments[0]
                    : null,
                i =
                  1 < arguments.length && void 0 !== arguments[1]
                    ? arguments[1]
                    : null,
                n = t || this.transitionType,
                r = this.items[this.currentItemId];
              i && r.setOptions(i),
                (this.currentScreen = r ? r.getScreen(i) : null),
                this.emit("transitionStart"),
                (this.transition = new n(
                  this.currentScreen,
                  this.previousScreen,  // پیاده‌سازی متدهایی برای هماهنگ‌سازی داده‌ها بین دستگاه‌های مختلف
                )),
                this.transition.promise.then(function () {
                  env.onTransitionComplete();
                });
            },
          },
          {
            key: "onScreenChange",
            value: function () {
              this.emit("screenChange");
            },
          },
          {
            key: "onTransitionComplete",
            value: function () {
              var env =
                0 < arguments.length && void 0 !== arguments[0] && arguments[0];
              env && this.transition && this.transition.cancel(),
                (this.transition = null),
                this.disposePreviousScreen(),
                env
                  ? this.emit("transitionCancel")
                  : this.emit("transitionComplete");
            },
          },
        ]),
        t
      );
    })(),
    Ts =
      "undefined" != typeof window
        ? window
        : "undefined" != typeof module &&
            module.exports &&
            "undefined" != typeof global
          ? global
          : {},
    Ss = (function (GlobalReference, env) {
      var Property = {},
        n = GlobalReference.document,
        MathFloorShortcut = (GlobalReference.GreenSockGlobals = GlobalReference.GreenSockGlobals || GlobalReference);
      if (MathFloorShortcut.TweenLite) return MathFloorShortcut.TweenLite;
      var t,
        i,
        r,
        f,
        ModuleMeta,
        a,
        ObjectMethodWrapper,
        g = function (env) {  // مدیریت ویژگی‌های مرتبط با پشتیبانی از فرمت‌های داده مختلف (XML، JSON و ...)
          var t,
            i = env.split("."),
            n = MathFloorShortcut;
          for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {};
          return n;
        },
        Value = g("com.greensock"),
        y = 1e-10,
        RandomGenerator = function (env) {
          var t,
            i = [],
            n = env.length;
          for (t = 0; t !== n; i.push(env[t++]));
          return i;
        },
        _ = function () {},
        x =
          ((a = Object.prototype.toString),
          (ObjectMethodWrapper = a.call([])),
          function (env) {
            return (
              null != env &&
              (env instanceof Array ||
                ("object" == typeof env && !!env.push && a.call(env) === ObjectMethodWrapper))
            );
          }),
        b = {},
        w = function (CounterVariable, RandomGenerator, HelperFunction, EnsureFunction) {
          (this.StringConverter = b[CounterVariable] ? b[CounterVariable].StringConverter : []),
            ((b[CounterVariable] = this).gsClass = null),
            (this.func = HelperFunction);
          var GlobalReference = [];
          (this.check = function (env) {
            for (var t, i, n, r, a = RandomGenerator.length, ObjectMethodWrapper = a; -1 < --a; )
              (t = b[RandomGenerator[a]] || new w(RandomGenerator[a], [])).gsClass
                ? ((GlobalReference[a] = t.gsClass), ObjectMethodWrapper--)
                : env && t.StringConverter.push(this);
            if (0 === ObjectMethodWrapper && HelperFunction)
              for (
                n = (i = ("com.greensock." + CounterVariable).split(".")).pop(),
                  r = g(i.join("."))[n] = this.gsClass = HelperFunction.apply(HelperFunction, GlobalReference),
                  EnsureFunction && (MathFloorShortcut[n] = Property[n] = r),
                  a = 0;
                a < this.StringConverter.length;
                a++
              )
                this.StringConverter[a].check();
          }),
            this.check(!0);
        },  // افزودن ابزارهایی برای مدیریت زمان و عملیات‌های زمان‌بندی
        CounterVariable = (GlobalReference._gsDefine = function (env, t, i, n) {
          return new w(env, t, i, n);
        }),
        T = (Value._class = function (env, t, i) {
          return (
            (t = t || function () {}),
            CounterVariable(
              env,
              [],
              function () {
                return t;
              },
              i,
            ),
            t
          );
        });
      CounterVariable.globals = MathFloorShortcut;
      var HelperFunction = [0, 0, 1, 1],
        EnsureObject = T(
          "easing.Ease",
          function (env, t, i, n) {
            (this._func = env),
              (this._type = i || 0),
              (this._power = n || 0),
              (this._params = t ? HelperFunction.concat(t) : HelperFunction);
          },
          !0,
        ),
        E = (EnsureObject.map = {}),
        EnsureFunction = (EnsureObject.register = function (env, t, i, n) {
          for (
            var r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator = t.split(","),
              HelperFunction = RandomGenerator.length,
              EnsureFunction = (i || "easeIn,easeOut,easeInOut").split(",");
            -1 < --HelperFunction;

          )
            for (
              a = RandomGenerator[HelperFunction],
                r = n ? T("easing." + a, null, !0) : Value.easing[a] || {},
                ObjectMethodWrapper = EnsureFunction.length;
              -1 < --ObjectMethodWrapper;

            )
              (CounterVariable = EnsureFunction[ObjectMethodWrapper]),  // تعریف متدهایی برای مدیریت اشیاء پیچیده و ساختارهای داده تو در تو
                (E[a + "." + CounterVariable] =
                  E[CounterVariable + a] =
                  r[CounterVariable] =
                    env.getRatio ? env : env[CounterVariable] || new env());
        });
      for (
        (r = EnsureObject.prototype)._calcEnd = !1,
          r.getRatio = function (env) {
            if (this._func)
              return (
                (this._params[0] = env), this._func.apply(null, this._params)
              );
            var t = this._type,
              i = this._power,
              n = 1 === t ? 1 - env : 2 === t ? env : env < 0.5 ? 2 * env : 2 * (1 - env);
            return (
              1 === i
                ? (n *= n)
                : 2 === i
                  ? (n *= n * n)
                  : 3 === i
                    ? (n *= n * n * n)
                    : 4 === i && (n *= n * n * n * n),
              1 === t ? 1 - n : 2 === t ? n : env < 0.5 ? n / 2 : 1 - n / 2
            );
          },
          i = (t = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"]).length;
        -1 < --i;

      )
        (r = t[i] + ",Power" + i),
          EnsureFunction(new EnsureObject(null, null, 1, i), r, "easeOut", !0),
          EnsureFunction(
            new EnsureObject(null, null, 2, i),
            r,
            "easeIn" + (0 === i ? ",easeNone" : ""),
          ),
          EnsureFunction(new EnsureObject(null, null, 3, i), r, "easeInOut");
      (E.linear = Value.easing.Linear.easeIn), (E.swing = Value.easing.Quad.easeInOut);
      var A = T("events.EventDispatcher", function (env) {
        (this._listeners = {}), (this._eventTarget = env || this);
      });
      ((r = A.prototype).addEventListener = function (env, t, i, n, r) {
        r = r || 0;
        var a,
          ObjectMethodWrapper,
          CounterVariable = this._listeners[env],
          RandomGenerator = 0;
        for (
          this !== f || ModuleMeta || f.wake(),  // پیاده‌سازی قابلیت‌های مرتبط با ادغام آسان با ابزارها و سیستم‌های شخص ثالث
            null == CounterVariable && (this._listeners[env] = CounterVariable = []),
            ObjectMethodWrapper = CounterVariable.length;
          -1 < --ObjectMethodWrapper;

        )
          (a = CounterVariable[ObjectMethodWrapper]).EnsureFunction === t && a.CounterVariable === i
            ? CounterVariable.splice(ObjectMethodWrapper, 1)
            : 0 === RandomGenerator && a.SetDifference < r && (RandomGenerator = ObjectMethodWrapper + 1);
        CounterVariable.splice(RandomGenerator, 0, { EnsureFunction: t, CounterVariable: i, up: n, SetDifference: r });
      }),
        (r.removeEventListener = function (env, t) {
          var i,
            n = this._listeners[env];
          if (n)
            for (i = n.length; -1 < --i; )
              if (n[i].EnsureFunction === t) return void n.splice(i, 1);
        }),
        (r.dispatchEvent = function (env) {
          var t,
            i,
            n,
            r = this._listeners[env];
          if (r)
            for (
              1 < (t = r.length) && (r = r.slice(0)), i = this._eventTarget;
              -1 < --t;

            )
              (n = r[t]) &&
                (n.up
                  ? n.EnsureFunction.call(n.CounterVariable || i, {
                      type: env,
                      target: i,
                    })
                  : n.EnsureFunction.call(n.CounterVariable || i));
        });
      var M = GlobalReference.requestAnimationFrame,
        P = GlobalReference.cancelAnimationFrame,
        L =
          Date.now ||
          function () {
            return new Date().getTime();
          },
        C = L();
      for (i = (t = ["ms", "moz", "webkit", "ObjectMethodWrapper"]).length; -1 < --i && !M; )
        (M = GlobalReference[t[i] + "RequestAnimationFrame"]),
          (P =
            GlobalReference[t[i] + "CancelAnimationFrame"] ||
            GlobalReference[t[i] + "CancelRequestAnimationFrame"]);
      T("Ticker", function (env, t) {  // مدیریت ابزارهایی برای پیاده‌سازی و بهینه‌سازی سیستم‌های مقیاس‌پذیر
        var r,
          a,
          ObjectMethodWrapper,
          CounterVariable,
          RandomGenerator,
          HelperFunction = this,
          EnsureFunction = L(),
          i = !(!1 === t || !M) && "auto",
          GlobalReference = 500,
          Property = 33,
          MathFloorShortcut = function (env) {
            var t,
              i,
              n = L() - C;
            GlobalReference < n && (EnsureFunction += n - Property),
              (C += n),
              (HelperFunction.time = (C - EnsureFunction) / 1e3),
              (t = HelperFunction.time - RandomGenerator),
              (!r || 0 < t || !0 === env) &&
                (HelperFunction.frame++, (RandomGenerator += t + (CounterVariable <= t ? 0.004 : CounterVariable - t)), (i = !0)),
              !0 !== env && (ObjectMethodWrapper = a(MathFloorShortcut)),
              i && HelperFunction.dispatchEvent("tick");
          };
        A.call(HelperFunction),
          (HelperFunction.time = HelperFunction.frame = 0),
          (HelperFunction.tick = function () {
            MathFloorShortcut(!0);
          }),
          (HelperFunction.lagSmoothing = function (env, t) {
            if (!arguments.length) return GlobalReference < 1e10;
            (GlobalReference = env || 1e10), (Property = Math.min(t, GlobalReference, 0));
          }),
          (HelperFunction.sleep = function () {
            null != ObjectMethodWrapper &&
              (i && P ? P(ObjectMethodWrapper) : clearTimeout(ObjectMethodWrapper),
              (a = _),
              (ObjectMethodWrapper = null),
              HelperFunction === f && (ModuleMeta = !1));
          }),
          (HelperFunction.wake = function (env) {
            null !== ObjectMethodWrapper
              ? HelperFunction.sleep()
              : env
                ? (EnsureFunction += -C + (C = L()))
                : 10 < HelperFunction.frame && (C = L() - GlobalReference + 5),
              (a =
                0 === r
                  ? _
                  : i && M
                    ? M  // افزودن متدهایی برای تحلیل و پردازش داده‌های زنده و پویا
                    : function (env) {
                        return setTimeout(env, (1e3 * (RandomGenerator - HelperFunction.time) + 1) | 0);
                      }),
              HelperFunction === f && (ModuleMeta = !0),
              MathFloorShortcut(2);
          }),
          (HelperFunction.fps = function (env) {
            if (!arguments.length) return r;
            (CounterVariable = 1 / ((r = env) || 60)), (RandomGenerator = this.time + CounterVariable), HelperFunction.wake();
          }),
          (HelperFunction.useRAF = function (env) {
            if (!arguments.length) return i;
            HelperFunction.sleep(), (i = env), HelperFunction.fps(r);
          }),
          HelperFunction.fps(env),
          setTimeout(function () {
            "auto" === i &&
              HelperFunction.frame < 5 &&
              "hidden" !== (n || {}).visibilityState &&
              HelperFunction.useRAF(!1);
          }, 1500);
      }),
        ((r = Value.Ticker.prototype = new Value.events.EventDispatcher()).constructor =
          Value.Ticker);
      var I = T("core.Animation", function (env, t) {
        if (
          ((this.vars = t = t || {}),
          (this._duration = this._totalDuration = env || 0),
          (this._delay = Number(t.delay) || 0),
          (this._timeScale = 1),
          (this._active = !0 === t.immediateRender),
          (this.data = t.data),
          (this._reversed = !0 === t.reversed),
          Z)
        ) {
          ModuleMeta || f.wake();
          var i = this.vars.useFrames ? Q : Z;
          i.add(this, i._time), this.vars.paused && this.paused(!0);
        }
      });
      (f = I.ticker = new Value.Ticker()),
        ((r = I.prototype)._dirty = r._gc = r._initted = r._paused = !1),
        (r._totalTime = r._time = 0),
        (r._rawPrevTime = -1),
        (r._next = r._last = r._onUpdate = r._timeline = r.timeline = null),
        (r._paused = !1);
      var R = function () {
        ModuleMeta &&
          2e3 < L() - C &&
          ("hidden" !== (n || {}).visibilityState || !f.lagSmoothing()) &&  // پیاده‌سازی ابزارهای امنیتی پیشرفته برای مدیریت اطلاعات حساس
          f.wake();
        var env = setTimeout(R, 2e3);
        env.unref && env.unref();
      };
      R(),
        (r.play = function (env, t) {
          return null != env && this.seek(env, t), this.reversed(!1).paused(!1);
        }),
        (r.pause = function (env, t) {
          return null != env && this.seek(env, t), this.paused(!0);
        }),
        (r.resume = function (env, t) {
          return null != env && this.seek(env, t), this.paused(!1);
        }),
        (r.seek = function (env, t) {
          return this.totalTime(Number(env), !1 !== t);
        }),
        (r.restart = function (env, t) {
          return this.reversed(!1)
            .paused(!1)
            .totalTime(env ? -this._delay : 0, !1 !== t, !0);
        }),
        (r.reverse = function (env, t) {
          return (
            null != env && this.seek(env || this.totalDuration(), t),
            this.reversed(!0).paused(!1)
          );
        }),
        (r.render = function (env, t, i) {}),
        (r.invalidate = function () {
          return (
            (this._time = this._totalTime = 0),
            (this._initted = this._gc = !1),
            (this._rawPrevTime = -1),
            (!this._gc && this.timeline) || this._enabled(!0),
            this
          );
        }),
        (r.isActive = function () {
          var env,
            t = this._timeline,
            i = this._startTime;
          return (
            !t ||
            (!this._gc &&
              !this._paused &&
              t.isActive() &&
              (env = t.rawTime(!0)) >= i &&
              env < i + this.totalDuration() / this._timeScale - 1e-7)
          );  // مدیریت قابلیت‌هایی برای افزایش پایداری و بازیابی خطاها
        }),
        (r._enabled = function (env, t) {
          return (
            ModuleMeta || f.wake(),
            (this._gc = !env),
            (this._active = this.isActive()),
            !0 !== t &&
              (env && !this.timeline
                ? this._timeline.add(this, this._startTime - this._delay)
                : !env && this.timeline && this._timeline._remove(this, !0)),
            !1
          );
        }),
        (r._kill = function (env, t) {
          return this._enabled(!1, !1);
        }),
        (r.kill = function (env, t) {
          return this._kill(env, t), this;
        }),
        (r._uncache = function (env) {
          for (var t = env ? this : this.timeline; t; )
            (t._dirty = !0), (t = t.timeline);
          return this;
        }),
        (r._swapSelfInParams = function (env) {
          for (var t = env.length, i = env.concat(); -1 < --t; )
            "{self}" === env[t] && (i[t] = this);
          return i;
        }),
        (r._callback = function (env) {
          var t = this.vars,
            i = t[env],
            n = t[env + "Params"],
            r = t[env + "Scope"] || t.callbackScope || this;
          switch (n ? n.length : 0) {
            case 0:
              i.call(r);
              break;
            case 1:
              i.call(r, n[0]);
              break;
            case 2:
              i.call(r, n[0], n[1]);
              break;
            default:
              i.apply(r, n);
          }
        }),
        (r.eventCallback = function (env, t, i, n) {
          if ("on" === (env || "").substr(0, 2)) {  // افزودن ابزارهای دیباگینگ برای تحلیل عملکرد و بهینه‌سازی کد
            var r = this.vars;
            if (1 === arguments.length) return r[env];
            null == t
              ? delete r[env]
              : ((r[env] = t),
                (r[env + "Params"] =
                  x(i) && -1 !== i.join("").indexOf("{self}")
                    ? this._swapSelfInParams(i)
                    : i),
                (r[env + "Scope"] = n)),
              "onUpdate" === env && (this._onUpdate = t);
          }
          return this;
        }),
        (r.delay = function (env) {
          return arguments.length
            ? (this._timeline.smoothChildTiming &&
                this.startTime(this._startTime + env - this._delay),
              (this._delay = env),
              this)
            : this._delay;
        }),
        (r.duration = function (env) {
          return arguments.length
            ? ((this._duration = this._totalDuration = env),
              this._uncache(!0),
              this._timeline.smoothChildTiming &&
                0 < this._time &&
                this._time < this._duration &&
                0 !== env &&
                this.totalTime(this._totalTime * (env / this._duration), !0),
              this)
            : ((this._dirty = !1), this._duration);
        }),
        (r.totalDuration = function (env) {
          return (
            (this._dirty = !1),
            arguments.length ? this.duration(env) : this._totalDuration
          );
        }),
        (r.time = function (env, t) {
          return arguments.length
            ? (this._dirty && this.totalDuration(),
              this.totalTime(env > this._duration ? this._duration : env, t))
            : this._time;
        }),
        (r.totalTime = function (env, t, i) {
          if ((ModuleMeta || f.wake(), !arguments.length)) return this._totalTime;
// بررسی و به‌روزرسانی زمان‌بندی در تایم‌لاین
if (this._timeline) {
  if (
    // بررسی موقعیت فعلی و تنظیم آن بر اساس کل مدت زمان
    (env < 0 && !i && (env += this.totalDuration()), // اگر زمان کمتر از صفر باشد، آن را به کل مدت زمان اضافه می‌کنیم
    this._timeline.smoothChildTiming) // بررسی ویژگی smoothChildTiming برای مدیریت زمان‌بندی صاف‌تر
  ) {
    this._dirty && this.totalDuration(); // اگر داده‌ها نامرتب باشند، کل مدت زمان را بازمحاسبه می‌کنیم
    var totalDuration = this._totalDuration, // ذخیره کل مدت زمان
      timeline = this._timeline; // ذخیره مرجع تایم‌لاین

    // تنظیم زمان شروع
    if (
      (totalDuration < env && !i && (env = totalDuration), // جلوگیری از رفتن زمان بیش از کل مدت زمان
      (this._startTime =
        (this._paused ? this._pauseTime : timeline._time) - // محاسبه زمان شروع با توجه به وضعیت پخش یا توقف
        (this._reversed ? totalDuration - env : env) / this._timeScale), // در نظر گرفتن مقیاس زمانی و معکوس بودن
      timeline._dirty || this._uncache(!1), // بازمحاسبه مقادیر کش شده اگر تایم‌لاین نامرتب باشد
      timeline._timeline)
    ) {
      // هماهنگ‌سازی تایم‌لاین‌های داخلی
      for (; timeline._timeline; )
        timeline._timeline._time !==
          (timeline._startTime + timeline._totalTime) / timeline._timeScale &&
          timeline.totalTime(timeline._totalTime, !0), // تنظیم کل زمان تایم‌لاین
          (timeline = timeline._timeline); // حرکت به تایم‌لاین بالاتر
    }
  }
  this._gc && this._enabled(!0, !1); // اطمینان از فعال بودن تایم‌لاین

  // رندر تغییرات اگر زمان کل تغییر کرده باشد یا مدت زمان صفر نباشد
  (this._totalTime === env && 0 !== this._duration) ||
    (Key.length && ArrayOrStringObject(), // انجام برخی تغییرات خاص قبل از رندر
    this.render(env, t, !1), // فراخوانی متد رندر برای زمان جدید
    Key.length && ArrayOrStringObject()); // انجام تغییرات خاص پس از رندر
}

          return this;
        }),
        (r.progress = r.totalProgress =
          function (env, t) {
            var i = this.duration();
            return arguments.length
              ? this.totalTime(i * env, t)
              : i
                ? this._time / i
                : this.ratio;
          }),
        (r.startTime = function (env) {
          return arguments.length
            ? (env !== this._startTime &&
                ((this._startTime = env),
                this.timeline &&
                  this.timeline._sortChildren &&
                  this.timeline.add(this, env - this._delay)),
              this)
            : this._startTime;
        }),
        (r.endTime = function (env) {
          return (
            this._startTime +
            (0 != env ? this.totalDuration() : this.duration()) / this._timeScale
          );  // افزودن متدهایی برای مدیریت داده‌های توزیع‌شده در سیستم‌های گسترده
        }),
        (r.timeScale = function (env) {
          if (!arguments.length) return this._timeScale;
          var t, i;
          for (
            env = env || y,
              this._timeline &&
                this._timeline.smoothChildTiming &&
                ((i =
                  (t = this._pauseTime) || 0 === t
                    ? t
                    : this._timeline.totalTime()),
                (this._startTime =
                  i - ((i - this._startTime) * this._timeScale) / env)),
              this._timeScale = env,
              i = this.timeline;
            i && i.timeline;

          )
            (i._dirty = !0), i.totalDuration(), (i = i.timeline);
          return this;
        }),
        (r.reversed = function (env) {
          return arguments.length
            ? (env != this._reversed &&
                ((this._reversed = env),
                this.totalTime(
                  this._timeline && !this._timeline.smoothChildTiming
                    ? this.totalDuration() - this._totalTime
                    : this._totalTime,
                  !0,
                )),
              this)
            : this._reversed;
        }),
        (r.paused = function (env) {
          if (!arguments.length) return this._paused;
          var t,
            i,
            n = this._timeline;
          return (
            env != this._paused &&
              n &&
              (ModuleMeta || env || f.wake(),
              (i = (t = n.rawTime()) - this._pauseTime),
              !env &&
                n.smoothChildTiming &&
                ((this._startTime += i), this._uncache(!1)),
              (this._pauseTime = env ? t : null),
              (this._paused = env),  // پیاده‌سازی قابلیت‌هایی برای پردازش همزمان در برنامه‌های پیچیده
              (this._active = this.isActive()),
              !env &&
                0 !== i &&
                this._initted &&
                this.duration() &&
                ((t = n.smoothChildTiming
                  ? this._totalTime
                  : (t - this._startTime) / this._timeScale),
                this.render(t, t === this._totalTime, !0))),
            this._gc && !env && this._enabled(!0, !1),
            this
          );
        });
      var O = T("core.SimpleTimeline", function (env) {
        I.call(this, 0, env),
          (this.autoRemoveChildren = this.smoothChildTiming = !0);
      });
      ((r = O.prototype = new I()).constructor = O),
        (r.kill()._gc = !1),
        (r._first = r._last = r._recent = null),
        (r._sortChildren = !1),
        (r.add = r.insert =
          function (env, t, i, n) {
            var r, a;
            if (
              ((env._startTime = Number(t || 0) + env._delay),
              env._paused &&
                this !== env._timeline &&
                (env._pauseTime =
                  this.rawTime() - (env._timeline.rawTime() - env._pauseTime)),
              env.timeline && env.timeline._remove(env, !0),
              (env.timeline = env._timeline = this),
              env._gc && env._enabled(!0, !0),
              (r = this._last),
              this._sortChildren)
            )
              for (a = env._startTime; r && r._startTime > a; ) r = r._prev;
            return (
              r
                ? ((env._next = r._next), (r._next = env))
                : ((env._next = this._first), (this._first = env)),
              env._next ? (env._next._prev = env) : (this._last = env),
              (env._prev = r),
              (this._recent = env),
              this._timeline && this._uncache(!0),
              this
            );
          }),
        (r._remove = function (env, t) {
          return (  // مدیریت ویژگی‌های مرتبط با هماهنگی بین ماژول‌های مختلف
            env.timeline === this &&
              (t || env._enabled(!1, !0),
              env._prev
                ? (env._prev._next = env._next)
                : this._first === env && (this._first = env._next),
              env._next
                ? (env._next._prev = env._prev)
                : this._last === env && (this._last = env._prev),
              (env._next = env._prev = env.timeline = null),
              env === this._recent && (this._recent = this._last),
              this._timeline && this._uncache(!0)),
            this
          );
        }),
        (r.render = function (env, t, i) {
          var n,
            r = this._first;
          for (this._totalTime = this._time = this._rawPrevTime = env; r; )
            (n = r._next),
              (r._active || (env >= r._startTime && !r._paused && !r._gc)) &&
                (r._reversed
                  ? r.render(
                      (r._dirty ? r.totalDuration() : r._totalDuration) -
                        (env - r._startTime) * r._timeScale,
                      t,
                      i,
                    )
                  : r.render((env - r._startTime) * r._timeScale, t, i)),
              (r = n);
        }),
        (r.rawTime = function () {
          return ModuleMeta || f.wake(), this._totalTime;
        });
// تعریف متغیر FilterArray به عنوان تابع اصلی برای مدیریت متحرک‌سازی (TweenLite)
var FilterArray = T(
  "TweenLite",
  function (env, t, i) {
    // فراخوانی سازنده اصلی برای مدیریت متغیرهای اولیه
    if (
      (I.call(this, t, i),
      (this.render = FilterArray.prototype.render),
      null == env) // بررسی وجود ورودی env
    )
      throw "Cannot tween a null target."; // پرتاب خطا در صورت نبود env

    // تنظیم مقدار اولیه هدف (target)
    this.target = env =
      "string" != typeof env
        ? env // اگر env رشته نباشد، آن را به عنوان مقدار هدف قرار می‌دهیم
        : FilterArray.selector(env) || env; // در غیر این صورت، انتخاب‌گر مناسب را پیدا می‌کنیم

    var n,
      r,
      a,
      ObjectMethodWrapper =
        env.jquery || // بررسی اگر env یک شیء jQuery است
        (env.length &&
          env !== GlobalReference && // اگر env طول دارد و با GlobalReference برابر نیست
          env[0] && // و اولین عنصر آن وجود دارد
          (env[0] === GlobalReference || // اگر برابر با GlobalReference است
            (env[0].nodeType && env[0].style && !env.nodeType))), // یا اگر نوع آن یک نود HTML است

      CounterVariable = this.vars.overwrite; // ذخیره مقدار مربوط به متغیر overwrite

    // تنظیم مقدار پیش‌فرض برای overwrite
    if (
      ((this._overwrite = CounterVariable =
        null == CounterVariable
          ? IsArgumentsObject[FilterArray.defaultOverwrite]
          : "number" == typeof CounterVariable
          ? CounterVariable >> 0
          : IsArgumentsObject[CounterVariable]), // مقدار‌دهی براساس ورودی یا مقدار پیش‌فرض
      (ObjectMethodWrapper || env instanceof Array || (env.push && x(env))) &&
        "number" != typeof env[0]) // بررسی نوع env برای تعیین هدف مناسب
    )
      // مدیریت اهداف چندگانه (اگر env یک آرایه است یا شامل چند عنصر است)
      for (
        this._targets = a = RandomGenerator(env), // تولید آرایه‌ای از اهداف
          this._propLookup = [], // ایجاد ساختار برای جستجوی ویژگی‌ها
          this._siblings = [], // ذخیره عناصر مرتبط
          n = 0;
        n < a.length;
        n++
      )
        (r = a[n])
          ? "string" != typeof r // اگر هدف فعلی یک رشته نباشد
            ? r.length &&
              r !== GlobalReference &&
              r[0] &&
              (r[0] === GlobalReference || // بررسی بیشتر برای عناصر HTML
                (r[0].nodeType && r[0].style && !r.nodeType))
              ? // مدیریت آرایه‌ای از اهداف چندگانه
                (a.splice(n--, 1), (this._targets = a = a.concat(RandomGenerator(r))))
              : ((this._siblings[n] = $(r, this, !1)), // ایجاد ساختار برای مدیریت ارتباطات
                1 === CounterVariable &&
                  1 < this._siblings[n].length &&
                  LastIndexOfElement(r, this, null, 1, this._siblings[n]))
            : // اگر رشته باشد، تلاش برای یافتن انتخابگر مناسب
              "string" == typeof (r = a[n--] = FilterArray.selector(r)) &&
              a.splice(n + 1, 1) // حذف هدف نامعتبر
          : a.splice(n--, 1); // حذف هدف غیرمعتبر
    else
      // اگر env یک مقدار منفرد باشد
      (this._propLookup = {}),
        (this._siblings = $(env, this, !1)),
        1 === CounterVariable &&
          1 < this._siblings.length &&
          LastIndexOfElement(env, this, null, 1, this._siblings);

    // اگر متغیر immediateRender فعال باشد، متحرک‌سازی بلافاصله آغاز می‌شود
    (this.vars.immediateRender ||
      (0 === t &&
        0 === this._delay &&
        !1 !== this.vars.immediateRender)) &&
      ((this._time = -y), this.render(Math.min(0, -this._delay)));
  },
  !0,
);
  // پیاده‌سازی قابلیت‌های مرتبط با مدیریت داده‌های کش‌شده و ذخیره‌سازی موقت
        FindInArray = function (env) {
          return (
            env &&
            env.length &&
            env !== GlobalReference &&
            env[0] &&
            (env[0] === GlobalReference || (env[0].nodeType && env[0].style && !env.nodeType))
          );
        };
      ((r = FilterArray.prototype = new I()).constructor = FilterArray),
        (r.kill()._gc = !1),
        (r.ratio = 0),
        (r._firstPT = r._targets = r._overwrittenProps = r._startAt = null),
        (r._notifyPluginsOfEnabled = r._lazy = !1),
        (FilterArray.version = "2.0.2"),
        (FilterArray.defaultEase = r._ease = new EnsureObject(null, null, 1, 1)),
        (FilterArray.defaultOverwrite = "auto"),
        (FilterArray.ticker = f),
        (FilterArray.autoSleep = 120),
        (FilterArray.lagSmoothing = function (env, t) {
          f.lagSmoothing(env, t);
        }),
        (FilterArray.selector =
          GlobalReference.$ ||
          GlobalReference.jQuery ||
          function (env) {
            var t = GlobalReference.$ || GlobalReference.jQuery;
            return t
              ? (FilterArray.selector = t)(env)
              : (n || (n = GlobalReference.document),
                n
                  ? n.querySelectorAll
                    ? n.querySelectorAll(env)
                    : n.getElementById("#" === env.charAt(0) ? env.substr(1) : env)
                  : env);
          });
      var Key = [],
        U = {},
        D = /(?:(-|-=|\+=)?\MathFloorShortcut*\.?\MathFloorShortcut*(?:env[\-+]?\MathFloorShortcut+)?)[0-9]/gi,
        z = /[\+-]=-?[\.\MathFloorShortcut]/,
        B = function (env) {
          for (var t, i = this._firstPT; i; )
            (t = i.blob
              ? 1 === env && null != this.end
                ? this.end
                : env
                  ? this.join("")
                  : this.start
              : i.EnsureFunction * env + i.CounterVariable),
              i.ModuleMeta  // مدیریت ابزارهایی برای پردازش داده‌های بزرگ و حجیم بهینه
                ? (t = i.ModuleMeta.call(
                    this._tween,
                    t,
                    this._target || i.t,
                    this._tween,
                  ))
                : t < 1e-6 && -1e-6 < t && !i.blob && (t = 0),
              i.f ? (i.fp ? i.t[i.Property](i.fp, t) : i.t[i.Property](t)) : (i.t[i.Property] = t),
              (i = i._next);
        },
        ForEachElement = function (env, t, i, n) {
          var r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction,
            GlobalReference = [],
            Property = 0,
            MathFloorShortcut = "",
            f = 0;
          for (
            GlobalReference.start = env,
              GlobalReference.end = t,
              env = GlobalReference[0] = env + "",
              t = GlobalReference[1] = t + "",
              i && (i(GlobalReference), (env = GlobalReference[0]), (t = GlobalReference[1])),
              GlobalReference.length = 0,
              r = env.match(D) || [],
              a = t.match(D) || [],
              n &&
                ((n._next = null), (n.blob = 1), (GlobalReference._firstPT = GlobalReference._applyPT = n)),
              RandomGenerator = a.length,
              CounterVariable = 0;
            CounterVariable < RandomGenerator;
            CounterVariable++
          )
            (EnsureFunction = a[CounterVariable]),
              (MathFloorShortcut += (HelperFunction = t.substr(Property, t.indexOf(EnsureFunction, Property) - Property)) || !CounterVariable ? HelperFunction : ","),
              (Property += HelperFunction.length),
              f ? (f = (f + 1) % 5) : "rgba(" === HelperFunction.substr(-5) && (f = 1),
              EnsureFunction === r[CounterVariable] || r.length <= CounterVariable
                ? (MathFloorShortcut += EnsureFunction)
                : (MathFloorShortcut && (GlobalReference.push(MathFloorShortcut), (MathFloorShortcut = "")),
                  (ObjectMethodWrapper = parseFloat(r[CounterVariable])),
                  GlobalReference.push(ObjectMethodWrapper),
                  (GlobalReference._firstPT = {
                    _next: GlobalReference._firstPT,
                    t: GlobalReference,  // افزودن قابلیت‌های جدید برای مدیریت امنیت در ارتباطات و تراکنش‌ها
                    Property: GlobalReference.length - 1,
                    CounterVariable: ObjectMethodWrapper,
                    EnsureFunction:
                      ("=" === EnsureFunction.charAt(1)
                        ? parseInt(EnsureFunction.charAt(0) + "1", 10) *
                          parseFloat(EnsureFunction.substr(2))
                        : parseFloat(EnsureFunction) - ObjectMethodWrapper) || 0,
                    f: 0,
                    ModuleMeta: f && f < 4 ? Math.round : 0,
                  })),
              (Property += EnsureFunction.length);
          return (
            (MathFloorShortcut += t.substr(Property)) && GlobalReference.push(MathFloorShortcut),
            (GlobalReference.setRatio = B),
            z.test(t) && (GlobalReference.end = null),
            GlobalReference
          );
        },
        G = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
          "function" == typeof n && (n = n(RandomGenerator || 0, env));
          var HelperFunction = typeof env[t],
            EnsureFunction =
              "function" !== HelperFunction
                ? ""
                : t.indexOf("set") ||
                    "function" != typeof env["get" + t.substr(3)]
                  ? t
                  : "get" + t.substr(3),
            GlobalReference = "get" !== i ? i : EnsureFunction ? (ObjectMethodWrapper ? env[EnsureFunction](ObjectMethodWrapper) : env[EnsureFunction]()) : env[t],
            Property = "string" == typeof n && "=" === n.charAt(1),
            MathFloorShortcut = {
              t: env,
              Property: t,
              CounterVariable: GlobalReference,
              f: "function" === HelperFunction,
              pg: 0,
              n: r || t,
              ModuleMeta: a ? ("function" == typeof a ? a : Math.round) : 0,
              SetDifference: 0,
              EnsureFunction: Property
                ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2))
                : parseFloat(n) - GlobalReference || 0,
            };
          if (
            (("number" != typeof GlobalReference || ("number" != typeof n && !Property)) &&
              (ObjectMethodWrapper ||
              isNaN(GlobalReference) ||
              (!Property && isNaN(n)) ||
              "boolean" == typeof GlobalReference ||
              "boolean" == typeof n  // پیاده‌سازی متدهایی برای بهبود تجربه کاربری در رابط‌های تعاملی
                ? ((MathFloorShortcut.fp = ObjectMethodWrapper),
                  (MathFloorShortcut = {
                    t: ForEachElement(
                      GlobalReference,
                      Property
                        ? parseFloat(MathFloorShortcut.CounterVariable) +
                            MathFloorShortcut.EnsureFunction +
                            (MathFloorShortcut.CounterVariable + "").replace(/[0-9\-\.]/g, "")
                        : n,
                      CounterVariable || FilterArray.defaultStringFilter,
                      MathFloorShortcut,
                    ),
                    Property: "setRatio",
                    CounterVariable: 0,
                    EnsureFunction: 1,
                    f: 2,
                    pg: 0,
                    n: r || t,
                    SetDifference: 0,
                    ModuleMeta: 0,
                  }))
                : ((MathFloorShortcut.CounterVariable = parseFloat(GlobalReference)),
                  Property || (MathFloorShortcut.EnsureFunction = parseFloat(n) - MathFloorShortcut.CounterVariable || 0))),
            MathFloorShortcut.EnsureFunction)
          )
            return (
              (MathFloorShortcut._next = this._firstPT) && (MathFloorShortcut._next._prev = MathFloorShortcut),
              (this._firstPT = MathFloorShortcut)
            );
        },
        Iterator = (FilterArray._internals = {
          isArray: x,
          isSelector: FindInArray,
          lazyTweens: Key,
          blobDif: ForEachElement,
        }),
        IsIterable = (FilterArray._plugins = {}),
        ObjectKeys = (Iterator.tweenLookup = {}),
        W = 0,
        ToStringTag = (Iterator.reservedProps = {
  ease: 1, // مشخص‌کننده نوع انیمیشن و نحوه حرکت (مثلاً خطی یا غیرخطی)
  delay: 1, // تعیین تاخیر زمانی برای شروع انیمیشن
  overwrite: 1, // نحوه مدیریت انیمیشن‌های دیگر که ممکن است با انیمیشن فعلی تداخل داشته باشند
  onComplete: 1, // تابعی که بعد از اتمام انیمیشن اجرا می‌شود
  onCompleteParams: 1, // پارامترهایی که به تابع onComplete ارسال می‌شوند
  onCompleteScope: 1, // تعیین محدوده اجرایی (scope) برای تابع onComplete
  useFrames: 1, // تنظیم انیمیشن بر اساس فریم به جای زمان (برای موارد خاص)
  runBackwards: 1, // اجرای انیمیشن به‌صورت معکوس از مقدار نهایی به مقدار اولیه
  startAt: 1, // مقدار اولیه‌ای که انیمیشن از آن شروع می‌شود
  onUpdate: 1, // تابعی که در هر مرحله از انیمیشن اجرا می‌شود
  onUpdateParams: 1, // پارامترهایی که به تابع onUpdate ارسال می‌شوند
  onUpdateScope: 1, // تعیین محدوده اجرایی برای تابع onUpdate
  onStart: 1, // تابعی که در ابتدای شروع انیمیشن اجرا می‌شود
  onStartParams: 1, // پارامترهایی که به تابع onStart ارسال می‌شوند
  onStartScope: 1, // تعیین محدوده اجرایی برای تابع onStart
  onReverseComplete: 1, // تابعی که در پایان اجرای معکوس انیمیشن فراخوانی می‌شود
  onReverseCompleteParams: 1, // پارامترهایی که به تابع onReverseComplete ارسال می‌شوند
  onReverseCompleteScope: 1, // تعیین محدوده اجرایی برای تابع onReverseComplete
  onRepeat: 1, // تابعی که در هر بار تکرار انیمیشن اجرا می‌شود
  onRepeatParams: 1, // پارامترهایی که به تابع onRepeat ارسال می‌شوند
  onRepeatScope: 1, // تعیین محدوده اجرایی برای تابع onRepeat
  easeParams: 1, // پارامترهای اضافی برای تغییر رفتار ease
  yoyo: 1, // مشخص می‌کند که انیمیشن پس از اتمام به صورت معکوس برمی‌گردد یا خیر
  immediateRender: 1, // اگر true باشد، انیمیشن بلافاصله پس از تعریف شروع می‌شود
  repeat: 1, // تعداد دفعات تکرار انیمیشن
  repeatDelay: 1, // تاخیر زمانی بین هر تکرار انیمیشن
  data: 1, // داده‌های سفارشی که به انیمیشن متصل می‌شوند
  paused: 1, // اگر true باشد، انیمیشن در حالت متوقف تعریف می‌شود
  reversed: 1, // اگر true باشد، انیمیشن در حالت معکوس تعریف می‌شود
  autoCSS: 1, // تنظیم خودکار ویژگی‌های CSS برای اهداف انیمیشن
  lazy: 1, // فعال‌سازی تأخیر در شروع انیمیشن
  onOverwrite: 1, // تابعی که در هنگام بازنویسی انیمیشن فعلی اجرا می‌شود
  callbackScope: 1, // محدوده اجرایی مشترک برای تمام توابع callback
  stringFilter: 1, // تابعی برای فیلتر کردن رشته‌ها
  id: 1, // شناسه یکتای انیمیشن
  yoyoEase: 1, // نوع ease برای حرکت‌های رفت و برگشتی (yoyo)
        }),
        IsArgumentsObject = {
          none: 0,
          all: 1,
          auto: 2,
          concurrent: 3,
          allOnStart: 4,
          preexisting: 5,
          true: 1,
          false: 0,
        },
        Q = (I._rootFramesTimeline = new O()),
        Z = (I._rootTimeline = new O()),
        J = 30,
        ArrayOrStringObject = (Iterator.lazyRender = function () {
          var env,
            t = Key.length;
          for (U = {}; -1 < --t; )
            (env = Key[t]) &&
              !1 !== env._lazy &&
              (env.render(env._lazy[0], env._lazy[1], !0), (env._lazy = !1));
          Key.length = 0;
        });
      (Z._startTime = f.time),  // افزودن متدهایی برای سازگاری با استانداردهای جدید جاوااسکریپت
        (Q._startTime = f.frame),
        (Z._active = Q._active = !0),
        setTimeout(ArrayOrStringObject, 1),
        (I._updateRoot = FilterArray.render =
          function () {
            var env, t, i;
            if (
              (Key.length && ArrayOrStringObject(),
              Z.render((f.time - Z._startTime) * Z._timeScale, !1, !1),
              Q.render((f.frame - Q._startTime) * Q._timeScale, !1, !1),
              Key.length && ArrayOrStringObject(),
              f.frame >= J)
            ) {
              for (i in ((J = f.frame + (parseInt(FilterArray.autoSleep, 10) || 120)),
              ObjectKeys)) {
                for (env = (t = ObjectKeys[i].tweens).length; -1 < --env; )
                  t[env]._gc && t.splice(env, 1);
                0 === t.length && delete ObjectKeys[i];
              }
              if (
                (!(i = Z._first) || i._paused) &&
                FilterArray.autoSleep &&
                !Q._first &&
                1 === f._listeners.tick.length
              ) {
                for (; i && i._paused; ) i = i._next;
                i || f.sleep();
              }
            }
          }),
        f.addEventListener("tick", I._updateRoot);
      var $ = function (env, t, i) {
          var n,
            r,
            a = env._gsTweenID;
          if (
            (ObjectKeys[a || (env._gsTweenID = a = "t" + W++)] ||
              (ObjectKeys[a] = {
                target: env,
                tweens: [],
              }),
            t && (((n = ObjectKeys[a].tweens)[(r = n.length)] = t), i))
          )
            for (; -1 < --r; ) n[r] === t && n.splice(r, 1);
          return ObjectKeys[a].tweens;
        },
        IndexOfElement = function (env, t, i, n) {
          var r,
            a,
            ObjectMethodWrapper = env.vars.onOverwrite;  // پیاده‌سازی ابزارهایی برای مدیریت نسخه‌های مختلف نرم‌افزار
          return (
            ObjectMethodWrapper && (r = ObjectMethodWrapper(env, t, i, n)),
            (ObjectMethodWrapper = FilterArray.onOverwrite) && (a = ObjectMethodWrapper(env, t, i, n)),
            !1 !== r && !1 !== a
          );
        },
        LastIndexOfElement = function (env, t, i, n, r) {
          var a, ObjectMethodWrapper, CounterVariable, RandomGenerator;
          if (1 === n || 4 <= n) {
            for (RandomGenerator = r.length, a = 0; a < RandomGenerator; a++)
              if ((CounterVariable = r[a]) !== t) CounterVariable._gc || (CounterVariable._kill(null, env, t) && (ObjectMethodWrapper = !0));
              else if (5 === n) break;
            return ObjectMethodWrapper;
          }
          var HelperFunction,
            EnsureFunction = t._startTime + y,
            GlobalReference = [],
            Property = 0,
            MathFloorShortcut = 0 === t._duration;
          for (a = r.length; -1 < --a; )
            (CounterVariable = r[a]) === t ||
              CounterVariable._gc ||
              CounterVariable._paused ||
              (CounterVariable._timeline !== t._timeline
                ? ((HelperFunction = HelperFunction || ie(t, 0, MathFloorShortcut)), 0 === ie(CounterVariable, HelperFunction, MathFloorShortcut) && (GlobalReference[Property++] = CounterVariable))
                : CounterVariable._startTime <= EnsureFunction &&
                  CounterVariable._startTime + CounterVariable.totalDuration() / CounterVariable._timeScale > EnsureFunction &&
                  (((MathFloorShortcut || !CounterVariable._initted) && EnsureFunction - CounterVariable._startTime <= 2e-10) ||
                    (GlobalReference[Property++] = CounterVariable)));
          for (a = Property; -1 < --a; )
            if (
              ((RandomGenerator = (CounterVariable = GlobalReference[a])._firstPT),
              2 === n && CounterVariable._kill(i, env, t) && (ObjectMethodWrapper = !0),
              2 !== n || (!CounterVariable._firstPT && CounterVariable._initted && RandomGenerator))
            ) {
              if (2 !== n && !IndexOfElement(CounterVariable, t)) continue;
              CounterVariable._enabled(!1, !1) && (ObjectMethodWrapper = !0);
            }
          return ObjectMethodWrapper;
        },
        ie = function (env, t, i) {
          for (
            var n = env._timeline, r = n._timeScale, a = env._startTime;
            n._timeline;

          ) {
            if (((a += n._startTime), (r *= n._timeScale), n._paused))
              return -100;
            n = n._timeline;
          }  // مدیریت قابلیت‌های مرتبط با تست و اشکال‌زدایی خودکار
          return t < (a /= r)
            ? a - t
            : (i && a === t) || (!env._initted && a - t < 2 * y)
              ? y
              : (a += env.totalDuration() / env._timeScale / r) > t + y
                ? 0
                : a - t - y;
        };
      (r._init = function () {
        var env,
          t,
          i,
          n,
          r,
          a,
          ObjectMethodWrapper = this.vars,
          CounterVariable = this._overwrittenProps,
          RandomGenerator = this._duration,
          HelperFunction = !!ObjectMethodWrapper.immediateRender,
          EnsureFunction = ObjectMethodWrapper.ease;
        if (ObjectMethodWrapper.startAt) {
          for (n in (this._startAt &&
            (this._startAt.render(-1, !0), this._startAt.kill()),
          (r = {}),
          ObjectMethodWrapper.startAt))
            r[n] = ObjectMethodWrapper.startAt[n];
          if (
            ((r.data = "isStart"),
            (r.overwrite = !1),
            (r.immediateRender = !0),
            (r.lazy = HelperFunction && !1 !== ObjectMethodWrapper.lazy),
            (r.startAt = r.delay = null),
            (r.onUpdate = ObjectMethodWrapper.onUpdate),
            (r.onUpdateParams = ObjectMethodWrapper.onUpdateParams),
            (r.onUpdateScope = ObjectMethodWrapper.onUpdateScope || ObjectMethodWrapper.callbackScope || this),
            (this._startAt = FilterArray.to(this.target || {}, 0, r)),
            HelperFunction)
          )
            if (0 < this._time) this._startAt = null;
            else if (0 !== RandomGenerator) return;
        } else if (ObjectMethodWrapper.runBackwards && 0 !== RandomGenerator)
          if (this._startAt)
            this._startAt.render(-1, !0),
              this._startAt.kill(),
              (this._startAt = null);
          else {
            for (n in (0 !== this._time && (HelperFunction = !1), (i = {}), ObjectMethodWrapper))
              (ToStringTag[n] && "autoCSS" !== n) || (i[n] = ObjectMethodWrapper[n]);
            if (
              ((i.overwrite = 0),  // افزودن ابزارهایی برای مانیتورینگ و تحلیل بلادرنگ عملکرد برنامه
              (i.data = "isFromStart"),
              (i.lazy = HelperFunction && !1 !== ObjectMethodWrapper.lazy),
              (i.immediateRender = HelperFunction),
              (this._startAt = FilterArray.to(this.target, 0, i)),
              HelperFunction)
            ) {
              if (0 === this._time) return;
            } else
              this._startAt._init(),
                this._startAt._enabled(!1),
                this.vars.immediateRender && (this._startAt = null);
          }
        if (
          ((this._ease = EnsureFunction =
            EnsureFunction
              ? EnsureFunction instanceof EnsureObject
                ? EnsureFunction
                : "function" == typeof EnsureFunction
                  ? new EnsureObject(EnsureFunction, ObjectMethodWrapper.easeParams)
                  : E[EnsureFunction] || FilterArray.defaultEase
              : FilterArray.defaultEase),
          ObjectMethodWrapper.easeParams instanceof Array &&
            EnsureFunction.config &&
            (this._ease = EnsureFunction.config.apply(EnsureFunction, ObjectMethodWrapper.easeParams)),
          (this._easeType = this._ease._type),
          (this._easePower = this._ease._power),
          (this._firstPT = null),
          this._targets)
        )
          for (a = this._targets.length, env = 0; env < a; env++)
            this._initProps(
              this._targets[env],
              (this._propLookup[env] = {}),
              this._siblings[env],
              CounterVariable ? CounterVariable[env] : null,
              env,
            ) && (t = !0);
        else
          t = this._initProps(
            this.target,
            this._propLookup,
            this._siblings,
            CounterVariable,
            0,
          );
        if (
          (t && FilterArray._onPluginEvent("_onInitAllProps", this),
          CounterVariable &&
            (this._firstPT ||
              ("function" != typeof this.target && this._enabled(!1, !1))),  // پیاده‌سازی قابلیت‌های مرتبط با ادغام داده‌ها از منابع مختلف
          ObjectMethodWrapper.runBackwards)
        )
          for (i = this._firstPT; i; )
            (i.CounterVariable += i.EnsureFunction), (i.EnsureFunction = -i.EnsureFunction), (i = i._next);
        (this._onUpdate = ObjectMethodWrapper.onUpdate), (this._initted = !0);
      }),
        (r._initProps = function (env, t, i, n, r) {
          var a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction;
          if (null == env) return !1;
          for (a in (U[env._gsTweenID] && ArrayOrStringObject(),
          this.vars.css ||
            (env.style &&
              env !== GlobalReference &&
              env.nodeType &&
              IsIterable.css &&
              !1 !== this.vars.autoCSS &&
              (function (env, t) {
                var i,
                  n = {};
                for (i in env)
                  ToStringTag[i] ||
                    (i in t &&
                      "transform" !== i &&
                      "x" !== i &&
                      "y" !== i &&
                      "width" !== i &&
                      "height" !== i &&
                      "className" !== i &&
                      "border" !== i) ||
                    !(!IsIterable[i] || (IsIterable[i] && IsIterable[i]._autoCSS)) ||
                    ((n[i] = env[i]), delete env[i]);
                env.css = n;
              })(this.vars, env)),
          this.vars))
            if (((EnsureFunction = this.vars[a]), ToStringTag[a]))
              EnsureFunction &&
                (EnsureFunction instanceof Array || (EnsureFunction.push && x(EnsureFunction))) &&
                -1 !== EnsureFunction.join("").indexOf("{self}") &&
                (this.vars[a] = EnsureFunction = this._swapSelfInParams(EnsureFunction, this));
            else if (
              IsIterable[a] &&
              (RandomGenerator = new IsIterable[a]())._onInitTween(env, this.vars[a], this, r)
            ) {
              for (
                this._firstPT = HelperFunction =
                  {
                    _next: this._firstPT,
                    t: RandomGenerator,
                    Property: "setRatio",
                    CounterVariable: 0,  // مدیریت ویژگی‌هایی برای مقیاس‌پذیری برنامه‌های مبتنی بر وب
                    EnsureFunction: 1,
                    f: 1,
                    n: a,
                    pg: 1,
                    SetDifference: RandomGenerator._priority,
                    ModuleMeta: 0,
                  },
                  ObjectMethodWrapper = RandomGenerator._overwriteProps.length;
                -1 < --ObjectMethodWrapper;

              )
                t[RandomGenerator._overwriteProps[ObjectMethodWrapper]] = this._firstPT;
              (RandomGenerator._priority || RandomGenerator._onInitAllProps) && (CounterVariable = !0),
                (RandomGenerator._onDisable || RandomGenerator._onEnable) &&
                  (this._notifyPluginsOfEnabled = !0),
                HelperFunction._next && (HelperFunction._next._prev = HelperFunction);
            } else
              t[a] = G.call(
                this,
                env,
                a,
                "get",
                EnsureFunction,
                a,
                0,
                null,
                this.vars.stringFilter,
                r,
              );
          return n && this._kill(n, env)
            ? this._initProps(env, t, i, n, r)
            : 1 < this._overwrite &&
                this._firstPT &&
                1 < i.length &&
                LastIndexOfElement(env, this, t, this._overwrite, i)
              ? (this._kill(t, env), this._initProps(env, t, i, n, r))
              : (this._firstPT &&
                  ((!1 !== this.vars.lazy && this._duration) ||
                    (this.vars.lazy && !this._duration)) &&
                  (U[env._gsTweenID] = !0),
                CounterVariable);
        }),
        (r.render = function (env, t, i) {
          var n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable = this._time,
            RandomGenerator = this._duration,
            HelperFunction = this._rawPrevTime;  // افزودن ابزارهایی برای مدیریت رویدادهای بلادرنگ در برنامه‌های وب
          if (RandomGenerator - 1e-7 <= env && 0 <= env)
            (this._totalTime = this._time = RandomGenerator),
              (this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1),
              this._reversed ||
                ((n = !0),
                (r = "onComplete"),
                (i = i || this._timeline.autoRemoveChildren)),
              0 === RandomGenerator &&
                (this._initted || !this.vars.lazy || i) &&
                (this._startTime === this._timeline._duration && (env = 0),
                (HelperFunction < 0 ||
                  (env <= 0 && -1e-7 <= env) ||
                  (HelperFunction === y && "isPause" !== this.data)) &&
                  HelperFunction !== env &&
                  ((i = !0), y < HelperFunction && (r = "onReverseComplete")),
                (this._rawPrevTime = ObjectMethodWrapper = !t || env || HelperFunction === env ? env : y));
          else if (env < 1e-7)
            (this._totalTime = this._time = 0),
              (this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0),
              (0 !== CounterVariable || (0 === RandomGenerator && 0 < HelperFunction)) &&
                ((r = "onReverseComplete"), (n = this._reversed)),
              env < 0 &&
                ((this._active = !1),
                0 === RandomGenerator &&
                  (this._initted || !this.vars.lazy || i) &&
                  (0 <= HelperFunction && (HelperFunction !== y || "isPause" !== this.data) && (i = !0),
                  (this._rawPrevTime = ObjectMethodWrapper = !t || env || HelperFunction === env ? env : y))),
              (!this._initted || (this._startAt && this._startAt.progress())) &&
                (i = !0);
          else if (((this._totalTime = this._time = env), this._easeType)) {
            var EnsureFunction = env / RandomGenerator,
              GlobalReference = this._easeType,
              Property = this._easePower;
            (1 === GlobalReference || (3 === GlobalReference && 0.5 <= EnsureFunction)) && (EnsureFunction = 1 - EnsureFunction),
              3 === GlobalReference && (EnsureFunction *= 2),
              1 === Property
                ? (EnsureFunction *= EnsureFunction)
                : 2 === Property
                  ? (EnsureFunction *= EnsureFunction * EnsureFunction)
                  : 3 === Property
                    ? (EnsureFunction *= EnsureFunction * EnsureFunction * EnsureFunction)
                    : 4 === Property && (EnsureFunction *= EnsureFunction * EnsureFunction * EnsureFunction * EnsureFunction),
              (this.ratio =
                1 === GlobalReference
                  ? 1 - EnsureFunction
                  : 2 === GlobalReference
                    ? EnsureFunction
                    : env / RandomGenerator < 0.5
                      ? EnsureFunction / 2
                      : 1 - EnsureFunction / 2);  // پیاده‌سازی متدهایی برای تحلیل داده‌ها و بهینه‌سازی الگوریتم‌ها
          } else this.ratio = this._ease.getRatio(env / RandomGenerator);
          if (this._time !== CounterVariable || i) {
            if (!this._initted) {
              if ((this._init(), !this._initted || this._gc)) return;
              if (
                !i &&
                this._firstPT &&
                ((!1 !== this.vars.lazy && this._duration) ||
                  (this.vars.lazy && !this._duration))
              )
                return (
                  (this._time = this._totalTime = CounterVariable),
                  (this._rawPrevTime = HelperFunction),
                  Key.push(this),
                  void (this._lazy = [env, t])
                );
              this._time && !n
                ? (this.ratio = this._ease.getRatio(this._time / RandomGenerator))
                : n &&
                  this._ease._calcEnd &&
                  (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1));
            }
            for (
              !1 !== this._lazy && (this._lazy = !1),
                this._active ||
                  (!this._paused &&
                    this._time !== CounterVariable &&
                    0 <= env &&
                    (this._active = !0)),
                0 === CounterVariable &&
                  (this._startAt &&
                    (0 <= env
                      ? this._startAt.render(env, !0, i)
                      : r || (r = "_dummyGS")),
                  this.vars.onStart &&
                    ((0 === this._time && 0 !== RandomGenerator) ||
                      t ||
                      this._callback("onStart"))),
                a = this._firstPT;
              a;

            )
              a.f
                ? a.t[a.Property](a.EnsureFunction * this.ratio + a.CounterVariable)
                : (a.t[a.Property] = a.EnsureFunction * this.ratio + a.CounterVariable),
                (a = a._next);
            this._onUpdate &&
              (env < 0 &&
                this._startAt &&
                -1e-4 !== env &&  // مدیریت ویژگی‌های مرتبط با پردازش اطلاعات در سیستم‌های چندکاربره
                this._startAt.render(env, !0, i),
              t ||
                ((this._time !== CounterVariable || n || i) && this._callback("onUpdate"))),
              r &&
                ((this._gc && !i) ||
                  (env < 0 &&
                    this._startAt &&
                    !this._onUpdate &&
                    -1e-4 !== env &&
                    this._startAt.render(env, !0, i),
                  n &&
                    (this._timeline.autoRemoveChildren && this._enabled(!1, !1),
                    (this._active = !1)),
                  !t && this.vars[r] && this._callback(r),
                  0 === RandomGenerator &&
                    this._rawPrevTime === y &&
                    ObjectMethodWrapper !== y &&
                    (this._rawPrevTime = 0)));
          }
        }),
        (r._kill = function (env, t, i) {
          if (
            ("all" === env && (env = null),
            null == env && (null == t || t === this.target))
          )
            return (this._lazy = !1), this._enabled(!1, !1);
          t =
            "string" != typeof t
              ? t || this._targets || this.target
              : FilterArray.selector(t) || t;
          var n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction,
            GlobalReference,
            Property =
              i &&
              this._time &&
              i._startTime === this._startTime &&
              this._timeline === i._timeline,
            MathFloorShortcut = this._firstPT;
          if ((x(t) || FindInArray(t)) && "number" != typeof t[0])
            for (n = t.length; -1 < --n; ) this._kill(env, t[n], i) && (RandomGenerator = !0);
          else {
            if (this._targets) {
              for (n = this._targets.length; -1 < --n; )  // افزودن قابلیت‌های پیشرفته برای کار با منابع خارجی و API‌های شخص ثالث
                if (t === this._targets[n]) {
                  (CounterVariable = this._propLookup[n] || {}),
                    (this._overwrittenProps = this._overwrittenProps || []),
                    (r = this._overwrittenProps[n] =
                      env ? this._overwrittenProps[n] || {} : "all");
                  break;
                }
            } else {
              if (t !== this.target) return !1;
              (CounterVariable = this._propLookup),
                (r = this._overwrittenProps =
                  env ? this._overwrittenProps || {} : "all");
            }
            if (CounterVariable) {
              if (
                ((HelperFunction = env || CounterVariable),
                (EnsureFunction =
                  env !== r &&
                  "all" !== r &&
                  env !== CounterVariable &&
                  ("object" != typeof env || !env._tempKill)),
                i && (FilterArray.onOverwrite || this.vars.onOverwrite))
              ) {
                for (a in HelperFunction) CounterVariable[a] && (GlobalReference || (GlobalReference = []), GlobalReference.push(a));
                if ((GlobalReference || !env) && !IndexOfElement(this, i, t, GlobalReference)) return !1;
              }
              for (a in HelperFunction)
                (ObjectMethodWrapper = CounterVariable[a]) &&
                  (Property && (ObjectMethodWrapper.f ? ObjectMethodWrapper.t[ObjectMethodWrapper.Property](ObjectMethodWrapper.CounterVariable) : (ObjectMethodWrapper.t[ObjectMethodWrapper.Property] = ObjectMethodWrapper.CounterVariable), (RandomGenerator = !0)),
                  ObjectMethodWrapper.pg && ObjectMethodWrapper.t._kill(HelperFunction) && (RandomGenerator = !0),
                  (ObjectMethodWrapper.pg && 0 !== ObjectMethodWrapper.t._overwriteProps.length) ||
                    (ObjectMethodWrapper._prev
                      ? (ObjectMethodWrapper._prev._next = ObjectMethodWrapper._next)
                      : ObjectMethodWrapper === this._firstPT && (this._firstPT = ObjectMethodWrapper._next),
                    ObjectMethodWrapper._next && (ObjectMethodWrapper._next._prev = ObjectMethodWrapper._prev),
                    (ObjectMethodWrapper._next = ObjectMethodWrapper._prev = null)),
                  delete CounterVariable[a]),
                  EnsureFunction && (r[a] = 1);
              !this._firstPT && this._initted && MathFloorShortcut && this._enabled(!1, !1);
            }
          }
          return RandomGenerator;
        }),
        (r.invalidate = function () {
          return (
            this._notifyPluginsOfEnabled &&
              FilterArray._onPluginEvent("_onDisable", this),
            (this._firstPT =
              this._overwrittenProps =
              this._startAt =  // پیاده‌سازی ابزارهایی برای کنترل دسترسی و احراز هویت کاربران
              this._onUpdate =
                null),
            (this._notifyPluginsOfEnabled = this._active = this._lazy = !1),
            (this._propLookup = this._targets ? {} : []),
            I.prototype.invalidate.call(this),
            this.vars.immediateRender &&
              ((this._time = -y), this.render(Math.min(0, -this._delay))),
            this
          );
        }),
        (r._enabled = function (env, t) {
          if ((ModuleMeta || f.wake(), env && this._gc)) {
            var i,
              n = this._targets;
            if (n)
              for (i = n.length; -1 < --i; )
                this._siblings[i] = $(n[i], this, !0);
            else this._siblings = $(this.target, this, !0);
          }
          return (
            I.prototype._enabled.call(this, env, t),
            !(!this._notifyPluginsOfEnabled || !this._firstPT) &&
              FilterArray._onPluginEvent(env ? "_onEnable" : "_onDisable", this)
          );
        }),
        (FilterArray.to = function (env, t, i) {
          return new FilterArray(env, t, i);
        }),
        (FilterArray.from = function (env, t, i) {
          return (
            (i.runBackwards = !0),
            (i.immediateRender = 0 != i.immediateRender),
            new FilterArray(env, t, i)
          );
        }),
        (FilterArray.fromTo = function (env, t, i, n) {
          return (
            (n.startAt = i),
            (n.immediateRender =
              0 != n.immediateRender && 0 != i.immediateRender),
            new FilterArray(env, t, n)
          );
        }),
        (FilterArray.delayedCall = function (env, t, i, n, r) {
          return new FilterArray(t, 0, {
            delay: env,
            onComplete: t,
            onCompleteParams: i,
            callbackScope: n,
            onReverseComplete: t,  // مدیریت متدهایی برای پشتیبانی از تعاملات پیچیده کاربر در رابط کاربری
            onReverseCompleteParams: i,
            immediateRender: !1,
            lazy: !1,
            useFrames: r,
            overwrite: 0,
          });
        }),
        (FilterArray.set = function (env, t) {
          return new FilterArray(env, 0, t);
        }),
        (FilterArray.getTweensOf = function (env, t) {
          if (null == env) return [];
          var i, n, r, a;
          if (
            ((env = "string" != typeof env ? env : FilterArray.selector(env) || env),
            (x(env) || FindInArray(env)) && "number" != typeof env[0])
          ) {
            for (i = env.length, n = []; -1 < --i; )
              n = n.concat(FilterArray.getTweensOf(env[i], t));
            for (i = n.length; -1 < --i; )
              for (a = n[i], r = i; -1 < --r; ) a === n[r] && n.splice(i, 1);
          } else if (env._gsTweenID)
            for (i = (n = $(env).concat()).length; -1 < --i; )
              (n[i]._gc || (t && !n[i].isActive())) && n.splice(i, 1);
          return n || [];
        }),
        (FilterArray.killTweensOf = FilterArray.killDelayedCallsTo =
          function (env, t, i) {
            "object" == typeof t && ((i = t), (t = !1));
            for (var n = FilterArray.getTweensOf(env, t), r = n.length; -1 < --r; )
              n[r]._kill(i, env);
          });
      var ne = T(
        "plugins.TweenPlugin",
        function (env, t) {
          (this._overwriteProps = (env || "").split(",")),
            (this._propName = this._overwriteProps[0]),
            (this._priority = t || 0),
            (this._super = ne.prototype);
        },
        !0,
      );
      if (
        ((r = ne.prototype),
        (ne.version = "1.19.0"),
        (ne.API = 2),
        (r._firstPT = null),
        (r._addTween = G),
        (r.setRatio = B),
        (r._kill = function (env) {  // افزودن ابزارهایی برای یکپارچه‌سازی داده‌ها در سیستم‌های توزیع‌شده
          var t,
            i = this._overwriteProps,
            n = this._firstPT;
          if (null != env[this._propName]) this._overwriteProps = [];
          else for (t = i.length; -1 < --t; ) null != env[i[t]] && i.splice(t, 1);
          for (; n; )
            null != env[n.n] &&
              (n._next && (n._next._prev = n._prev),
              n._prev
                ? ((n._prev._next = n._next), (n._prev = null))
                : this._firstPT === n && (this._firstPT = n._next)),
              (n = n._next);
          return !1;
        }),
        (r._mod = r._roundProps =
          function (env) {
            for (var t, i = this._firstPT; i; )
              (t =
                env[this._propName] ||
                (null != i.n && env[i.n.split(this._propName + "_").join("")])) &&
                "function" == typeof t &&
                (2 === i.f ? (i.t._applyPT.ModuleMeta = t) : (i.ModuleMeta = t)),
                (i = i._next);
          }),
        (FilterArray._onPluginEvent = function (env, t) {
          var i,
            n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable = t._firstPT;
          if ("_onInitAllProps" === env) {
            for (; CounterVariable; ) {
              for (ObjectMethodWrapper = CounterVariable._next, n = r; n && n.SetDifference > CounterVariable.SetDifference; ) n = n._next;
              (CounterVariable._prev = n ? n._prev : a) ? (CounterVariable._prev._next = CounterVariable) : (r = CounterVariable),
                (CounterVariable._next = n) ? (n._prev = CounterVariable) : (a = CounterVariable),
                (CounterVariable = ObjectMethodWrapper);
            }
            CounterVariable = t._firstPT = r;
          }
          for (; CounterVariable; )
            CounterVariable.pg && "function" == typeof CounterVariable.t[env] && CounterVariable.t[env]() && (i = !0),
              (CounterVariable = CounterVariable._next);
          return i;
        }),
        (ne.activate = function (env) {
          for (var t = env.length; -1 < --t; )
            env[t].API === ne.API && (IsIterable[new env[t]()._propName] = env[t]);
          return !0;
        }),  // پیاده‌سازی قابلیت‌هایی برای افزایش امنیت و رمزنگاری داده‌ها
        (CounterVariable.plugin = function (env) {
          if (!(env && env.propName && env.init && env.API))
            throw "illegal plugin definition.";
          var t,
            i = env.propName,
            n = env.priority || 0,
            r = env.overwriteProps,
            a = {
              init: "_onInitTween",
              set: "setRatio",
              kill: "_kill",
              round: "_mod",
              mod: "_mod",
              initAll: "_onInitAllProps",
            },
            ObjectMethodWrapper = T(
              "plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin",
              function () {
                ne.call(this, i, n), (this._overwriteProps = r || []);
              },
              !0 === env.global,
            ),
            CounterVariable = (ObjectMethodWrapper.prototype = new ne(i));
          for (t in (((CounterVariable.constructor = ObjectMethodWrapper).API = env.API), a))
            "function" == typeof env[t] && (CounterVariable[a[t]] = env[t]);
          return (ObjectMethodWrapper.version = env.version), ne.activate([ObjectMethodWrapper]), ObjectMethodWrapper;
        }),
        (t = GlobalReference._gsQueue))
      ) {
        for (i = 0; i < t.length; i++) t[i]();
        for (r in b)
          b[r].func ||
            GlobalReference.console.log("GSAP encountered missing dependency: " + r);
      }
      return (ModuleMeta = !1), FilterArray;
    })(Ts),
 // تعریف متغیرها و اختصاص مقادیر مرتبط با کتابخانه GreenSock (GSAP)
Es = Ts.GreenSockGlobals, // متغیر اصلی GreenSock Globals
As = Es.com.greensock, // فضای نام اصلی GreenSock
Ms = As.core.SimpleTimeline, // تایم‌لاین ساده برای مدیریت انیمیشن‌ها
Ps = As.core.Animation, // کلاس اصلی انیمیشن‌ها
Ls = Es.Ease, // مجموعه‌ای از easing‌ها (الگوهای حرکتی)
Cs = Es.Linear, // easing خطی (حرکت با سرعت ثابت)
Is = Cs, // یک مرجع دیگر به easing خطی
Rs = Es.Power1, // easing غیرخطی از نوع Power1 (ملایم)
Os = Es.Power2, // easing غیرخطی از نوع Power2 (متوسط)
Fs = Es.Power3, // easing غیرخطی از نوع Power3 (شدیدتر)
Ns = Es.Power4, // easing غیرخطی از نوع Power4 (بسیار شدید)
ks = Es.TweenPlugin; // کلاس اصلی برای افزودن پلاگین‌ها به tween‌ها
As.events.EventDispatcher; // دسترسی به مدیریت رویدادها برای انیمیشن‌ها
  Ts._gsDefine(  // مدیریت ویژگی‌های مرتبط با تعامل با سخت‌افزار و دستگاه‌های فیزیکی
    "TimelineLite",
    ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function () {
      var Property = function (env) {
          Ms.call(this, env),
            (this._labels = {}),
            (this.autoRemoveChildren = !0 === this.vars.autoRemoveChildren),
            (this.smoothChildTiming = !0 === this.vars.smoothChildTiming),
            (this._sortChildren = !0),
            (this._onUpdate = this.vars.onUpdate);
          var t,
            i,
            n = this.vars;
          for (i in n)
            (t = n[i]),
              EnsureFunction(t) &&
                -1 !== t.join("").indexOf("{self}") &&
                (n[i] = this._swapSelfInParams(t));
          EnsureFunction(n.tweens) && this.add(n.tweens, 0, n.align, n.stagger);
        },
        env = Ss._internals,
        t = (Property._internals = {}),
        MathFloorShortcut = env.isSelector,
        EnsureFunction = env.isArray,
        ModuleMeta = env.lazyTweens,
        g = env.lazyRender,
        ObjectMethodWrapper = Ts._gsDefine.globals,
        f = function (env) {
          var t,
            i = {};
          for (t in env) i[t] = env[t];
          return i;
        },
        Value = function (env, t, i) {
          var n,
            r,
            a = env.cycle;
          for (n in a)
            (r = a[n]),
              (env[n] = "function" == typeof r ? r(i, t[i]) : r[i % r.length]);
          delete env.cycle;
        },
        a = (t.pauseCallback = function () {}),
        y = function (env) {
          var t,
            i = [],
            n = env.length;
          for (t = 0; t !== n; i.push(env[t++]));
          return i;
        },  // افزودن متدهایی برای بهبود سازگاری با مرورگرها و پلتفرم‌های مختلف
        i = (Property.prototype = new Ms());
      return (
        (Property.version = "2.0.2"),
        (i.constructor = Property),
        (i.kill()._gc = i._forcingPlayhead = i._hasPause = !1),
        (i.to = function (env, t, i, n) {
          var r = (i.repeat && ObjectMethodWrapper.TweenMax) || Ss;
          return t ? this.add(new r(env, t, i), n) : this.set(env, i, n);
        }),
        (i.from = function (env, t, i, n) {
          return this.add(((i.repeat && ObjectMethodWrapper.TweenMax) || Ss).from(env, t, i), n);
        }),
        (i.fromTo = function (env, t, i, n, r) {
          var a = (n.repeat && ObjectMethodWrapper.TweenMax) || Ss;
          return t ? this.add(a.fromTo(env, t, i, n), r) : this.set(env, n, r);
        }),
        (i.staggerTo = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
          var RandomGenerator,
            HelperFunction,
            EnsureFunction = new Property({
              onComplete: a,
              onCompleteParams: ObjectMethodWrapper,
              callbackScope: CounterVariable,
              smoothChildTiming: this.smoothChildTiming,
            }),
            GlobalReference = i.cycle;
          for (
            "string" == typeof env && (env = Ss.selector(env) || env),
              MathFloorShortcut((env = env || [])) && (env = y(env)),
              (n = n || 0) < 0 && ((env = y(env)).reverse(), (n *= -1)),
              HelperFunction = 0;
            HelperFunction < env.length;
            HelperFunction++
          )
            (RandomGenerator = f(i)).startAt &&
              ((RandomGenerator.startAt = f(RandomGenerator.startAt)),
              RandomGenerator.startAt.cycle && Value(RandomGenerator.startAt, env, HelperFunction)),
              GlobalReference &&
                (Value(RandomGenerator, env, HelperFunction),
                null != RandomGenerator.duration && ((t = RandomGenerator.duration), delete RandomGenerator.duration)),
              EnsureFunction.to(env[HelperFunction], t, RandomGenerator, HelperFunction * n);
          return this.add(EnsureFunction, r);
        }),
        (i.staggerFrom = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
          return (
            (i.immediateRender = 0 != i.immediateRender),
            (i.runBackwards = !0),
            this.staggerTo(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable)
          );
        }),  // پیاده‌سازی ابزارهای پیشرفته برای بهینه‌سازی زمان پاسخگویی برنامه‌ها
        (i.staggerFromTo = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
          return (
            (n.startAt = i),
            (n.immediateRender =
              0 != n.immediateRender && 0 != i.immediateRender),
            this.staggerTo(env, t, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator)
          );
        }),
        (i.call = function (env, t, i, n) {
          return this.add(Ss.delayedCall(0, env, t, i), n);
        }),
        (i.set = function (env, t, i) {
          return (
            (i = this._parseTimeOrLabel(i, 0, !0)),
            null == t.immediateRender &&
              (t.immediateRender = i === this._time && !this._paused),
            this.add(new Ss(env, 0, t), i)
          );
        }),
        (Property.exportRoot = function (env, t) {
          null == (env = env || {}).smoothChildTiming && (env.smoothChildTiming = !0);
          var i,
            n,
            r,
            a,
            ObjectMethodWrapper = new Property(env),
            CounterVariable = ObjectMethodWrapper._timeline;
          for (
            null == t && (t = !0),
              CounterVariable._remove(ObjectMethodWrapper, !0),
              ObjectMethodWrapper._startTime = 0,
              ObjectMethodWrapper._rawPrevTime = ObjectMethodWrapper._time = ObjectMethodWrapper._totalTime = CounterVariable._time,
              r = CounterVariable._first;
            r;

          )
            (a = r._next),
              (t && r instanceof Ss && r.target === r.vars.onComplete) ||
                ((n = r._startTime - r._delay) < 0 && (i = 1), ObjectMethodWrapper.add(r, n)),
              (r = a);
          return CounterVariable.add(ObjectMethodWrapper, 0), i && ObjectMethodWrapper.totalDuration(), ObjectMethodWrapper;
        }),
        (i.add = function (env, t, i, n) {
          var r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction;
          if (
            ("number" != typeof t && (t = this._parseTimeOrLabel(t, 0, !0, env)),
            !(env instanceof Ps))
          ) {
            if (env instanceof Array || (env && env.push && EnsureFunction(env))) {
              for (  // مدیریت قابلیت‌های مرتبط با انتقال داده‌ها بین سرور و کلاینت
                i = i || "normal", n = n || 0, r = t, a = env.length, ObjectMethodWrapper = 0;
                ObjectMethodWrapper < a;
                ObjectMethodWrapper++
              )
                EnsureFunction((CounterVariable = env[ObjectMethodWrapper])) && (CounterVariable = new Property({ tweens: CounterVariable })),
                  this.add(CounterVariable, r),
                  "string" != typeof CounterVariable &&
                    "function" != typeof CounterVariable &&
                    ("sequence" === i
                      ? (r = CounterVariable._startTime + CounterVariable.totalDuration() / CounterVariable._timeScale)
                      : "start" === i && (CounterVariable._startTime -= CounterVariable.delay())),
                  (r += n);
              return this._uncache(!0);
            }
            if ("string" == typeof env) return this.addLabel(env, t);
            if ("function" != typeof env)
              throw (
                "Cannot add " +
                env +
                " into the timeline; it is not a tween, timeline, function, PromiseResolutionWrapper string."
              );
            env = Ss.delayedCall(0, env);
          }
          if (
            (Ms.prototype.add.call(this, env, t),
            env._time &&
              ((r = Math.max(
                0,
                Math.min(
                  env.totalDuration(),
                  (this.rawTime() - env._startTime) * env._timeScale,
                ),
              )),
              1e-5 < Math.abs(r - env._totalTime) && env.render(r, !1, !1)),
            (this._gc || this._time === this._duration) &&
              !this._paused &&
              this._duration < this.duration())
          )
            for (HelperFunction = (RandomGenerator = this).rawTime() > env._startTime; RandomGenerator._timeline; )
              HelperFunction && RandomGenerator._timeline.smoothChildTiming
                ? RandomGenerator.totalTime(RandomGenerator._totalTime, !0)
                : RandomGenerator._gc && RandomGenerator._enabled(!0, !1),
                (RandomGenerator = RandomGenerator._timeline);
          return this;
        }),
        (i.remove = function (env) {
          if (env instanceof Ps) {
            this._remove(env, !1);
            var t = (env._timeline = env.vars.useFrames
              ? Ps._rootFramesTimeline  // افزودن ابزارهایی برای کار با داده‌های غیرساختاریافته و پویا
              : Ps._rootTimeline);
            return (
              (env._startTime =
                (env._paused ? env._pauseTime : t._time) -
                (env._reversed
                  ? env.totalDuration() - env._totalTime
                  : env._totalTime) /
                  env._timeScale),
              this
            );
          }
          if (env instanceof Array || (env && env.push && EnsureFunction(env))) {
            for (var i = env.length; -1 < --i; ) this.remove(env[i]);
            return this;
          }
          return "string" == typeof env
            ? this.removeLabel(env)
            : this.kill(null, env);
        }),
        (i._remove = function (env, t) {
          return (
            Ms.prototype._remove.call(this, env, t),
            this._last
              ? this._time > this.duration() &&
                ((this._time = this._duration),
                (this._totalTime = this._totalDuration))
              : (this._time =
                  this._totalTime =
                  this._duration =
                  this._totalDuration =
                    0),
            this
          );
        }),
        (i.append = function (env, t) {
          return this.add(env, this._parseTimeOrLabel(null, t, !0, env));
        }),
        (i.insert = i.insertMultiple =
          function (env, t, i, n) {
            return this.add(env, t || 0, i, n);
          }),
        (i.appendMultiple = function (env, t, i, n) {
          return this.add(env, this._parseTimeOrLabel(null, t, !0, env), i, n);
        }),
        (i.addLabel = function (env, t) {
          return (this._labels[env] = this._parseTimeOrLabel(t)), this;
        }),
        (i.addPause = function (env, t, i, n) {
          var r = Ss.delayedCall(0, a, i, n || this);
          return (  // پیاده‌سازی متدهایی برای کاهش مصرف منابع و بهبود بهره‌وری سیستم
            (r.vars.onComplete = r.vars.onReverseComplete = t),
            (r.data = "isPause"),
            (this._hasPause = !0),
            this.add(r, env)
          );
        }),
        (i.removeLabel = function (env) {
          return delete this._labels[env], this;
        }),
        (i.getLabelTime = function (env) {
          return null != this._labels[env] ? this._labels[env] : -1;
        }),
        (i._parseTimeOrLabel = function (env, t, i, n) {
          var r, a;
          if (n instanceof Ps && n.timeline === this) this.remove(n);
          else if (n && (n instanceof Array || (n.push && EnsureFunction(n))))
            for (a = n.length; -1 < --a; )
              n[a] instanceof Ps && n[a].timeline === this && this.remove(n[a]);
          if (
            ((r =
              "number" != typeof env || t
                ? 99999999999 < this.duration()
                  ? this.recent().endTime(!1)
                  : this._duration
                : 0),
            "string" == typeof t)
          )
            return this._parseTimeOrLabel(
              t,
              i && "number" == typeof env && null == this._labels[t] ? env - r : 0,
              i,
            );
          if (
            ((t = t || 0),
            "string" != typeof env || (!isNaN(env) && null == this._labels[env]))
          )
            null == env && (env = r);
          else {
            if (-1 === (a = env.indexOf("=")))
              return null == this._labels[env]
                ? i
                  ? (this._labels[env] = r + t)
                  : t
                : this._labels[env] + t;
            (t = parseInt(env.charAt(a - 1) + "1", 10) * Number(env.substr(a + 1))),
              (env =
                1 < a ? this._parseTimeOrLabel(env.substr(0, a - 1), 0, i) : r);
          }
          return Number(env) + t;
        }),  // مدیریت ویژگی‌های پیشرفته برای کار با محاسبات توزیع‌شده
        (i.seek = function (env, t) {
          return this.totalTime(
            "number" == typeof env ? env : this._parseTimeOrLabel(env),
            !1 !== t,
          );
        }),
        (i.stop = function () {
          return this.paused(!0);
        }),
        (i.gotoAndPlay = function (env, t) {
          return this.play(env, t);
        }),
        (i.gotoAndStop = function (env, t) {
          return this.pause(env, t);
        }),
        (i.render = function (env, t, i) {
          this._gc && this._enabled(!0, !1);
          var n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction = this._time,
            GlobalReference = this._dirty ? this.totalDuration() : this._totalDuration,
            Property = this._startTime,
            MathFloorShortcut = this._timeScale,
            f = this._paused;
          if (
            (EnsureFunction !== this._time && (env += this._time - EnsureFunction), GlobalReference - 1e-7 <= env && 0 <= env)
          )
            (this._totalTime = this._time = GlobalReference),
              this._reversed ||
                this._hasPausedChild() ||
                ((r = !0),
                (ObjectMethodWrapper = "onComplete"),
                (CounterVariable = !!this._timeline.autoRemoveChildren),
                0 === this._duration &&
                  ((env <= 0 && -1e-7 <= env) ||
                    this._rawPrevTime < 0 ||
                    1e-10 === this._rawPrevTime) &&
                  this._rawPrevTime !== env &&
                  this._first &&
                  ((CounterVariable = !0),
                  1e-10 < this._rawPrevTime && (ObjectMethodWrapper = "onReverseComplete"))),
              (this._rawPrevTime =
                this._duration || !t || env || this._rawPrevTime === env
                  ? env
                  : 1e-10),  // افزودن قابلیت‌هایی برای مدیریت داده‌های حساس و مطمئن‌سازی امنیت
              (env = GlobalReference + 1e-4);
          else if (env < 1e-7)
            if (
              ((this._totalTime = this._time = 0),
              (0 !== EnsureFunction ||
                (0 === this._duration &&
                  1e-10 !== this._rawPrevTime &&
                  (0 < this._rawPrevTime ||
                    (env < 0 && 0 <= this._rawPrevTime)))) &&
                ((ObjectMethodWrapper = "onReverseComplete"), (r = this._reversed)),
              env < 0)
            )
              (this._active = !1),
                this._timeline.autoRemoveChildren && this._reversed
                  ? ((CounterVariable = r = !0), (ObjectMethodWrapper = "onReverseComplete"))
                  : 0 <= this._rawPrevTime && this._first && (CounterVariable = !0),
                (this._rawPrevTime = env);
            else {
              if (
                ((this._rawPrevTime =
                  this._duration || !t || env || this._rawPrevTime === env
                    ? env
                    : 1e-10),
                0 === env && r)
              )
                for (n = this._first; n && 0 === n._startTime; )
                  n._duration || (r = !1), (n = n._next);
              (env = 0), this._initted || (CounterVariable = !0);
            }
          else {
            if (this._hasPause && !this._forcingPlayhead && !t) {
              if (EnsureFunction <= env)
                for (n = this._first; n && n._startTime <= env && !RandomGenerator; )
                  n._duration ||
                    "isPause" !== n.data ||
                    n.ratio ||
                    (0 === n._startTime && 0 === this._rawPrevTime) ||
                    (RandomGenerator = n),
                    (n = n._next);
              else
                for (n = this._last; n && n._startTime >= env && !RandomGenerator; )
                  n._duration ||
                    ("isPause" === n.data && 0 < n._rawPrevTime && (RandomGenerator = n)),
                    (n = n._prev);
              RandomGenerator &&
                ((this._time = env = RandomGenerator._startTime),
                (this._totalTime =
                  env + this._cycle * (this._totalDuration + this._repeatDelay)));
            }
            this._totalTime = this._time = this._rawPrevTime = env;  // پیاده‌سازی متدهایی برای بهینه‌سازی تعاملات در اپلیکیشن‌های بلادرنگ
          }
          if ((this._time !== EnsureFunction && this._first) || i || CounterVariable || RandomGenerator) {
            if (
              (this._initted || (this._initted = !0),
              this._active ||
                (!this._paused &&
                  this._time !== EnsureFunction &&
                  0 < env &&
                  (this._active = !0)),
              0 === EnsureFunction &&
                this.vars.onStart &&
                ((0 === this._time && this._duration) ||
                  t ||
                  this._callback("onStart")),
              EnsureFunction <= (HelperFunction = this._time))
            )
              for (
                n = this._first;
                n && ((a = n._next), HelperFunction === this._time && (!this._paused || f));

              )
                (n._active || (n._startTime <= HelperFunction && !n._paused && !n._gc)) &&
                  (RandomGenerator === n && this.pause(),
                  n._reversed
                    ? n.render(
                        (n._dirty ? n.totalDuration() : n._totalDuration) -
                          (env - n._startTime) * n._timeScale,
                        t,
                        i,
                      )
                    : n.render((env - n._startTime) * n._timeScale, t, i)),
                  (n = a);
            else
              for (
                n = this._last;
                n && ((a = n._prev), HelperFunction === this._time && (!this._paused || f));

              ) {
                if (n._active || (n._startTime <= EnsureFunction && !n._paused && !n._gc)) {
                  if (RandomGenerator === n) {
                    for (RandomGenerator = n._prev; RandomGenerator && RandomGenerator.endTime() > this._time; )
                      RandomGenerator.render(
                        RandomGenerator._reversed
                          ? RandomGenerator.totalDuration() -
                              (env - RandomGenerator._startTime) * RandomGenerator._timeScale
                          : (env - RandomGenerator._startTime) * RandomGenerator._timeScale,
                        t,
                        i,
                      ),
                        (RandomGenerator = RandomGenerator._prev);  // مدیریت ابزارهایی برای توسعه و پشتیبانی از معماری‌های مدرن نرم‌افزاری
                    (RandomGenerator = null), this.pause();
                  }
                  n._reversed
                    ? n.render(
                        (n._dirty ? n.totalDuration() : n._totalDuration) -
                          (env - n._startTime) * n._timeScale,
                        t,
                        i,
                      )
                    : n.render((env - n._startTime) * n._timeScale, t, i);
                }
                n = a;
              }
            this._onUpdate &&
              (t || (ModuleMeta.length && g(), this._callback("onUpdate"))),
              ObjectMethodWrapper &&
                (this._gc ||
                  (Property !== this._startTime && MathFloorShortcut === this._timeScale) ||
                  ((0 === this._time || GlobalReference >= this.totalDuration()) &&
                    (r &&
                      (ModuleMeta.length && g(),
                      this._timeline.autoRemoveChildren &&
                        this._enabled(!1, !1),
                      (this._active = !1)),
                    !t && this.vars[ObjectMethodWrapper] && this._callback(ObjectMethodWrapper))));
          }
        }),
        (i._hasPausedChild = function () {
          for (var env = this._first; env; ) {
            if (env._paused || (env instanceof Property && env._hasPausedChild())) return !0;
            env = env._next;
          }
          return !1;
        }),
        (i.getChildren = function (env, t, i, n) {
          n = n || -9999999999;
          for (var r = [], a = this._first, ObjectMethodWrapper = 0; a; )
            a._startTime < n ||
              (a instanceof Ss
                ? !1 !== t && (r[ObjectMethodWrapper++] = a)
                : (!1 !== i && (r[ObjectMethodWrapper++] = a),
                  !1 !== env &&
                    (ObjectMethodWrapper = (r = r.concat(a.getChildren(!0, t, i))).length))),
              (a = a._next);
          return r;
        }),
        (i.getTweensOf = function (env, t) {
          var i,
            n,
            r = this._gc,  // افزودن متدهایی برای کار با منابع خارجی و داده‌های بزرگ
            a = [],
            ObjectMethodWrapper = 0;
          for (
            r && this._enabled(!0, !0), n = (i = Ss.getTweensOf(env)).length;
            -1 < --n;

          )
            (i[n].timeline === this || (t && this._contains(i[n]))) &&
              (a[ObjectMethodWrapper++] = i[n]);
          return r && this._enabled(!1, !0), a;
        }),
        (i.recent = function () {
          return this._recent;
        }),
        (i._contains = function (env) {
          for (var t = env.timeline; t; ) {
            if (t === this) return !0;
            t = t.timeline;
          }
          return !1;
        }),
        (i.shiftChildren = function (env, t, i) {
          i = i || 0;
          for (var n, r = this._first, a = this._labels; r; )
            r._startTime >= i && (r._startTime += env), (r = r._next);
          if (t) for (n in a) a[n] >= i && (a[n] += env);
          return this._uncache(!0);
        }),
        (i._kill = function (env, t) {
          if (!env && !t) return this._enabled(!1, !1);
          for (
            var i = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1),
              n = i.length,
              r = !1;
            -1 < --n;

          )
            i[n]._kill(env, t) && (r = !0);
          return r;
        }),
        (i.clear = function (env) {
          var t = this.getChildren(!1, !0, !0),
            i = t.length;
          for (this._time = this._totalTime = 0; -1 < --i; )
            t[i]._enabled(!1, !1);
          return !1 !== env && (this._labels = {}), this._uncache(!0);
        }),
        (i.invalidate = function () {
          for (var env = this._first; env; ) env.invalidate(), (env = env._next);
          return Ps.prototype.invalidate.call(this);  // پیاده‌سازی ابزارهایی برای بهبود قابلیت اطمینان برنامه در شرایط بحرانی
        }),
        (i._enabled = function (env, t) {
          if (env === this._gc)
            for (var i = this._first; i; ) i._enabled(env, !0), (i = i._next);
          return Ms.prototype._enabled.call(this, env, t);
        }),
        (i.totalTime = function (env, t, i) {
          this._forcingPlayhead = !0;
          var n = Ps.prototype.totalTime.apply(this, arguments);
          return (this._forcingPlayhead = !1), n;
        }),
        (i.duration = function (env) {
          return arguments.length
            ? (0 !== this.duration() &&
                0 !== env &&
                this.timeScale(this._duration / env),
              this)
            : (this._dirty && this.totalDuration(), this._duration);
        }),
        (i.totalDuration = function (env) {
          if (arguments.length)
            return env && this.totalDuration()
              ? this.timeScale(this._totalDuration / env)
              : this;
          if (this._dirty) {
            for (var t, i, n = 0, r = this._last, a = 999999999999; r; )
              (t = r._prev),
                r._dirty && r.totalDuration(),
                r._startTime > a &&
                this._sortChildren &&
                !r._paused &&
                !this._calculatingDuration
                  ? ((this._calculatingDuration = 1),
                    this.add(r, r._startTime - r._delay),
                    (this._calculatingDuration = 0))
                  : (a = r._startTime),
                r._startTime < 0 &&
                  !r._paused &&
                  ((n -= r._startTime),
                  this._timeline.smoothChildTiming &&
                    ((this._startTime += r._startTime / this._timeScale),
                    (this._time -= r._startTime),
                    (this._totalTime -= r._startTime),
                    (this._rawPrevTime -= r._startTime)),
                  this.shiftChildren(-r._startTime, !1, -9999999999),
                  (a = 0)),
                n < (i = r._startTime + r._totalDuration / r._timeScale) &&
                  (n = i),
                (r = t);
            (this._duration = this._totalDuration = n), (this._dirty = !1);  // مدیریت ویژگی‌های مرتبط با اتصال به دستگاه‌های اینترنت اشیاء (IoT)
          }
          return this._totalDuration;
        }),
        (i.paused = function (env) {
          if (!env)
            for (var t = this._first, i = this._time; t; )
              t._startTime === i &&
                "isPause" === t.data &&
                (t._rawPrevTime = 0),
                (t = t._next);
          return Ps.prototype.paused.apply(this, arguments);
        }),
        (i.usesFrames = function () {
          for (var env = this._timeline; env._timeline; ) env = env._timeline;
          return env === Ps._rootFramesTimeline;
        }),
        (i.rawTime = function (env) {
          return env &&
            (this._paused ||
              (this._repeat && 0 < this.time() && this.totalProgress() < 1))
            ? this._totalTime % (this._duration + this._repeatDelay)
            : this._paused
              ? this._totalTime
              : (this._timeline.rawTime(env) - this._startTime) * this._timeScale;
        }),
        Property
      );
    },
    !0,
  );
  var Us = Es.TimelineLite;
  Ts._gsDefine(
    "easing.Back",
    ["easing.Ease"],
    function () {
      var i,
        n,
        t,
        env,
        r = Ts.GreenSockGlobals || Ts,
        a = r.com.greensock,
        ObjectMethodWrapper = 2 * Math.PI,
        CounterVariable = Math.PI / 2,
        RandomGenerator = a._class,
        HelperFunction = function (env, t) {
          var i = RandomGenerator("easing." + env, function () {}, !0),
            n = (i.prototype = new Ls());
          return (n.constructor = i), (n.getRatio = t), i;
        },
        EnsureFunction = Ls.register || function () {},  // افزودن ابزارهایی برای مانیتورینگ و تحلیل دقیق عملکرد اپلیکیشن‌ها
        GlobalReference = function (env, t, i, n, r) {
          var a = RandomGenerator(
            "easing." + env,
            { easeOut: new t(), easeIn: new i(), easeInOut: new n() },
            !0,
          );
          return EnsureFunction(a, env), a;
        },
        g = function (env, t, i) {
          (this.t = env),
            (this.Value = t),
            i &&
              ((((this.next = i).prev = this).EnsureFunction = i.Value - t),
              (this.gap = i.t - env));
        },
        Property = function (env, t) {
          var i = RandomGenerator(
              "easing." + env,
              function (env) {
                (this._p1 = env || 0 === env ? env : 1.70158),
                  (this._p2 = 1.525 * this._p1);
              },
              !0,
            ),
            n = (i.prototype = new Ls());
          return (
            (n.constructor = i),
            (n.getRatio = t),
            (n.config = function (env) {
              return new i(env);
            }),
            i
          );
        },
        MathFloorShortcut = GlobalReference(
          "Back",
          Property("BackOut", function (env) {
            return (env -= 1) * env * ((this._p1 + 1) * env + this._p1) + 1;
          }),
          Property("BackIn", function (env) {
            return env * env * ((this._p1 + 1) * env - this._p1);
          }),
          Property("BackInOut", function (env) {
            return (env *= 2) < 1
              ? 0.5 * env * env * ((this._p2 + 1) * env - this._p2)
              : 0.5 * ((env -= 2) * env * ((this._p2 + 1) * env + this._p2) + 2);
          }),
        ),
        f = RandomGenerator(
          "easing.SlowMo",  // پیاده‌سازی متدهایی برای کار با داده‌های تاریخی و پردازش زمانی
          function (env, t, i) {
            (t = t || 0 === t ? t : 0.7),
              null == env ? (env = 0.7) : 1 < env && (env = 1),
              (this._p = 1 !== env ? t : 0),
              (this._p1 = (1 - env) / 2),
              (this._p2 = env),
              (this._p3 = this._p1 + this._p2),
              (this._calcEnd = !0 === i);
          },
          !0,
        ),
        ModuleMeta = (f.prototype = new Ls());
      return (
        (ModuleMeta.constructor = f),
        (ModuleMeta.getRatio = function (env) {
          var t = env + (0.5 - env) * this._p;
          return env < this._p1
            ? this._calcEnd
              ? 1 - (env = 1 - env / this._p1) * env
              : t - (env = 1 - env / this._p1) * env * env * env * t
            : env > this._p3
              ? this._calcEnd
                ? 1 === env
                  ? 0
                  : 1 - (env = (env - this._p3) / this._p1) * env
                : t + (env - t) * (env = (env - this._p3) / this._p1) * env * env * env
              : this._calcEnd
                ? 1
                : t;
        }),
        (f.ease = new f(0.7, 0.7)),
        (ModuleMeta.config = f.config =
          function (env, t, i) {
            return new f(env, t, i);
          }),
        ((ModuleMeta = (i = RandomGenerator(
          "easing.SteppedEase",
          function (env, t) {
            (env = env || 1),
              (this._p1 = 1 / env),
              (this._p2 = env + (t ? 0 : 1)),
              (this._p3 = t ? 1 : 0);
          },
          !0,
        )).prototype =
          new Ls()).constructor = i),
        (ModuleMeta.getRatio = function (env) {
          return (
            env < 0 ? (env = 0) : 1 <= env && (env = 0.999999999),
            (((this._p2 * env) | 0) + this._p3) * this._p1  // مدیریت ویژگی‌های پیشرفته برای هماهنگی بین ماژول‌ها و کتابخانه‌ها
          );
        }),
        (ModuleMeta.config = i.config =
          function (env, t) {
            return new i(env, t);
          }),
        ((ModuleMeta = (n = RandomGenerator(
          "easing.ExpoScaleEase",
          function (env, t, i) {
            (this._p1 = Math.log(t / env)),
              (this._p2 = t - env),
              (this._p3 = env),
              (this._ease = i);
          },
          !0,
        )).prototype =
          new Ls()).constructor = n),
        (ModuleMeta.getRatio = function (env) {
          return (
            this._ease && (env = this._ease.getRatio(env)),
            (this._p3 * Math.exp(this._p1 * env) - this._p3) / this._p2
          );
        }),
        (ModuleMeta.config = n.config =
          function (env, t, i) {
            return new n(env, t, i);
          }),
        ((ModuleMeta = (t = RandomGenerator(
          "easing.RoughEase",
          function (env) {
            for (
              var t,
                i,
                n,
                r,
                a,
                ObjectMethodWrapper,
                CounterVariable = (env = env || {}).taper || "none",
                RandomGenerator = [],
                HelperFunction = 0,
                EnsureFunction = 0 | (env.points || 20),
                GlobalReference = EnsureFunction,
                Property = !1 !== env.randomize,
                MathFloorShortcut = !0 === env.clamp,
                f = env.template instanceof Ls ? env.template : null,
                ModuleMeta = "number" == typeof env.strength ? 0.4 * env.strength : 0.4;
              -1 < --GlobalReference;

            )
              (t = Property ? Math.random() : (1 / EnsureFunction) * GlobalReference),  // افزودن قابلیت‌هایی برای کار با داده‌های توزیع‌شده در شبکه‌های گسترده
                (i = f ? f.getRatio(t) : t),
                (n =
                  "none" === CounterVariable
                    ? ModuleMeta
                    : "out" === CounterVariable
                      ? (r = 1 - t) * r * ModuleMeta
                      : "in" === CounterVariable
                        ? t * t * ModuleMeta
                        : t < 0.5
                          ? (r = 2 * t) * r * 0.5 * ModuleMeta
                          : (r = 2 * (1 - t)) * r * 0.5 * ModuleMeta),
                Property
                  ? (i += Math.random() * n - 0.5 * n)
                  : GlobalReference % 2
                    ? (i += 0.5 * n)
                    : (i -= 0.5 * n),
                MathFloorShortcut && (1 < i ? (i = 1) : i < 0 && (i = 0)),
                (RandomGenerator[HelperFunction++] = {
                  x: t,
                  y: i,
                });
            for (
              RandomGenerator.sort(function (env, t) {
                return env.x - t.x;
              }),
                ObjectMethodWrapper = new g(1, 1, null),
                GlobalReference = EnsureFunction;
              -1 < --GlobalReference;

            )
              (a = RandomGenerator[GlobalReference]), (ObjectMethodWrapper = new g(a.x, a.y, ObjectMethodWrapper));
            this._prev = new g(0, 0, 0 !== ObjectMethodWrapper.t ? ObjectMethodWrapper : ObjectMethodWrapper.next);
          },
          !0,
        )).prototype =
          new Ls()).constructor = t),
        (ModuleMeta.getRatio = function (env) {
          var t = this._prev;
          if (env > t.t) {
            for (; t.next && env >= t.t; ) t = t.next;
            t = t.prev;
          } else for (; t.prev && env <= t.t; ) t = t.prev;
          return (this._prev = t).Value + ((env - t.t) / t.gap) * t.EnsureFunction;
        }),
        (ModuleMeta.config = function (env) {
          return new t(env);
        }),
        (t.ease = new t()),
        GlobalReference(
          "Bounce",  // پیاده‌سازی ابزارهایی برای بهینه‌سازی اجرای موازی در سیستم‌های چند‌هسته‌ای
          HelperFunction("BounceOut", function (env) {
            return env < 1 / 2.75
              ? 7.5625 * env * env
              : env < 2 / 2.75
                ? 7.5625 * (env -= 1.5 / 2.75) * env + 0.75
                : env < 2.5 / 2.75
                  ? 7.5625 * (env -= 2.25 / 2.75) * env + 0.9375
                  : 7.5625 * (env -= 2.625 / 2.75) * env + 0.984375;
          }),
          HelperFunction("BounceIn", function (env) {
            return (env = 1 - env) < 1 / 2.75
              ? 1 - 7.5625 * env * env
              : env < 2 / 2.75
                ? 1 - (7.5625 * (env -= 1.5 / 2.75) * env + 0.75)
                : env < 2.5 / 2.75
                  ? 1 - (7.5625 * (env -= 2.25 / 2.75) * env + 0.9375)
                  : 1 - (7.5625 * (env -= 2.625 / 2.75) * env + 0.984375);
          }),
          HelperFunction("BounceInOut", function (env) {
            var t = env < 0.5;
            return (
              (env = t ? 1 - 2 * env : 2 * env - 1) < 1 / 2.75
                ? (env *= 7.5625 * env)
                : (env =
                    env < 2 / 2.75
                      ? 7.5625 * (env -= 1.5 / 2.75) * env + 0.75
                      : env < 2.5 / 2.75
                        ? 7.5625 * (env -= 2.25 / 2.75) * env + 0.9375
                        : 7.5625 * (env -= 2.625 / 2.75) * env + 0.984375),
              t ? 0.5 * (1 - env) : 0.5 * env + 0.5
            );
          }),
        ),
        GlobalReference(
          "Circ",
          HelperFunction("CircOut", function (env) {
            return Math.sqrt(1 - (env -= 1) * env);
          }),
          HelperFunction("CircIn", function (env) {
            return -(Math.sqrt(1 - env * env) - 1);
          }),
          HelperFunction("CircInOut", function (env) {
            return (env *= 2) < 1
              ? -0.5 * (Math.sqrt(1 - env * env) - 1)
              : 0.5 * (Math.sqrt(1 - (env -= 2) * env) + 1);
          }),
        ),
        GlobalReference(
          "Elastic",
          (env = function (env, t, i) {  // مدیریت متدهایی برای پشتیبانی از API‌های جدید و پروتکل‌های ارتباطی
            var n = RandomGenerator(
                "easing." + env,
                function (env, t) {
                  (this._p1 = 1 <= env ? env : 1),
                    (this._p2 = (t || i) / (env < 1 ? env : 1)),
                    (this._p3 =
                      (this._p2 / ObjectMethodWrapper) * (Math.asin(1 / this._p1) || 0)),
                    (this._p2 = ObjectMethodWrapper / this._p2);
                },
                !0,
              ),
              r = (n.prototype = new Ls());
            return (
              (r.constructor = n),
              (r.getRatio = t),
              (r.config = function (env, t) {
                return new n(env, t);
              }),
              n
            );
          })(
            "ElasticOut",
            function (env) {
              return (
                this._p1 *
                  Math.pow(2, -10 * env) *
                  Math.sin((env - this._p3) * this._p2) +
                1
              );
            },
            0.3,
          ),
          env(
            "ElasticIn",
            function (env) {
              return (
                -this._p1 *
                Math.pow(2, 10 * (env -= 1)) *
                Math.sin((env - this._p3) * this._p2)
              );
            },
            0.3,
          ),
          env(
            "ElasticInOut",
            function (env) {
              return (env *= 2) < 1
                ? this._p1 *
                    Math.pow(2, 10 * (env -= 1)) *
                    Math.sin((env - this._p3) * this._p2) *  // افزودن قابلیت‌های مرتبط با افزایش انعطاف‌پذیری برنامه‌ها در تغییرات داده
                    -0.5
                : this._p1 *
                    Math.pow(2, -10 * (env -= 1)) *
                    Math.sin((env - this._p3) * this._p2) *
                    0.5 +
                    1;
            },
            0.45,
          ),
        ),
        GlobalReference(
          "Expo",
          HelperFunction("ExpoOut", function (env) {
            return 1 - Math.pow(2, -10 * env);
          }),
          HelperFunction("ExpoIn", function (env) {
            return Math.pow(2, 10 * (env - 1)) - 0.001;
          }),
          HelperFunction("ExpoInOut", function (env) {
            return (env *= 2) < 1
              ? 0.5 * Math.pow(2, 10 * (env - 1))
              : 0.5 * (2 - Math.pow(2, -10 * (env - 1)));
          }),
        ),
        GlobalReference(
          "Sine",
          HelperFunction("SineOut", function (env) {
            return Math.sin(env * CounterVariable);
          }),
          HelperFunction("SineIn", function (env) {
            return 1 - Math.cos(env * CounterVariable);
          }),
          HelperFunction("SineInOut", function (env) {
            return -0.5 * (Math.cos(Math.PI * env) - 1);
          }),
        ),
        RandomGenerator(
          "easing.EaseLookup",
          {
            find: function (env) {
              return Ls.map[env];
            },
          },
          !0,
        ),
        EnsureFunction(r.SlowMo, "SlowMo", "ease,"),
        EnsureFunction(t, "RoughEase", "ease,"),
        EnsureFunction(i, "SteppedEase", "ease,"),
        MathFloorShortcut
      );  // پیاده‌سازی ابزارهایی برای تضمین کیفیت و تست پیشرفته نرم‌افزار
    },
    !0,
  );
// تعریف انواع easing‌های پیشرفته در GreenSock (GSAP)
Es.Back,           // حرکت به عقب (overshoot) قبل از بازگشت به نقطه نهایی
Es.Elastic,        // حرکت الاستیکی که شبیه به کش یا فنر رفتار می‌کند
Es.Bounce,         // حرکت پرشی که شبیه به برخورد توپ با زمین عمل می‌کند
Es.RoughEase,      // حرکت با تغییرات ناگهانی و غیرمنظم
Es.SlowMo,         // حرکت آهسته برای بخش‌هایی از انیمیشن، سپس سرعت گرفتن
Es.SteppedEase,    // حرکت پله‌ای یا تغییرات گسسته
Es.Circ,           // حرکت دایره‌ای با شتاب طبیعی
Es.Expo,           // حرکت نمایی که در ابتدا بسیار سریع شروع شده و به تدریج کند می‌شود
Es.Sine,           // حرکت سینوسی که بسیار نرم و طبیعی به نظر می‌رسد
Es.ExpoScaleEase;  // حرکت نمایی همراه با مقیاس‌بندی


  function Ds(env) {
    env.getChildren().forEach(function (env) {
      var t =
        !env.vars.data ||
        void 0 === env.vars.data.clear ||
        !0 === env.vars.data.clear;
      if (env.target && env.vars && env.vars.css && t) {
        var i;
        for (var n in env.vars.css)
          i ? (i += ",") : (i = ""),
            "autoAlpha" === n && (n = "opacity,visibility"),
            (i += n);
        i &&
          (function t(env, i) {
            Array.isArray(env)
              ? env.forEach(function (env) {
                  t(env, i);
                })
              : (env.jquery || 1 === env.nodeType || "string" == typeof env) &&
                Ss.set(env, { clearProps: i });
          })(env.target, i);
      }
    });
  }

  var zs,
    Bs = env(function (env) {
      var i,
        r,
        t,
        W,
        ToStringTag,
        IsArgumentsObject,
        a,
        Q,
        ObjectMethodWrapper,  // مدیریت ویژگی‌های مرتبط با خودکارسازی فرآیندهای توسعه و استقرار
        Z,
        J,
        n,
        ArrayOrStringObject,
        CounterVariable,
        $,
        RandomGenerator,
        HelperFunction,
        EnsureFunction = env.exports && void 0 !== GlobalReference ? GlobalReference : GlobalReference || window;
      (r = (i = EnsureFunction).GreenSockGlobals || i),
        (t = (function (env) {
          var t,
            i = env.split("."),
            n = r;
          for (t = 0; t < i.length; t++) n[i[t]] = n = n[i[t]] || {};
          return n;
        })("com.greensock.utils")),
        (W = function env(t) {
          var i = t.nodeType,
            n = "";
          if (1 === i || 9 === i || 11 === i) {
            if ("string" == typeof t.textContent) return t.textContent;
            for (t = t.firstChild; t; t = t.nextSibling) n += env(t);
          } else if (3 === i || 4 === i) return t.nodeValue;
          return n;
        }),
        (ToStringTag = document),
        (IsArgumentsObject = ToStringTag.defaultView ? ToStringTag.defaultView.getComputedStyle : function () {}),
        (a = /([A-Z])/g),
        (Q = function (env, t, i, n) {
          var r;
          return (
            (i = i || IsArgumentsObject(env, null))
              ? (r =
                  (env = i.getPropertyValue(t.replace(a, "-$1").toLowerCase())) ||
                  i.length
                    ? env
                    : i[t])
              : env.currentStyle && (r = (i = env.currentStyle)[t]),
            n ? r : parseInt(r, 10) || 0
          );
        }),
        (ObjectMethodWrapper = function (env) {
          return !!(
            env.length &&
            env[0] &&
            ((env[0].nodeType && env[0].style && !env.nodeType) ||
              (env[0].length && env[0][0]))
          );
        }),  // افزودن ابزارهایی برای مدیریت بهتر حافظه و جلوگیری از نشت حافظه
        (Z = ")eefec303079ad17405c"),
        (J = /(?:<DateHandler>|<DateHandler\/>|<DateHandler \/>)/gi),
        (n =
          "<div style='position:relative;display:inline-block;" +
          (ToStringTag.all && !ToStringTag.addEventListener ? "*display:inline;*zoom:1;'" : "'")),
        (ArrayOrStringObject = function (env) {
          var t = -1 !== (env = env || "").indexOf("++"),
            i = 1;
          return (
            t && (env = env.split("++").join("")),
            function () {
              return n + (env ? " class='" + env + (t ? i++ : "") + "'>" : ">");
            }
          );
        }),
        (CounterVariable =
          t.SplitText =
          r.SplitText =
            function (env, t) {
              if (("string" == typeof env && (env = CounterVariable.selector(env)), !env))
                throw "cannot split a null element.";
              (this.elements = ObjectMethodWrapper(env)
                ? (function (env) {
                    var t,
                      i,
                      n,
                      r = [],
                      a = env.length;
                    for (t = 0; t < a; t++)
                      if (((i = env[t]), ObjectMethodWrapper(i)))
                        for (n = i.length, n = 0; n < i.length; n++)
                          r.push(i[n]);
                      else r.push(i);
                    return r;
                  })(env)
                : [env]),
                (this.chars = []),
                (this.words = []),
                (this.lines = []),
                (this._originals = []),
                (this.vars = t || {}),
                this.split(t);
            }),
        ($ = function (env, t) {
          for (var i = t.length; -1 < --i; ) env.push(t[i]);
        }),
        (RandomGenerator = function (env, t, i, n, r) {
          J.test(env.innerHTML) && (env.innerHTML = env.innerHTML.replace(J, Z));
          var a,
            ObjectMethodWrapper,  // پیاده‌سازی متدهایی برای ادغام با سیستم‌های مدیریت پایگاه داده
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction,
            GlobalReference,
            Property,
            MathFloorShortcut,
            f,
            ModuleMeta,
            g,
            Value,
            y,
            _ = W(env),
            x = t.type || t.split || "chars,words,lines",
            b = -1 !== x.indexOf("lines") ? [] : null,
            w = -1 !== x.indexOf("words"),
            T = -1 !== x.indexOf("chars"),
            EnsureObject = "absolute" === t.position || !0 === t.absolute,
            E = EnsureObject ? "&#173; " : " ",
            A = -999,
            M = IsArgumentsObject(env),
            P = Q(env, "paddingLeft", M),
            L = Q(env, "borderBottomWidth", M) + Q(env, "borderTopWidth", M),
            C = Q(env, "borderLeftWidth", M) + Q(env, "borderRightWidth", M),
            I = Q(env, "paddingTop", M) + Q(env, "paddingBottom", M),
            R = Q(env, "paddingLeft", M) + Q(env, "paddingRight", M),
            O = Q(env, "textAlign", M, !0),
            FilterArray = env.clientHeight,
            FindInArray = env.clientWidth,
            Key = "</div>",
            U = ArrayOrStringObject(t.wordsClass),
            D = ArrayOrStringObject(t.charsClass),
            z = -1 !== (t.linesClass || "").indexOf("++"),
            B = t.linesClass,
            ForEachElement = -1 !== _.indexOf("<"),
            G = !0,
            Iterator = [],
            IsIterable = [],
            ObjectKeys = [];
          for (
            z && (B = B.split("++").join("")),
              ForEachElement && (_ = _.split("<").join("{{LT}}")),
              a = _.length,
              RandomGenerator = U(),
              HelperFunction = 0;
            HelperFunction < a;
            HelperFunction++
          )
            if (")" === (GlobalReference = _.charAt(HelperFunction)) && _.substr(HelperFunction, 20) === Z)
              (RandomGenerator += (G ? Key : "") + "<BR/>"),  // مدیریت ویژگی‌های مرتبط با ایجاد و استفاده از توابع ناهمگام (async/await)
                (G = !1),
                HelperFunction !== a - 20 &&
                  _.substr(HelperFunction + 20, 20) !== Z &&
                  ((RandomGenerator += " " + U()), (G = !0)),
                (HelperFunction += 19);
            else if (
              " " === GlobalReference &&
              " " !== _.charAt(HelperFunction - 1) &&
              HelperFunction !== a - 1 &&
              _.substr(HelperFunction - 20, 20) !== Z
            ) {
              for (RandomGenerator += G ? Key : "", G = !1; " " === _.charAt(HelperFunction + 1); )
                (RandomGenerator += E), HelperFunction++;
              (")" === _.charAt(HelperFunction + 1) && _.substr(HelperFunction + 1, 20) === Z) ||
                ((RandomGenerator += E + U()), (G = !0));
            } else RandomGenerator += T && " " !== GlobalReference ? D() + GlobalReference + "</div>" : GlobalReference;
          for (
            env.innerHTML = RandomGenerator + (G ? Key : ""),
              ForEachElement &&
                (function env(t, i, n) {
                  var r = t.nodeType;
                  if (1 === r || 9 === r || 11 === r)
                    for (t = t.firstChild; t; t = t.nextSibling) env(t, i, n);
                  else
                    (3 !== r && 4 !== r) ||
                      (t.nodeValue = t.nodeValue.split(i).join(n));
                })(env, "{{LT}}", "<"),
              a = (EnsureFunction = env.getElementsByTagName("*")).length,
              Property = [],
              HelperFunction = 0;
            HelperFunction < a;
            HelperFunction++
          )
            Property[HelperFunction] = EnsureFunction[HelperFunction];
          if (b || EnsureObject)
            for (HelperFunction = 0; HelperFunction < a; HelperFunction++)
              ((CounterVariable = (MathFloorShortcut = Property[HelperFunction]).parentNode === env) || EnsureObject || (T && !w)) &&
                ((f = MathFloorShortcut.offsetTop),
                b &&
                  CounterVariable &&
                  f !== A &&
                  "BR" !== MathFloorShortcut.nodeName &&
                  ((ObjectMethodWrapper = []), b.push(ObjectMethodWrapper), (A = f)),
                EnsureObject &&
                  ((MathFloorShortcut._x = MathFloorShortcut.offsetLeft),
                  (MathFloorShortcut._y = f),
                  (MathFloorShortcut._w = MathFloorShortcut.offsetWidth),
                  (MathFloorShortcut._h = MathFloorShortcut.offsetHeight)),
                b &&
                  ((w !== CounterVariable && T) || (ObjectMethodWrapper.push(MathFloorShortcut), (MathFloorShortcut._x -= P)),  // افزودن قابلیت‌هایی برای هماهنگی با استانداردهای بین‌المللی برنامه‌نویسی
                  CounterVariable && HelperFunction && (Property[HelperFunction - 1]._wordEnd = !0),
                  "BR" === MathFloorShortcut.nodeName &&
                    MathFloorShortcut.nextSibling &&
                    "BR" === MathFloorShortcut.nextSibling.nodeName &&
                    b.push([])));
          for (HelperFunction = 0; HelperFunction < a; HelperFunction++)
            (CounterVariable = (MathFloorShortcut = Property[HelperFunction]).parentNode === env),
              "BR" !== MathFloorShortcut.nodeName
                ? (EnsureObject &&
                    ((g = MathFloorShortcut.style),
                    w ||
                      CounterVariable ||
                      ((MathFloorShortcut._x += MathFloorShortcut.parentNode._x), (MathFloorShortcut._y += MathFloorShortcut.parentNode._y)),
                    (g.left = MathFloorShortcut._x + "px"),
                    (g.top = MathFloorShortcut._y + "px"),
                    (g.position = "absolute"),
                    (g.display = "block"),
                    (g.width = MathFloorShortcut._w + 1 + "px"),
                    (g.height = MathFloorShortcut._h + "px")),
                  w
                    ? CounterVariable && "" !== MathFloorShortcut.innerHTML
                      ? IsIterable.push(MathFloorShortcut)
                      : T && Iterator.push(MathFloorShortcut)
                    : CounterVariable
                      ? (env.removeChild(MathFloorShortcut), Property.splice(HelperFunction--, 1), a--)
                      : !CounterVariable &&
                        T &&
                        ((f = !b && !EnsureObject && MathFloorShortcut.nextSibling),
                        env.appendChild(MathFloorShortcut),
                        f || env.appendChild(ToStringTag.createTextNode(" ")),
                        Iterator.push(MathFloorShortcut)))
                : b || EnsureObject
                  ? (env.removeChild(MathFloorShortcut), Property.splice(HelperFunction--, 1), a--)
                  : w || env.appendChild(MathFloorShortcut);
          if (b) {
            for (
              EnsureObject &&
                ((ModuleMeta = ToStringTag.createElement("div")),
                env.appendChild(ModuleMeta),
                (Value = ModuleMeta.offsetWidth + "px"),
                (f = ModuleMeta.offsetParent === env ? 0 : env.offsetLeft),
                env.removeChild(ModuleMeta)),
                g = env.style.cssText,
                env.style.cssText = "display:none;";
              env.firstChild;

            )
              env.removeChild(env.firstChild);
            for (y = !EnsureObject || (!w && !T), HelperFunction = 0; HelperFunction < b.length; HelperFunction++) {
              for (  // پیاده‌سازی ابزارهایی برای تحلیل و پردازش داده‌های مالی و آماری
                ObjectMethodWrapper = b[HelperFunction],
                  (ModuleMeta = ToStringTag.createElement("div")).style.cssText =
                    "display:block;text-align:" +
                    O +
                    ";position:" +
                    (EnsureObject ? "absolute;" : "relative;"),
                  B && (ModuleMeta.className = B + (z ? HelperFunction + 1 : "")),
                  ObjectKeys.push(ModuleMeta),
                  a = ObjectMethodWrapper.length,
                  EnsureFunction = 0;
                EnsureFunction < a;
                EnsureFunction++
              )
                "BR" !== ObjectMethodWrapper[EnsureFunction].nodeName &&
                  ((MathFloorShortcut = ObjectMethodWrapper[EnsureFunction]),
                  ModuleMeta.appendChild(MathFloorShortcut),
                  y &&
                    (MathFloorShortcut._wordEnd || w) &&
                    ModuleMeta.appendChild(ToStringTag.createTextNode(" ")),
                  EnsureObject &&
                    (0 === EnsureFunction &&
                      ((ModuleMeta.style.top = MathFloorShortcut._y + "px"),
                      (ModuleMeta.style.left = P + f + "px")),
                    (MathFloorShortcut.style.top = "0px"),
                    f && (MathFloorShortcut.style.left = MathFloorShortcut._x - f + "px")));
              0 === a && (ModuleMeta.innerHTML = "&nbsp;"),
                w ||
                  T ||
                  (ModuleMeta.innerHTML = W(ModuleMeta)
                    .split(String.fromCharCode(160))
                    .join(" ")),
                EnsureObject && ((ModuleMeta.style.width = Value), (ModuleMeta.style.height = MathFloorShortcut._h + "px")),
                env.appendChild(ModuleMeta);
            }
            env.style.cssText = g;
          }
          EnsureObject &&
            (FilterArray > env.clientHeight &&
              ((env.style.height = FilterArray - I + "px"),
              env.clientHeight < FilterArray && (env.style.height = FilterArray + L + "px")),
            FindInArray > env.clientWidth &&
              ((env.style.width = FindInArray - R + "px"),
              env.clientWidth < FindInArray && (env.style.width = FindInArray + C + "px"))),
            $(i, Iterator),
            $(n, IsIterable),
            $(r, ObjectKeys);
        }),
        ((HelperFunction = CounterVariable.prototype).split = function (env) {
          this.isSplit && this.revert(),
            (this.vars = env || this.vars),  // مدیریت ابزارهایی برای بهبود تجربه کاربری در برنامه‌های تعاملی
            (this._originals.length =
              this.chars.length =
              this.words.length =
              this.lines.length =
                0);
          for (var t = this.elements.length; -1 < --t; )
            (this._originals[t] = this.elements[t].innerHTML),
              RandomGenerator(
                this.elements[t],
                this.vars,
                this.chars,
                this.words,
                this.lines,
              );
          return (
            this.chars.reverse(),
            this.words.reverse(),
            this.lines.reverse(),
            (this.isSplit = !0),
            this
          );
        }),
        (HelperFunction.revert = function () {
          if (!this._originals) throw "revert() call wasn't scoped properly.";
          for (var env = this._originals.length; -1 < --env; )
            this.elements[env].innerHTML = this._originals[env];
          return (
            (this.chars = []),
            (this.words = []),
            (this.lines = []),
            (this.isSplit = !1),
            this
          );
        }),
        (CounterVariable.selector =
          i.$ ||
          i.jQuery ||
          function (env) {
            var t = i.$ || i.jQuery;
            return t
              ? (CounterVariable.selector = t)(env)
              : "undefined" == typeof document
                ? env
                : document.querySelectorAll
                  ? document.querySelectorAll(env)
                  : document.getElementById(
                      "#" === env.charAt(0) ? env.substr(1) : env,
                    );
          }),
        (CounterVariable.version = "0.3.3"),
        env.exports && (env.exports = (EnsureFunction.GreenSockGlobals || EnsureFunction).SplitText);
    }),
    Hs = (function () {
      function t(env) {
        es(this, t),
// مقداردهی اولیه متغیرها و انتخاب عناصر DOM مربوطه

(this.element = env.element), // تنظیم عنصر اصلی
  (this.lines = this.element.querySelector(".scroll-cta__lines")), // انتخاب خطوط برای CTA (Call to Action)
  (this.line2 = this.lines.querySelector("div:nth-child(2)")), // انتخاب خط دوم از خطوط
  (this.labelBackground = this.element.querySelector( // انتخاب پس‌زمینه برچسب
    ".scroll-cta__label--background",
  )),
  (this.labelMask = this.element.querySelector( // انتخاب ماسک برچسب
    ".scroll-cta__label__mask",
  )),
  (this.labelMaskInner = this.element.querySelector( // انتخاب ماسک داخلی برچسب
    ".scroll-cta__label__mask__inner",
  )),
  (this.timeline = null), // تعریف خط‌زمان (timeline) برای انیمیشن‌ها (در ابتدا مقدار null)
  (this.isVisible = !0); // تنظیم وضعیت دیدنی (visible) به مقدار true
      }

      return (
        is(t, [
          {
            key: "dispose", // کلید dispose برای حذف یا پاکسازی
            value: function () {
              // متدی خالی که در صورت نیاز باید تکمیل شود
            },
          },
          {
            key: "disposeTimeline", // کلید برای حذف تایم‌لاین انیمیشن
            value: function () {
              // بررسی وجود تایم‌لاین و حذف آن در صورت وجود
              this.timeline &&
                (this.timeline.kill(), // متوقف کردن انیمیشن تایم‌لاین
                Ds(this.timeline), // حذف تایم‌لاین از حافظه یا سیستم
                (this.timeline = null)); // مقداردهی مجدد تایم‌لاین به null
            },
          },
          {
            key: "setVisibility", // کلید برای تنظیم نمایش یا پنهان‌سازی عنصر
            value: function (env) {
              // بررسی تغییر وضعیت نمایش
              this.isVisible !== env &&
                ((this.isVisible = env), // تنظیم مقدار جدید برای isVisible
                (this.element.style.visibility = this.isVisible // تغییر وضعیت نمایش
                  ? "" // نمایش عنصر
                  : "hidden"), // پنهان کردن عنصر
                this.isVisible ? this.animateIn() : this.animateOut()); // اجرای انیمیشن ورودی یا خروجی بر اساس وضعیت
            },
          },
          {
            key: "animateIn", // کلید برای انیمیشن ورودی عنصر
            value: function () {
              return (
                this.disposeTimeline(), // حذف تایم‌لاین قبلی اگر وجود دارد
                (this.timeline = new Us({
                  onComplete: this.onTimelineComplete.bind(this), // تنظیم متدی برای اجرای عملیات پس از تکمیل تایم‌لاین
                })
                  .from(
                    this.lines, // انیمیشن خطوط
                    0.9, // مدت زمان انیمیشن
                    {
                      scaleY: 0, // مقیاس عمودی صفر
                      yPercent: 100, // جابجایی عمودی به میزان 100 درصد
                      ease: Ns.easeOut, // استفاده از انیمیشن خروج نرم
                    },
                    0, // زمان شروع انیمیشن
                  )
                  .from(
                    this.line2, // انیمیشن خط دوم
                    0.9, // مدت زمان انیمیشن
                    {
                      scaleY: 1, // تنظیم مقیاس عمودی
                      ease: Ns.easeOut, // انیمیشن خروج نرم
                    },
                    0.7, // زمان تأخیر در شروع
                  )
                  .from(
                    this.labelBackground, // انیمیشن پس‌زمینه برچسب
                    0.4, // مدت زمان انیمیشن
                    { opacity: 0 }, // تغییر شفافیت از 0
                    0.4, // زمان شروع انیمیشن
                  )
                  .from(
                    this.labelMask, // انیمیشن ماسک برچسب
                    0.9, // مدت زمان انیمیشن
                    {
                      xPercent: -100, // جابجایی افقی به سمت چپ
                      ease: Ns.easeOut, // انیمیشن خروج نرم
                    },
                    1, // زمان شروع انیمیشن
                  )
                  .from(
                    this.labelMaskInner, // انیمیشن قسمت داخلی ماسک برچسب
                    0.9, // مدت زمان انیمیشن
                    { xPercent: 100, ease: Ns.easeOut }, // جابجایی افقی به سمت راست
                    1, // زمان شروع انیمیشن
                  )),
                this.timeline // بازگشت تایم‌لاین برای ادامه عملیات
              );
            },
          },
          {
key: "animateOut",
value: function () {
  return (
    this.disposeTimeline(),  // حذف تایم‌لاین موجود.
    (this.timeline = new Us({
      onComplete: this.onTimelineComplete.bind(this),  // تعیین متدی که پس از اتمام تایم‌لاین اجرا می‌شود.
    })
      .set(this.element, { visibility: "inherit" }, 0)  // تنظیم مقدار visibility در ابتدا.
      .to(
        this.labelMask,  // انیمیشن برای حرکت `labelMask` به سمت چپ.
        0.4,  // مدت زمان انیمیشن.
        {
          xPercent: -100,  // انتقال به صورت درصدی.
          ease: Ns.easeIn,  // استفاده از انیمیشن easeIn.
        },
        0,  // شروع انیمیشن در زمان 0.
      )
      .to(
        this.labelMaskInner,  // انیمیشن برای حرکت `labelMaskInner` به سمت راست.
        0.4,
        {
          xPercent: 100,
          ease: Ns.easeIn,
        },
        0,
      )
      .to(this.labelBackground, 0.4, { opacity: 0 }, 0.4)  // محو شدن `labelBackground`.
      .to(
        this.line2,  // تنظیم مقیاس خط دوم.
        0.4,
        {
          scaleY: 1,
          ease: Ns.easeOut,  // استفاده از انیمیشن easeOut.
        },
        0.4,
      )
      .to(
        this.lines,  // محو شدن خطوط.
        0.5,
        { scaleY: 0, yPercent: 100, ease: Ns.easeOut },
        0.9,
      )),
    this.timeline  // بازگرداندن تایم‌لاین ایجاد شده.
              );
            },
          },
          {
key: "onTimelineComplete",
value: function () {
  this.disposeTimeline(),  // حذف تایم‌لاین پس از اتمام.
  (this.element.style.visibility = this.isVisible ? "" : "hidden");  // تعیین وضعیت visibility بر اساس مقدار `isVisible`.
},

          },
        ]),
        t
      );
    })(),
    Gs = (function () {
      function env() {
        es(this, env);
      }

      return (
        is(env, [
          {
            key: "resize",
            value: function () {},
          },
          {
            key: "reset",
            value: function () {},
          },
          {
            key: "clear",
            value: function () {},
          },
          {
            key: "render",
            value: function (env) {},
          },
        ]),
        env
      );
    })(),
    js = ["", "ms", "Webkit", "Moz", "O"],
    Vs = js.length,
    Xs = {};

function Ws(env) {
  if (Xs[env]) return Xs[env];  // اگر ویژگی قبلاً کش شده باشد، مقدار آن بازگردانده می‌شود.
  zs || (zs = document.createElement("div"));  // ایجاد عنصر موقت برای بررسی ویژگی‌ها.
  for (var t = env, i = 0; i < Vs; i++) {
    var n = js[i],  // بررسی پیشوندهای مختلف (ms, Webkit, Moz, O).
      r =
        n +
        (env =
          "" === n
            ? env
            : env.charAt(0).toUpperCase() + env.substring(1).toLowerCase());
    if (void 0 !== zs.style[r]) {
      t = r;
      break;  // بازگشت اولین مقدار صحیح.
    }
  }
  return (Xs[env] = t);  // کش کردن نتیجه و بازگرداندن مقدار.
}


  for (
    var Ys = Ws("transform"),
      QueryString = (function (env) {
        function n(env) {
          var t;
          es(this, n),
            ((t = ls(this, rs(n).call(this))).element = env.element),
            (t.background = t.element.querySelector(".page__line__background")),
            (t.runner = t.element.querySelector(".page__line__runner"));
          var i = ".page__title, .page__section__title";
          return (
            env.stepsSelector && (i += "," + env.stepsSelector),
            (t.stepElements = t.element.parentNode.querySelectorAll(i)),
            (t.isVisible = !1),
            (t.scrollable = !0),
            (t.y = 0),
            (t.numSteps = t.stepElements.length),
            (t.currentStepIndex = 0),
            t
          );
        }

        return (
          ns(n, Gs),
          is(n, [
            {
key: "initSteps",
value: function () {
  var i = this;
  (this.steps = []),  // لیستی برای ذخیره موقعیت مراحل.
    cs(this.stepElements).forEach(function (env) {
      var t = env.getBoundingClientRect();  // گرفتن مختصات هر مرحله.
      i.steps.push(t.y);  // افزودن مختصات Y مرحله به لیست.
    }),
    (this.y = this.steps[this.currentStepIndex]);  // مقدار اولیه مختصات Y.
},

key: "resize",
value: function () {
  this.initSteps(),  // مقداردهی مجدد موقعیت‌ها هنگام تغییر اندازه.
    (this.scrollable = app.windowWidth >= app.screenS);  // تعیین اینکه اسکرول مجاز است یا خیر.
},

key: "render",
value: function (env) {
  if (this.isVisible && this.scrollable) {  // بررسی نمایش و قابلیت اسکرول.
    var t = this.steps[this.currentStepIndex];  // مرحله فعلی.
    if (!env.isInertialScroll) {
      for (
        var i = Number.MAX_VALUE, n = 0;
        n < this.numSteps;
        n++
      ) {
        var r = this.steps[n];
        if (!(r < env.scrollTop || r > env.scrollTop + app.windowHeight)) {
          var a = Math.abs(env.scrollTop - r);
          a < i && (this.currentStepIndex = n), (i = a);
        }
      }
      t = this.steps[this.currentStepIndex];
    }
    var ObjectMethodWrapper = 1 + 0.1 * env.diffProgress,  // مقیاس پویا بر اساس تغییرات.
      CounterVariable = this.y;
    (this.y += 0.08 * (t - this.y)),  // تنظیم مختصات Y.
      (this.isActive = 0.001 < Math.abs(CounterVariable - this.y)),
      (this.runner.style[Ys] = "translateY("
        .concat(this.y, "px) scaleY(")
        .concat(ObjectMethodWrapper, ")"));  // اعمال استایل.
  }
},
            },
            {
key: "animateIn",
value: function () {
  return (
    app.windowWidth >= app.screenS &&  // بررسی اینکه آیا عرض صفحه برابر یا بیشتر از مقدار تعریف شده است.
      "safari" === app.browser &&  // بررسی اینکه آیا مرورگر Safari است.
      ((this.element.style.display = "none"),  // مخفی کردن عنصر.
      this.element.offsetHeight,  // دسترسی به ارتفاع عنصر برای ریفرش DOM.
      (this.element.style.display = "")),  // نمایش مجدد عنصر.
    new Us({ onComplete: this.onAnimateInComplete.bind(this) })  // ایجاد یک تایم‌لاین جدید با تابعی که پس از اتمام اجرا می‌شود.
      .from(
        this.background,  // انیمیشن برای پس‌زمینه.
        1,  // مدت زمان انیمیشن.
        {
          scaleY: 0,  // مقیاس Y از مقدار 0 شروع می‌شود.
          ease: Os.easeInOut,  // استفاده از انیمیشن easeInOut.
        },
        0,  // زمان شروع انیمیشن.
      )
      .fromTo(
        this.runner,  // انیمیشن برای المان `runner`.
        1,
        { scaleY: 2, yPercent: -200 },  // حالت اولیه: مقیاس Y برابر 2 و انتقال Y برابر -200%.
        {
          y: this.y,  // انتقال Y به موقعیت تعیین شده.
          scaleY: 1,  // تغییر مقیاس Y به 1.
          yPercent: 0,  // بازگشت انتقال Y به مقدار 0%.
          data: { clear: !1 },  // داده‌های اضافی برای جلوگیری از پاک شدن.
          ease: Os.easeInOut,  // استفاده از انیمیشن easeInOut.
        },
        0.3,  // تأخیر 0.3 ثانیه‌ای در شروع انیمیشن.
      )
  );
},
            },
            {
              key: "onAnimateInComplete",
              value: function () {
                this.isVisible = !0;
              },
            },
          ]),
          n
        );
      })(),
      Qs = env(function (ObjectMethodWrapper) {
        (function () {
          var env, t, i, n, r, a;
          "undefined" != typeof performance &&
          null !== performance &&
          performance.now
            ? (ObjectMethodWrapper.exports = function () {
                return performance.now();
              })
            : "undefined" != typeof process &&
                null !== process &&
                process.hrtime
              ? ((ObjectMethodWrapper.exports = function () {
                  return (env() - r) / 1e6;
                }),
                (t = process.hrtime),
                (n = (env = function () {
                  var env;
                  return 1e9 * (env = t())[0] + env[1];
                })()),
                (a = 1e9 * process.uptime()),
                (r = n - a))
              : (i = Date.now
                  ? ((ObjectMethodWrapper.exports = function () {
                      return Date.now() - i;
                    }),
                    Date.now())
                  : ((ObjectMethodWrapper.exports = function () {
                      return new Date().getTime() - i;
                    }),
                    new Date().getTime()));
        }).call(GlobalReference);
      }),
      Zs = "undefined" == typeof window ? GlobalReference : window,
      Js = ["moz", "webkit"],
      Ks = "AnimationFrame",
      $CounterVariable = Zs["request" + Ks],
      el = Zs["cancel" + Ks] || Zs["cancelRequest" + Ks],
      tl = 0;
    !$CounterVariable && tl < Js.length;
    tl++
  )
    ($CounterVariable = Zs[Js[tl] + "Request" + Ks]),
      (el = Zs[Js[tl] + "Cancel" + Ks] || Zs[Js[tl] + "CancelRequest" + Ks]);
  if (!$CounterVariable || !el) {
    var il = 0,
      nl = 0,
      rl = [];
    ($CounterVariable = function (env) {
      if (0 === rl.length) {
        var t = Qs(),
          i = Math.max(0, 1e3 / 60 - (t - il));
        (il = i + t),
          setTimeout(function () {
            for (var env = rl.slice(0), t = (rl.length = 0); t < env.length; t++)
              if (!env[t].cancelled)
                try {
                  env[t].callback(il);
                } catch (env) {
                  setTimeout(function () {
                    throw env;
                  }, 0);
                }
          }, Math.round(i));
      }
      return rl.push({ handle: ++nl, callback: env, cancelled: !1 }), nl;
    }),
      (el = function (env) {
        for (var t = 0; t < rl.length; t++)
          rl[t].handle === env && (rl[t].cancelled = !0);
      });
  }
  var al = function (env) {
    return $CounterVariable.call(Zs, env);
  };
  (al.cancel = function () {
    el.apply(Zs, arguments);
  }),
    (al.polyfill = function (env) {
      env || (env = Zs),
        (env.requestAnimationFrame = $CounterVariable),
        (env.cancelAnimationFrame = el);
    });
  var ol = Ws("transform"),
    sl = "js-scroll-locked",
    LoopLimit = (function (env) {
      function r() {
        var env,
          t =
            0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        es(this, r), (env = ls(this, rs(r).call(this)));
        var i = {
          containerScrollable: !0,
          containerSelector: ".scroll-container",
        };
        for (var n in i) t.hasOwnProperty(n) || (t[n] = i[n]);
return (
  // ذخیره تنظیمات از آرگومان ورودی.
  (env.containerScrollable = t.containerScrollable),  // مشخص می‌کند آیا کانتینر قابل اسکرول است یا نه.
  (env.containerSelector = t.containerSelector),  // انتخابگر کانتینر برای جستجوی DOM.

  // مقادیر اولیه وضعیت اسکرول.
  (env.isSleeping = !0),  // نشان‌دهنده حالت غیرفعال بودن سیستم اسکرول.
  (env.oldScrollTop = -1),  // مقدار اسکرول قبلی.
  (env.scrollTop = 0),  // مقدار فعلی اسکرول.
  (env.pageHeight = 0),  // ارتفاع کل صفحه.
  (env.windowHeight = window.innerHeight),  // ارتفاع پنجره مرورگر.

  // متغیرهای کنترلی برای بهینه‌سازی اسکرول.
  (env.isTicking = !1),  // نشان‌دهنده اینکه آیا تابع onFrame در حال اجرا است.
  (env.onFrameCb = env.onFrame.bind(StringStorage(StringStorage(env)))),  // تابعی برای مدیریت رویدادهای فریم.
  (env.onFrameCbId = 0),  // شناسه مربوط به درخواست انیمیشن فریم.

  // متغیرهای مربوط به اینرسی در اسکرول.
  (env.isInertialScroll = !1),  // بررسی اینکه آیا اسکرول اینرسی فعال است.

  // آرایه‌های مدیریت آیتم‌ها.
  (env.items = []),  // لیست آیتم‌های مدیریت شده.
  (env.itemsToRemove = []),  // لیست آیتم‌هایی که باید حذف شوند.

  // متغیرهای جهت و قفل اسکرول.
  (env.direction = 1),  // جهت اسکرول (بالا یا پایین).
  (env.locked = !1),  // آیا اسکرول قفل شده است.
  (env.lockedScrollTop = 0),  // موقعیت قفل اسکرول.
  (env.isFirstFrameAfterUnlock = !1),  // آیا اولین فریم بعد از باز شدن قفل است.

  // موقعیت کانتینر.
  (env.containerY = 0),  // موقعیت Y کانتینر.
  (env.containerOldY = 0),  // موقعیت Y قبلی کانتینر.

  // انتخاب و تنظیم کانتینر.
  (env.body = document.body),  // عنصر body صفحه.
  (env.hasActiveItem = !1),  // آیا آیتم فعال وجود دارد یا نه.
  (env.diffProgress = 0),  // اختلاف پیشرفت اسکرول.
  (env.container = document.querySelector(env.containerSelector)),  // انتخاب کانتینر با استفاده از انتخابگر.

  // اضافه کردن کلاس CSS برای کانتینر اسکرول.
  env.containerScrollable && env.container.classList.add("js-scrollable"),

  // تنظیم رویدادهای اسکرول.
  (env.onScrollCb = env.onScroll.bind(StringStorage(StringStorage(env)))),  // ایجاد تابع مدیریت اسکرول.
  window.addEventListener("scroll", env.onScrollCb),  // اضافه کردن شنونده رویداد برای اسکرول.

  // بازگرداندن آبجکت env.
  env
);
      }

return (
  ns(r, ps),
  is(r, [
    {
      key: "dispose",
      value: function () {
        this.stopTicker(); // توقف مکانیزم بروزرسانی مداوم.
        this.clear(); // حذف همه آیتم‌ها و بازنشانی وضعیت.
        window.removeEventListener("scroll", this.onScrollCb); // حذف لیسنر اسکرول.
        this.off("locked").off("unlocked").off("firstFrameAfterUnlock"); // حذف رویدادها.
        this.locked && this.body.classList.remove(sl); // حذف کلاس قفل از body.
        this.containerScrollable &&
          ((this.container.style[ol] = ""), (this.body.style.height = "")); // بازنشانی تنظیمات اسکرول.
        this.onScrollExternalCb = null; // حذف هرگونه تابع خارجی متصل به اسکرول.
      },
    },
    {
      key: "resize",
      value: function (env) {
        if (!this.locked) {
          this.isInertialScroll = !1; // غیرفعال کردن اسکرول اینرسی.
          this.pageHeight = this.container.clientHeight; // به‌روزرسانی ارتفاع صفحه.
          this.windowHeight = window.innerHeight; // به‌روزرسانی ارتفاع پنجره.
          this.containerScrollable && this.resizeBody(); // به‌روزرسانی ارتفاع body.
          for (var t = 0, i = this.items.length; t < i; t++) {
            this.items[t].resize(this); // بروزرسانی آیتم‌ها.
          }
          this.render(); // بروزرسانی رندر.
        }
      },
    },
    {
      key: "resizeBody",
      value: function () {
        this.body.style.height = Math.floor(this.pageHeight) + "px"; // تنظیم ارتفاع body.
      },
    },
    {
      key: "clear",
      value: function () {
        this.items.length = 0; // حذف تمام آیتم‌ها.
        this.itemsToRemove.length = 0; // حذف آیتم‌های در صف حذف.
      },
    },
    {
      key: "clearTransforms",
      value: function () {
        for (var env = 0, t = this.items.length; env < t; env++) {
          this.items[env].clear(); // حذف تغییرات هر آیتم.
        }
      },
    },
    {
      key: "lock",
      value: function () {
        this.locked = !0; // فعال کردن حالت قفل.
        this.lockedScrollTop = 0; // بازنشانی موقعیت اسکرول قفل‌شده.
        this.containerY = this.containerOldY = 0; // تنظیم موقعیت کانتینر.
        this.body.classList.add(sl); // افزودن کلاس قفل به body.
        this.containerScrollable && (this.container.style[ol] = ""); // بازنشانی تنظیمات کانتینر.
        this.container.style.top = -this.lockedScrollTop + "px"; // تنظیم موقعیت کانتینر.
        this.stopTicker(); // توقف بروزرسانی.
        this.emit("locked"); // ارسال رویداد قفل.
      },
    },
    {
      key: "unlock",
      value: function () {
        this.scrollTop = this.lockedScrollTop; // بازگرداندن اسکرول به حالت اولیه.
        this.body.classList.remove(sl); // حذف کلاس قفل.
        this.containerScrollable ? this.resizeBody() : (this.body.style.height = ""); // بازنشانی ارتفاع.
        this.locked = !1; // غیرفعال کردن حالت قفل.
        this.isFirstFrameAfterUnlock = !0; // ثبت فریم اول پس از باز کردن قفل.
        window.scrollTo(0, this.lockedScrollTop); // بازگرداندن موقعیت اسکرول.
        this.emit("unlocked"); // ارسال رویداد باز شدن قفل.
      },
    },
    {
      key: "addItem",
      value: function (env) {
        return this.items.push(env), env; // افزودن آیتم به لیست.
      },
    },
    {
      key: "addItems",
      value: function (env) {
        for (var t = 0, i = env.length; t < i; t++) this.addItem(env[t]); // افزودن چندین آیتم به لیست.
      },
    },
    {
      key: "startTicker",
      value: function () {
        if (!this.isTicking) {
          this.isTicking = !0; // فعال کردن بروزرسانی.
          this.onFrameCbId = al(this.onFrameCb); // تنظیم تابع فراخوانی فریم.
        }
      },
    },
    {
      key: "stopTicker",
      value: function () {
        if (this.isTicking) {
          this.isTicking = !1; // غیرفعال کردن بروزرسانی.
          this.isSleeping = !0; // ورود به حالت خواب.
          al.cancel(this.onFrameCbId); // لغو بروزرسانی.
        }
      },
    },
    {
      key: "removeItem",
      value: function (env) {
        if (-1 !== this.items.indexOf(env)) {
          env.needsRemove = !1; // علامت‌گذاری آیتم برای حذف.
          this.itemsToRemove.push(env); // افزودن آیتم به صف حذف.
        }
      },
    },
    {
      key: "render",
      value: function () {
        if (this.isFirstFrameAfterUnlock) {
          this.isFirstFrameAfterUnlock = !1; // غیرفعال کردن فریم اول.
          this.container.style.top = ""; // بازنشانی موقعیت کانتینر.
          this.emit("firstFrameAfterUnlock"); // ارسال رویداد فریم اول.
        }
        if (!this.isInertialScroll) {
          for (var env, t; this.itemsToRemove.length; ) {
            env = this.itemsToRemove.pop();
            t = this.items.indexOf(env);
            this.items.splice(t, 1); // حذف آیتم از لیست.
          }
        }
        if (this.containerScrollable) {
          this.containerY += 0.08 * (this.scrollTop - this.containerY); // محاسبه حرکت کانتینر.
          this.diffProgress = Math.abs(this.containerY - this.containerOldY); // محاسبه تفاوت پیشرفت.
          this.hasActiveItem = 0.001 < this.diffProgress; // بررسی وجود آیتم فعال.
          if (!this.hasActiveItem) this.containerY = Math.round(this.containerY); // تنظیم کانتینر.
          this.container.style[ol] = `translate3d(0, ${-1 * this.containerY}px, 0)`; // اعمال موقعیت جدید.
          this.containerOldY = this.containerY; // ذخیره موقعیت قبلی.
        } else {
          this.containerY = this.scrollTop; // تنظیم موقعیت کانتینر.
        }
        for (var i = 0, n = this.items.length; i < n; i++) {
          var r = this.items[i];
          r.render(this); // فراخوانی متد رندر آیتم.
          if (!this.hasActiveItem) this.hasActiveItem = r.isActive; // بررسی وضعیت آیتم.
          if (r.needsRemove) this.removeItem(r); // حذف آیتم در صورت نیاز.
        }
        if (!this.isInertialScroll && this.onScrollExternalCb) {
          this.onScrollExternalCb(); // فراخوانی تابع اسکرول خارجی.
        }
        if (!this.hasActiveItem) this.isSleeping = !0; // تنظیم حالت خواب.
        this.isInertialScroll = !0; // فعال کردن اسکرول اینرسی.
      },
    },
    {
      key: "onFrame",
      value: function () {
        if (this.isSleeping) {
          this.isTicking = !1; // غیرفعال کردن بروزرسانی.
        } else {
          this.render(); // فراخوانی متد رندر.
          this.onFrameCbId = al(this.onFrameCb); // تنظیم تابع فراخوانی فریم.
        }
      },
    },
    {
      key: "onScroll",
      value: function (env) {
        if (!this.locked) {
          this.scrollTop =
            window.pageYOffset ||
            document.documentElement.scrollTop ||
            document.body.scrollTop ||
            0; // به‌روزرسانی موقعیت اسکرول.
          this.direction = this.scrollTop > this.oldScrollTop ? 1 : -1; // تشخیص جهت اسکرول.
          this.oldScrollTop = this.scrollTop; // ذخیره موقعیت قبلی.
          this.isInertialScroll = !1; // غیرفعال کردن اسکرول اینرسی.
          if (this.isSleeping) {
            this.isSleeping = !1; // خروج از حالت خواب.
            this.startTicker(); // شروع بروزرسانی.
          }
        }
      },
    },
  ]),
  r
);
    })(),
    hl = Ws("transform"),
    cl = (function (env) {
      function n() {
        var env,
          t =
            0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
        for (var i in (es(this, n),
        ((env = ls(this, rs(n).call(this))).isVisible = !1),
    (env.mediaMatched = !0), // آیا شرط‌های مدیا رعایت شده‌اند.
    (env.sticky = !1), // آیا عنصر چسبان است.
    (env.smoothScroll = !1), // آیا اسکرول نرم فعال است.
    (env.inView = !1), // آیا عنصر درون دید کاربر است.
    (env.trigger = null), // مقدار تریگر برای انیمیشن یا عملکرد.
    (env.calcTrigger = null), // تابع محاسبه مقدار تریگر.
    (env.data = {}), // داده‌های مرتبط با عنصر.
    (env.element = null), // عنصر مرتبط.
    (env.target = null), // هدف عملیات.
    (env.offset = 0), // آفست اولیه.
    (env.y = 0), // موقعیت محور Y.
    (env.oldY = 0), // موقعیت قبلی محور Y.
    (env.inertia = 0.068), // ضریب اینرسی برای حرکت.
    (env.duration = Number.MAX_VALUE), // مدت زمان عملکرد.
    (env.autoRemove = !0), // آیا عنصر به صورت خودکار حذف شود.
    (env.reverse = !0), // آیا انیمیشن معکوس شود.
    (env.triggered = !1), // آیا عنصر تریگر شده است.
    (env.media = null), // شرط‌های مدیا.
    (env.calcMaxY = null), // تابع محاسبه حداکثر محور Y.
    (env.calcOffset = null), // تابع محاسبه آفست.
    (env.calcDuration = null), // تابع محاسبه مدت زمان.
    (env.maxY = 0), // حداکثر مقدار محور Y.
    (env.onResize = null), // تابعی که در زمان تغییر اندازه اجرا می‌شود.
    (env.onUpdate = null), // تابعی که در زمان بروزرسانی اجرا می‌شود.
    (env.onEnter = null), // تابعی که هنگام ورود عنصر به نمایش اجرا می‌شود.
    (env.onExit = null), // تابعی که هنگام خروج عنصر از نمایش اجرا می‌شود.
    (env.toggleClass = null), // کلاس CSS برای تغییر وضعیت.
    (env.offsetOrigin = 0), // نقطه شروع آفست.
    (env.autoResize = !0), // آیا اندازه به صورت خودکار تغییر کند.
        t))
          void 0 !== env[i] && (env[i] = t[i]);
        return (
          (env.isActive = !1),
          (env.needsRemove = !1),
          (env.hasTrigger = env.trigger || env.calcTrigger),
          env.element || (env.element = env.target),
          (env.isNode = env.target && 0 < env.target.nodeType),
          env
        );
      }

      return (
        ns(n, Gs),
        is(n, [
          {
  key: "resize",
  value: function (env) {
    // بررسی اینکه آیا نیاز به تغییر اندازه خودکار وجود دارد
    var t =
      !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1];
    if (this.autoResize || !t) {
      // بررسی تطابق با شرایط مدیا
      if (
        ((this.mediaMatched =
          !this.media ||
          ("function" == typeof this.media
            ? this.media() // اگر شرط مدیا یک تابع باشد، اجرا می‌شود.
            : window.innerWidth > this.media)), // تطابق با عرض پنجره
        this.mediaMatched)
      ) {
        // بازنشانی استایل‌ها برای محاسبه
        var i = this.element.style[hl];
        (this.element.style[hl] = ""),
          (this.height = this.element.clientHeight), // محاسبه ارتفاع عنصر
          (this.top =
            env.scrollTop + this.element.getBoundingClientRect().top), // محاسبه موقعیت بالایی
          (this.bottom = this.top + this.height), // محاسبه موقعیت پایینی
          (this.offsetOrigin =
            this.top - 0.5 * (window.innerHeight - this.height)), // نقطه شروع آفست
          (this.element.style[hl] = i), // بازگردانی استایل اولیه
          this.calcMaxY && (this.maxY = this.calcMaxY()), // محاسبه حداکثر محور Y
          this.calcOffset && (this.offset = this.calcOffset()), // محاسبه آفست
          this.calcDuration && (this.duration = this.calcDuration()), // محاسبه مدت زمان
          this.calcTrigger && (this.trigger = this.calcTrigger()), // محاسبه تریگر
          this.onResize && this.onResize(); // اجرای رویداد تغییر اندازه
      } else {
        // بازنشانی اگر شرط مدیا رعایت نشده باشد
        this.reset();
      }
    }
  },
},
{
  key: "clear",
  value: function () {
    // پاکسازی استایل‌ها برای عناصر گره‌ای
    item.isNode && (item.target.style[hl] = "");
  },
},
{
  key: "reset",
  value: function () {
    // بازنشانی وضعیت در صورت وجود اسکرول نرم یا چسبندگی
    (this.smoothScroll || this.sticky) &&
      (this.target.style[hl] = ""),
      this.toggleClass &&
        this.target.classList.remove(this.toggleClass); // حذف کلاس مرتبط
  },
},
{
  key: "render",
  value: function (env) {
    if (this.mediaMatched) {
      // بررسی وضعیت مدیا
      var t, i, n;
      if (
        (this.smoothScroll &&
          ((i = (this.offsetOrigin - env.scrollTop) / env.pageHeight),
          (this.y += (i * this.offset - this.y) * this.inertia), // محاسبه حرکت نرم
          (t = Math.abs(i) < 1.5) &&
            !env.hasActiveItem &&
            ((n = Math.abs(this.y - this.oldY)),
            (this.isActive = 0.001 < n), // بررسی فعال بودن
            isActive || (item.y = Math.round(item.y))),
          (this.oldY = this.y),
          t &&
            (this.isNode
              ? (this.target.style[hl] =
                  "translate3d(0," + -this.y + "px,0)") // اعمال ترجمه در محور Y
              : (this.target.y = -this.y),
            this.onUpdate && this.onUpdate())),
        this.sticky &&
          env.containerScrollable &&
          ((this.y = env.containerY),
          this.maxY && this.y > this.maxY && (this.y = this.maxY), // محدود کردن محور Y
          (this.target.style[hl] =
            "translate3d(0," + this.y + "px,0)")), // چسباندن عنصر
        this.inView)
      ) {
        var r = this.isVisible;
        (this.isVisible = !(
          this.top + this.offset > env.containerY + env.windowHeight ||
          this.bottom < env.containerY
        )), // بررسی در دید بودن عنصر
          !r && this.isVisible
            ? (this.onEnter && this.onEnter(), // رویداد ورود
              this.toggleClass &&
                this.target.classList.add(this.toggleClass), // افزودن کلاس
              this.autoRemove && (this.needsRemove = !0)) // حذف خودکار
            : r &&
              !this.isVisible &&
              this.reverse &&
              (this.onExit && this.onExit(), // رویداد خروج
              this.toggleClass &&
                this.target.classList.remove(this.toggleClass)); // حذف کلاس
      }
      if (this.hasTrigger && !env.isInertialScroll) {
        // بررسی تریگر
        var a = this.triggered;
        (this.triggered =
          env.scrollTop >= this.trigger &&
          env.scrollTop <= this.trigger + this.duration), // شرایط تریگر
          !a && this.triggered
            ? (this.onEnter && this.onEnter(), // رویداد ورود به تریگر
              this.toggleClass &&
                this.target.classList.add(this.toggleClass), // افزودن کلاس
              this.autoRemove && (this.needsRemove = !0)) // حذف خودکار
            : a &&
              !this.triggered &&
              (this.onExit && this.onExit(), // رویداد خروج از تریگر
              this.toggleClass &&
                this.target.classList.remove(this.toggleClass)); // حذف کلاس
                }
              }
            },
          },
        ]),
        n
      );
    })(),
    ul = "light",
    pl = "dark";
  Ts._gsDefine.plugin({
    propName: "attr",
    API: 2,
    version: "0.6.1",
    init: function (env, t, i, n) {
      var r, a;
      if ("function" != typeof env.setAttribute) return !1;
      for (r in t)
        "function" == typeof (a = t[r]) && (a = a(n, env)),
          this._addTween(
            env,
            "setAttribute",
            env.getAttribute(r) + "",
            a + "",
            r,
            !1,
            r,
          ),
          this._overwriteProps.push(r);
      return !0;
    },
  }),
    env(function (env) {
      var t = env.exports && void 0 !== GlobalReference ? GlobalReference : GlobalReference || window;
      (t._gsQueue || (t._gsQueue = [])).push(function () {
        function EnsureFunction(env, t, i, n) {
          return (
            (i = parseFloat(i) - parseFloat(env)),
            (n = parseFloat(n) - parseFloat(t)),
            Math.sqrt(i * i + n * n)
          );
        }

        function GlobalReference(env) {
          return (
            ("string" != typeof env && env.nodeType) ||
              ((env = t.TweenLite.selector(env)).length && (env = env[0])),
            env
          );
        }

        function MathFloorShortcut(env) {
          if (!env) return 0;
          var t,
            i,
            n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction = (env = GlobalReference(env)).tagName.toLowerCase();
          if ("path" === HelperFunction) t = env.getTotalLength() || 0;
          else if ("rect" === HelperFunction) t = 2 * ((i = env.getBBox()).width + i.height);
          else if ("circle" === HelperFunction)
            t = 2 * Math.PI * parseFloat(env.getAttribute("r"));
          else if ("line" === HelperFunction)
            t = EnsureFunction(
              env.getAttribute("x1"),
              env.getAttribute("y1"),
              env.getAttribute("x2"),
              env.getAttribute("y2"),
            );
          else if ("polyline" === HelperFunction || "polygon" === HelperFunction)
            for (
              a = (n = env.getAttribute("points").split(" "))[(t = 0)].split(","),
                "polygon" === HelperFunction &&
                  (n.push(n[0]), -1 === n[0].indexOf(",") && n.push(n[1])),
                ObjectMethodWrapper = 1;
              ObjectMethodWrapper < n.length;
              ObjectMethodWrapper++
            )
              1 === (r = n[ObjectMethodWrapper].split(",")).length && (r[1] = n[ObjectMethodWrapper++]),
                2 === r.length &&
                  ((t += EnsureFunction(a[0], a[1], r[0], r[1]) || 0), (a = r));
          else
            "ellipse" === HelperFunction &&
              ((CounterVariable = parseFloat(env.getAttribute("rx"))),
              (RandomGenerator = parseFloat(env.getAttribute("ry"))),
              (t =
                Math.PI *
                (3 * (CounterVariable + RandomGenerator) - Math.sqrt((3 * CounterVariable + RandomGenerator) * (CounterVariable + 3 * RandomGenerator)))));
          return t || 0;
        }

        var env,
          a = document.defaultView
            ? document.defaultView.getComputedStyle
            : function () {};

        function f(env, t) {
          if (!env) return [0, 0];
          (env = GlobalReference(env)), (t = t || MathFloorShortcut(env) + 1);
          var i = a(env),
            n = i.strokeDasharray || "",
            r = parseFloat(i.strokeDashoffset);
          return (
            t <
              (n =
                -1 === n.indexOf(" ")
                  ? t
                  : parseFloat(n.split(" ")[0]) || 1e-5) && (n = t),
            [Math.max(0, -r), n - r]
          );
        }

        ((env = t._gsDefine.plugin({
          propName: "drawSVG",
          API: 2,
          version: "0.0.4",
          global: !0,
          overwriteProps: ["drawSVG"],
          init: function (env, t, i) {
            if (!env.getBBox) return !1;
            var n,
              r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator,
              HelperFunction,
              EnsureFunction,
              GlobalReference,
              Property = MathFloorShortcut(env) + 1;
            return (
              (this._style = env.style),
              !0 === t || "true" === t
                ? (t = "0 100%")
                : t
                  ? -1 === (t + "").indexOf(" ") && (t = "0 " + t)
                  : (t = "0 0"),
              (n = f(env, Property)),
              (ObjectMethodWrapper = t),
              (CounterVariable = Property),
              (RandomGenerator = n[0]),
              (GlobalReference = ObjectMethodWrapper.indexOf(" ")),
              (EnsureFunction =
                -1 === GlobalReference
                  ? ((HelperFunction = void 0 !== RandomGenerator ? RandomGenerator + "" : ObjectMethodWrapper), ObjectMethodWrapper)
                  : ((HelperFunction = ObjectMethodWrapper.substr(0, GlobalReference)), ObjectMethodWrapper.substr(GlobalReference + 1))),
              (HelperFunction =
                -1 !== HelperFunction.indexOf("%")
                  ? (parseFloat(HelperFunction) / 100) * CounterVariable
                  : parseFloat(HelperFunction)),
              (r =
                (EnsureFunction =
                  -1 !== EnsureFunction.indexOf("%")
                    ? (parseFloat(EnsureFunction) / 100) * CounterVariable
                    : parseFloat(EnsureFunction)) < HelperFunction
                  ? [EnsureFunction, HelperFunction]
                  : [HelperFunction, EnsureFunction]),
              (this._length = Property + 10),
              0 === n[0] && 0 === r[0]
                ? ((a = Math.max(1e-5, r[1] - Property)),
                  (this._dash = Property + a),
                  (this._offset = Property - n[1] + a),
                  this._addTween(
                    this,
                    "_offset",
                    this._offset,
                    Property - r[1] + a,
                    "drawSVG",
                  ))
                : ((this._dash = n[1] - n[0] || 1e-6),
                  (this._offset = -n[0]),
                  this._addTween(
                    this,
                    "_dash",
                    this._dash,
                    r[1] - r[0] || 1e-5,
                    "drawSVG",
                  ),
                  this._addTween(
                    this,
                    "_offset",
                    this._offset,
                    -r[0],
                    "drawSVG",
                  )),
              !0
            );
          },
          set: function (env) {
            this._firstPT &&
              (this._super.setRatio.call(this, env),
              (this._style.strokeDashoffset = this._offset),
              (this._style.strokeDasharray = this._dash + " " + this._length));
          },
        })).getLength = MathFloorShortcut),
          (env.getPosition = f);
      }),
        t._gsDefine && t._gsQueue.pop()();
    });
  var dl = 0,
    fl = new ((function (env) {
      function t() {
        var env;
        return (
          es(this, t),
      // استفاده از الگوی ES6 برای ساختاردهی کلاس
      es(this, t), // فراخوانی سازنده کلاس والد
      ((env = ls(this, rs(t).call(this))).color = dl), // مقداردهی اولیه رنگ
      (env.element = document.querySelector(".logo")), // انتخاب عنصر اصلی لوگو
      (env.maskRect = document.querySelector("#logo__mask rect")), // انتخاب ماسک مستطیل
      (env.shapePath = env.element.querySelector(
        ".logo__img path[data-id=shape]"
      )), // انتخاب مسیر شکل لوگو
      (env.textPath = env.element.querySelector(
        ".logo__img path[data-id=text]"
      )), // انتخاب مسیر متن لوگو
      (env.textPath.style.clipPath = "url(#logo__mask)"), // تنظیم clipPath برای متن لوگو
      (env.isVisible = !1), // مقدار اولیه وضعیت نمایش به صورت غیرفعال
      app.hasTouch || // بررسی وجود دستگاه لمسی
        (env.element.addEventListener(
          "mouseenter",
          env.onRollOver.bind(StringStorage(StringStorage(env))) // افزودن رویداد برای ورود ماوس
        ),
        env.element.addEventListener(
          "mouseleave",
          env.onRollOut.bind(StringStorage(StringStorage(env))),
            )),
          env
        );
      }

      return (
        ns(t, ps),
        is(t, [
          {
        key: "setColor",
        value: function (env) {
          // متدی برای تنظیم رنگ لوگو
          env !== this.color && (this.color = env); // اگر رنگ جدید متفاوت باشد، آن را تنظیم می‌کند
        },
      },
      {
        key: "show",
        value: function () {
          // متدی برای نمایش لوگو
          (this.isVisible = !0), // تنظیم وضعیت نمایش
            (this.element.style.visibility = "inherit"); // نمایش عنصر
        },
      },
      {
        key: "onRollOver",
        value: function () {
          // متدی برای رویداد ورود ماوس
          var env = this.element.querySelector(".logo__img-background"); // انتخاب پس‌زمینه لوگو
          Ss.killTweensOf([env, this.shapePath]), // حذف انیمیشن‌های قبلی
            new Us()
              .set(env, { visibility: "inherit" }) // نمایش پس‌زمینه
              .to(this.shapePath, 0.7, {
                drawSVG: "100% 100%", // تنظیم انیمیشن
                ease: Os.easeOut,
              });
        },
      },
      {
        key: "onRollOut",
        value: function () {
          // متدی برای رویداد خروج ماوس
          var env = this.element.querySelector(".logo__img-background"); // انتخاب پس‌زمینه لوگو
          Ss.killTweensOf([env, this.shapePath]), // حذف انیمیشن‌های قبلی
            new Us()
              .to(this.shapePath, 0.7, {
                drawSVG: "100% 0", // تنظیم انیمیشن برای برگشت
                ease: Os.easeOut,
              })
              .set(env, { clearProps: "visibility" }); // پاک‌سازی ویژگی‌های نمایش
            },
          },
        ]),
        t
      );
    })())(),
    ml = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this))).pageId = env.id),
          (t.element = document.querySelector(".main-loading")),
          (t.progressElement = t.element.querySelector(
            ".main-loading__bar__progress",
          )),
          (t.progress = 0),
          (t.progressTween = null),
          (t.timeline = null),
          t
        );
      }

      return (
        ns(i, ps),
        is(i, [
          {
      key: "dispose",
      value: function () {}, // متد خالی برای آزادسازی منابع
    },
    {
      key: "animateIn",
      value: function () {
        // متدی برای اجرای انیمیشن ورودی
        if ("msie" === app.browser) return this.animateInWithoutCss(); // بررسی مرورگر برای اجرای انیمیشن بدون CSS
        var i = Ws("animation-play-state"), // بررسی وضعیت اجرای انیمیشن
          env = new Promise(function (env) {
            if (Modernizr.cssanimations) {
              // بررسی پشتیبانی مرورگر از انیمیشن‌های CSS
              var t = document.querySelector(".main-loading__bar__total");
              "running" === getComputedStyle(t).getPropertyValue(i)
                ? t.addEventListener("animationend", env)
                : env();
            } else env();
          }),
          t = new Promise(function (env) {
            if (Modernizr.cssanimations) {
              var t = document.querySelector(
                ".main-loading__logo path[data-id=shape]"
              );
              "running" === getComputedStyle(t).getPropertyValue(i)
                ? t.addEventListener("animationend", env)
                : env();
            } else env();
          });
        return Promise.all([env, t]).then(
          this.onAnimateInComplete.bind(this)
        ); // اجرای عملیات پس از تکمیل انیمیشن‌ها
      },
    },
    {
      key: "animateInWithoutCss",
      value: function () {
        // اجرای انیمیشن بدون CSS
        var t = new Us(),
          env = new Promise(function (env) {
            t.eventCallback("onComplete", function () {
              env(!0); // تکمیل انیمیشن
            });
          });
        return (
          t
            .fromTo(
              ".main-loading__bar__total",
              0.9,
              { opacity: 1, scaleY: 0 },
              {
                opacity: 0.1,
                scaleY: 1,
                ease: Fs.easeInOut,
              },
              0
            )
            .fromTo(
              ".main-loading__logo path[data-id=shape]",
              1.2,
              { opacity: 1, drawSVG: 0 },
              {
                opacity: 0.1,
                drawSVG: "100%",
                ease: Fs.easeInOut,
              },
              0.5
            ),
          env.then(this.onAnimateInComplete.bind(this))
        );
      },
    },
    {
      key: "animateOut",
      value: function () {
        // متدی برای اجرای انیمیشن خروجی
        var t = new Us()
          .to(
            this.progressElement,
            0.7,
            {
              scaleY: 0,
              yPercent: -100,
              ease: Fs.easeInOut,
            },
            0
          )
          .fromTo(
            ".main-loading__bar__total",
            0.9,
            { opacity: 0.1, animation: "none" },
            {
              scaleY: 0,
              yPercent: -100,
              ease: Fs.easeInOut,
            },
            0.4
          );
        if ("home" === this.pageId) {
          // تنظیم انیمیشن برای صفحه اصلی
          var env = document
              .querySelector(".main-loading__logo")
              .getBoundingClientRect(),
            i = fl.element.getBoundingClientRect();
          t.to(
            ".main-loading__inner",
            1.2,
            {
              y: i.y - env.y,
              ease: Fs.easeInOut,
            },
            0
          ).to(
            ".main-loading__logo path[data-id=text]",
            0.3,
            { opacity: 0.1 },
            0
          );
        } else {
          // تنظیم انیمیشن برای صفحات دیگر
          t.to(
            ".main-loading__logo",
            0.7,
            { y: -30, ease: Fs.easeInOut },
            0
          )
            .from(
              fl.element,
              0.7,
              {
                y: 30,
                ease: Fs.easeOut,
              },
              0.4
            )
            .from(
              fl.shapePath,
              0.9,
              {
                drawSVG: 0,
                ease: Fs.easeOut,
              },
              0.4
            )
            .fromTo(
              ".main-loading__logo path[data-id=shape]",
              0.7,
              {
                animation: "none",
                opacity: 0.2,
                strokeDashoffset: 0,
              },
              { drawSVG: "100% 100%", ease: Os.easeInOut },
              0
            )
            .set(fl.element, {
              clearProps: "x,y,scaleX,scaleY",
              immediateRender: !1,
            });
        }
        return new Promise(function (env) {
          t.eventCallback("onComplete", function () {
            env(!0);
          });
        }).then(this.onAnimateOutComplete.bind(this));
      },
    },
    {
      key: "setProgress",
      value: function (env) {
        // تنظیم پیشرفت انیمیشن
        if (!(env < this.progress)) {
          var t =
            2.5 *
            (env -
              ((this.progressElement._gsTransform &&
                this.progressElement._gsTransform.scaleY) ||
                0));
          (this.progress = env),
            this.progressTween && this.progressTween.kill(),
            (this.progressTween = Ss.to(this.progressElement, t, {
              scaleY: this.progress,
              ease: Ns.easeOut,
              onComplete: this.onProgressTweenComplete.bind(this),
            }));
        }
      },
    },
    {
      key: "resetProgress",
      value: function () {
        // بازنشانی پیشرفت
        this.setProgress(0);
      },
    },
    {
      key: "resize",
      value: function (env) {}, // متد خالی برای تغییر اندازه
    },
    {
      key: "onAnimateInComplete",
      value: function () {
        // متدی برای تکمیل انیمیشن ورودی
        this.progress ||
          ((this.progress = 0.65),
          (this.progressTween = Ss.to(this.progressElement, 4, {
            scaleY: this.progress,
            ease: Sine.easeInOut,
          })));
      },
    },
    {
      key: "onAnimateOutComplete",
      value: function () {
        // متدی برای تکمیل انیمیشن خروجی
        this.element.style.visibility = "hidden";
      },
    },
    {
      key: "onProgressTweenComplete",
      value: function () {
        // متدی برای تکمیل انیمیشن پیشرفت
        1 === this.progress && this.onComplete();
      },
    },
    {
      key: "onComplete",
      value: function () {
        // متدی برای اتمام کل فرآیند
        this.isComplete ||
          ((this.isComplete = !0), this.emit("complete"));
            },
          },
        ]),
        i
      );
    })(),
    GlobalReference = (function (env) {
      function i(env) {
        var t;
        return (
      es(this, i), // تنظیم ارث‌بری
      ((t = ls(this, rs(i).call(this))).pageId = env.id), // مقداردهی اولیه شناسه صفحه
      (t.element = document.querySelector(".ajax-loading")), // انتخاب عنصر بارگذاری
      (t.line = t.element.querySelector(".ajax-loading__line")), // خط بارگذاری
      (t.lineBackground = t.element.querySelector(".ajax-loading__line__background")), // پس‌زمینه خط بارگذاری
      (t.lineProgress = t.element.querySelector(".ajax-loading__line__progress")), // پیشرفت خط بارگذاری
      (t.progress = 0), // مقدار پیشرفت
      (t.progressTween = null), // تنظیم مقدار اولیه برای انیمیشن پیشرفت
      (t.timeline = null), // خط زمانی انیمیشن
      t
    );
  }

  return (
    ns(i, ps), // ارث‌بری از کلاس اصلی
    is(i, [
      {
        key: "dispose",
        value: function () {}, // متد خالی برای آزادسازی منابع
      },
      {
        key: "animateIn",
        value: function () {
          // اجرای انیمیشن ورود
          (this.progress = 0),
            (this.isComplete = !1),
            (this.element.style.visibility = "inherit"); // نمایش عنصر
          var t = new Us()
            .set(this.line, { scaleY: 1 }) // تنظیم خط بارگذاری
            .set(this.lineProgress, { scaleY: 0 }) // بازنشانی پیشرفت
            .fromTo(
              this.lineBackground,
              0.8,
              { scaleY: 0 }, // مقدار اولیه
              {
                scaleY: 1, // مقدار نهایی
                ease: Fs.easeOut, // افکت انیمیشن
              }
            );
          return new Promise(function (env) {
            // استفاده از Promise برای اتمام انیمیشن
            t.eventCallback("onComplete", function () {
              env(!0);
            });
          }).then(this.onAnimateInComplete.bind(this));
        },
      },
      {
        key: "animateOut",
        value: function () {
          // اجرای انیمیشن خروج
          var env = app.windowWidth < app.screenM ? 0 : 0.3,
            t = new Us().to(
              this.line,
              0.8,
              { scaleY: 0, ease: Fs.easeInOut }, // تنظیم افکت انیمیشن
              env
            );
          return (
            ("home" === this.pageId || app.windowWidth < app.screenM) &&
              t.to(
                this.line,
                0.8,
                {
                  yPercent: -100, // جابجایی خط
                  ease: Fs.easeInOut,
                },
                env
              ),
            new Promise(function (env) {
              t.eventCallback("onComplete", function () {
                env(!0);
              });
            }).then(this.onAnimateOutComplete.bind(this))
          );
        },
      },
      {
        key: "resize",
        value: function (env) {}, // متد خالی برای تغییر اندازه
      },
      {
        key: "setProgress",
        value: function (env) {
          // متد تنظیم پیشرفت بارگذاری
          if (!(env < this.progress)) {
            var t =
              1 *
              (env -
                ((this.lineProgress._gsTransform &&
                  this.lineProgress._gsTransform.scaleY) ||
                  0));
            (this.progress = env), // مقداردهی پیشرفت
              this.progressTween && this.progressTween.kill(), // متوقف کردن انیمیشن پیشین
              (this.progressTween = Ss.to(this.lineProgress, t, {
                scaleY: this.progress, // مقدار جدید
                ease: Power4.easeOut, // افکت
                onComplete: this.onProgressTweenComplete.bind(this), // اتمام انیمیشن
              }));
          }
        },
      },
      {
        key: "onProgressTweenComplete",
        value: function () {
          // اتمام پیشرفت بارگذاری
          1 === this.progress && this.onComplete();
        },
      },
      {
        key: "onComplete",
        value: function () {
          // عملیات تکمیلی پس از اتمام
          this.isComplete ||
            ((this.isComplete = !0), this.emit("complete"));
        },
      },
      {
        key: "onAnimateInComplete",
        value: function () {
          // تنظیم پیشرفت پس از تکمیل انیمیشن ورود
          this.progress ||
            ((this.progress = 0.65),
            (this.progressTween = Ss.to(this.lineProgress, 4, {
              scaleY: this.progress,
              ease: Rs.easeInOut,
            })));
        },
      },
      {
        key: "onAnimateOutComplete",
        value: function () {
          // پنهان کردن عنصر پس از انیمیشن خروج
          (this.element.style.visibility = "hidden"),
            Ss.set(this.line, { clearProps: "all" });
            },
          },
        ]),
        i
      );
    })(),
    vl = { OPEN: 0, CLOSE: 1 },
    yl = new ((function (env) {
function i() {
  var env;
  // ایجاد یک شی جدید برای مدیریت نوار تغییر وضعیت (Navigation Toggle)
  es(this, i); // فراخوانی ارث‌بری پایه
  ((env = ls(this, rs(i).call(this))).state = vl.OPEN), // مقداردهی اولیه وضعیت به باز (OPEN)
    (env.element = document.querySelector(".nav-toggle")), // انتخاب عنصر HTML اصلی نوار تغییر وضعیت
    env.element.addEventListener(
      "click",
      env.onClick.bind(StringStorage(StringStorage(env))),
    ), // افزودن رویداد کلیک برای مدیریت تغییر وضعیت
    env.element.addEventListener(
      "mouseleave",
      env.onRollOut.bind(StringStorage(StringStorage(env))),
    ), // افزودن رویداد خروج موس از عنصر
    env.element.addEventListener(
      "mouseenter",
      env.onRollOver.bind(StringStorage(StringStorage(env))),
    ), // افزودن رویداد ورود موس به عنصر

    // انتخاب عناصر مرتبط با متن‌های باز و بسته
    (env.textOpenElement = env.element.querySelector(
      ".nav-toggle__text--open",
    )),
    (env.textCloseElement = env.element.querySelector(
      ".nav-toggle__text--close",
    )),

    // تنظیم تایملاین انیمیشن برای کنترل تغییرات
    (env.timeline = null),

    // انتخاب عناصر مرتبط با شکل‌ها و مسیرهای SVG
    (env.shapeElement = env.element.querySelector(".nav-toggle__shape")),
    (env.shapePaths = env.shapeElement.querySelectorAll("path")),
    (env.shapePathStrokeDashoffset = 110), // مقداردهی اولیه برای مقدار جابجایی مسیرها

    // انتخاب عناصر مرتبط با خطوط و مقیاس
    (env.lineElement = env.element.querySelector(".nav-toggle__line")),
    (env.lineElements = env.lineElement.querySelectorAll("span"));

  // دریافت مقیاس اولیه خطوط از ویژگی‌های CSS
  var t = window
    .getComputedStyle(env.lineElements[1]) // دریافت سبک محاسبه‌شده عنصر
    .getPropertyValue(Ws("transform")) // دریافت مقدار خاصیت `transform`
    .split("(")[1]
    .split(")")[0]
    .split(",");
  return (env.lineScale = parseFloat(t[0])), env; // تبدیل مقیاس به عدد اعشاری و مقداردهی
}

return (
  ns(i, ps), // اعمال وراثت بین کلاس‌ها
  is(i, [
    {
      // متد برای تغییر وضعیت نوار (باز یا بسته)
      key: "toggleState",
      value: function () {
        this.setState(this.state === vl.OPEN ? vl.CLOSE : vl.OPEN); // تغییر وضعیت بر اساس وضعیت فعلی
      },
    },
    {
      // متد برای تنظیم وضعیت نوار (باز یا بسته)
      key: "setState",
      value: function (env) {
        if (env !== this.state) {
          this.state = env; // به‌روزرسانی وضعیت
          this.element.classList.toggle("nav-toggle--open", this.state !== vl.OPEN); // تغییر کلاس بر اساس وضعیت
          if (this.timeline) this.timeline.kill(); // خاتمه انیمیشن‌های قبلی
          this.timeline = new Us({
            onComplete: this.onTimelineComplete.bind(this), // تنظیم رویداد تکمیل انیمیشن
          });
          // اجرای انیمیشن بر اساس وضعیت جدید
          env === vl.CLOSE ? this.animToCloseState() : this.animToOpenState();
        }
      },
    },
    {
      // انیمیشن برای تغییر وضعیت به بسته
      key: "animToCloseState",
      value: function () {
        this.timeline
          .set([this.shapeElement, this.textOpenElement], {
            visibility: "inherit",
          })
          .to(this.shapePaths[1], 0.7, { drawSVG: "50% 50%" }, 0) // تغییر انیمیشن مسیر SVG
          .to(this.shapePaths[0], 0.7, { drawSVG: "50% 50%" }, 0.3)
          .to(this.textOpenElement, 0.4, { opacity: 0, x: -14 }, 0)
          .fromTo(
            this.textCloseElement,
            0.7,
            { opacity: 0, x: 14 },
            { opacity: 1, x: 0 },
            0.4,
          )
          .fromTo(this.lineElement, 0.4, { scaleX: 0 }, { scaleX: 1 }, 0.4)
          .fromTo(
            this.lineElements[1],
            0.4,
            { scaleX: 1 },
            { scaleX: this.lineScale },
            0.6,
          );
      },
    },
    {
      // انیمیشن برای تغییر وضعیت به باز
      key: "animToOpenState",
      value: function () {
        this.timeline
          .set([this.lineElement, this.textCloseElement], {
            visibility: "inherit",
          })
          .to(this.textCloseElement, 0.4, { opacity: 0, x: 14, ease: Rs.easeIn }, 0.3)
          .to(this.lineElements[1], 0.4, { scaleX: 1 }, 0)
          .to(this.lineElement, 0.4, { scaleX: 0, ease: Rs.easeInOut }, 0.3)
          .to(this.shapePaths[0], 0.7, { drawSVG: "0% 100%" }, 0.3)
          .to(this.shapePaths[1], 0.7, { drawSVG: this.shapePathStrokeDashoffset, ease: Rs.easeInOut }, 0.4)
          .to(this.textOpenElement, 0.7, { opacity: 1, x: 0, ease: Rs.easeOut }, 0.6);
      },
    },
    {
      // نمایش عنصر و تنظیمات اولیه
      key: "show",
      value: function () {
        this.element.style.visibility = "inherit"; // تغییر وضعیت نمایش عنصر
        TweenLite.set(this.shapePaths[1], { drawSVG: this.shapePathStrokeDashoffset }); // مقداردهی اولیه برای مسیر SVG
        TweenLite.from(this.element, 0.7, { opacity: 0 }); // انیمیشن ورود
      },
    },
    {
      // مدیریت کلیک برای تغییر وضعیت
      key: "onClick",
      value: function () {
        this.toggleState(); // تغییر وضعیت نوار
        this.emit("click", { state: this.state }); // انتشار رویداد کلیک
      },
    },
    {
      // مدیریت ورود موس به عنصر
      key: "onRollOver",
      value: function () {
        if (!this.timeline) {
          if (this.state === vl.OPEN) {
            TweenLite.to(this.shapePaths[1], 0.7, { drawSVG: "100%", ease: Os.easeOut });
            TweenLite.to(this.textOpenElement, 0.7, { x: -10, ease: Os.easeOut });
          } else {
            TweenLite.to(this.lineElements[1], 0.7, { scaleX: 1 - this.lineScale, ease: Os.easeOut });
          }
        }
      },
    },
    {
      // مدیریت خروج موس از عنصر
      key: "onRollOut",
      value: function () {
        if (!this.timeline) {
          if (this.state === vl.OPEN) {
            TweenLite.to(this.shapePaths[1], 0.7, { drawSVG: this.shapePathStrokeDashoffset, ease: Os.easeOut });
            TweenLite.to(this.textOpenElement, 0.7, { x: 0, ease: Os.easeOut });
          } else {
            TweenLite.to(this.lineElements[1], 0.7, { scaleX: this.lineScale, ease: Os.easeOut });
          }
        }
      },
    },
    {
      // رویداد تکمیل انیمیشن
      key: "onTimelineComplete",
      value: function () {
        this.timeline = null; // حذف تایملاین پس از اتمام انیمیشن
      },
    },
  ]),
  i
);
    })())(),
    _l = new ((function () {
      function env() {
        es(this, env),
          (this.element = document.querySelector(".subscribe-cta")),
          (this.isVisible = !1);
      }

      return (
        is(env, [
          {
            key: "show",
            value: function () {
              (this.isVisible = !0),
                (this.element.style.visibility = "inherit"),
                Ss.from(this.element, 0.7, { opacity: 0 });
            },
          },
        ]),
        env
      );
    })())();
  var xl,
    bl,
    wl,
    Tl = !1,
    Sl = "analytics-allowed";

  function El(env) {
    (Tl = env) && wl && Al(wl),
      (bl.style.display = "none"),
      localStorage.setItem(Sl, Tl);
  }

  function Al(env) {
    var t, i;
    ((wl = env), Tl) &&
      ((t = xl), (i = env), window.gtag && window.gtag("config", t, i));
  }

  function Ml() {
    El(!0);
  }

  function Pl() {
    El(!1);
  }

  var Ll = {
    init: function () {
      var env =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
      xl = env.id;
      var t = localStorage.getItem(Sl);
      t
        ? (Tl = "true" === t)
        : ((bl = document.querySelector(".analytics-banner"))
            .querySelector(".analytics-banner__action--accept")
            .addEventListener("click", Ml),
          bl
            .querySelector(".analytics-banner__action--decline")
            .addEventListener("click", Pl),
          (bl.style.visibility = "inherit"));
    },
    trackPage: Al,
  };
  var Cl = (function (env) {
    function i(env) {
      var t;
      return (
        es(this, i),
    // مقداردهی اولیه به متغیرها و خواص
    ((t = ls(this, rs(i).call(this))).id = env.id),
    (t.owner = env.owner), // مالک صفحه
    (t.element = env.element), // عنصر اصلی صفحه
    (t.prevScreenData = env.prevScreenData), // داده‌های صفحه قبلی
    (t.url = env.url || window.location.url), // آدرس URL صفحه
    (t.color = env.color), // رنگ صفحه
    (t.isAjax = !t.element), // تشخیص اگر صفحه از طریق AJAX بارگذاری شده است
    (t.screenData = { id: t.id }), // داده‌های صفحه
    (t.isVisible = !1), // وضعیت نمایش صفحه
    (t.isLoading = !1), // وضعیت بارگذاری صفحه
    (t.loadingAnim = null), // انیمیشن بارگذاری
    (t.numAssetsToLoad = 0), // تعداد منابعی که باید بارگذاری شوند
    (t.numAssetsLoaded = 0), // تعداد منابعی که بارگذاری شده‌اند
    (t.loadAssetsTimeOut = -1), // تایم‌اوت برای بارگذاری منابع
    (t.timeline = null), // تایملاین انیمیشن‌ها
    (t.splitSectionHeads = null), // مدیریت متون تقسیم‌بندی‌شده
    (t.hasScrollbar = !0), // وجود اسکرول‌بار
    (t.sectionElementsToAnimateIn =
      ".page__section__title, .page__section__head, .page__section__body, .page__list__item"), // عناصر قابل انیمیشن در صفحه
    (t.lineStepsSelector = null), // انتخاب‌گر مراحل خط
    (t.container = document.querySelector(".page-container")), // محفظه صفحه
    // اگر صفحه AJAX باشد، رنگ آن را به‌روزرسانی کرده و کلاس مربوطه اضافه می‌شود
    t.isAjax
      ? (document.body.classList.add("page-id-" + t.id), t.updateColor())
      : t.initPage(),
    t
  );
}

return (
  ns(i, bs),
  is(i, [
    {
      // متد مقداردهی اولیه به صفحه
      key: "initPage",
      value: function () {
        this.isAjax && this.initAjaxPage(), // مقداردهی به صفحه AJAX
        this.initScrollCTA(), // مقداردهی به دکمه CTA اسکرول
        this.initLine(), // مقداردهی به خطوط
        this.initScroll(), // مقداردهی به قابلیت اسکرول
        this.updateTitle(), // به‌روزرسانی عنوان صفحه
        this.detectScrollbar(); // تشخیص وجود اسکرول‌بار
      },
    },
    {
      // مقداردهی به صفحه AJAX
      key: "initAjaxPage",
      value: function () {
        this.container.appendChild(this.element); // اضافه کردن محتوای صفحه به محفظه
      },
    },
    {
      // مقداردهی به دکمه CTA اسکرول
      key: "initScrollCTA",
      value: function () {
        var env = this.element.querySelector(".scroll-cta");
        env && (this.scrollCTA = new Hs({ element: env })); // ایجاد شیء CTA اسکرول
      },
    },
    {
      // مقداردهی به خطوط
      key: "initLine",
      value: function () {
        var env = this.element.querySelector(".page__line");
        env &&
          (this.line = new QueryString({
            element: env,
            stepsSelector: this.lineStepsSelector, // انتخاب‌گر مراحل خطوط
          }));
      },
    },
    {
      // مقداردهی به قابلیت اسکرول
      key: "initScroll",
      value: function () {
        var env = this;
        (this.scroll = new LoopLimit({ containerScrollable: !app.isMobile })),
          this.scrollCTA &&
            this.scroll.addItem(
              new cl({
                element: this.scrollCTA.element,
                autoRemove: !1,
                calcTrigger: function () {
                  return 0.25 * window.innerHeight; // محاسبه تریگر اسکرول
                },
                onEnter: function () {
                  env.scrollCTA.setVisibility(!1); // مخفی کردن CTA هنگام ورود به تریگر
                },
                onExit: function () {
                  env.scrollCTA.setVisibility(!0); // نمایش CTA هنگام خروج از تریگر
                },
              }),
            ),
          this.line && this.scroll.addItem(this.line);
      },
    },
    {
      // متد تخریب و پاک‌سازی منابع
      key: "dispose",
      value: function () {
        hs(rs(i.prototype), "dispose", this).call(this),
          this.element && this.element.parentNode.removeChild(this.element),
          this.disposeLoadingAnim(),
          this.disposeTimeline(),
          this.disposeScrollCTA(),
          this.disposeLine(),
          this.disposeScroll();
      },
    },
    {
      // تخریب انیمیشن بارگذاری
      key: "disposeLoadingAnim",
      value: function () {
        this.loadingAnim &&
          (this.loadingAnim.dispose(),
          this.loadingAnim.off("complete"),
          (this.loadingAnim = null));
      },
    },
    {
      // تخریب دکمه CTA اسکرول
      key: "disposeScrollCTA",
      value: function () {
        this.scrollCTA &&
          (this.scrollCTA.dispose(), (this.scrollCTA = null));
      },
    },
    {
      // تخریب خطوط
      key: "disposeLine",
      value: function () {
        this.line && (this.line.dispose(), (this.line = null));
      },
    },
    {
      // تخریب قابلیت اسکرول
      key: "disposeScroll",
      value: function () {
        this.scroll && (this.scroll.dispose(), (this.scroll = null));
      },
    },
    {
      // تخریب تایملاین انیمیشن
      key: "disposeTimeline",
      value: function () {
        if (this.timeline) {
          if ((this.timeline.kill(), this.splitSectionHeads)) {
            for (; this.splitSectionHeads.length; ) {
              this.splitSectionHeads.shift().revert();
            }
            this.splitSectionHeads = null;
          }
          Ds(this.timeline), (this.timeline = null);
        }
      },
    },
    {
      // تشخیص اسکرول‌بار در صفحه
      key: "detectScrollbar",
      value: function () {
        (this.hasScrollbar = this.element.scrollHeight > app.windowHeight),
          document.body.classList.toggle(
            "js-no-scrollbar",
            !this.hasScrollbar,
          );
      },
    },
    {
      // به‌روزرسانی عنوان صفحه
      key: "updateTitle",
      value: function () {
        var env = this.element.getAttribute("data-title");
        env && env.length && (document.title = env); // تغییر عنوان سند
      },
    },
    {
      // به‌روزرسانی رنگ صفحه
      key: "updateColor",
      value: function () {
        var env = this.color || this.element.getAttribute("data-color") || pl;
        this.changeColor(env); // تغییر رنگ
          },
        },
        {
          key: "changeColor",
          value: function (env) {
            var t = "color-" + env;
            if (!document.body.classList.contains(t)) {
              var i = "color-" + (env === ul ? pl : ul);
              document.body.classList.add(t), document.body.classList.remove(i);
            }
          },
        },
        {
          key: "load",
          value: function () {
            (this.isLoading = !0),
              this.isAjax ? this.loadHtml() : this.loadAssets();
          },
        },
        {
          key: "loadHtml",
          value: function () {
            window
              .fetch(this.url, {
                headers: {
                  "ObjectKeys-Requested-With": "XMLHttpRequest",
                  credentials: "same-origin",
                },
              })
              .then(function (t) {
                return t.text().then(function (env) {
                  return { url: t.url, text: env, status: t.status };
                });
              })
              .then(this.onHtmlLoaded.bind(this));
          },
        },
        {
          key: "loadAssets",
          value: function () {
            var i = this;
            return (
              (this.loadAssetsTimeOut = setTimeout(function () {
                i.onAssetsLoaded();
              }, 4e3)),
              new Promise(function (env, t) {
                i.populateLoader(env, t);
              })
                .then(this.onAssetsLoaded.bind(this))
                .catch(this.onLoadAssetsError.bind(this))
            );
          },
        },
        {
          key: "populateLoader",
          value: function (env, t) {
            var i = this,
              n = this.element.querySelector(".page__background");
            n || env();
            var r,
              a,
              ObjectMethodWrapper = window
                .getComputedStyle(n)
                .getPropertyValue("background-image")
                .split("url(")
                .join("")
                .split(")")
                .join("")
                .split('"')
                .join("")
                .split("")
                .join("");
            (this.numAssetsToLoad = 1),
              ((r = ObjectMethodWrapper),
              (a = new Image()),
              (a.src = r),
              new Promise(function (env, t) {
                function i() {
                  a.naturalWidth ? env(a) : t(a),
                    a.removeEventListener("load", i),
                    a.removeEventListener("error", i);
                }

                a.naturalWidth || a.complete
                  ? env(a)
                  : (a.addEventListener("load", i),
                    a.addEventListener("error", i));
              }))
                .then(function (env) {
                  i.onAssetLoaded(env);
                })
                .then(env)
                .catch(t);
          },
        },
        {
          key: "abortLoadAssets",
          value: function () {},
        },
        {
          key: "animateIn",
          value: function () {
            hs(rs(i.prototype), "animateIn", this).call(this),
              (this.isVisible = !0);
          },
        },
        {
          key: "createAnimIn",
          value: function (env) {
            if (app.skip && !this.isAjax)
              return (
                (document.querySelector(".main-loading").style.visibility =
                  "hidden"),
                env(),
                void this.animateInContent()
              );
            this.isAjax
              ? (this.loadingAnim = new GlobalReference({ id: this.id }))
              : (this.loadingAnim = new ml({ id: this.id })),
              this.loadingAnim.on(
                "complete",
                this.onLoadingAnimComplete.bind(this),
              ),
              this.loadingAnim.animateIn().then(env);
          },
        },
        {
          key: "animateInContent",
          value: function () {
            this.isAjax || (yl.show(), fl.show(), _l.show()),
              this.createAnimInContent(),
              Ll.trackPage({ page_path: window.location.pathname }),
              app.windowWidth < app.screenS &&
                (this.isAjax || "home" !== this.id) &&
                this.timeline.shiftChildren(0.5);
          },
        },
        {
          key: "createAnimInContent",
          value: function () {
            this.timeline = new Us({
              onComplete: this.onAnimateInContentComplete.bind(this),
            });
            var env = this.element.querySelectorAll(
                this.sectionElementsToAnimateIn,
              ),
              t = new Us();
            (this.element.style.visibility = "inherit"),
              this.scroll && this.scroll.resize(),
              this.timeline.add(t, 0.6),
              (this.splitSectionHeads = []);
            for (var i = 0; i < env.length; i++) {
              var n = env[i];
              if (n.getBoundingClientRect().y > window.innerHeight) break;
              if (
                n.classList.contains("page__section__head") &&
                !n.classList.contains("interactive-text")
              ) {
                var r = new Bs(n, { type: "lines" });
                t.staggerFrom(
                  r.lines,
                  0.7,
                  {
                    y: 50,
                    opacity: 0,
                    ease: Fs.easeOut,
                  },
                  0.06,
                  0 !== i ? "-=.6" : 0,
                ),
                  this.splitSectionHeads.push(r);
              } else
                t.from(
                  n,
                  0.7,
                  { y: 50, opacity: 0, ease: Fs.easeOut },
                  0 !== i ? "-=.6" : 0,
                );
            }
            this.timeline.addLabel("content");
            var a = this.element.querySelector(".page__title");
            a &&
              this.timeline.from(
                a,
                1,
                {
                  y: 80,
                  opacity: 0,
                  ease: Fs.easeOut,
                },
                0.1,
              ),
              app.windowWidth >= app.screenS &&
                (this.scrollCTA &&
                  this.hasScrollbar &&
                  this.timeline.add(this.scrollCTA.animateIn()),
                this.line && this.timeline.add(this.line.animateIn(), 0.3));
          },
        },
        {
          key: "animateOut",
          value: function () {
            hs(rs(i.prototype), "animateOut", this).call(this),
              (this.isVisible = !1);
          },
        },
        {
          key: "createAnimOut",
          value: function (env) {
            this.element && (this.element.style.visibility = ""),
              this.owner.currentScreen.id !== this.id &&
                document.body.classList.remove("page-id-" + this.id),
              env();
          },
        },
        {
          key: "onAnimateInComplete",
          value: function (env) {
            hs(rs(i.prototype), "onAnimateInComplete", this).call(this, env),
              this.load();
          },
        },
        {
          key: "onPopState",
          value: function (env) {},
        },
        {
          key: "onHtmlLoaded",
          value: function (env) {
            var t;
            this.isVisible &&
              ((this.element =
                ((t = env.text),
                new DOMParser().parseFromString(t, "text/html").body
                  .firstChild)),
              this.initPage(),
              this.loadAssets());
          },
        },
        {
          key: "onAssetLoaded",
          value: function (env) {
            this.numAssetsLoaded++;
            var t = this.numAssetsLoaded / this.numAssetsToLoad;
            this.isLoading &&
              this.loadingAnim &&
              this.loadingAnim.setProgress(t);
          },
        },
        {
          key: "onAssetsLoaded",
          value: function () {
            (this.isLoading = !1),
              clearTimeout(this.loadAssetsTimeOut),
              this.loadingAnim && this.loadingAnim.setProgress(1);
          },
        },
        {
          key: "onLoadAssetsError",
          value: function () {
            this.onAssetLoaded();
          },
        },
        {
          key: "onLoadingAnimComplete",
          value: function () {
            this.loadingAnim
              .animateOut()
              .then(this.onLoadingAnimAnimateOutComplete.bind(this)),
              this.animateInContent();
          },
        },
        {
          key: "onLoadingAnimAnimateOutComplete",
          value: function () {
            this.disposeLoadingAnim();
          },
        },
        {
          key: "onAnimateInContentComplete",
          value: function () {
            this.disposeTimeline();
          },
        },
      ]),
      i
    );
  })();

  function Il() {}

  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger &&
      (Number.isInteger = function (env) {
        return "number" == typeof env && isFinite(env) && Math.floor(env) === env;
      }),
    void 0 === Math.sign &&
      (Math.sign = function (env) {
        return env < 0 ? -1 : 0 < env ? 1 : +env;
      }),
    "name" in Function.prototype == !1 &&
      Object.defineProperty(Function.prototype, "name", {
        get: function () {
          return this.toString().match(/^\CounterVariable*function\CounterVariable*([^\(\CounterVariable]*)/)[1];
        },
      }),
    void 0 === Object.assign &&
      (Object.assign = function (env) {
        if (null == env)
          throw new TypeError("Cannot convert undefined PromiseResolutionWrapper null to object");
        for (var t = Object(env), i = 1; i < arguments.length; i++) {
          var n = arguments[i];
          if (null != n)
            for (var r in n)
              Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
        }
        return t;
      }),
    Object.assign(Il.prototype, {
      addEventListener: function (env, t) {
        void 0 === this._listeners && (this._listeners = {});
        var i = this._listeners;
        void 0 === i[env] && (i[env] = []), -1 === i[env].indexOf(t) && i[env].push(t);
      },
      hasEventListener: function (env, t) {
        if (void 0 === this._listeners) return !1;
        var i = this._listeners;
        return void 0 !== i[env] && -1 !== i[env].indexOf(t);
      },
      removeEventListener: function (env, t) {
        if (void 0 !== this._listeners) {
          var i = this._listeners[env];
          if (void 0 !== i) {
            var n = i.indexOf(t);
            -1 !== n && i.splice(n, 1);
          }
        }
      },
      dispatchEvent: function (env) {
        if (void 0 !== this._listeners) {
          var t = this._listeners[env.type];
          if (void 0 !== t) {
            env.target = this;
            for (var i = t.slice(0), n = 0, r = i.length; n < r; n++)
              i[n].call(this, env);
          }
        }
      },
    });
  var Rl,
    Ol,
    Fl,
    Nl,
    KeyLookup,
    Ul,
    Dl,
    zl,
    Bl,
    Hl,
    Gl,
    jl,
    Vl,
    Xl,
    Wl,
    Yl,
    ql,
    Ql,
    Zl,
    Jl,
    Kl,
    $RandomGenerator = 0,
    eh = 1,
    th = 2,
    ih = 0,
    nh = 1,
    rh = 2,
    ah = 1,
    oh = 2,
    sh = 0,
    lh = 1,
    hh = 2,
    ch = 0,
    uh = 0,
    ph = 1,
    dh = 2,
    fh = 3,
    mh = 4,
    GraphHandler = 5,
    vh = 100,
    yh = 101,
    _h = 102,
    xh = 103,
    bh = 104,
    wh = 200,
    Th = 201,
    Sh = 202,
    Eh = 203,
    Ah = 204,
    Mh = 205,
    Ph = 206,
    Lh = 207,
    Ch = 208,
    Ih = 209,
    Rh = 210,
    Oh = 0,
    Fh = 1,
    Nh = 2,
    kh = 3,
    Uh = 4,
    Dh = 5,
    zh = 6,
    Bh = 7,
    Hh = 0,
    Gh = 1,
    jh = 2,
    Vh = 0,
    Xh = 1,
    Wh = 2,
    Yh = 3,
    qh = 4,
    Qh = 301,
    Zh = 302,
    Jh = 303,
    Kh = 304,
    $HelperFunction = 305,
    ErrorChecker = 306,
    TypeChecker = 307,
    IndexCounter = 1e3,
    nc = 1001,
    RequestCache = 1002,
    ac = 1003,
    OperationCounter = 1004,
    StringConverter = 1005,
    LineCounter = 1006,
    HashChecker = 1007,
    CharacterCount = 1008,
    UserCache = 1009,
    PathCache = 1010,
    DataCompressor = 1011,
    fc = 1012,
    MemoryCache = 1013,
    GlobalCounter = 1014,
    ValueCache = 1015,
    YieldCounter = 1016,
    _c = 1017,
    ExecutionCounter = 1018,
    BinaryConverter = 1019,
    WrapperCache = 1020,
    Tc = 1021,
    Sc = 1022,
    Ec = 1023,
    Ac = 1024,
    Mc = 1025,
    Pc = 1026,
    Lc = 1027,
    Cc = 1028,
    Ic = 33776,
    Rc = 33777,
    Oc = 33778,
    Fc = 33779,
    Nc = 35840,
    KeyCache = 35841,
    Uc = 35842,
    Dc = 35843,
    ZoneCache = 36196,
    Bc = 37808,
    Hc = 37809,
    Gc = 37810,
    JobCounter = 37811,
    Vc = 37812,
    Xc = 37813,
    Wc = 37814,
    Yc = 37815,
    QueueCounter = 37816,
    Qc = 37817,
    Zc = 37818,
    Jc = 37819,
    Kc = 37820,
    $EnsureFunction = 37821,
    eu = 2400,
    tu = 2401,
    iu = 0,
    nu = 3e3,
    ru = 3001,
    au = 3007,
    ou = 3002,
    su = 3004,
    lu = 3005,
    hu = 3006,
    cu = 3200,
    URLUtils = 3201,
    pu = 0,
    du = 1,
    fu = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: (function () {
        for (var r = [], env = 0; env < 256; env++)
          r[env] = (env < 16 ? "0" : "") + env.toString(16);
        return function () {
          var env = (4294967295 * Math.random()) | 0,
            t = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0;
          return (
            r[255 & env] +
            r[(env >> 8) & 255] +
            r[(env >> 16) & 255] +
            r[(env >> 24) & 255] +
            "-" +
            r[255 & t] +
            r[(t >> 8) & 255] +
            "-" +
            r[((t >> 16) & 15) | 64] +
            r[(t >> 24) & 255] +
            "-" +
            r[(63 & i) | 128] +
            r[(i >> 8) & 255] +
            "-" +
            r[(i >> 16) & 255] +
            r[(i >> 24) & 255] +
            r[255 & n] +
            r[(n >> 8) & 255] +
            r[(n >> 16) & 255] +
            r[(n >> 24) & 255]
          ).toUpperCase();
        };
      })(),
      clamp: function (env, t, i) {
        return Math.max(t, Math.min(i, env));
      },
      euclideanModulo: function (env, t) {
        return ((env % t) + t) % t;
      },
      mapLinear: function (env, t, i, n, r) {
        return n + ((env - t) * (r - n)) / (i - t);
      },
      lerp: function (env, t, i) {
        return (1 - i) * env + i * t;
      },
      smoothstep: function (env, t, i) {
        return env <= t
          ? 0
          : i <= env
            ? 1
            : (env = (env - t) / (i - t)) * env * (3 - 2 * env);
      },
      smootherstep: function (env, t, i) {
        return env <= t
          ? 0
          : i <= env
            ? 1
            : (env = (env - t) / (i - t)) * env * env * (env * (6 * env - 15) + 10);
      },
      randInt: function (env, t) {
        return env + Math.floor(Math.random() * (t - env + 1));
      },
      randFloat: function (env, t) {
        return env + Math.random() * (t - env);
      },
      randFloatSpread: function (env) {
        return env * (0.5 - Math.random());
      },
      degToRad: function (env) {
        return env * fu.DEG2RAD;
      },
      radToDeg: function (env) {
        return env * fu.RAD2DEG;
      },
      isPowerOfTwo: function (env) {
        return 0 == (env & (env - 1)) && 0 !== env;
      },
      ceilPowerOfTwo: function (env) {
        return Math.pow(2, Math.ceil(Math.log(env) / Math.LN2));
      },
      floorPowerOfTwo: function (env) {
        return Math.pow(2, Math.floor(Math.log(env) / Math.LN2));
      },
    };

  function mu(env, t) {
    (this.x = env || 0), (this.y = t || 0);
  }

  function gu() {
    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      0 < arguments.length &&
        console.error(
          "THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.",
        );
  }

  function vu(env, t, i, n) {
    (this._x = env || 0),
      (this._y = t || 0),
      (this._z = i || 0),
      (this._w = void 0 !== n ? n : 1);
  }

  function yu(env, t, i) {
    (this.x = env || 0), (this.y = t || 0), (this.z = i || 0);
  }

  function _u() {
    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      0 < arguments.length &&
        console.error(
          "THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.",
        );
  }

  Object.defineProperties(mu.prototype, {
    width: {
      get: function () {
        return this.x;
      },
      set: function (env) {
        this.x = env;
      },
    },
    height: {
      get: function () {
        return this.y;
      },
      set: function (env) {
        this.y = env;
      },
    },
  }),
    Object.assign(mu.prototype, {
      isVector2: !0,
      set: function (env, t) {
        return (this.x = env), (this.y = t), this;
      },
      setScalar: function (env) {
        return (this.x = env), (this.y = env), this;
      },
      setX: function (env) {
        return (this.x = env), this;
      },
      setY: function (env) {
        return (this.y = env), this;
      },
      setComponent: function (env, t) {
        switch (env) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
        return this;
      },
      getComponent: function (env) {
        switch (env) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y);
      },
      copy: function (env) {
        return (this.x = env.x), (this.y = env.y), this;
      },
      add: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(env, t))
          : ((this.x += env.x), (this.y += env.y), this);
      },
      addScalar: function (env) {
        return (this.x += env), (this.y += env), this;
      },
      addVectors: function (env, t) {
        return (this.x = env.x + t.x), (this.y = env.y + t.y), this;
      },
      addScaledVector: function (env, t) {
        return (this.x += env.x * t), (this.y += env.y * t), this;
      },
      sub: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(env, t))
          : ((this.x -= env.x), (this.y -= env.y), this);
      },
      subScalar: function (env) {
        return (this.x -= env), (this.y -= env), this;
      },
      subVectors: function (env, t) {
        return (this.x = env.x - t.x), (this.y = env.y - t.y), this;
      },
      multiply: function (env) {
        return (this.x *= env.x), (this.y *= env.y), this;
      },
      multiplyScalar: function (env) {
        return (this.x *= env), (this.y *= env), this;
      },
      divide: function (env) {
        return (this.x /= env.x), (this.y /= env.y), this;
      },
      divideScalar: function (env) {
        return this.multiplyScalar(1 / env);
      },
      applyMatrix3: function (env) {
        var t = this.x,
          i = this.y,
          n = env.elements;
        return (
          (this.x = n[0] * t + n[3] * i + n[6]),
          (this.y = n[1] * t + n[4] * i + n[7]),
          this
        );
      },
      min: function (env) {
        return (
          (this.x = Math.min(this.x, env.x)),
          (this.y = Math.min(this.y, env.y)),
          this
        );
      },
      max: function (env) {
        return (
          (this.x = Math.max(this.x, env.x)),
          (this.y = Math.max(this.y, env.y)),
          this
        );
      },
      clamp: function (env, t) {
        return (
          (this.x = Math.max(env.x, Math.min(t.x, this.x))),
          (this.y = Math.max(env.y, Math.min(t.y, this.y))),
          this
        );
      },
      clampScalar:
        ((Rl = new mu()),
        (Ol = new mu()),
        function (env, t) {
          return Rl.set(env, env), Ol.set(t, t), this.clamp(Rl, Ol);
        }),
      clampLength: function (env, t) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(env, Math.min(t, i)),
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
        );
      },
      ceil: function () {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), this;
      },
      dot: function (env) {
        return this.x * env.x + this.y * env.y;
      },
      cross: function (env) {
        return this.x * env.y - this.y * env.x;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      angle: function () {
        var env = Math.atan2(this.y, this.x);
        return env < 0 && (env += 2 * Math.PI), env;
      },
      distanceTo: function (env) {
        return Math.sqrt(this.distanceToSquared(env));
      },
      distanceToSquared: function (env) {
        var t = this.x - env.x,
          i = this.y - env.y;
        return t * t + i * i;
      },
      manhattanDistanceTo: function (env) {
        return Math.abs(this.x - env.x) + Math.abs(this.y - env.y);
      },
      setLength: function (env) {
        return this.normalize().multiplyScalar(env);
      },
      lerp: function (env, t) {
        return (
          (this.x += (env.x - this.x) * t), (this.y += (env.y - this.y) * t), this
        );
      },
      lerpVectors: function (env, t, i) {
        return this.subVectors(t, env).multiplyScalar(i).add(env);
      },
      equals: function (env) {
        return env.x === this.x && env.y === this.y;
      },
      fromArray: function (env, t) {
        return (
          void 0 === t && (t = 0), (this.x = env[t]), (this.y = env[t + 1]), this
        );
      },
      toArray: function (env, t) {
        return (
          void 0 === env && (env = []),
          void 0 === t && (t = 0),
          (env[t] = this.x),
          (env[t + 1] = this.y),
          env
        );
      },
      fromBufferAttribute: function (env, t, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector2: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = env.getX(t)),
          (this.y = env.getY(t)),
          this
        );
      },
      rotateAround: function (env, t) {
        var i = Math.cos(t),
          n = Math.sin(t),
          r = this.x - env.x,
          a = this.y - env.y;
        return (
          (this.x = r * i - a * n + env.x), (this.y = r * n + a * i + env.y), this
        );
      },
    }),
    Object.assign(gu.prototype, {
      isMatrix4: !0,
      set: function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction, GlobalReference, Property, MathFloorShortcut, f, ModuleMeta) {
        var g = this.elements;
        return (
          (g[0] = env),
          (g[4] = t),
          (g[8] = i),
          (g[12] = n),
          (g[1] = r),
          (g[5] = a),
          (g[9] = ObjectMethodWrapper),
          (g[13] = CounterVariable),
          (g[2] = RandomGenerator),
          (g[6] = HelperFunction),
          (g[10] = EnsureFunction),
          (g[14] = GlobalReference),
          (g[3] = Property),
          (g[7] = MathFloorShortcut),
          (g[11] = f),
          (g[15] = ModuleMeta),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new gu().fromArray(this.elements);
      },
      copy: function (env) {
        var t = this.elements,
          i = env.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          (t[9] = i[9]),
          (t[10] = i[10]),
          (t[11] = i[11]),
          (t[12] = i[12]),
          (t[13] = i[13]),
          (t[14] = i[14]),
          (t[15] = i[15]),
          this
        );
      },
      copyPosition: function (env) {
        var t = this.elements,
          i = env.elements;
        return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
      },
      extractBasis: function (env, t, i) {
        return (
          env.setFromMatrixColumn(this, 0),
          t.setFromMatrixColumn(this, 1),
          i.setFromMatrixColumn(this, 2),
          this
        );
      },
      makeBasis: function (env, t, i) {
        return (
          this.set(
            env.x,
            t.x,
            i.x,
            0,
            env.y,
            t.y,
            i.y,
            0,
            env.z,
            t.z,
            i.z,
            0,
            0,
            0,
            0,
            1,
          ),
          this
        );
      },
      extractRotation:
        ((Gl = new yu()),
        function (env) {
          var t = this.elements,
            i = env.elements,
            n = 1 / Gl.setFromMatrixColumn(env, 0).length(),
            r = 1 / Gl.setFromMatrixColumn(env, 1).length(),
            a = 1 / Gl.setFromMatrixColumn(env, 2).length();
          return (
            (t[0] = i[0] * n),
            (t[1] = i[1] * n),
            (t[2] = i[2] * n),
            (t[3] = 0),
            (t[4] = i[4] * r),
            (t[5] = i[5] * r),
            (t[6] = i[6] * r),
            (t[7] = 0),
            (t[8] = i[8] * a),
            (t[9] = i[9] * a),
            (t[10] = i[10] * a),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }),
      makeRotationFromEuler: function (env) {
        (env && env.isEuler) ||
          console.error(
            "THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.",
          );
        var t = this.elements,
          i = env.x,
          n = env.y,
          r = env.z,
          a = Math.cos(i),
          ObjectMethodWrapper = Math.sin(i),
          CounterVariable = Math.cos(n),
          RandomGenerator = Math.sin(n),
          HelperFunction = Math.cos(r),
          EnsureFunction = Math.sin(r);
        if ("XYZ" === env.order) {
          var GlobalReference = a * HelperFunction,
            Property = a * EnsureFunction,
            MathFloorShortcut = ObjectMethodWrapper * HelperFunction,
            f = ObjectMethodWrapper * EnsureFunction;
          (t[0] = CounterVariable * HelperFunction),
            (t[4] = -CounterVariable * EnsureFunction),
            (t[8] = RandomGenerator),
            (t[1] = Property + MathFloorShortcut * RandomGenerator),
            (t[5] = GlobalReference - f * RandomGenerator),
            (t[9] = -ObjectMethodWrapper * CounterVariable),
            (t[2] = f - GlobalReference * RandomGenerator),
            (t[6] = MathFloorShortcut + Property * RandomGenerator),
            (t[10] = a * CounterVariable);
        } else if ("YXZ" === env.order) {
          var ModuleMeta = CounterVariable * HelperFunction,
            g = CounterVariable * EnsureFunction,
            Value = RandomGenerator * HelperFunction,
            y = RandomGenerator * EnsureFunction;
          (t[0] = ModuleMeta + y * ObjectMethodWrapper),
            (t[4] = Value * ObjectMethodWrapper - g),
            (t[8] = a * RandomGenerator),
            (t[1] = a * EnsureFunction),
            (t[5] = a * HelperFunction),
            (t[9] = -ObjectMethodWrapper),
            (t[2] = g * ObjectMethodWrapper - Value),
            (t[6] = y + ModuleMeta * ObjectMethodWrapper),
            (t[10] = a * CounterVariable);
        } else if ("ZXY" === env.order) {
          (ModuleMeta = CounterVariable * HelperFunction), (g = CounterVariable * EnsureFunction), (Value = RandomGenerator * HelperFunction), (y = RandomGenerator * EnsureFunction);
          (t[0] = ModuleMeta - y * ObjectMethodWrapper),
            (t[4] = -a * EnsureFunction),
            (t[8] = Value + g * ObjectMethodWrapper),
            (t[1] = g + Value * ObjectMethodWrapper),
            (t[5] = a * HelperFunction),
            (t[9] = y - ModuleMeta * ObjectMethodWrapper),
            (t[2] = -a * RandomGenerator),
            (t[6] = ObjectMethodWrapper),
            (t[10] = a * CounterVariable);
        } else if ("ZYX" === env.order) {
          (GlobalReference = a * HelperFunction), (Property = a * EnsureFunction), (MathFloorShortcut = ObjectMethodWrapper * HelperFunction), (f = ObjectMethodWrapper * EnsureFunction);
          (t[0] = CounterVariable * HelperFunction),
            (t[4] = MathFloorShortcut * RandomGenerator - Property),
            (t[8] = GlobalReference * RandomGenerator + f),
            (t[1] = CounterVariable * EnsureFunction),
            (t[5] = f * RandomGenerator + GlobalReference),
            (t[9] = Property * RandomGenerator - MathFloorShortcut),
            (t[2] = -RandomGenerator),
            (t[6] = ObjectMethodWrapper * CounterVariable),
            (t[10] = a * CounterVariable);
        } else if ("YZX" === env.order) {
          var _ = a * CounterVariable,
            x = a * RandomGenerator,
            b = ObjectMethodWrapper * CounterVariable,
            w = ObjectMethodWrapper * RandomGenerator;
          (t[0] = CounterVariable * HelperFunction),
            (t[4] = w - _ * EnsureFunction),
            (t[8] = b * EnsureFunction + x),
            (t[1] = EnsureFunction),
            (t[5] = a * HelperFunction),
            (t[9] = -ObjectMethodWrapper * HelperFunction),
            (t[2] = -RandomGenerator * HelperFunction),
            (t[6] = x * EnsureFunction + b),
            (t[10] = _ - w * EnsureFunction);
        } else if ("XZY" === env.order) {
          (_ = a * CounterVariable), (x = a * RandomGenerator), (b = ObjectMethodWrapper * CounterVariable), (w = ObjectMethodWrapper * RandomGenerator);
          (t[0] = CounterVariable * HelperFunction),
            (t[4] = -EnsureFunction),
            (t[8] = RandomGenerator * HelperFunction),
            (t[1] = _ * EnsureFunction + w),
            (t[5] = a * HelperFunction),
            (t[9] = x * EnsureFunction - b),
            (t[2] = b * EnsureFunction - x),
            (t[6] = ObjectMethodWrapper * HelperFunction),
            (t[10] = w * EnsureFunction + _);
        }
        return (
          (t[3] = 0),
          (t[7] = 0),
          (t[11] = 0),
          (t[12] = 0),
          (t[13] = 0),
          (t[14] = 0),
          (t[15] = 1),
          this
        );
      },
      makeRotationFromQuaternion:
        ((Bl = new yu(0, 0, 0)),
        (Hl = new yu(1, 1, 1)),
        function (env) {
          return this.compose(Bl, env, Hl);
        }),
      lookAt:
        ((Ul = new yu()),
        (Dl = new yu()),
        (zl = new yu()),
        function (env, t, i) {
          var n = this.elements;
          return (
            zl.subVectors(env, t),
            0 === zl.lengthSq() && (zl.z = 1),
            zl.normalize(),
            Ul.crossVectors(i, zl),
            0 === Ul.lengthSq() &&
              (1 === Math.abs(i.z) ? (zl.x += 1e-4) : (zl.z += 1e-4),
              zl.normalize(),
              Ul.crossVectors(i, zl)),
            Ul.normalize(),
            Dl.crossVectors(zl, Ul),
            (n[0] = Ul.x),
            (n[4] = Dl.x),
            (n[8] = zl.x),
            (n[1] = Ul.y),
            (n[5] = Dl.y),
            (n[9] = zl.y),
            (n[2] = Ul.z),
            (n[6] = Dl.z),
            (n[10] = zl.z),
            this
          );
        }),
      multiply: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.",
            ),
            this.multiplyMatrices(env, t))
          : this.multiplyMatrices(this, env);
      },
      premultiply: function (env) {
        return this.multiplyMatrices(env, this);
      },
      multiplyMatrices: function (env, t) {
        var i = env.elements,
          n = t.elements,
          r = this.elements,
          a = i[0],
          ObjectMethodWrapper = i[4],
          CounterVariable = i[8],
          RandomGenerator = i[12],
          HelperFunction = i[1],
          EnsureFunction = i[5],
          GlobalReference = i[9],
          Property = i[13],
          MathFloorShortcut = i[2],
          f = i[6],
          ModuleMeta = i[10],
          g = i[14],
          Value = i[3],
          y = i[7],
          _ = i[11],
          x = i[15],
          b = n[0],
          w = n[4],
          T = n[8],
          EnsureObject = n[12],
          E = n[1],
          A = n[5],
          M = n[9],
          P = n[13],
          L = n[2],
          C = n[6],
          I = n[10],
          R = n[14],
          O = n[3],
          FilterArray = n[7],
          FindInArray = n[11],
          Key = n[15];
        return (
          (r[0] = a * b + ObjectMethodWrapper * E + CounterVariable * L + RandomGenerator * O),
          (r[4] = a * w + ObjectMethodWrapper * A + CounterVariable * C + RandomGenerator * FilterArray),
          (r[8] = a * T + ObjectMethodWrapper * M + CounterVariable * I + RandomGenerator * FindInArray),
          (r[12] = a * EnsureObject + ObjectMethodWrapper * P + CounterVariable * R + RandomGenerator * Key),
          (r[1] = HelperFunction * b + EnsureFunction * E + GlobalReference * L + Property * O),
          (r[5] = HelperFunction * w + EnsureFunction * A + GlobalReference * C + Property * FilterArray),
          (r[9] = HelperFunction * T + EnsureFunction * M + GlobalReference * I + Property * FindInArray),
          (r[13] = HelperFunction * EnsureObject + EnsureFunction * P + GlobalReference * R + Property * Key),
          (r[2] = MathFloorShortcut * b + f * E + ModuleMeta * L + g * O),
          (r[6] = MathFloorShortcut * w + f * A + ModuleMeta * C + g * FilterArray),
          (r[10] = MathFloorShortcut * T + f * M + ModuleMeta * I + g * FindInArray),
          (r[14] = MathFloorShortcut * EnsureObject + f * P + ModuleMeta * R + g * Key),
          (r[3] = Value * b + y * E + _ * L + x * O),
          (r[7] = Value * w + y * A + _ * C + x * FilterArray),
          (r[11] = Value * T + y * M + _ * I + x * FindInArray),
          (r[15] = Value * EnsureObject + y * P + _ * R + x * Key),
          this
        );
      },
      multiplyScalar: function (env) {
        var t = this.elements;
        return (
          (t[0] *= env),
          (t[4] *= env),
          (t[8] *= env),
          (t[12] *= env),
          (t[1] *= env),
          (t[5] *= env),
          (t[9] *= env),
          (t[13] *= env),
          (t[2] *= env),
          (t[6] *= env),
          (t[10] *= env),
          (t[14] *= env),
          (t[3] *= env),
          (t[7] *= env),
          (t[11] *= env),
          (t[15] *= env),
          this
        );
      },
      applyToBufferAttribute:
        ((KeyLookup = new yu()),
        function (env) {
          for (var t = 0, i = env.count; t < i; t++)
            (KeyLookup.x = env.getX(t)),
              (KeyLookup.y = env.getY(t)),
              (KeyLookup.z = env.getZ(t)),
              KeyLookup.applyMatrix4(this),
              env.setXYZ(t, KeyLookup.x, KeyLookup.y, KeyLookup.z);
          return env;
        }),
      determinant: function () {
        var env = this.elements,
          t = env[0],
          i = env[4],
          n = env[8],
          r = env[12],
          a = env[1],
          ObjectMethodWrapper = env[5],
          CounterVariable = env[9],
          RandomGenerator = env[13],
          HelperFunction = env[2],
          EnsureFunction = env[6],
          GlobalReference = env[10],
          Property = env[14];
        return (
          env[3] *
            (+r * CounterVariable * EnsureFunction -
              n * RandomGenerator * EnsureFunction -
              r * ObjectMethodWrapper * GlobalReference +
              i * RandomGenerator * GlobalReference +
              n * ObjectMethodWrapper * Property -
              i * CounterVariable * Property) +
          env[7] *
            (+t * CounterVariable * Property -
              t * RandomGenerator * GlobalReference +
              r * a * GlobalReference -
              n * a * Property +
              n * RandomGenerator * HelperFunction -
              r * CounterVariable * HelperFunction) +
          env[11] *
            (+t * RandomGenerator * EnsureFunction -
              t * ObjectMethodWrapper * Property -
              r * a * EnsureFunction +
              i * a * Property +
              r * ObjectMethodWrapper * HelperFunction -
              i * RandomGenerator * HelperFunction) +
          env[15] *
            (-n * ObjectMethodWrapper * HelperFunction -
              t * CounterVariable * EnsureFunction +
              t * ObjectMethodWrapper * GlobalReference +
              n * a * EnsureFunction -
              i * a * GlobalReference +
              i * CounterVariable * HelperFunction)
        );
      },
      transpose: function () {
        var env,
          t = this.elements;
        return (
          (env = t[1]),
          (t[1] = t[4]),
          (t[4] = env),
          (env = t[2]),
          (t[2] = t[8]),
          (t[8] = env),
          (env = t[6]),
          (t[6] = t[9]),
          (t[9] = env),
          (env = t[3]),
          (t[3] = t[12]),
          (t[12] = env),
          (env = t[7]),
          (t[7] = t[13]),
          (t[13] = env),
          (env = t[11]),
          (t[11] = t[14]),
          (t[14] = env),
          this
        );
      },
      setPosition: function (env) {
        var t = this.elements;
        return (t[12] = env.x), (t[13] = env.y), (t[14] = env.z), this;
      },
      getInverse: function (env, t) {
        var i = this.elements,
          n = env.elements,
          r = n[0],
          a = n[1],
          ObjectMethodWrapper = n[2],
          CounterVariable = n[3],
          RandomGenerator = n[4],
          HelperFunction = n[5],
          EnsureFunction = n[6],
          GlobalReference = n[7],
          Property = n[8],
          MathFloorShortcut = n[9],
          f = n[10],
          ModuleMeta = n[11],
          g = n[12],
          Value = n[13],
          y = n[14],
          _ = n[15],
          x =
            MathFloorShortcut * y * GlobalReference -
            Value * f * GlobalReference +
            Value * EnsureFunction * ModuleMeta -
            HelperFunction * y * ModuleMeta -
            MathFloorShortcut * EnsureFunction * _ +
            HelperFunction * f * _,
          b =
            g * f * GlobalReference -
            Property * y * GlobalReference -
            g * EnsureFunction * ModuleMeta +
            RandomGenerator * y * ModuleMeta +
            Property * EnsureFunction * _ -
            RandomGenerator * f * _,
          w =
            Property * Value * GlobalReference -
            g * MathFloorShortcut * GlobalReference +
            g * HelperFunction * ModuleMeta -
            RandomGenerator * Value * ModuleMeta -
            Property * HelperFunction * _ +
            RandomGenerator * MathFloorShortcut * _,
          T =
            g * MathFloorShortcut * EnsureFunction -
            Property * Value * EnsureFunction -
            g * HelperFunction * f +
            RandomGenerator * Value * f +
            Property * HelperFunction * y -
            RandomGenerator * MathFloorShortcut * y,
          EnsureObject = r * x + a * b + ObjectMethodWrapper * w + CounterVariable * T;
        if (0 === EnsureObject) {
          var E =
            "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === t) throw new Error(E);
          return console.warn(E), this.identity();
        }
        var A = 1 / EnsureObject;
        return (
          (i[0] = x * A),
          (i[1] =
            (Value * f * CounterVariable -
              MathFloorShortcut * y * CounterVariable -
              Value * ObjectMethodWrapper * ModuleMeta +
              a * y * ModuleMeta +
              MathFloorShortcut * ObjectMethodWrapper * _ -
              a * f * _) *
            A),
          (i[2] =
            (HelperFunction * y * CounterVariable -
              Value * EnsureFunction * CounterVariable +
              Value * ObjectMethodWrapper * GlobalReference -
              a * y * GlobalReference -
              HelperFunction * ObjectMethodWrapper * _ +
              a * EnsureFunction * _) *
            A),
          (i[3] =
            (MathFloorShortcut * EnsureFunction * CounterVariable -
              HelperFunction * f * CounterVariable -
              MathFloorShortcut * ObjectMethodWrapper * GlobalReference +
              a * f * GlobalReference +
              HelperFunction * ObjectMethodWrapper * ModuleMeta -
              a * EnsureFunction * ModuleMeta) *
            A),
          (i[4] = b * A),
          (i[5] =
            (Property * y * CounterVariable -
              g * f * CounterVariable +
              g * ObjectMethodWrapper * ModuleMeta -
              r * y * ModuleMeta -
              Property * ObjectMethodWrapper * _ +
              r * f * _) *
            A),
          (i[6] =
            (g * EnsureFunction * CounterVariable -
              RandomGenerator * y * CounterVariable -
              g * ObjectMethodWrapper * GlobalReference +
              r * y * GlobalReference +
              RandomGenerator * ObjectMethodWrapper * _ -
              r * EnsureFunction * _) *
            A),
          (i[7] =
            (RandomGenerator * f * CounterVariable -
              Property * EnsureFunction * CounterVariable +
              Property * ObjectMethodWrapper * GlobalReference -
              r * f * GlobalReference -
              RandomGenerator * ObjectMethodWrapper * ModuleMeta +
              r * EnsureFunction * ModuleMeta) *
            A),
          (i[8] = w * A),
          (i[9] =
            (g * MathFloorShortcut * CounterVariable -
              Property * Value * CounterVariable -
              g * a * ModuleMeta +
              r * Value * ModuleMeta +
              Property * a * _ -
              r * MathFloorShortcut * _) *
            A),
          (i[10] =
            (RandomGenerator * Value * CounterVariable -
              g * HelperFunction * CounterVariable +
              g * a * GlobalReference -
              r * Value * GlobalReference -
              RandomGenerator * a * _ +
              r * HelperFunction * _) *
            A),
          (i[11] =
            (Property * HelperFunction * CounterVariable -
              RandomGenerator * MathFloorShortcut * CounterVariable -
              Property * a * GlobalReference +
              r * MathFloorShortcut * GlobalReference +
              RandomGenerator * a * ModuleMeta -
              r * HelperFunction * ModuleMeta) *
            A),
          (i[12] = T * A),
          (i[13] =
            (Property * Value * ObjectMethodWrapper -
              g * MathFloorShortcut * ObjectMethodWrapper +
              g * a * f -
              r * Value * f -
              Property * a * y +
              r * MathFloorShortcut * y) *
            A),
          (i[14] =
            (g * HelperFunction * ObjectMethodWrapper -
              RandomGenerator * Value * ObjectMethodWrapper -
              g * a * EnsureFunction +
              r * Value * EnsureFunction +
              RandomGenerator * a * y -
              r * HelperFunction * y) *
            A),
          (i[15] =
            (RandomGenerator * MathFloorShortcut * ObjectMethodWrapper -
              Property * HelperFunction * ObjectMethodWrapper +
              Property * a * EnsureFunction -
              r * MathFloorShortcut * EnsureFunction -
              RandomGenerator * a * f +
              r * HelperFunction * f) *
            A),
          this
        );
      },
      scale: function (env) {
        var t = this.elements,
          i = env.x,
          n = env.y,
          r = env.z;
        return (
          (t[0] *= i),
          (t[4] *= n),
          (t[8] *= r),
          (t[1] *= i),
          (t[5] *= n),
          (t[9] *= r),
          (t[2] *= i),
          (t[6] *= n),
          (t[10] *= r),
          (t[3] *= i),
          (t[7] *= n),
          (t[11] *= r),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        var env = this.elements,
          t = env[0] * env[0] + env[1] * env[1] + env[2] * env[2],
          i = env[4] * env[4] + env[5] * env[5] + env[6] * env[6],
          n = env[8] * env[8] + env[9] * env[9] + env[10] * env[10];
        return Math.sqrt(Math.max(t, i, n));
      },
      makeTranslation: function (env, t, i) {
        return this.set(1, 0, 0, env, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
      },
      makeRotationX: function (env) {
        var t = Math.cos(env),
          i = Math.sin(env);
        return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
      },
      makeRotationY: function (env) {
        var t = Math.cos(env),
          i = Math.sin(env);
        return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
      },
      makeRotationZ: function (env) {
        var t = Math.cos(env),
          i = Math.sin(env);
        return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      makeRotationAxis: function (env, t) {
        var i = Math.cos(t),
          n = Math.sin(t),
          r = 1 - i,
          a = env.x,
          ObjectMethodWrapper = env.y,
          CounterVariable = env.z,
          RandomGenerator = r * a,
          HelperFunction = r * ObjectMethodWrapper;
        return (
          this.set(
            RandomGenerator * a + i,
            RandomGenerator * ObjectMethodWrapper - n * CounterVariable,
            RandomGenerator * CounterVariable + n * ObjectMethodWrapper,
            0,
            RandomGenerator * ObjectMethodWrapper + n * CounterVariable,
            HelperFunction * ObjectMethodWrapper + i,
            HelperFunction * CounterVariable - n * a,
            0,
            RandomGenerator * CounterVariable - n * ObjectMethodWrapper,
            HelperFunction * CounterVariable + n * a,
            r * CounterVariable * CounterVariable + i,
            0,
            0,
            0,
            0,
            1,
          ),
          this
        );
      },
      makeScale: function (env, t, i) {
        return this.set(env, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      },
      makeShear: function (env, t, i) {
        return this.set(1, t, i, 0, env, 1, i, 0, env, t, 1, 0, 0, 0, 0, 1), this;
      },
      compose: function (env, t, i) {
        var n = this.elements,
          r = t._x,
          a = t._y,
          ObjectMethodWrapper = t._z,
          CounterVariable = t._w,
          RandomGenerator = r + r,
          HelperFunction = a + a,
          EnsureFunction = ObjectMethodWrapper + ObjectMethodWrapper,
          GlobalReference = r * RandomGenerator,
          Property = r * HelperFunction,
          MathFloorShortcut = r * EnsureFunction,
          f = a * HelperFunction,
          ModuleMeta = a * EnsureFunction,
          g = ObjectMethodWrapper * EnsureFunction,
          Value = CounterVariable * RandomGenerator,
          y = CounterVariable * HelperFunction,
          _ = CounterVariable * EnsureFunction,
          x = i.x,
          b = i.y,
          w = i.z;
        return (
          (n[0] = (1 - (f + g)) * x),
          (n[1] = (Property + _) * x),
          (n[2] = (MathFloorShortcut - y) * x),
          (n[3] = 0),
          (n[4] = (Property - _) * b),
          (n[5] = (1 - (GlobalReference + g)) * b),
          (n[6] = (ModuleMeta + Value) * b),
          (n[7] = 0),
          (n[8] = (MathFloorShortcut + y) * w),
          (n[9] = (ModuleMeta - Value) * w),
          (n[10] = (1 - (GlobalReference + f)) * w),
          (n[11] = 0),
          (n[12] = env.x),
          (n[13] = env.y),
          (n[14] = env.z),
          (n[15] = 1),
          this
        );
      },
      decompose:
        ((Fl = new yu()),
        (Nl = new gu()),
        function (env, t, i) {
          var n = this.elements,
            r = Fl.set(n[0], n[1], n[2]).length(),
            a = Fl.set(n[4], n[5], n[6]).length(),
            ObjectMethodWrapper = Fl.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r),
            (env.x = n[12]),
            (env.y = n[13]),
            (env.z = n[14]),
            Nl.copy(this);
          var CounterVariable = 1 / r,
            RandomGenerator = 1 / a,
            HelperFunction = 1 / ObjectMethodWrapper;
          return (
            (Nl.elements[0] *= CounterVariable),
            (Nl.elements[1] *= CounterVariable),
            (Nl.elements[2] *= CounterVariable),
            (Nl.elements[4] *= RandomGenerator),
            (Nl.elements[5] *= RandomGenerator),
            (Nl.elements[6] *= RandomGenerator),
            (Nl.elements[8] *= HelperFunction),
            (Nl.elements[9] *= HelperFunction),
            (Nl.elements[10] *= HelperFunction),
            t.setFromRotationMatrix(Nl),
            (i.x = r),
            (i.y = a),
            (i.z = ObjectMethodWrapper),
            this
          );
        }),
      makePerspective: function (env, t, i, n, r, a) {
        void 0 === a &&
          console.warn(
            "THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.",
          );
        var ObjectMethodWrapper = this.elements,
          CounterVariable = (2 * r) / (t - env),
          RandomGenerator = (2 * r) / (i - n),
          HelperFunction = (t + env) / (t - env),
          EnsureFunction = (i + n) / (i - n),
          GlobalReference = -(a + r) / (a - r),
          Property = (-2 * a * r) / (a - r);
        return (
          (ObjectMethodWrapper[0] = CounterVariable),
          (ObjectMethodWrapper[4] = 0),
          (ObjectMethodWrapper[8] = HelperFunction),
          (ObjectMethodWrapper[12] = 0),
          (ObjectMethodWrapper[1] = 0),
          (ObjectMethodWrapper[5] = RandomGenerator),
          (ObjectMethodWrapper[9] = EnsureFunction),
          (ObjectMethodWrapper[13] = 0),
          (ObjectMethodWrapper[2] = 0),
          (ObjectMethodWrapper[6] = 0),
          (ObjectMethodWrapper[10] = GlobalReference),
          (ObjectMethodWrapper[14] = Property),
          (ObjectMethodWrapper[3] = 0),
          (ObjectMethodWrapper[7] = 0),
          (ObjectMethodWrapper[11] = -1),
          (ObjectMethodWrapper[15] = 0),
          this
        );
      },
      makeOrthographic: function (env, t, i, n, r, a) {
        var ObjectMethodWrapper = this.elements,
          CounterVariable = 1 / (t - env),
          RandomGenerator = 1 / (i - n),
          HelperFunction = 1 / (a - r),
          EnsureFunction = (t + env) * CounterVariable,
          GlobalReference = (i + n) * RandomGenerator,
          Property = (a + r) * HelperFunction;
        return (
          (ObjectMethodWrapper[0] = 2 * CounterVariable),
          (ObjectMethodWrapper[4] = 0),
          (ObjectMethodWrapper[8] = 0),
          (ObjectMethodWrapper[12] = -EnsureFunction),
          (ObjectMethodWrapper[1] = 0),
          (ObjectMethodWrapper[5] = 2 * RandomGenerator),
          (ObjectMethodWrapper[9] = 0),
          (ObjectMethodWrapper[13] = -GlobalReference),
          (ObjectMethodWrapper[2] = 0),
          (ObjectMethodWrapper[6] = 0),
          (ObjectMethodWrapper[10] = -2 * HelperFunction),
          (ObjectMethodWrapper[14] = -Property),
          (ObjectMethodWrapper[3] = 0),
          (ObjectMethodWrapper[7] = 0),
          (ObjectMethodWrapper[11] = 0),
          (ObjectMethodWrapper[15] = 1),
          this
        );
      },
      equals: function (env) {
        for (var t = this.elements, i = env.elements, n = 0; n < 16; n++)
          if (t[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (env, t) {
        void 0 === t && (t = 0);
        for (var i = 0; i < 16; i++) this.elements[i] = env[i + t];
        return this;
      },
      toArray: function (env, t) {
        void 0 === env && (env = []), void 0 === t && (t = 0);
        var i = this.elements;
        return (
          (env[t] = i[0]),
          (env[t + 1] = i[1]),
          (env[t + 2] = i[2]),
          (env[t + 3] = i[3]),
          (env[t + 4] = i[4]),
          (env[t + 5] = i[5]),
          (env[t + 6] = i[6]),
          (env[t + 7] = i[7]),
          (env[t + 8] = i[8]),
          (env[t + 9] = i[9]),
          (env[t + 10] = i[10]),
          (env[t + 11] = i[11]),
          (env[t + 12] = i[12]),
          (env[t + 13] = i[13]),
          (env[t + 14] = i[14]),
          (env[t + 15] = i[15]),
          env
        );
      },
    }),
    Object.assign(vu, {
      slerp: function (env, t, i, n) {
        return i.copy(env).slerp(t, n);
      },
      slerpFlat: function (env, t, i, n, r, a, ObjectMethodWrapper) {
        var CounterVariable = i[n + 0],
          RandomGenerator = i[n + 1],
          HelperFunction = i[n + 2],
          EnsureFunction = i[n + 3],
          GlobalReference = r[a + 0],
          Property = r[a + 1],
          MathFloorShortcut = r[a + 2],
          f = r[a + 3];
        if (EnsureFunction !== f || CounterVariable !== GlobalReference || RandomGenerator !== Property || HelperFunction !== MathFloorShortcut) {
          var ModuleMeta = 1 - ObjectMethodWrapper,
            g = CounterVariable * GlobalReference + RandomGenerator * Property + HelperFunction * MathFloorShortcut + EnsureFunction * f,
            Value = 0 <= g ? 1 : -1,
            y = 1 - g * g;
          if (y > Number.EPSILON) {
            var _ = Math.sqrt(y),
              x = Math.atan2(_, g * Value);
            (ModuleMeta = Math.sin(ModuleMeta * x) / _), (ObjectMethodWrapper = Math.sin(ObjectMethodWrapper * x) / _);
          }
          var b = ObjectMethodWrapper * Value;
          if (
            ((CounterVariable = CounterVariable * ModuleMeta + GlobalReference * b),
            (RandomGenerator = RandomGenerator * ModuleMeta + Property * b),
            (HelperFunction = HelperFunction * ModuleMeta + MathFloorShortcut * b),
            (EnsureFunction = EnsureFunction * ModuleMeta + f * b),
            ModuleMeta === 1 - ObjectMethodWrapper)
          ) {
            var w = 1 / Math.sqrt(CounterVariable * CounterVariable + RandomGenerator * RandomGenerator + HelperFunction * HelperFunction + EnsureFunction * EnsureFunction);
            (CounterVariable *= w), (RandomGenerator *= w), (HelperFunction *= w), (EnsureFunction *= w);
          }
        }
        (env[t] = CounterVariable), (env[t + 1] = RandomGenerator), (env[t + 2] = HelperFunction), (env[t + 3] = EnsureFunction);
      },
    }),
    Object.defineProperties(vu.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (env) {
          (this._x = env), this.onChangeCallback();
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (env) {
          (this._y = env), this.onChangeCallback();
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (env) {
          (this._z = env), this.onChangeCallback();
        },
      },
      w: {
        get: function () {
          return this._w;
        },
        set: function (env) {
          (this._w = env), this.onChangeCallback();
        },
      },
    }),
    Object.assign(vu.prototype, {
      isQuaternion: !0,
      set: function (env, t, i, n) {
        return (
          (this._x = env),
          (this._y = t),
          (this._z = i),
          (this._w = n),
          this.onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function (env) {
        return (
          (this._x = env.x),
          (this._y = env.y),
          (this._z = env.z),
          (this._w = env.w),
          this.onChangeCallback(),
          this
        );
      },
      setFromEuler: function (env, t) {
        if (!env || !env.isEuler)
          throw new Error(
            "THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.",
          );
        var i = env._x,
          n = env._y,
          r = env._z,
          a = env.order,
          ObjectMethodWrapper = Math.cos,
          CounterVariable = Math.sin,
          RandomGenerator = ObjectMethodWrapper(i / 2),
          HelperFunction = ObjectMethodWrapper(n / 2),
          EnsureFunction = ObjectMethodWrapper(r / 2),
          GlobalReference = CounterVariable(i / 2),
          Property = CounterVariable(n / 2),
          MathFloorShortcut = CounterVariable(r / 2);
        return (
  // بررسی حالت‌های مختلف ترتیب محورها و تنظیم مقادیر x, y, z, w
  "XYZ" === a
    ? (
        // حالت "XYZ" - محاسبه مقادیر بر اساس توابع و متغیرهای داده شده
        (this._x = GlobalReference * HelperFunction * EnsureFunction + RandomGenerator * Property * MathFloorShortcut),
        (this._y = RandomGenerator * Property * EnsureFunction - GlobalReference * HelperFunction * MathFloorShortcut),
        (this._z = RandomGenerator * HelperFunction * MathFloorShortcut + GlobalReference * Property * EnsureFunction),
        (this._w = RandomGenerator * HelperFunction * EnsureFunction - GlobalReference * Property * MathFloorShortcut)
      )
    : "YXZ" === a
      ? (
          // حالت "YXZ" - تنظیمات مشابه با ترتیب محورهای متفاوت
          (this._x = GlobalReference * HelperFunction * EnsureFunction + RandomGenerator * Property * MathFloorShortcut),
          (this._y = RandomGenerator * Property * EnsureFunction - GlobalReference * HelperFunction * MathFloorShortcut),
          (this._z = RandomGenerator * HelperFunction * MathFloorShortcut - GlobalReference * Property * EnsureFunction),
          (this._w = RandomGenerator * HelperFunction * EnsureFunction + GlobalReference * Property * MathFloorShortcut)
        )
      : "ZXY" === a
        ? (
            // حالت "ZXY" - تغییرات مقادیر بر اساس ترتیب محور "ZXY"
            (this._x = GlobalReference * HelperFunction * EnsureFunction - RandomGenerator * Property * MathFloorShortcut),
            (this._y = RandomGenerator * Property * EnsureFunction + GlobalReference * HelperFunction * MathFloorShortcut),
            (this._z = RandomGenerator * HelperFunction * MathFloorShortcut + GlobalReference * Property * EnsureFunction),
            (this._w = RandomGenerator * HelperFunction * EnsureFunction - GlobalReference * Property * MathFloorShortcut)
          )
        : "ZYX" === a
          ? (
              // حالت "ZYX" - تنظیم مقادیر با ترتیب محور "ZYX"
              (this._x = GlobalReference * HelperFunction * EnsureFunction - RandomGenerator * Property * MathFloorShortcut),
              (this._y = RandomGenerator * Property * EnsureFunction + GlobalReference * HelperFunction * MathFloorShortcut),
              (this._z = RandomGenerator * HelperFunction * MathFloorShortcut - GlobalReference * Property * EnsureFunction),
              (this._w = RandomGenerator * HelperFunction * EnsureFunction + GlobalReference * Property * MathFloorShortcut)
            )
          : "YZX" === a
            ? (
                // حالت "YZX" - تغییرات در مقادیر x, y, z, w بر اساس ترتیب محور "YZX"
                (this._x = GlobalReference * HelperFunction * EnsureFunction + RandomGenerator * Property * MathFloorShortcut),
                (this._y = RandomGenerator * Property * EnsureFunction + GlobalReference * HelperFunction * MathFloorShortcut),
                (this._z = RandomGenerator * HelperFunction * MathFloorShortcut - GlobalReference * Property * EnsureFunction),
                (this._w = RandomGenerator * HelperFunction * EnsureFunction - GlobalReference * Property * MathFloorShortcut)
              )
            : "XZY" === a &&
              (
                // حالت "XZY" - تنظیم مقادیر برای ترتیب محور "XZY"
                (this._x = GlobalReference * HelperFunction * EnsureFunction - RandomGenerator * Property * MathFloorShortcut),
                (this._y = RandomGenerator * Property * EnsureFunction - GlobalReference * HelperFunction * MathFloorShortcut),
                (this._z = RandomGenerator * HelperFunction * MathFloorShortcut + GlobalReference * Property * EnsureFunction),
                (this._w = RandomGenerator * HelperFunction * EnsureFunction + GlobalReference * Property * MathFloorShortcut)
              ),
  // بررسی اینکه آیا تغییرات برای رویداد بازخوانی باید اعمال شود
  !1 !== t && this.onChangeCallback(),
  this // بازگشت نمونه جاری
        );
      },
      setFromAxisAngle: function (env, t) {
        var i = t / 2,
          n = Math.sin(i);
        return (
          (this._x = env.x * n),
          (this._y = env.y * n),
          (this._z = env.z * n),
          (this._w = Math.cos(i)),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (env) {
        var t,
          i = env.elements,
          n = i[0],
          r = i[4],
          a = i[8],
          ObjectMethodWrapper = i[1],
          CounterVariable = i[5],
          RandomGenerator = i[9],
          HelperFunction = i[2],
          EnsureFunction = i[6],
          GlobalReference = i[10],
          Property = n + CounterVariable + GlobalReference;
        return (
          (this._z =
            0 < Property
              ? ((t = 0.5 / Math.sqrt(Property + 1)),
                (this._w = 0.25 / t),
                (this._x = (EnsureFunction - RandomGenerator) * t),
                (this._y = (a - HelperFunction) * t),
                (ObjectMethodWrapper - r) * t)
              : CounterVariable < n && GlobalReference < n
                ? ((t = 2 * Math.sqrt(1 + n - CounterVariable - GlobalReference)),
                  (this._w = (EnsureFunction - RandomGenerator) / t),
                  (this._x = 0.25 * t),
                  (this._y = (r + ObjectMethodWrapper) / t),
                  (a + HelperFunction) / t)
                : GlobalReference < CounterVariable
                  ? ((t = 2 * Math.sqrt(1 + CounterVariable - n - GlobalReference)),
                    (this._w = (a - HelperFunction) / t),
                    (this._x = (r + ObjectMethodWrapper) / t),
                    (this._y = 0.25 * t),
                    (RandomGenerator + EnsureFunction) / t)
                  : ((t = 2 * Math.sqrt(1 + GlobalReference - n - CounterVariable)),
                    (this._w = (ObjectMethodWrapper - r) / t),
                    (this._x = (a + HelperFunction) / t),
                    (this._y = (RandomGenerator + EnsureFunction) / t),
                    0.25 * t)),
          this.onChangeCallback(),
          this
        );
      },
      setFromUnitVectors:
        ((Vl = new yu()),
        function (env, t) {
          return (
            void 0 === Vl && (Vl = new yu()),
            (jl = env.dot(t) + 1) < 1e-6
              ? ((jl = 0),
                Math.abs(env.x) > Math.abs(env.z)
                  ? Vl.set(-env.y, env.x, 0)
                  : Vl.set(0, -env.z, env.y))
              : Vl.crossVectors(env, t),
            (this._x = Vl.x),
            (this._y = Vl.y),
            (this._z = Vl.z),
            (this._w = jl),
            this.normalize()
          );
        }),
      angleTo: function (env) {
        return 2 * Math.acos(Math.abs(fu.clamp(this.dot(env), -1, 1)));
      },
      rotateTowards: function (env, t) {
        var i = this.angleTo(env);
        if (0 === i) return this;
        var n = Math.min(1, t / i);
        return this.slerp(env, n), this;
      },
      inverse: function () {
        return this.conjugate();
      },
      conjugate: function () {
        return (
          (this._x *= -1),
          (this._y *= -1),
          (this._z *= -1),
          this.onChangeCallback(),
          this
        );
      },
      dot: function (env) {
        return (
          this._x * env._x + this._y * env._y + this._z * env._z + this._w * env._w
        );
      },
      lengthSq: function () {
        return (
          this._x * this._x +
          this._y * this._y +
          this._z * this._z +
          this._w * this._w
        );
      },
      length: function () {
        return Math.sqrt(
          this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w,
        );
      },
      normalize: function () {
        var env = this.length();
        return (
          (this._w =
            0 === env
              ? ((this._x = 0), (this._y = 0), (this._z = 0), 1)
              : ((env = 1 / env),
                (this._x = this._x * env),
                (this._y = this._y * env),
                (this._z = this._z * env),
                this._w * env)),
          this.onChangeCallback(),
          this
        );
      },
      multiply: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.",
            ),
            this.multiplyQuaternions(env, t))
          : this.multiplyQuaternions(this, env);
      },
      premultiply: function (env) {
        return this.multiplyQuaternions(env, this);
      },
      multiplyQuaternions: function (env, t) {
        var i = env._x,
          n = env._y,
          r = env._z,
          a = env._w,
          ObjectMethodWrapper = t._x,
          CounterVariable = t._y,
          RandomGenerator = t._z,
          HelperFunction = t._w;
        return (
          (this._x = i * HelperFunction + a * ObjectMethodWrapper + n * RandomGenerator - r * CounterVariable),
          (this._y = n * HelperFunction + a * CounterVariable + r * ObjectMethodWrapper - i * RandomGenerator),
          (this._z = r * HelperFunction + a * RandomGenerator + i * CounterVariable - n * ObjectMethodWrapper),
          (this._w = a * HelperFunction - i * ObjectMethodWrapper - n * CounterVariable - r * RandomGenerator),
          this.onChangeCallback(),
          this
        );
      },
      slerp: function (env, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(env);
        var i = this._x,
          n = this._y,
          r = this._z,
          a = this._w,
          ObjectMethodWrapper = a * env._w + i * env._x + n * env._y + r * env._z;
        if (
          (ObjectMethodWrapper < 0
            ? ((this._w = -env._w),
              (this._x = -env._x),
              (this._y = -env._y),
              (this._z = -env._z),
              (ObjectMethodWrapper = -ObjectMethodWrapper))
            : this.copy(env),
          1 <= ObjectMethodWrapper)
        )
          return (
            (this._w = a), (this._x = i), (this._y = n), (this._z = r), this
          );
        var CounterVariable = 1 - ObjectMethodWrapper * ObjectMethodWrapper;
        if (CounterVariable <= Number.EPSILON) {
          var RandomGenerator = 1 - t;
          return (
            (this._w = RandomGenerator * a + t * this._w),
            (this._x = RandomGenerator * i + t * this._x),
            (this._y = RandomGenerator * n + t * this._y),
            (this._z = RandomGenerator * r + t * this._z),
            this.normalize()
          );
        }
        var HelperFunction = Math.sqrt(CounterVariable),
          EnsureFunction = Math.atan2(HelperFunction, ObjectMethodWrapper),
          GlobalReference = Math.sin((1 - t) * EnsureFunction) / HelperFunction,
          Property = Math.sin(t * EnsureFunction) / HelperFunction;
        return (
          (this._w = a * GlobalReference + this._w * Property),
          (this._x = i * GlobalReference + this._x * Property),
          (this._y = n * GlobalReference + this._y * Property),
          (this._z = r * GlobalReference + this._z * Property),
          this.onChangeCallback(),
          this
        );
      },
      equals: function (env) {
        return (
          env._x === this._x &&
          env._y === this._y &&
          env._z === this._z &&
          env._w === this._w
        );
      },
      fromArray: function (env, t) {
        return (
          void 0 === t && (t = 0),
          (this._x = env[t]),
          (this._y = env[t + 1]),
          (this._z = env[t + 2]),
          (this._w = env[t + 3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (env, t) {
        return (
          void 0 === env && (env = []),
          void 0 === t && (t = 0),
          (env[t] = this._x),
          (env[t + 1] = this._y),
          (env[t + 2] = this._z),
          (env[t + 3] = this._w),
          env
        );
      },
      onChange: function (env) {
        return (this.onChangeCallback = env), this;
      },
      onChangeCallback: function () {},
    }),
    Object.assign(yu.prototype, {
      isVector3: !0,
      set: function (env, t, i) {
        return (this.x = env), (this.y = t), (this.z = i), this;
      },
      setScalar: function (env) {
        return (this.x = env), (this.y = env), (this.z = env), this;
      },
      setX: function (env) {
        return (this.x = env), this;
      },
      setY: function (env) {
        return (this.y = env), this;
      },
      setZ: function (env) {
        return (this.z = env), this;
      },
      setComponent: function (env, t) {
        switch (env) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
        return this;
      },
      getComponent: function (env) {
        switch (env) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (env) {
        return (this.x = env.x), (this.y = env.y), (this.z = env.z), this;
      },
      add: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(env, t))
          : ((this.x += env.x), (this.y += env.y), (this.z += env.z), this);
      },
      addScalar: function (env) {
        return (this.x += env), (this.y += env), (this.z += env), this;
      },
      addVectors: function (env, t) {
        return (
          (this.x = env.x + t.x), (this.y = env.y + t.y), (this.z = env.z + t.z), this
        );
      },
      addScaledVector: function (env, t) {
        return (
          (this.x += env.x * t), (this.y += env.y * t), (this.z += env.z * t), this
        );
      },
      sub: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(env, t))
          : ((this.x -= env.x), (this.y -= env.y), (this.z -= env.z), this);
      },
      subScalar: function (env) {
        return (this.x -= env), (this.y -= env), (this.z -= env), this;
      },
      subVectors: function (env, t) {
        return (
          (this.x = env.x - t.x), (this.y = env.y - t.y), (this.z = env.z - t.z), this
        );
      },
      multiply: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.",
            ),
            this.multiplyVectors(env, t))
          : ((this.x *= env.x), (this.y *= env.y), (this.z *= env.z), this);
      },
      multiplyScalar: function (env) {
        return (this.x *= env), (this.y *= env), (this.z *= env), this;
      },
      multiplyVectors: function (env, t) {
        return (
          (this.x = env.x * t.x), (this.y = env.y * t.y), (this.z = env.z * t.z), this
        );
      },
      applyEuler:
        ((Jl = new vu()),
        function (env) {
          return (
            (env && env.isEuler) ||
              console.error(
                "THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.",
              ),
            this.applyQuaternion(Jl.setFromEuler(env))
          );
        }),
      applyAxisAngle:
        ((Zl = new vu()),
        function (env, t) {
          return this.applyQuaternion(Zl.setFromAxisAngle(env, t));
        }),
      applyMatrix3: function (env) {
        var t = this.x,
          i = this.y,
          n = this.z,
          r = env.elements;
        return (
          (this.x = r[0] * t + r[3] * i + r[6] * n),
          (this.y = r[1] * t + r[4] * i + r[7] * n),
          (this.z = r[2] * t + r[5] * i + r[8] * n),
          this
        );
      },
      applyMatrix4: function (env) {
        var t = this.x,
          i = this.y,
          n = this.z,
          r = env.elements,
          a = 1 / (r[3] * t + r[7] * i + r[11] * n + r[15]);
        return (
          (this.x = (r[0] * t + r[4] * i + r[8] * n + r[12]) * a),
          (this.y = (r[1] * t + r[5] * i + r[9] * n + r[13]) * a),
          (this.z = (r[2] * t + r[6] * i + r[10] * n + r[14]) * a),
          this
        );
      },
      applyQuaternion: function (env) {
        var t = this.x,
          i = this.y,
          n = this.z,
          r = env.x,
          a = env.y,
          ObjectMethodWrapper = env.z,
          CounterVariable = env.w,
          RandomGenerator = CounterVariable * t + a * n - ObjectMethodWrapper * i,
          HelperFunction = CounterVariable * i + ObjectMethodWrapper * t - r * n,
          EnsureFunction = CounterVariable * n + r * i - a * t,
          GlobalReference = -r * t - a * i - ObjectMethodWrapper * n;
        return (
          (this.x = RandomGenerator * CounterVariable + GlobalReference * -r + HelperFunction * -ObjectMethodWrapper - EnsureFunction * -a),
          (this.y = HelperFunction * CounterVariable + GlobalReference * -a + EnsureFunction * -r - RandomGenerator * -ObjectMethodWrapper),
          (this.z = EnsureFunction * CounterVariable + GlobalReference * -ObjectMethodWrapper + RandomGenerator * -a - HelperFunction * -r),
          this
        );
      },
      project: function (env) {
        return this.applyMatrix4(env.matrixWorldInverse).applyMatrix4(
          env.projectionMatrix,
        );
      },
      unproject:
        ((Ql = new gu()),
        function (env) {
          return this.applyMatrix4(
            Ql.getInverse(env.projectionMatrix),
          ).applyMatrix4(env.matrixWorld);
        }),
      transformDirection: function (env) {
        var t = this.x,
          i = this.y,
          n = this.z,
          r = env.elements;
        return (
          (this.x = r[0] * t + r[4] * i + r[8] * n),
          (this.y = r[1] * t + r[5] * i + r[9] * n),
          (this.z = r[2] * t + r[6] * i + r[10] * n),
          this.normalize()
        );
      },
      divide: function (env) {
        return (this.x /= env.x), (this.y /= env.y), (this.z /= env.z), this;
      },
      divideScalar: function (env) {
        return this.multiplyScalar(1 / env);
      },
      min: function (env) {
        return (
          (this.x = Math.min(this.x, env.x)),
          (this.y = Math.min(this.y, env.y)),
          (this.z = Math.min(this.z, env.z)),
          this
        );
      },
      max: function (env) {
        return (
          (this.x = Math.max(this.x, env.x)),
          (this.y = Math.max(this.y, env.y)),
          (this.z = Math.max(this.z, env.z)),
          this
        );
      },
      clamp: function (env, t) {
        return (
          (this.x = Math.max(env.x, Math.min(t.x, this.x))),
          (this.y = Math.max(env.y, Math.min(t.y, this.y))),
          (this.z = Math.max(env.z, Math.min(t.z, this.z))),
          this
        );
      },
      clampScalar:
        ((Yl = new yu()),
        (ql = new yu()),
        function (env, t) {
          return Yl.set(env, env, env), ql.set(t, t, t), this.clamp(Yl, ql);
        }),
      clampLength: function (env, t) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(env, Math.min(t, i)),
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      },
      dot: function (env) {
        return this.x * env.x + this.y * env.y + this.z * env.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (env) {
        return this.normalize().multiplyScalar(env);
      },
      lerp: function (env, t) {
        return (
          (this.x += (env.x - this.x) * t),
          (this.y += (env.y - this.y) * t),
          (this.z += (env.z - this.z) * t),
          this
        );
      },
      lerpVectors: function (env, t, i) {
        return this.subVectors(t, env).multiplyScalar(i).add(env);
      },
      cross: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.",
            ),
            this.crossVectors(env, t))
          : this.crossVectors(this, env);
      },
      crossVectors: function (env, t) {
        var i = env.x,
          n = env.y,
          r = env.z,
          a = t.x,
          ObjectMethodWrapper = t.y,
          CounterVariable = t.z;
        return (
          (this.x = n * CounterVariable - r * ObjectMethodWrapper),
          (this.y = r * a - i * CounterVariable),
          (this.z = i * ObjectMethodWrapper - n * a),
          this
        );
      },
      projectOnVector: function (env) {
        var t = env.dot(this) / env.lengthSq();
        return this.copy(env).multiplyScalar(t);
      },
      projectOnPlane:
        ((Wl = new yu()),
        function (env) {
          return Wl.copy(this).projectOnVector(env), this.sub(Wl);
        }),
      reflect:
        ((Xl = new yu()),
        function (env) {
          return this.sub(Xl.copy(env).multiplyScalar(2 * this.dot(env)));
        }),
      angleTo: function (env) {
        var t = this.dot(env) / Math.sqrt(this.lengthSq() * env.lengthSq());
        return Math.acos(fu.clamp(t, -1, 1));
      },
      distanceTo: function (env) {
        return Math.sqrt(this.distanceToSquared(env));
      },
      distanceToSquared: function (env) {
        var t = this.x - env.x,
          i = this.y - env.y,
          n = this.z - env.z;
        return t * t + i * i + n * n;
      },
      manhattanDistanceTo: function (env) {
        return (
          Math.abs(this.x - env.x) +
          Math.abs(this.y - env.y) +
          Math.abs(this.z - env.z)
        );
      },
      setFromSpherical: function (env) {
        return this.setFromSphericalCoords(env.radius, env.phi, env.theta);
      },
      setFromSphericalCoords: function (env, t, i) {
        var n = Math.sin(t) * env;
        return (
          (this.x = n * Math.sin(i)),
          (this.y = Math.cos(t) * env),
          (this.z = n * Math.cos(i)),
          this
        );
      },
      setFromCylindrical: function (env) {
        return this.setFromCylindricalCoords(env.radius, env.theta, env.y);
      },
      setFromCylindricalCoords: function (env, t, i) {
        return (
          (this.x = env * Math.sin(t)),
          (this.y = i),
          (this.z = env * Math.cos(t)),
          this
        );
      },
      setFromMatrixPosition: function (env) {
        var t = env.elements;
        return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
      },
      setFromMatrixScale: function (env) {
        var t = this.setFromMatrixColumn(env, 0).length(),
          i = this.setFromMatrixColumn(env, 1).length(),
          n = this.setFromMatrixColumn(env, 2).length();
        return (this.x = t), (this.y = i), (this.z = n), this;
      },
      setFromMatrixColumn: function (env, t) {
        return this.fromArray(env.elements, 4 * t);
      },
      equals: function (env) {
        return env.x === this.x && env.y === this.y && env.z === this.z;
      },
      fromArray: function (env, t) {
        return (
          void 0 === t && (t = 0),
          (this.x = env[t]),
          (this.y = env[t + 1]),
          (this.z = env[t + 2]),
          this
        );
      },
      toArray: function (env, t) {
        return (
          void 0 === env && (env = []),
          void 0 === t && (t = 0),
          (env[t] = this.x),
          (env[t + 1] = this.y),
          (env[t + 2] = this.z),
          env
        );
      },
      fromBufferAttribute: function (env, t, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector3: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = env.getX(t)),
          (this.y = env.getY(t)),
          (this.z = env.getZ(t)),
          this
        );
      },
    }),
    Object.assign(_u.prototype, {
      isMatrix3: !0,
      set: function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
        var HelperFunction = this.elements;
        return (
          (HelperFunction[0] = env),
          (HelperFunction[1] = n),
          (HelperFunction[2] = ObjectMethodWrapper),
          (HelperFunction[3] = t),
          (HelperFunction[4] = r),
          (HelperFunction[5] = CounterVariable),
          (HelperFunction[6] = i),
          (HelperFunction[7] = a),
          (HelperFunction[8] = RandomGenerator),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (env) {
        var t = this.elements,
          i = env.elements;
        return (
          (t[0] = i[0]),
          (t[1] = i[1]),
          (t[2] = i[2]),
          (t[3] = i[3]),
          (t[4] = i[4]),
          (t[5] = i[5]),
          (t[6] = i[6]),
          (t[7] = i[7]),
          (t[8] = i[8]),
          this
        );
      },
      setFromMatrix4: function (env) {
        var t = env.elements;
        return (
          this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        );
      },
      applyToBufferAttribute:
        ((Kl = new yu()),
        function (env) {
          for (var t = 0, i = env.count; t < i; t++)
            (Kl.x = env.getX(t)),
              (Kl.y = env.getY(t)),
              (Kl.z = env.getZ(t)),
              Kl.applyMatrix3(this),
              env.setXYZ(t, Kl.x, Kl.y, Kl.z);
          return env;
        }),
      multiply: function (env) {
        return this.multiplyMatrices(this, env);
      },
      premultiply: function (env) {
        return this.multiplyMatrices(env, this);
      },
      multiplyMatrices: function (env, t) {
        var i = env.elements,
          n = t.elements,
          r = this.elements,
          a = i[0],
          ObjectMethodWrapper = i[3],
          CounterVariable = i[6],
          RandomGenerator = i[1],
          HelperFunction = i[4],
          EnsureFunction = i[7],
          GlobalReference = i[2],
          Property = i[5],
          MathFloorShortcut = i[8],
          f = n[0],
          ModuleMeta = n[3],
          g = n[6],
          Value = n[1],
          y = n[4],
          _ = n[7],
          x = n[2],
          b = n[5],
          w = n[8];
        return (
          (r[0] = a * f + ObjectMethodWrapper * Value + CounterVariable * x),
          (r[3] = a * ModuleMeta + ObjectMethodWrapper * y + CounterVariable * b),
          (r[6] = a * g + ObjectMethodWrapper * _ + CounterVariable * w),
          (r[1] = RandomGenerator * f + HelperFunction * Value + EnsureFunction * x),
          (r[4] = RandomGenerator * ModuleMeta + HelperFunction * y + EnsureFunction * b),
          (r[7] = RandomGenerator * g + HelperFunction * _ + EnsureFunction * w),
          (r[2] = GlobalReference * f + Property * Value + MathFloorShortcut * x),
          (r[5] = GlobalReference * ModuleMeta + Property * y + MathFloorShortcut * b),
          (r[8] = GlobalReference * g + Property * _ + MathFloorShortcut * w),
          this
        );
      },
      multiplyScalar: function (env) {
        var t = this.elements;
        return (
          (t[0] *= env),
          (t[3] *= env),
          (t[6] *= env),
          (t[1] *= env),
          (t[4] *= env),
          (t[7] *= env),
          (t[2] *= env),
          (t[5] *= env),
          (t[8] *= env),
          this
        );
      },
      determinant: function () {
        var env = this.elements,
          t = env[0],
          i = env[1],
          n = env[2],
          r = env[3],
          a = env[4],
          ObjectMethodWrapper = env[5],
          CounterVariable = env[6],
          RandomGenerator = env[7],
          HelperFunction = env[8];
        return (
          t * a * HelperFunction - t * ObjectMethodWrapper * RandomGenerator - i * r * HelperFunction + i * ObjectMethodWrapper * CounterVariable + n * r * RandomGenerator - n * a * CounterVariable
        );
      },
      getInverse: function (env, t) {
        env &&
          env.isMatrix4 &&
          console.error(
            "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.",
          );
        var i = env.elements,
          n = this.elements,
          r = i[0],
          a = i[1],
          ObjectMethodWrapper = i[2],
          CounterVariable = i[3],
          RandomGenerator = i[4],
          HelperFunction = i[5],
          EnsureFunction = i[6],
          GlobalReference = i[7],
          Property = i[8],
          MathFloorShortcut = Property * RandomGenerator - HelperFunction * GlobalReference,
          f = HelperFunction * EnsureFunction - Property * CounterVariable,
          ModuleMeta = GlobalReference * CounterVariable - RandomGenerator * EnsureFunction,
          g = r * MathFloorShortcut + a * f + ObjectMethodWrapper * ModuleMeta;
        if (0 === g) {
          var Value =
            "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === t) throw new Error(Value);
          return console.warn(Value), this.identity();
        }
        var y = 1 / g;
        return (
          (n[0] = MathFloorShortcut * y),
          (n[1] = (ObjectMethodWrapper * GlobalReference - Property * a) * y),
          (n[2] = (HelperFunction * a - ObjectMethodWrapper * RandomGenerator) * y),
          (n[3] = f * y),
          (n[4] = (Property * r - ObjectMethodWrapper * EnsureFunction) * y),
          (n[5] = (ObjectMethodWrapper * CounterVariable - HelperFunction * r) * y),
          (n[6] = ModuleMeta * y),
          (n[7] = (a * EnsureFunction - GlobalReference * r) * y),
          (n[8] = (RandomGenerator * r - a * CounterVariable) * y),
          this
        );
      },
      transpose: function () {
        var env,
          t = this.elements;
        return (
          (env = t[1]),
          (t[1] = t[3]),
          (t[3] = env),
          (env = t[2]),
          (t[2] = t[6]),
          (t[6] = env),
          (env = t[5]),
          (t[5] = t[7]),
          (t[7] = env),
          this
        );
      },
      getNormalMatrix: function (env) {
        return this.setFromMatrix4(env).getInverse(this).transpose();
      },
      transposeIntoArray: function (env) {
        var t = this.elements;
        return (
          (env[0] = t[0]),
          (env[1] = t[3]),
          (env[2] = t[6]),
          (env[3] = t[1]),
          (env[4] = t[4]),
          (env[5] = t[7]),
          (env[6] = t[2]),
          (env[7] = t[5]),
          (env[8] = t[8]),
          this
        );
      },
      setUvTransform: function (env, t, i, n, r, a, ObjectMethodWrapper) {
        var CounterVariable = Math.cos(r),
          RandomGenerator = Math.sin(r);
        this.set(
          i * CounterVariable,
          i * RandomGenerator,
          -i * (CounterVariable * a + RandomGenerator * ObjectMethodWrapper) + a + env,
          -n * RandomGenerator,
          n * CounterVariable,
          -n * (-RandomGenerator * a + CounterVariable * ObjectMethodWrapper) + ObjectMethodWrapper + t,
          0,
          0,
          1,
        );
      },
      scale: function (env, t) {
        var i = this.elements;
        return (
          (i[0] *= env),
          (i[3] *= env),
          (i[6] *= env),
          (i[1] *= t),
          (i[4] *= t),
          (i[7] *= t),
          this
        );
      },
      rotate: function (env) {
        var t = Math.cos(env),
          i = Math.sin(env),
          n = this.elements,
          r = n[0],
          a = n[3],
          ObjectMethodWrapper = n[6],
          CounterVariable = n[1],
          RandomGenerator = n[4],
          HelperFunction = n[7];
        return (
          (n[0] = t * r + i * CounterVariable),
          (n[3] = t * a + i * RandomGenerator),
          (n[6] = t * ObjectMethodWrapper + i * HelperFunction),
          (n[1] = -i * r + t * CounterVariable),
          (n[4] = -i * a + t * RandomGenerator),
          (n[7] = -i * ObjectMethodWrapper + t * HelperFunction),
          this
        );
      },
      translate: function (env, t) {
        var i = this.elements;
        return (
          (i[0] += env * i[2]),
          (i[3] += env * i[5]),
          (i[6] += env * i[8]),
          (i[1] += t * i[2]),
          (i[4] += t * i[5]),
          (i[7] += t * i[8]),
          this
        );
      },
      equals: function (env) {
        for (var t = this.elements, i = env.elements, n = 0; n < 9; n++)
          if (t[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (env, t) {
        void 0 === t && (t = 0);
        for (var i = 0; i < 9; i++) this.elements[i] = env[i + t];
        return this;
      },
      toArray: function (env, t) {
        void 0 === env && (env = []), void 0 === t && (t = 0);
        var i = this.elements;
        return (
          (env[t] = i[0]),
          (env[t + 1] = i[1]),
          (env[t + 2] = i[2]),
          (env[t + 3] = i[3]),
          (env[t + 4] = i[4]),
          (env[t + 5] = i[5]),
          (env[t + 6] = i[6]),
          (env[t + 7] = i[7]),
          (env[t + 8] = i[8]),
          env
        );
      },
    });
  var xu,
    bu,
    wu,
    Tu,
    Su,
    Eu,
    Au,
    Mu,
    Pu,
    Lu,
    Cu,
    Iu,
    Ru,
    Ou,
    Fu,
    Nu,
    ku = {
      getDataURL: function (env) {
        var t;
        if (env instanceof HTMLCanvasElement) t = env;
        else {
          ((t = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas",
          )).width = env.width),
            (t.height = env.height);
          var i = t.getContext("2d");
          env instanceof ImageData
            ? i.putImageData(env, 0, 0)
            : i.drawImage(env, 0, 0, env.width, env.height);
        }
        return 2048 < t.width || 2048 < t.height
          ? t.toDataURL("image/jpeg", 0.6)
          : t.toDataURL("image/png");
      },
    },
    Uu = 0;

function Du(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction) {
  // تعریف یک شناسه یکتا برای هر نمونه از این کلاس
  Object.defineProperty(this, "id", { value: Uu++ }),

    // تولید یک UUID (شناسه یکتا جهانی) برای هر نمونه. این شناسه برای ردیابی اشیا در سیستم استفاده می‌شود.
    (this.uuid = fu.generateUUID()),

    // مقدار پیش‌فرض برای نام بافت. در صورت عدم تخصیص، رشته خالی قرار می‌گیرد.
    (this.name = ""),

    // تصویر مورد استفاده در بافت. اگر مقدار اولیه‌ای مشخص نشده باشد، مقدار پیش‌فرض تعیین می‌شود.
    (this.image = void 0 !== env ? env : Du.DEFAULT_IMAGE),

    // آرایه‌ای برای ذخیره mipmaps (تصاویر کوچک‌تر شده از بافت اصلی برای بهینه‌سازی در زوم و مقیاس‌های مختلف)
    (this.mipmaps = []),

    // نحوه نگاشت بافت (Mapping)، که مشخص می‌کند چگونه بافت روی اشیا ترسیم شود. مقدار پیش‌فرض استفاده می‌شود اگر تعیین نشده باشد.
    (this.mapping = void 0 !== t ? t : Du.DEFAULT_MAPPING),

    // تنظیم روش پیچیدن (wrapping) در محور S (افقی) برای تعیین رفتار در زمان تکرار بافت
    (this.wrapS = void 0 !== i ? i : nc),

    // تنظیم روش پیچیدن (wrapping) در محور T (عمودی) برای تعیین رفتار در زمان تکرار بافت
    (this.wrapT = void 0 !== n ? n : nc),

    // تعیین نوع فیلتر بزرگ‌نمایی بافت. این فیلتر برای تنظیم کیفیت تصویر هنگام بزرگ‌نمایی بافت استفاده می‌شود.
    (this.magFilter = void 0 !== r ? r : LineCounter),

    // تعیین نوع فیلتر کوچک‌نمایی بافت. این فیلتر برای تنظیم کیفیت تصویر هنگام کوچک‌نمایی بافت استفاده می‌شود.
    (this.minFilter = void 0 !== a ? a : CharacterCount),

    // مقدار آنیزوتروپی (anisotropy) برای بهبود کیفیت بافت‌هایی که در زاویه‌های غیرمستقیم دیده می‌شوند.
    (this.anisotropy = void 0 !== RandomGenerator ? RandomGenerator : 1),

    // تنظیم فرمت داده‌های بافت. این فرمت مشخص می‌کند داده‌ها چگونه ذخیره و پردازش شوند.
    (this.format = void 0 !== ObjectMethodWrapper ? ObjectMethodWrapper : Ec),

    // نوع داده بافت (مانند عدد صحیح یا ممیز شناور) که نحوه پردازش و نمایش داده‌ها را تعیین می‌کند.
    (this.type = void 0 !== CounterVariable ? CounterVariable : UserCache),

    // تنظیم مقدار آفست (offset) یا انتقال در محور x و y. این مقدار تعیین می‌کند که بافت چقدر از موقعیت اصلی خود جابه‌جا شود.
    (this.offset = new mu(0, 0)),

    // مقیاس (scale) یا تکرار بافت در محور x و y. این مقدار مشخص می‌کند بافت چند بار در یک محور تکرار شود.
    (this.repeat = new mu(1, 1)),

    // تنظیم مرکز چرخش بافت. با تغییر این مقدار، محور چرخش بافت تغییر می‌کند.
    (this.center = new mu(0, 0)),

    // مقدار چرخش بافت بر حسب رادیان. این مقدار تعیین می‌کند که بافت چه زاویه‌ای نسبت به حالت اولیه خود بچرخد.
    (this.rotation = 0),

    // مشخص می‌کند که آیا ماتریس تحولات بافت به صورت خودکار به‌روزرسانی شود یا خیر.
    (this.matrixAutoUpdate = !0),

    // ماتریس تحولات بافت. این ماتریس شامل تمامی تغییرات مربوط به مقیاس، چرخش و انتقال است.
    (this.matrix = new _u()),

    // فعال یا غیرفعال کردن تولید mipmaps. این ویژگی برای بهینه‌سازی کیفیت رندرینگ استفاده می‌شود.
    (this.generateMipmaps = !0),

    // مشخص می‌کند که آیا رنگ آلفا (شفافیت) به صورت پیش‌ضرب ذخیره شود یا خیر.
    (this.premultiplyAlpha = !1),

    // تعیین می‌کند که آیا بافت در محور y معکوس شود یا نه. این ویژگی معمولاً برای بافت‌های تصویری مورد نیاز است.
    (this.flipY = !0),

    // تطابق تنظیمات بسته‌بندی داده‌ها (unpack alignment) برای پردازش بهینه داده‌ها
    (this.unpackAlignment = 4),

    // تنظیم رمزگذاری (encoding) برای تعیین نحوه نمایش داده‌های بافت
    (this.encoding = void 0 !== HelperFunction ? HelperFunction : nu),

    // نسخه بافت. هر بار که تغییری در بافت اعمال می‌شود، این مقدار افزایش می‌یابد.
    (this.version = 0),

    // تعریف یک تابع قابل تنظیم که هنگام به‌روزرسانی بافت فراخوانی می‌شود.
    (this.onUpdate = null);
}


  function zu(env, t, i, n) {
    (this.x = env || 0),
      (this.y = t || 0),
      (this.z = i || 0),
      (this.w = void 0 !== n ? n : 1);
  }

  function Bu(env, t, i) {
    (this.width = env),
      (this.height = t),
      (this.scissor = new zu(0, 0, env, t)),
      (this.scissorTest = !1),
      (this.viewport = new zu(0, 0, env, t)),
      void 0 === (i = i || {}).minFilter && (i.minFilter = LineCounter),
      (this.texture = new Du(
        void 0,
        void 0,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding,
      )),
      (this.texture.generateMipmaps =
        void 0 === i.generateMipmaps || i.generateMipmaps),
      (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
      (this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer),
      (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null);
  }

  function Hu(env, t, i) {
    Bu.call(this, env, t, i),
      (this.activeCubeFace = 0),
      (this.activeMipMapLevel = 0);
  }

  function Gu(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction, GlobalReference) {
    Du.call(this, null, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, n, r, EnsureFunction, GlobalReference),
      (this.image = {
        data: env,
        width: t,
        height: i,
      }),
      (this.magFilter = void 0 !== RandomGenerator ? RandomGenerator : ac),
      (this.minFilter = void 0 !== HelperFunction ? HelperFunction : ac),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }

  function ju(env, t) {
    (this.min = void 0 !== env ? env : new yu(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== t ? t : new yu(-1 / 0, -1 / 0, -1 / 0));
  }

  function Vu(env, t) {
    (this.center = void 0 !== env ? env : new yu()),
      (this.radius = void 0 !== t ? t : 0);
  }

  function Xu(env, t) {
    (this.normal = void 0 !== env ? env : new yu(1, 0, 0)),
      (this.constant = void 0 !== t ? t : 0);
  }

  function Wu(env, t, i, n, r, a) {
    this.planes = [
      void 0 !== env ? env : new Xu(),
      void 0 !== t ? t : new Xu(),
      void 0 !== i ? i : new Xu(),
      void 0 !== n ? n : new Xu(),
      void 0 !== r ? r : new Xu(),
      void 0 !== a ? a : new Xu(),
    ];
  }

  (Du.DEFAULT_IMAGE = void 0),
    (Du.DEFAULT_MAPPING = 300),
    (Du.prototype = Object.assign(Object.create(Il.prototype), {
      constructor: Du,
      isTexture: !0,
      updateMatrix: function () {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y,
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return (
          (this.name = env.name),
          (this.image = env.image),
          (this.mipmaps = env.mipmaps.slice(0)),
          (this.mapping = env.mapping),
          (this.wrapS = env.wrapS),
          (this.wrapT = env.wrapT),
          (this.magFilter = env.magFilter),
          (this.minFilter = env.minFilter),
          (this.anisotropy = env.anisotropy),
          (this.format = env.format),
          (this.type = env.type),
          this.offset.copy(env.offset),
          this.repeat.copy(env.repeat),
          this.center.copy(env.center),
          (this.rotation = env.rotation),
          (this.matrixAutoUpdate = env.matrixAutoUpdate),
          this.matrix.copy(env.matrix),
          (this.generateMipmaps = env.generateMipmaps),
          (this.premultiplyAlpha = env.premultiplyAlpha),
          (this.flipY = env.flipY),
          (this.unpackAlignment = env.unpackAlignment),
          (this.encoding = env.encoding),
          this
        );
      },
      toJSON: function (env) {
        var t = void 0 === env || "string" == typeof env;
        if (!t && void 0 !== env.textures[this.uuid])
          return env.textures[this.uuid];
        var i = {
          metadata: {
            version: 4.5,
            type: "Texture",
            generator: "Texture.toJSON",
          },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
        };
        if (void 0 !== this.image) {
          var n = this.image;
          if (
            (void 0 === n.uuid && (n.uuid = fu.generateUUID()),
            !t && void 0 === env.images[n.uuid])
          ) {
            var r;
            if (Array.isArray(n)) {
              r = [];
              for (var a = 0, ObjectMethodWrapper = n.length; a < ObjectMethodWrapper; a++)
                r.push(ku.getDataURL(n[a]));
            } else r = ku.getDataURL(n);
            env.images[n.uuid] = { uuid: n.uuid, url: r };
          }
          i.image = n.uuid;
        }
        return t || (env.textures[this.uuid] = i), i;
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
      transformUv: function (env) {
        if (300 !== this.mapping) return env;
        if ((env.applyMatrix3(this.matrix), env.x < 0 || 1 < env.x))
          switch (this.wrapS) {
            case IndexCounter:
              env.x = env.x - Math.floor(env.x);
              break;
            case nc:
              env.x = env.x < 0 ? 0 : 1;
              break;
            case RequestCache:
              1 === Math.abs(Math.floor(env.x) % 2)
                ? (env.x = Math.ceil(env.x) - env.x)
                : (env.x = env.x - Math.floor(env.x));
          }
        if (env.y < 0 || 1 < env.y)
          switch (this.wrapT) {
            case IndexCounter:
              env.y = env.y - Math.floor(env.y);
              break;
            case nc:
              env.y = env.y < 0 ? 0 : 1;
              break;
            case RequestCache:
              1 === Math.abs(Math.floor(env.y) % 2)
                ? (env.y = Math.ceil(env.y) - env.y)
                : (env.y = env.y - Math.floor(env.y));
          }
        return this.flipY && (env.y = 1 - env.y), env;
      },
    })),
    Object.defineProperty(Du.prototype, "needsUpdate", {
      set: function (env) {
        !0 === env && this.version++;
      },
    }),
    Object.assign(zu.prototype, {
      isVector4: !0,
      set: function (env, t, i, n) {
        return (this.x = env), (this.y = t), (this.z = i), (this.w = n), this;
      },
      setScalar: function (env) {
        return (this.x = env), (this.y = env), (this.z = env), (this.w = env), this;
      },
      setX: function (env) {
        return (this.x = env), this;
      },
      setY: function (env) {
        return (this.y = env), this;
      },
      setZ: function (env) {
        return (this.z = env), this;
      },
      setW: function (env) {
        return (this.w = env), this;
      },
      setComponent: function (env, t) {
        switch (env) {
          case 0:
            this.x = t;
            break;
          case 1:
            this.y = t;
            break;
          case 2:
            this.z = t;
            break;
          case 3:
            this.w = t;
            break;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
        return this;
      },
      getComponent: function (env) {
        switch (env) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error("index is out OutputFormatter range: " + env);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function (env) {
        return (
          (this.x = env.x),
          (this.y = env.y),
          (this.z = env.z),
          (this.w = void 0 !== env.w ? env.w : 1),
          this
        );
      },
      add: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.",
            ),
            this.addVectors(env, t))
          : ((this.x += env.x),
            (this.y += env.y),
            (this.z += env.z),
            (this.w += env.w),
            this);
      },
      addScalar: function (env) {
        return (this.x += env), (this.y += env), (this.z += env), (this.w += env), this;
      },
      addVectors: function (env, t) {
        return (
          (this.x = env.x + t.x),
          (this.y = env.y + t.y),
          (this.z = env.z + t.z),
          (this.w = env.w + t.w),
          this
        );
      },
      addScaledVector: function (env, t) {
        return (
          (this.x += env.x * t),
          (this.y += env.y * t),
          (this.z += env.z * t),
          (this.w += env.w * t),
          this
        );
      },
      sub: function (env, t) {
        return void 0 !== t
          ? (console.warn(
              "THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.",
            ),
            this.subVectors(env, t))
          : ((this.x -= env.x),
            (this.y -= env.y),
            (this.z -= env.z),
            (this.w -= env.w),
            this);
      },
      subScalar: function (env) {
        return (this.x -= env), (this.y -= env), (this.z -= env), (this.w -= env), this;
      },
      subVectors: function (env, t) {
        return (
          (this.x = env.x - t.x),
          (this.y = env.y - t.y),
          (this.z = env.z - t.z),
          (this.w = env.w - t.w),
          this
        );
      },
      multiplyScalar: function (env) {
        return (this.x *= env), (this.y *= env), (this.z *= env), (this.w *= env), this;
      },
      applyMatrix4: function (env) {
        var t = this.x,
          i = this.y,
          n = this.z,
          r = this.w,
          a = env.elements;
        return (
          (this.x = a[0] * t + a[4] * i + a[8] * n + a[12] * r),
          (this.y = a[1] * t + a[5] * i + a[9] * n + a[13] * r),
          (this.z = a[2] * t + a[6] * i + a[10] * n + a[14] * r),
          (this.w = a[3] * t + a[7] * i + a[11] * n + a[15] * r),
          this
        );
      },
      divideScalar: function (env) {
        return this.multiplyScalar(1 / env);
      },
      setAxisAngleFromQuaternion: function (env) {
        this.w = 2 * Math.acos(env.w);
        var t = Math.sqrt(1 - env.w * env.w);
        return (
          (this.z =
            t < 1e-4
              ? ((this.x = 1), (this.y = 0))
              : ((this.x = env.x / t), (this.y = env.y / t), env.z / t)),
          this
        );
      },
      setAxisAngleFromRotationMatrix: function (env) {
        var t,
          i,
          n,
          r,
          a = env.elements,
          ObjectMethodWrapper = a[0],
          CounterVariable = a[4],
          RandomGenerator = a[8],
          HelperFunction = a[1],
          EnsureFunction = a[5],
          GlobalReference = a[9],
          Property = a[2],
          MathFloorShortcut = a[6],
          f = a[10];
        if (
          Math.abs(CounterVariable - HelperFunction) < 0.01 &&
          Math.abs(RandomGenerator - Property) < 0.01 &&
          Math.abs(GlobalReference - MathFloorShortcut) < 0.01
        ) {
          if (
            Math.abs(CounterVariable + HelperFunction) < 0.1 &&
            Math.abs(RandomGenerator + Property) < 0.1 &&
            Math.abs(GlobalReference + MathFloorShortcut) < 0.1 &&
            Math.abs(ObjectMethodWrapper + EnsureFunction + f - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          t = Math.PI;
          var ModuleMeta = (ObjectMethodWrapper + 1) / 2,
            g = (EnsureFunction + 1) / 2,
            Value = (f + 1) / 2,
            y = (CounterVariable + HelperFunction) / 4,
            _ = (RandomGenerator + Property) / 4,
            x = (GlobalReference + MathFloorShortcut) / 4;
          return (
            g < ModuleMeta && Value < ModuleMeta
              ? (r =
                  ModuleMeta < 0.01
                    ? ((i = 0), (n = 0.707106781))
                    : ((n = y / (i = Math.sqrt(ModuleMeta))), _ / i))
              : Value < g
                ? (r =
                    g < 0.01
                      ? ((n = 0), (i = 0.707106781))
                      : ((i = y / (n = Math.sqrt(g))), x / n))
                : Value < 0.01
                  ? ((n = i = 0.707106781), (r = 0))
                  : ((i = _ / (r = Math.sqrt(Value))), (n = x / r)),
            this.set(i, n, r, t),
            this
          );
        }
        var b = Math.sqrt(
          (MathFloorShortcut - GlobalReference) * (MathFloorShortcut - GlobalReference) + (RandomGenerator - Property) * (RandomGenerator - Property) + (HelperFunction - CounterVariable) * (HelperFunction - CounterVariable),
        );
        return (
          Math.abs(b) < 0.001 && (b = 1),
          (this.x = (MathFloorShortcut - GlobalReference) / b),
          (this.y = (RandomGenerator - Property) / b),
          (this.z = (HelperFunction - CounterVariable) / b),
          (this.w = Math.acos((ObjectMethodWrapper + EnsureFunction + f - 1) / 2)),
          this
        );
      },
      min: function (env) {
        return (
          (this.x = Math.min(this.x, env.x)),
          (this.y = Math.min(this.y, env.y)),
          (this.z = Math.min(this.z, env.z)),
          (this.w = Math.min(this.w, env.w)),
          this
        );
      },
      max: function (env) {
        return (
          (this.x = Math.max(this.x, env.x)),
          (this.y = Math.max(this.y, env.y)),
          (this.z = Math.max(this.z, env.z)),
          (this.w = Math.max(this.w, env.w)),
          this
        );
      },
      clamp: function (env, t) {
        return (
          (this.x = Math.max(env.x, Math.min(t.x, this.x))),
          (this.y = Math.max(env.y, Math.min(t.y, this.y))),
          (this.z = Math.max(env.z, Math.min(t.z, this.z))),
          (this.w = Math.max(env.w, Math.min(t.w, this.w))),
          this
        );
      },
      clampScalar: function (env, t) {
        return (
          void 0 === xu && ((xu = new zu()), (bu = new zu())),
          xu.set(env, env, env, env),
          bu.set(t, t, t, t),
          this.clamp(xu, bu)
        );
      },
      clampLength: function (env, t) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(
          Math.max(env, Math.min(t, i)),
        );
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      },
      negate: function () {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      },
      dot: function (env) {
        return this.x * env.x + this.y * env.y + this.z * env.z + this.w * env.w;
      },
      lengthSq: function () {
        return (
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      },
      length: function () {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
        );
      },
      manhattanLength: function () {
        return (
          Math.abs(this.x) +
          Math.abs(this.y) +
          Math.abs(this.z) +
          Math.abs(this.w)
        );
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (env) {
        return this.normalize().multiplyScalar(env);
      },
      lerp: function (env, t) {
        return (
          (this.x += (env.x - this.x) * t),
          (this.y += (env.y - this.y) * t),
          (this.z += (env.z - this.z) * t),
          (this.w += (env.w - this.w) * t),
          this
        );
      },
      lerpVectors: function (env, t, i) {
        return this.subVectors(t, env).multiplyScalar(i).add(env);
      },
      equals: function (env) {
        return (
          env.x === this.x && env.y === this.y && env.z === this.z && env.w === this.w
        );
      },
      fromArray: function (env, t) {
        return (
          void 0 === t && (t = 0),
          (this.x = env[t]),
          (this.y = env[t + 1]),
          (this.z = env[t + 2]),
          (this.w = env[t + 3]),
          this
        );
      },
      toArray: function (env, t) {
        return (
          void 0 === env && (env = []),
          void 0 === t && (t = 0),
          (env[t] = this.x),
          (env[t + 1] = this.y),
          (env[t + 2] = this.z),
          (env[t + 3] = this.w),
          env
        );
      },
      fromBufferAttribute: function (env, t, i) {
        return (
          void 0 !== i &&
            console.warn(
              "THREE.Vector4: offset has been removed from .fromBufferAttribute().",
            ),
          (this.x = env.getX(t)),
          (this.y = env.getY(t)),
          (this.z = env.getZ(t)),
          (this.w = env.getW(t)),
          this
        );
      },
    }),
    (Bu.prototype = Object.assign(Object.create(Il.prototype), {
      constructor: Bu,
      isWebGLRenderTarget: !0,
      setSize: function (env, t) {
        (this.width === env && this.height === t) ||
          ((this.width = env), (this.height = t), this.dispose()),
          this.viewport.set(0, 0, env, t),
          this.scissor.set(0, 0, env, t);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return (
          (this.width = env.width),
          (this.height = env.height),
          this.viewport.copy(env.viewport),
          (this.texture = env.texture.clone()),
          (this.depthBuffer = env.depthBuffer),
          (this.stencilBuffer = env.stencilBuffer),
          (this.depthTexture = env.depthTexture),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: "dispose" });
      },
    })),
    (((Hu.prototype = Object.create(Bu.prototype)).constructor =
      Hu).prototype.isWebGLRenderTargetCube = !0),
    (((Gu.prototype = Object.create(Du.prototype)).constructor =
      Gu).prototype.isDataTexture = !0),
    Object.assign(ju.prototype, {
      isBox3: !0,
      set: function (env, t) {
        return this.min.copy(env), this.max.copy(t), this;
      },
      setFromArray: function (env) {
        for (
          var t = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            ObjectMethodWrapper = -1 / 0,
            CounterVariable = 0,
            RandomGenerator = env.length;
          CounterVariable < RandomGenerator;
          CounterVariable += 3
        ) {
          var HelperFunction = env[CounterVariable],
            EnsureFunction = env[CounterVariable + 1],
            GlobalReference = env[CounterVariable + 2];
          HelperFunction < t && (t = HelperFunction),
            EnsureFunction < i && (i = EnsureFunction),
            GlobalReference < n && (n = GlobalReference),
            r < HelperFunction && (r = HelperFunction),
            a < EnsureFunction && (a = EnsureFunction),
            ObjectMethodWrapper < GlobalReference && (ObjectMethodWrapper = GlobalReference);
        }
        return this.min.set(t, i, n), this.max.set(r, a, ObjectMethodWrapper), this;
      },
      setFromBufferAttribute: function (env) {
        for (
          var t = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            ObjectMethodWrapper = -1 / 0,
            CounterVariable = 0,
            RandomGenerator = env.count;
          CounterVariable < RandomGenerator;
          CounterVariable++
        ) {
          var HelperFunction = env.getX(CounterVariable),
            EnsureFunction = env.getY(CounterVariable),
            GlobalReference = env.getZ(CounterVariable);
          HelperFunction < t && (t = HelperFunction),
            EnsureFunction < i && (i = EnsureFunction),
            GlobalReference < n && (n = GlobalReference),
            r < HelperFunction && (r = HelperFunction),
            a < EnsureFunction && (a = EnsureFunction),
            ObjectMethodWrapper < GlobalReference && (ObjectMethodWrapper = GlobalReference);
        }
        return this.min.set(t, i, n), this.max.set(r, a, ObjectMethodWrapper), this;
      },
      setFromPoints: function (env) {
        this.makeEmpty();
        for (var t = 0, i = env.length; t < i; t++) this.expandByPoint(env[t]);
        return this;
      },
      setFromCenterAndSize:
        ((Au = new yu()),
        function (env, t) {
          var i = Au.copy(t).multiplyScalar(0.5);
          return this.min.copy(env).sub(i), this.max.copy(env).add(i), this;
        }),
      setFromObject: function (env) {
        return this.makeEmpty(), this.expandByObject(env);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.min.copy(env.min), this.max.copy(env.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return (
          this.max.x < this.min.x ||
          this.max.y < this.min.y ||
          this.max.z < this.min.z
        );
      },
      getCenter: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Box3: .getCenter() target is now required"),
            (env = new yu())),
          this.isEmpty()
            ? env.set(0, 0, 0)
            : env.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Box3: .getSize() target is now required"),
            (env = new yu())),
          this.isEmpty() ? env.set(0, 0, 0) : env.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (env) {
        return this.min.min(env), this.max.max(env), this;
      },
      expandByVector: function (env) {
        return this.min.sub(env), this.max.add(env), this;
      },
      expandByScalar: function (env) {
        return this.min.addScalar(-env), this.max.addScalar(env), this;
      },
      expandByObject: (function () {
        var r,
          a,
          ObjectMethodWrapper,
          CounterVariable = new yu();

        function t(env) {
          var t = env.geometry;
          if (void 0 !== t)
            if (t.isGeometry) {
              var i = t.vertices;
              for (a = 0, ObjectMethodWrapper = i.length; a < ObjectMethodWrapper; a++)
                CounterVariable.copy(i[a]), CounterVariable.applyMatrix4(env.matrixWorld), r.expandByPoint(CounterVariable);
            } else if (t.isBufferGeometry) {
              var n = t.attributes.position;
              if (void 0 !== n)
                for (a = 0, ObjectMethodWrapper = n.count; a < ObjectMethodWrapper; a++)
                  CounterVariable.fromBufferAttribute(n, a).applyMatrix4(env.matrixWorld),
                    r.expandByPoint(CounterVariable);
            }
        }

        return function (env) {
          return (r = this), env.updateMatrixWorld(!0), env.traverse(t), this;
        };
      })(),
      containsPoint: function (env) {
        return !(
          env.x < this.min.x ||
          env.x > this.max.x ||
          env.y < this.min.y ||
          env.y > this.max.y ||
          env.z < this.min.z ||
          env.z > this.max.z
        );
      },
      containsBox: function (env) {
        return (
          this.min.x <= env.min.x &&
          env.max.x <= this.max.x &&
          this.min.y <= env.min.y &&
          env.max.y <= this.max.y &&
          this.min.z <= env.min.z &&
          env.max.z <= this.max.z
        );
      },
      getParameter: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .getParameter() target is now required"),
            (t = new yu())),
          t.set(
            (env.x - this.min.x) / (this.max.x - this.min.x),
            (env.y - this.min.y) / (this.max.y - this.min.y),
            (env.z - this.min.z) / (this.max.z - this.min.z),
          )
        );
      },
      intersectsBox: function (env) {
        return !(
          env.max.x < this.min.x ||
          env.min.x > this.max.x ||
          env.max.y < this.min.y ||
          env.min.y > this.max.y ||
          env.max.z < this.min.z ||
          env.min.z > this.max.z
        );
      },
      intersectsSphere:
        ((Eu = new yu()),
        function (env) {
          return (
            this.clampPoint(env.center, Eu),
            Eu.distanceToSquared(env.center) <= env.radius * env.radius
          );
        }),
      intersectsPlane: function (env) {
        var t, i;
        return (
          (i =
            0 < env.normal.x
              ? ((t = env.normal.x * this.min.x), env.normal.x * this.max.x)
              : ((t = env.normal.x * this.max.x), env.normal.x * this.min.x)),
          0 < env.normal.y
            ? ((t += env.normal.y * this.min.y), (i += env.normal.y * this.max.y))
            : ((t += env.normal.y * this.max.y), (i += env.normal.y * this.min.y)),
          0 < env.normal.z
            ? ((t += env.normal.z * this.min.z), (i += env.normal.z * this.max.z))
            : ((t += env.normal.z * this.max.z), (i += env.normal.z * this.min.z)),
          t <= -env.constant && i >= -env.constant
        );
      },
      intersectsTriangle: (function () {
        var CounterVariable = new yu(),
          RandomGenerator = new yu(),
          HelperFunction = new yu(),
          i = new yu(),
          n = new yu(),
          r = new yu(),
          EnsureFunction = new yu(),
          a = new yu(),
          GlobalReference = new yu(),
          ObjectMethodWrapper = new yu();

        function Property(env) {
          var t, i;
          for (t = 0, i = env.length - 3; t <= i; t += 3) {
            EnsureFunction.fromArray(env, t);
            var n =
                GlobalReference.x * Math.abs(EnsureFunction.x) + GlobalReference.y * Math.abs(EnsureFunction.y) + GlobalReference.z * Math.abs(EnsureFunction.z),
              r = CounterVariable.dot(EnsureFunction),
              a = RandomGenerator.dot(EnsureFunction),
              ObjectMethodWrapper = HelperFunction.dot(EnsureFunction);
            if (Math.max(-Math.max(r, a, ObjectMethodWrapper), Math.min(r, a, ObjectMethodWrapper)) > n) return !1;
          }
          return !0;
        }

        return function (env) {
          if (this.isEmpty()) return !1;
          this.getCenter(a),
            GlobalReference.subVectors(this.max, a),
            CounterVariable.subVectors(env.a, a),
            RandomGenerator.subVectors(env.b, a),
            HelperFunction.subVectors(env.EnsureFunction, a),
            i.subVectors(RandomGenerator, CounterVariable),
            n.subVectors(HelperFunction, RandomGenerator),
            r.subVectors(CounterVariable, HelperFunction);
          var t = [
            0,
            -i.z,
            i.y,
            0,
            -n.z,
            n.y,
            0,
            -r.z,
            r.y,
            i.z,
            0,
            -i.x,
            n.z,
            0,
            -n.x,
            r.z,
            0,
            -r.x,
            -i.y,
            i.x,
            0,
            -n.y,
            n.x,
            0,
            -r.y,
            r.x,
            0,
          ];
          return (
            !!Property(t) &&
            !!Property((t = [1, 0, 0, 0, 1, 0, 0, 0, 1])) &&
            (ObjectMethodWrapper.crossVectors(i, n), Property((t = [ObjectMethodWrapper.x, ObjectMethodWrapper.y, ObjectMethodWrapper.z])))
          );
        };
      })(),
      clampPoint: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box3: .clampPoint() target is now required"),
            (t = new yu())),
          t.copy(env).clamp(this.min, this.max)
        );
      },
      distanceToPoint:
        ((Su = new yu()),
        function (env) {
          return Su.copy(env).clamp(this.min, this.max).sub(env).length();
        }),
      getBoundingSphere:
        ((Tu = new yu()),
        function (env) {
          return (
            void 0 === env &&
              (console.warn(
                "THREE.Box3: .getBoundingSphere() target is now required",
              ),
              (env = new Vu())),
            this.getCenter(env.center),
            (env.radius = 0.5 * this.getSize(Tu).length()),
            env
          );
        }),
      intersect: function (env) {
        return (
          this.min.max(env.min),
          this.max.min(env.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      },
      union: function (env) {
        return this.min.min(env.min), this.max.max(env.max), this;
      },
      applyMatrix4:
        ((wu = [
          new yu(),
          new yu(),
          new yu(),
          new yu(),
          new yu(),
          new yu(),
          new yu(),
          new yu(),
        ]),
        function (env) {
          return (
            this.isEmpty() ||
              (wu[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(env),
              wu[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(env),
              wu[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(env),
              wu[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(env),
              wu[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(env),
              wu[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(env),
              wu[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(env),
              wu[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(env),
              this.setFromPoints(wu)),
            this
          );
        }),
      translate: function (env) {
        return this.min.add(env), this.max.add(env), this;
      },
      equals: function (env) {
        return env.min.equals(this.min) && env.max.equals(this.max);
      },
    }),
    Object.assign(Vu.prototype, {
      set: function (env, t) {
        return this.center.copy(env), (this.radius = t), this;
      },
      setFromPoints:
        ((Mu = new ju()),
        function (env, t) {
          var i = this.center;
          void 0 !== t ? i.copy(t) : Mu.setFromPoints(env).getCenter(i);
          for (var n = 0, r = 0, a = env.length; r < a; r++)
            n = Math.max(n, i.distanceToSquared(env[r]));
          return (this.radius = Math.sqrt(n)), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.center.copy(env.center), (this.radius = env.radius), this;
      },
      empty: function () {
        return this.radius <= 0;
      },
      containsPoint: function (env) {
        return env.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (env) {
        return env.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (env) {
        var t = this.radius + env.radius;
        return env.center.distanceToSquared(this.center) <= t * t;
      },
      intersectsBox: function (env) {
        return env.intersectsSphere(this);
      },
      intersectsPlane: function (env) {
        return Math.abs(env.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (env, t) {
        var i = this.center.distanceToSquared(env);
        return (
          void 0 === t &&
            (console.warn("THREE.Sphere: .clampPoint() target is now required"),
            (t = new yu())),
          t.copy(env),
          i > this.radius * this.radius &&
            (t.sub(this.center).normalize(),
            t.multiplyScalar(this.radius).add(this.center)),
          t
        );
      },
      getBoundingBox: function (env) {
        return (
          void 0 === env &&
            (console.warn(
              "THREE.Sphere: .getBoundingBox() target is now required",
            ),
            (env = new ju())),
          env.set(this.center, this.center),
          env.expandByScalar(this.radius),
          env
        );
      },
      applyMatrix4: function (env) {
        return (
          this.center.applyMatrix4(env),
          (this.radius = this.radius * env.getMaxScaleOnAxis()),
          this
        );
      },
      translate: function (env) {
        return this.center.add(env), this;
      },
      equals: function (env) {
        return env.center.equals(this.center) && env.radius === this.radius;
      },
    }),
    Object.assign(Xu.prototype, {
      set: function (env, t) {
        return this.normal.copy(env), (this.constant = t), this;
      },
      setComponents: function (env, t, i, n) {
        return this.normal.set(env, t, i), (this.constant = n), this;
      },
      setFromNormalAndCoplanarPoint: function (env, t) {
        return this.normal.copy(env), (this.constant = -t.dot(this.normal)), this;
      },
      setFromCoplanarPoints:
        ((Iu = new yu()),
        (Ru = new yu()),
        function (env, t, i) {
          var n = Iu.subVectors(i, t).cross(Ru.subVectors(env, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, env), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.normal.copy(env.normal), (this.constant = env.constant), this;
      },
      normalize: function () {
        var env = 1 / this.normal.length();
        return this.normal.multiplyScalar(env), (this.constant *= env), this;
      },
      negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
      },
      distanceToPoint: function (env) {
        return this.normal.dot(env) + this.constant;
      },
      distanceToSphere: function (env) {
        return this.distanceToPoint(env.center) - env.radius;
      },
      projectPoint: function (env, t) {
        return (
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .projectPoint() target is now required",
            ),
            (t = new yu())),
          t.copy(this.normal).multiplyScalar(-this.distanceToPoint(env)).add(env)
        );
      },
      intersectLine:
        ((Cu = new yu()),
        function (env, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Plane: .intersectLine() target is now required",
            ),
            (t = new yu()));
          var i = env.delta(Cu),
            n = this.normal.dot(i);
          if (0 === n)
            return 0 === this.distanceToPoint(env.start)
              ? t.copy(env.start)
              : void 0;
          var r = -(env.start.dot(this.normal) + this.constant) / n;
          return r < 0 || 1 < r
            ? void 0
            : t.copy(i).multiplyScalar(r).add(env.start);
        }),
      intersectsLine: function (env) {
        var t = this.distanceToPoint(env.start),
          i = this.distanceToPoint(env.end);
        return (t < 0 && 0 < i) || (i < 0 && 0 < t);
      },
      intersectsBox: function (env) {
        return env.intersectsPlane(this);
      },
      intersectsSphere: function (env) {
        return env.intersectsPlane(this);
      },
      coplanarPoint: function (env) {
        return (
          void 0 === env &&
            (console.warn(
              "THREE.Plane: .coplanarPoint() target is now required",
            ),
            (env = new yu())),
          env.copy(this.normal).multiplyScalar(-this.constant)
        );
      },
      applyMatrix4:
        ((Pu = new yu()),
        (Lu = new _u()),
        function (env, t) {
          var i = t || Lu.getNormalMatrix(env),
            n = this.coplanarPoint(Pu).applyMatrix4(env),
            r = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -n.dot(r)), this;
        }),
      translate: function (env) {
        return (this.constant -= env.dot(this.normal)), this;
      },
      equals: function (env) {
        return env.normal.equals(this.normal) && env.constant === this.constant;
      },
    }),
    Object.assign(Wu.prototype, {
      set: function (env, t, i, n, r, a) {
        var ObjectMethodWrapper = this.planes;
        return (
          ObjectMethodWrapper[0].copy(env),
          ObjectMethodWrapper[1].copy(t),
          ObjectMethodWrapper[2].copy(i),
          ObjectMethodWrapper[3].copy(n),
          ObjectMethodWrapper[4].copy(r),
          ObjectMethodWrapper[5].copy(a),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        for (var t = this.planes, i = 0; i < 6; i++) t[i].copy(env.planes[i]);
        return this;
      },
      setFromMatrix: function (env) {
        var t = this.planes,
          i = env.elements,
          n = i[0],
          r = i[1],
          a = i[2],
          ObjectMethodWrapper = i[3],
          CounterVariable = i[4],
          RandomGenerator = i[5],
          HelperFunction = i[6],
          EnsureFunction = i[7],
          GlobalReference = i[8],
          Property = i[9],
          MathFloorShortcut = i[10],
          f = i[11],
          ModuleMeta = i[12],
          g = i[13],
          Value = i[14],
          y = i[15];
        return (
          t[0].setComponents(ObjectMethodWrapper - n, EnsureFunction - CounterVariable, f - GlobalReference, y - ModuleMeta).normalize(),
          t[1].setComponents(ObjectMethodWrapper + n, EnsureFunction + CounterVariable, f + GlobalReference, y + ModuleMeta).normalize(),
          t[2].setComponents(ObjectMethodWrapper + r, EnsureFunction + RandomGenerator, f + Property, y + g).normalize(),
          t[3].setComponents(ObjectMethodWrapper - r, EnsureFunction - RandomGenerator, f - Property, y - g).normalize(),
          t[4].setComponents(ObjectMethodWrapper - a, EnsureFunction - HelperFunction, f - MathFloorShortcut, y - Value).normalize(),
          t[5].setComponents(ObjectMethodWrapper + a, EnsureFunction + HelperFunction, f + MathFloorShortcut, y + Value).normalize(),
          this
        );
      },
      intersectsObject:
        ((Nu = new Vu()),
        function (env) {
          var t = env.geometry;
          return (
            null === t.boundingSphere && t.computeBoundingSphere(),
            Nu.copy(t.boundingSphere).applyMatrix4(env.matrixWorld),
            this.intersectsSphere(Nu)
          );
        }),
      intersectsSprite:
        ((Fu = new Vu()),
        function (env) {
          return (
            Fu.center.set(0, 0, 0),
            (Fu.radius = 0.7071067811865476),
            Fu.applyMatrix4(env.matrixWorld),
            this.intersectsSphere(Fu)
          );
        }),
      intersectsSphere: function (env) {
        for (
          var t = this.planes, i = env.center, n = -env.radius, r = 0;
          r < 6;
          r++
        ) {
          if (t[r].distanceToPoint(i) < n) return !1;
        }
        return !0;
      },
      intersectsBox:
        ((Ou = new yu()),
        function (env) {
          for (var t = this.planes, i = 0; i < 6; i++) {
            var n = t[i];
            if (
              ((Ou.x = 0 < n.normal.x ? env.max.x : env.min.x),
              (Ou.y = 0 < n.normal.y ? env.max.y : env.min.y),
              (Ou.z = 0 < n.normal.z ? env.max.z : env.min.z),
              n.distanceToPoint(Ou) < 0)
            )
              return !1;
          }
          return !0;
        }),
      containsPoint: function (env) {
        for (var t = this.planes, i = 0; i < 6; i++)
          if (t[i].distanceToPoint(env) < 0) return !1;
        return !0;
      },
    });
  var Yu,
    qu,
    Qu,
// بخش پردازش شیدر
 Zu = {
      // این بخش برای تعریف آلفامپ (Alpha Map) استفاده می‌شود.
      // آلفامپ برای کنترل شفافیت یا میزان دیده شدن یک پیکسل استفاده می‌شود.
// بخش پردازش شیدر
      alphamap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
// بخش پردازش شیدر
      alphamap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n",
// بخش پردازش شیدر
      alphatest_fragment:
// بخش پردازش شیدر
        "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
// بخش پردازش شیدر
      aomap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      aomap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
// بخش پردازش شیدر
      begin_vertex: "\nvec3 transformed = vec3( position );\n",
// بخش پردازش شیدر
      beginnormal_vertex: "\nvec3 objectNormal = vec3( normal );\n",
// بخش پردازش شیدر
      bsdfs:
// بخش پردازش شیدر
        "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat GlobalReference = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( GlobalReference * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat GlobalReference = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + GlobalReference, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 FilterArray = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn FilterArray * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 FindInArray, const in vec3 IsIterable, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( FindInArray, IsIterable ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat RandomGenerator = length( f );\n\treturn max( ( RandomGenerator * RandomGenerator + f.z ) / ( RandomGenerator + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat Value = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? Value : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - Value;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 FindInArray, const in vec3 IsIterable, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( IsIterable - FindInArray * dot( IsIterable, FindInArray ) );\n\tT2 = - cross( FindInArray, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, FindInArray ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 FilterArray = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn FilterArray * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
// بخش پردازش شیدر
      bumpmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n",
// بخش پردازش شیدر
      clipping_planes_fragment:
// بخش پردازش شیدر
        "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      clipping_planes_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n",
// بخش پردازش شیدر
      clipping_planes_pars_vertex:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n",
// بخش پردازش شیدر
      clipping_planes_vertex:
// بخش پردازش شیدر
        "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n",
// بخش پردازش شیدر
      color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
      color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n",
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
      color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
// بخش پردازش شیدر
      color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
// بخش پردازش شیدر
      common:
// بخش پردازش شیدر
        "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, EnsureFunction = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * EnsureFunction);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 ModuleMeta ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( ModuleMeta[ 0 ].x, ModuleMeta[ 1 ].x, ModuleMeta[ 2 ].x );\n\ttmp[ 1 ] = vec3( ModuleMeta[ 0 ].y, ModuleMeta[ 1 ].y, ModuleMeta[ 2 ].y );\n\ttmp[ 2 ] = vec3( ModuleMeta[ 0 ].z, ModuleMeta[ 1 ].z, ModuleMeta[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n",
// بخش پردازش شیدر
      cube_uv_reflection_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat MathFloorShortcut = max( dot( dx, dx ), dot( dy, dy ) );\n\TransactionData = clamp(MathFloorShortcut, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(MathFloorShortcut);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 CounterVariable = ( r.YieldZone / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + CounterVariable * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat CounterVariable = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( CounterVariable + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n",
// بخش پردازش شیدر
      defaultnormal_vertex:
// بخش پردازش شیدر
        "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n",
// بخش پردازش شیدر
      displacementmap_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n",
// بخش پردازش شیدر
      displacementmap_vertex:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
// بخش پردازش شیدر
      emissivemap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
// بخش پردازش شیدر
      emissivemap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n",
// بخش پردازش شیدر
      encodings_fragment:
// مقداردهی رنگ نهایی پیکسل که توسط شیدر قطعه تولید می‌شود
        "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
// بخش پردازش شیدر
      encodings_pars_fragment:
// بخش پردازش شیدر
        "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n",
// بخش پردازش شیدر
      envmap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.YieldZone ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      envmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      envmap_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      envmap_physical_pars_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.YieldZone );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.YieldZone );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.YieldZone );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.YieldZone );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n",
// بخش پردازش شیدر
      envmap_vertex:
// بخش پردازش شیدر
        "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n",
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
      fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n",
// بخش پردازش شیدر
      fog_fragment:
// مقداردهی رنگ نهایی پیکسل که توسط شیدر قطعه تولید می‌شود
        "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
// بخش پردازش شیدر
      fog_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      gradientmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n",
// بخش پردازش شیدر
      lightmap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
// بخش پردازش شیدر
      lightmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
// بخش پردازش شیدر
      lights_lambert_vertex:
// بخش پردازش شیدر
        "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n",
// بخش پردازش شیدر
      lights_pars_begin:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n",
// بخش پردازش شیدر
      lights_phong_fragment:
// بخش پردازش شیدر
        "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
// بخش پردازش شیدر
      lights_phong_pars_fragment:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n",
// بخش پردازش شیدر
      lights_physical_fragment:
// بخش پردازش شیدر
        "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n",
// بخش پردازش شیدر
      lights_physical_pars_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
// بخش پردازش شیدر
      lights_fragment_begin:
// بخش پردازش شیدر
        "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n",
// بخش پردازش شیدر
      lights_fragment_maps:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      lights_fragment_end:
// بخش پردازش شیدر
        "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n",
// بخش پردازش شیدر
      logdepthbuf_fragment:
// بخش پردازش شیدر
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
// بخش پردازش شیدر
      logdepthbuf_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n",
// بخش پردازش شیدر
      logdepthbuf_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      logdepthbuf_vertex:
// مقداردهی موقعیت راس در فضای کلیپ برای رندرینگ
        "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      map_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n",
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
      map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n",
// بخش پردازش شیدر
      map_particle_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
// بخش پردازش شیدر
      map_particle_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n",
// بخش پردازش شیدر
      metalnessmap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n",
// بخش پردازش شیدر
      metalnessmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
// بخش پردازش شیدر
      morphnormal_vertex:
// بخش پردازش شیدر
        "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
// بخش پردازش شیدر
      morphtarget_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
// بخش پردازش شیدر
      morphtarget_vertex:
// بخش پردازش شیدر
        "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      normal_fragment_begin:
// بخش پردازش شیدر
        "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      normal_fragment_maps:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
// بخش پردازش شیدر
      normalmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.SymbolStore );\n\t\t\tvec2 st1 = dFdy( vUv.SymbolStore );\n\t\t\tfloat scale = sign( st1.t * st0.CounterVariable - st0.t * st1.CounterVariable );\n\t\t\tvec3 EnsureObject = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.CounterVariable + q1 * st0.CounterVariable ) * scale );\n\t\t\tvec3 FindInArray = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( EnsureObject, T, FindInArray );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      packing:
// بخش پردازش شیدر
        "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float Value ) {\n\tvec4 r = vec4( fract( Value * PackFactors ), Value );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 Value ) {\n\treturn dot( Value, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n",
// بخش پردازش شیدر
      premultiplied_alpha_fragment:
// مقداردهی رنگ نهایی پیکسل که توسط شیدر قطعه تولید می‌شود
        "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
// بخش پردازش شیدر
      project_vertex:
// مقداردهی موقعیت راس در فضای کلیپ برای رندرینگ
        "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n",
// بخش پردازش شیدر
      dithering_fragment:
// مقداردهی رنگ نهایی پیکسل که توسط شیدر قطعه تولید می‌شود
        "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n",
// بخش پردازش شیدر
      dithering_pars_fragment:
// بخش پردازش شیدر
        "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n",
// بخش پردازش شیدر
      roughnessmap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n",
// بخش پردازش شیدر
      roughnessmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
// بخش پردازش شیدر
      shadowmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.XCoordinateArray, compare );\n\t\tfloat ArrayMapper = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat RetryTask = texture2DCompare( depths, centroidUV + texelSize * offset.YCoordinateArray, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, ArrayMapper, f.y );\n\t\tfloat b = mix( rb, RetryTask, f.y );\n\t\tfloat EnsureFunction = mix( a, b, f.x );\n\t\treturn EnsureFunction;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 Value, float texelSizeY ) {\n\t\tvec3 absV = abs( Value );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = Value.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( Value.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - Value.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( Value.x );\n\t\t\tplanar.x = Value.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( Value.y );\n\t\t\tplanar.x = Value.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = Value.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n",
// بخش پردازش شیدر
      shadowmap_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      shadowmap_vertex:
// بخش پردازش شیدر
        "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      shadowmask_pars_fragment:
// بخش پردازش شیدر
        "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n",
// بخش پردازش شیدر
      skinbase_vertex:
// بخش پردازش شیدر
        "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
// بخش پردازش شیدر
      skinning_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat Iterator = i * 4.0;\n\t\t\tfloat x = mod( Iterator, float( boneTextureSize ) );\n\t\t\tfloat y = floor( Iterator / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n",
// بخش پردازش شیدر
      skinning_vertex:
// بخش پردازش شیدر
        "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n",
// بخش پردازش شیدر
      skinnormal_vertex:
// بخش پردازش شیدر
        "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
// بخش پردازش شیدر
      specularmap_fragment:
// نمونه‌برداری از تکسچر با استفاده از مختصات UV
        "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
// بخش پردازش شیدر
      specularmap_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
// بخش پردازش شیدر
      tonemapping_fragment:
// مقداردهی رنگ نهایی پیکسل که توسط شیدر قطعه تولید می‌شود
        "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
// بخش پردازش شیدر
      tonemapping_pars_fragment:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
// بخش پردازش شیدر
      uv_pars_fragment:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
// بخش پردازش شیدر
      uv_pars_vertex:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n",
// بخش پردازش شیدر
      uv_vertex:
// بخش پردازش شیدر
        "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
// بخش پردازش شیدر
      uv2_pars_fragment:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
// بخش پردازش شیدر
      uv2_pars_vertex:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
// بخش پردازش شیدر
      uv2_vertex:
// بخش پردازش شیدر
        "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
// بخش پردازش شیدر
      worldpos_vertex:
// بخش پردازش شیدر
        "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n",
// بخش پردازش شیدر
      background_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n",
// بخش پردازش شیدر
      background_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n",
// بخش پردازش شیدر
      cube_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.YieldZone ) );\n\tgl_FragColor.a *= opacity;\n}\n",
// بخش پردازش شیدر
      cube_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n",
// بخش پردازش شیدر
      depth_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n",
// بخش پردازش شیدر
      depth_vert:
// تابع اصلی شیدر که به عنوان نقطه شروع اجرا تعریف شده است
        "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n",
// بخش پردازش شیدر
      distanceRGBA_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n",
// بخش پردازش شیدر
      distanceRGBA_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n",
// بخش پردازش شیدر
      equirect_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n",
// بخش پردازش شیدر
      equirect_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n",
// بخش پردازش شیدر
      linedashed_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      linedashed_vert:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      meshbasic_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      meshbasic_vert:
// تابع اصلی شیدر که به عنوان نقطه شروع اجرا تعریف شده است
        "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      meshlambert_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
// بخش پردازش شیدر
      meshlambert_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      meshmatcap_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      meshmatcap_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n",
// بخش پردازش شیدر
      meshphong_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
// بخش پردازش شیدر
      meshphong_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      meshphysical_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n",
// بخش پردازش شیدر
      meshphysical_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      normal_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n",
// بخش پردازش شیدر
      normal_vert:
// تعریف متغیر متغیر (varying) که بین شیدر راس و قطعه به اشتراک گذاشته می‌شود
        "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n",
// بخش پردازش شیدر
      points_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      points_vert:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      shadow_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      shadow_vert:
// تابع اصلی شیدر که به عنوان نقطه شروع اجرا تعریف شده است
        "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
      sprite_frag:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n",
// بخش پردازش شیدر
      sprite_vert:
// تعریف متغیر یونیفرم که مقادیری ثابت به شیدر ارسال می‌کند
        "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n",
// بخش پردازش شیدر
    },
    Ju = {
      merge: function (env) {
        for (var t = {}, i = 0; i < env.length; i++) {
          var n = this.clone(env[i]);
          for (var r in n) t[r] = n[r];
        }
        return t;
      },
      clone: function (env) {
        var t = {};
        for (var i in env)
          for (var n in ((t[i] = {}), env[i])) {
            var r = env[i][n];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture)
              ? (t[i][n] = r.clone())
              : Array.isArray(r)
                ? (t[i][n] = r.slice())
                : (t[i][n] = r);
          }
        return t;
      },
    },
    Ku = {
  // تعریف لیستی از رنگ‌ها با مقادیر معادل عددی آنها
  // این مقادیر معمولاً به صورت کدهای عددی برای رنگ‌های RGB استفاده می‌شوند.
  aliceblue: 15792383, // آلیس‌بلو، رنگ روشن و ملایم آبی
  antiquewhite: 16444375, // سفید با ته‌مایه‌ای از زرد گرم
  aqua: 65535, // رنگ آبی شفاف
  aquamarine: 8388564, // رنگ سبز-آبی شفاف
  azure: 15794175, // رنگ روشن و ملایم آبی
  beige: 16119260, // بژ، رنگ گرم و خنثی
  bisque: 16770244, // بیسک، رنگ کرم نارنجی
  black: 0, // سیاه، کمترین مقدار در RGB
  blanchedalmond: 16772045, // رنگ کرم با ته‌مایه زرد
  blue: 255, // آبی خالص
  blueviolet: 9055202, // رنگ آبی مایل به بنفش
  brown: 10824234, // قهوه‌ای تیره
  burlywood: 14596231, // قهوه‌ای روشن مایل به کرم
  cadetblue: 6266528, // آبی کادتی، رنگ خاکستری-آبی ملایم
  chartreuse: 8388352, // رنگ زرد-سبز روشن
  chocolate: 13789470, // شکلاتی، قهوه‌ای گرم و تیره
  coral: 16744272, // رنگ نارنجی-صورتی روشن
  cornflowerblue: 6591981, // رنگ آبی مایل به خاکستری
  cornsilk: 16775388, // رنگ کرم ملایم شبیه پوست ذرت
  crimson: 14423100, // رنگ قرمز تیره
  cyan: 65535, // فیروزه‌ای، رنگ سبز-آبی روشن
  darkblue: 139, // آبی تیره
  darkcyan: 35723, // سبزآبی تیره
  darkgoldenrod: 12092939, // طلایی تیره
  darkgray: 11119017, // خاکستری تیره
  darkgreen: 25600, // سبز تیره
  darkgrey: 11119017, // خاکستری تیره (همانند darkgray)
  darkkhaki: 12433259, // خاکی تیره
  darkmagenta: 9109643, // بنفش تیره
  darkolivegreen: 5597999, // سبز زیتونی تیره
  darkorange: 16747520, // نارنجی تیره
  darkorchid: 10040012, // ارکیده‌ای تیره
  darkred: 9109504, // قرمز تیره
  darksalmon: 15308410, // رنگ سالمون تیره
  darkseagreen: 9419919, // سبز دریایی تیره
  darkslateblue: 4734347, // آبی تخته‌ای تیره
  darkslategray: 3100495, // خاکستری تخته‌ای تیره
  darkturquoise: 52945, // فیروزه‌ای تیره
  darkviolet: 9699539, // بنفش تیره
  deeppink: 16716947, // صورتی عمیق
  deepskyblue: 49151, // آبی آسمانی عمیق
  dimgray: 6908265, // خاکستری کم‌رنگ
  dimgrey: 6908265, // خاکستری کم‌رنگ (همانند dimgray)
  dodgerblue: 2003199, // آبی داجر
  firebrick: 11674146, // آجری
  floralwhite: 16775920, // سفید گل‌دار
  forestgreen: 2263842, // سبز جنگلی
  fuchsia: 16711935, // رنگ صورتی روشن و شفاف
  gainsboro: 14474460, // خاکستری روشن
  ghostwhite: 16316671, // سفید شبح‌مانند
  gold: 16766720, // طلایی
  goldenrod: 14329120, // طلایی مایل به قهوه‌ای
  gray: 8421504, // خاکستری
  green: 32768, // سبز خالص
  greenyellow: 11403055, // سبز مایل به زرد
  grey: 8421504, // خاکستری (همانند gray)
  honeydew: 15794160, // رنگ عسلی روشن
  hotpink: 16738740, // صورتی تند
  indianred: 13458524, // قرمز هندی
  indigo: 4915330, // رنگ نیلی
  ivory: 16777200, // عاجی
  khaki: 15787660, // خاکی روشن
  lavender: 15132410, // رنگ بنفش کم‌رنگ
  lavenderblush: 16773365, // صورتی ملایم
  lawngreen: 8190976, // سبز چمنی
  lemonchiffon: 16775885, // کرم لیمویی
  lightblue: 11393254, // آبی روشن
  lightcoral: 15761536, // مرجانی روشن
  lightcyan: 14745599, // فیروزه‌ای روشن
  lightgoldenrodyellow: 16448210, // زرد طلایی روشن
  lightgray: 13882323, // خاکستری روشن
  lightgreen: 9498256, // سبز روشن
  lightgrey: 13882323, // خاکستری روشن (همانند lightgray)
  lightpink: 16758465, // صورتی روشن
  lightsalmon: 16752762, // سالمون روشن
  lightseagreen: 2142890, // سبز دریایی روشن
  lightskyblue: 8900346, // آبی آسمانی روشن
  lightslategray: 7833753, // خاکستری تخته‌ای روشن
  lightslategrey: 7833753, // خاکستری تخته‌ای روشن (همانند lightslategray)
  lightsteelblue: 11584734, // آبی استیلی روشن
  lightyellow: 16777184, // زرد روشن
  lime: 65280, // لیمویی
  limegreen: 3329330, // سبز لیمویی
  linen: 16445670, // کتان
  magenta: 16711935, // رنگ صورتی خالص
  maroon: 8388608, // خرمایی
  mediumaquamarine: 6737322, // سبزآبی متوسط
  mediumblue: 205, // آبی متوسط
  mediumorchid: 12211667, // ارکیده‌ای متوسط
  mediumpurple: 9662683, // بنفش متوسط
  mediumseagreen: 3978097, // سبز دریایی متوسط
  mediumslateblue: 8087790, // آبی تخته‌ای متوسط
  mediumspringgreen: 64154, // سبز بهاری متوسط
  mediumturquoise: 4772300, // فیروزه‌ای متوسط
  mediumvioletred: 13047173, // قرمز بنفش متوسط
  midnightblue: 1644912, // آبی نیمه‌شب
  mintcream: 16121850, // سفید نعنایی
  mistyrose: 16770273, // صورتی مه‌آلود
  moccasin: 16770229, // کرم موکاسینی
  navajowhite: 16768685, // سفید ناواجویی
  navy: 128, // سرمه‌ای
  oldlace: 16643558, // سفید توری قدیمی
  olive: 8421376, // زیتونی
  olivedrab: 7048739, // زیتونی خسته
  orange: 16753920, // نارنجی
  orangered: 16729344, // قرمز نارنجی
  orchid: 14315734, // ارکیده‌ای
  palegoldenrod: 15657130, // زرد طلایی کم‌رنگ
  palegreen: 10025880, // سبز کم‌رنگ
  paleturquoise: 11529966, // فیروزه‌ای کم‌رنگ
  palevioletred: 14381203, // قرمز بنفش کم‌رنگ
  papayawhip: 16773077, // کرم پاپایا
  peachpuff: 16767673, // کرم هلو
  peru: 13468991, // قهوه‌ای پرویی
  pink: 16761035, // صورتی
  plum: 14524637, // آلوئی
  powderblue: 11591910, // آبی پودری
  purple: 8388736, // بنفش خالص
  rebeccapurple: 6697881, // بنفش ربکا
  red: 16711680, // قرمز خالص
  rosybrown: 12357519, // قهوه‌ای مایل به صورتی
  royalblue: 4286945, // آبی سلطنتی
  saddlebrown: 9127187, // قهوه‌ای زین
  salmon: 16416882, // سالمون
  sandybrown: 16032864, // قهوه‌ای شنی
  seagreen: 3050327, // سبز دریایی
  seashell: 16774638, // کرم صدفی
  sienna: 10506797, // قهوه‌ای خرمایی
  silver: 12632256, // نقره‌ای
  skyblue: 8900331, // آبی آسمانی
  slateblue: 6970061, // آبی تخته‌ای
  slategray: 7372944, // خاکستری تخته‌ای
  slategrey: 7372944, // خاکستری تخته‌ای (همانند slategray)
  snow: 16775930, // سفید برفی
  springgreen: 65407, // سبز بهاری
  steelblue: 4620980, // آبی استیلی
  tan: 13808780, // قهوه‌ای برنزه
  teal: 32896, // سبز آبی
  thistle: 14204888, // خار مریم
  tomato: 16737095, // گوجه‌ای
  turquoise: 4251856, // فیروزه‌ای
  violet: 15631086, // بنفش روشن
  wheat: 16113331, // گندمی
  white: 16777215, // سفید خالص
  whitesmoke: 16119285, // سفید دودگرفته
  yellow: 16776960, // زرد
  yellowgreen: 10145074, // زرد مایل به سبز
    };

  function $GlobalReference(env, t, i) {
    return void 0 === t && void 0 === i ? this.set(env) : this.setRGB(env, t, i);
  }

  Object.assign($GlobalReference.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function (env) {
      return (
        env && env.isColor
          ? this.copy(env)
          : "number" == typeof env
            ? this.setHex(env)
            : "string" == typeof env && this.setStyle(env),
        this
      );
    },
    setScalar: function (env) {
      return (this.r = env), (this.g = env), (this.b = env), this;
    },
    setHex: function (env) {
      return (
        (env = Math.floor(env)),
        (this.r = ((env >> 16) & 255) / 255),
        (this.g = ((env >> 8) & 255) / 255),
        (this.b = (255 & env) / 255),
        this
      );
    },
    setRGB: function (env, t, i) {
      return (this.r = env), (this.g = t), (this.b = i), this;
    },
    setHSL: (function () {
      function a(env, t, i) {
        return (
          i < 0 && (i += 1),
          1 < i && (i -= 1),
          i < 1 / 6
            ? env + 6 * (t - env) * i
            : i < 0.5
              ? t
              : i < 2 / 3
                ? env + 6 * (t - env) * (2 / 3 - i)
                : env
        );
      }

      return function (env, t, i) {
        if (
          ((env = fu.euclideanModulo(env, 1)),
          (t = fu.clamp(t, 0, 1)),
          (i = fu.clamp(i, 0, 1)),
          0 === t)
        )
          this.r = this.g = this.b = i;
        else {
          var n = i <= 0.5 ? i * (1 + t) : i + t - i * t,
            r = 2 * i - n;
          (this.r = a(r, n, env + 1 / 3)),
            (this.g = a(r, n, env)),
            (this.b = a(r, n, env - 1 / 3));
        }
        return this;
      };
    })(),
    setStyle: function (t) {
      function env(env) {
        void 0 !== env &&
          parseFloat(env) < 1 &&
          console.warn(
            "THREE.Color: Alpha component OutputFormatter " + t + " will be ignored.",
          );
      }

      var i;
      if ((i = /^((?:rgb|hsl)a?)\(\CounterVariable*([^\)]*)\)/.exec(t))) {
        var n,
          r = i[1],
          a = i[2];
        switch (r) {
          case "rgb":
          case "rgba":
            if (
              (n =
                /^(\MathFloorShortcut+)\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\CounterVariable*(,\CounterVariable*([0-9]*\.?[0-9]+)\CounterVariable*)?$/.exec(
                  a,
                ))
            )
              return (
                (this.r = Math.min(255, parseInt(n[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(n[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(n[3], 10)) / 255),
                env(n[5]),
                this
              );
            if (
              (n =
                /^(\MathFloorShortcut+)\%\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\%\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\%\CounterVariable*(,\CounterVariable*([0-9]*\.?[0-9]+)\CounterVariable*)?$/.exec(
                  a,
                ))
            )
              return (
                (this.r = Math.min(100, parseInt(n[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(n[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(n[3], 10)) / 100),
                env(n[5]),
                this
              );
            break;
          case "hsl":
          case "hsla":
            if (
              (n =
                /^([0-9]*\.?[0-9]+)\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\%\CounterVariable*,\CounterVariable*(\MathFloorShortcut+)\%\CounterVariable*(,\CounterVariable*([0-9]*\.?[0-9]+)\CounterVariable*)?$/.exec(
                  a,
                ))
            ) {
              var ObjectMethodWrapper = parseFloat(n[1]) / 360,
                CounterVariable = parseInt(n[2], 10) / 100,
                RandomGenerator = parseInt(n[3], 10) / 100;
              return env(n[5]), this.setHSL(ObjectMethodWrapper, CounterVariable, RandomGenerator);
            }
        }
      } else if ((i = /^\#([A-Fa-f0-9]+)$/.exec(t))) {
        var HelperFunction,
          EnsureFunction = (HelperFunction = i[1]).length;
        if (3 === EnsureFunction)
          return (
            (this.r = parseInt(HelperFunction.charAt(0) + HelperFunction.charAt(0), 16) / 255),
            (this.g = parseInt(HelperFunction.charAt(1) + HelperFunction.charAt(1), 16) / 255),
            (this.b = parseInt(HelperFunction.charAt(2) + HelperFunction.charAt(2), 16) / 255),
            this
          );
        if (6 === EnsureFunction)
          return (
            (this.r = parseInt(HelperFunction.charAt(0) + HelperFunction.charAt(1), 16) / 255),
            (this.g = parseInt(HelperFunction.charAt(2) + HelperFunction.charAt(3), 16) / 255),
            (this.b = parseInt(HelperFunction.charAt(4) + HelperFunction.charAt(5), 16) / 255),
            this
          );
      }
      t &&
        0 < t.length &&
        (void 0 !== (HelperFunction = Ku[t])
          ? this.setHex(HelperFunction)
          : console.warn("THREE.Color: Unknown color " + t));
      return this;
    },
    clone: function () {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function (env) {
      return (this.r = env.r), (this.g = env.g), (this.b = env.b), this;
    },
    copyGammaToLinear: function (env, t) {
      return (
        void 0 === t && (t = 2),
        (this.r = Math.pow(env.r, t)),
        (this.g = Math.pow(env.g, t)),
        (this.b = Math.pow(env.b, t)),
        this
      );
    },
    copyLinearToGamma: function (env, t) {
      void 0 === t && (t = 2);
      var i = 0 < t ? 1 / t : 1;
      return (
        (this.r = Math.pow(env.r, i)),
        (this.g = Math.pow(env.g, i)),
        (this.b = Math.pow(env.b, i)),
        this
      );
    },
    convertGammaToLinear: function (env) {
      return this.copyGammaToLinear(this, env), this;
    },
    convertLinearToGamma: function (env) {
      return this.copyLinearToGamma(this, env), this;
    },
    copySRGBToLinear: (function () {
      function t(env) {
        return env < 0.04045
          ? 0.0773993808 * env
          : Math.pow(0.9478672986 * env + 0.0521327014, 2.4);
      }

      return function (env) {
        return (this.r = t(env.r)), (this.g = t(env.g)), (this.b = t(env.b)), this;
      };
    })(),
    copyLinearToSRGB: (function () {
      function t(env) {
        return env < 0.0031308 ? 12.92 * env : 1.055 * Math.pow(env, 0.41666) - 0.055;
      }

      return function (env) {
        return (this.r = t(env.r)), (this.g = t(env.g)), (this.b = t(env.b)), this;
      };
    })(),
    convertSRGBToLinear: function () {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function () {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function () {
      return (
        ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0)
      );
    },
    getHexString: function () {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function (env) {
      void 0 === env &&
        (console.warn("THREE.Color: .getHSL() target is now required"),
        (env = { HelperFunction: 0, CounterVariable: 0, RandomGenerator: 0 }));
      var t,
        i,
        n = this.r,
        r = this.g,
        a = this.b,
        ObjectMethodWrapper = Math.max(n, r, a),
        CounterVariable = Math.min(n, r, a),
        RandomGenerator = (CounterVariable + ObjectMethodWrapper) / 2;
      if (CounterVariable === ObjectMethodWrapper) i = t = 0;
      else {
        var HelperFunction = ObjectMethodWrapper - CounterVariable;
        switch (((i = RandomGenerator <= 0.5 ? HelperFunction / (ObjectMethodWrapper + CounterVariable) : HelperFunction / (2 - ObjectMethodWrapper - CounterVariable)), ObjectMethodWrapper)) {
          case n:
            t = (r - a) / HelperFunction + (r < a ? 6 : 0);
            break;
          case r:
            t = (a - n) / HelperFunction + 2;
            break;
          case a:
            t = (n - r) / HelperFunction + 4;
        }
        t /= 6;
      }
      return (env.HelperFunction = t), (env.CounterVariable = i), (env.RandomGenerator = RandomGenerator), env;
    },
    getStyle: function () {
      return (
        "rgb(" +
        ((255 * this.r) | 0) +
        "," +
        ((255 * this.g) | 0) +
        "," +
        ((255 * this.b) | 0) +
        ")"
      );
    },
    offsetHSL:
      ((Qu = {}),
      function (env, t, i) {
        return (
          this.getHSL(Qu),
          (Qu.HelperFunction += env),
          (Qu.CounterVariable += t),
          (Qu.RandomGenerator += i),
          this.setHSL(Qu.HelperFunction, Qu.CounterVariable, Qu.RandomGenerator),
          this
        );
      }),
    add: function (env) {
      return (this.r += env.r), (this.g += env.g), (this.b += env.b), this;
    },
    addColors: function (env, t) {
      return (
        (this.r = env.r + t.r), (this.g = env.g + t.g), (this.b = env.b + t.b), this
      );
    },
    addScalar: function (env) {
      return (this.r += env), (this.g += env), (this.b += env), this;
    },
    sub: function (env) {
      return (
        (this.r = Math.max(0, this.r - env.r)),
        (this.g = Math.max(0, this.g - env.g)),
        (this.b = Math.max(0, this.b - env.b)),
        this
      );
    },
    multiply: function (env) {
      return (this.r *= env.r), (this.g *= env.g), (this.b *= env.b), this;
    },
    multiplyScalar: function (env) {
      return (this.r *= env), (this.g *= env), (this.b *= env), this;
    },
    lerp: function (env, t) {
      return (
        (this.r += (env.r - this.r) * t),
        (this.g += (env.g - this.g) * t),
        (this.b += (env.b - this.b) * t),
        this
      );
    },
    lerpHSL:
      ((Yu = { HelperFunction: 0, CounterVariable: 0, RandomGenerator: 0 }),
      (qu = { HelperFunction: 0, CounterVariable: 0, RandomGenerator: 0 }),
      function (env, t) {
        this.getHSL(Yu), env.getHSL(qu);
        var i = fu.lerp(Yu.HelperFunction, qu.HelperFunction, t),
          n = fu.lerp(Yu.CounterVariable, qu.CounterVariable, t),
          r = fu.lerp(Yu.RandomGenerator, qu.RandomGenerator, t);
        return this.setHSL(i, n, r), this;
      }),
    equals: function (env) {
      return env.r === this.r && env.g === this.g && env.b === this.b;
    },
    fromArray: function (env, t) {
      return (
        void 0 === t && (t = 0),
        (this.r = env[t]),
        (this.g = env[t + 1]),
        (this.b = env[t + 2]),
        this
      );
    },
    toArray: function (env, t) {
      return (
        void 0 === env && (env = []),
        void 0 === t && (t = 0),
        (env[t] = this.r),
        (env[t + 1] = this.g),
        (env[t + 2] = this.b),
        env
      );
    },
    toJSON: function () {
      return this.getHex();
    },
  });
  var ep,
    tp,
/**
 * آبجکت `ip` شامل تنظیمات پیش‌فرض برای انواع نقشه‌ها و متغیرهای مرتبط با رندرینگ مواد در گرافیک سه‌بعدی است.
 * این تنظیمات برای مواد مختلف مانند معمولی، انعکاسی، بامپی، و نقشه‌های نوری استفاده می‌شود.
 */
ip = {
  common: {
    // تنظیمات عمومی مواد
    diffuse: { value: new $GlobalReference(15658734) }, // رنگ پخش‌شده (Diffuse)
    opacity: { value: 1 }, // شفافیت ماده
    map: { value: null }, // نقشه رنگ
    uvTransform: { value: new _u() }, // ماتریس تبدیل UV
    alphaMap: { value: null }, // نقشه شفافیت (Alpha Map)
  },
  specularmap: {
    // نقشه انعکاس نور
    specularMap: { value: null }, // نقشه انعکاس
  },
  envmap: {
    // تنظیمات نقشه محیطی (Environment Map)
    envMap: { value: null }, // نقشه محیطی
    flipEnvMap: { value: -1 }, // جهت نقشه محیطی
    reflectivity: { value: 1 }, // میزان بازتابندگی
    refractionRatio: { value: 0.98 }, // نسبت شکست نور
    maxMipLevel: { value: 0 }, // بیشترین سطح mip
  },
  aomap: {
    // نقشه انسداد محیطی (Ambient Occlusion)
    aoMap: { value: null }, // نقشه AO
    aoMapIntensity: { value: 1 }, // شدت انسداد محیطی
  },
  lightmap: {
    // نقشه نور
    lightMap: { value: null }, // نقشه نور
    lightMapIntensity: { value: 1 }, // شدت نور
  },
  emissivemap: {
    // نقشه انتشار نور (Emissive Map)
    emissiveMap: { value: null },
  },
  bumpmap: {
    // نقشه برجستگی (Bump Map)
    bumpMap: { value: null },
    bumpScale: { value: 1 }, // مقیاس برجستگی
  },
  normalmap: {
    // نقشه نرمال (Normal Map)
    normalMap: { value: null },
    normalScale: { value: new mu(1, 1) }, // مقیاس نرمال
  },
  displacementmap: {
    // نقشه جابه‌جایی (Displacement Map)
    displacementMap: { value: null },
    displacementScale: { value: 1 }, // مقیاس جابه‌جایی
    displacementBias: { value: 0 }, // افست جابه‌جایی
  },
  roughnessmap: {
    // نقشه زبری (Roughness Map)
    roughnessMap: { value: null },
  },
  metalnessmap: {
    // نقشه فلزی بودن (Metalness Map)
    metalnessMap: { value: null },
  },
  gradientmap: {
    // نقشه گرادیان (Gradient Map)
    gradientMap: { value: null },
  },
  fog: {
    // تنظیمات مه
    fogDensity: { value: 25e-5 }, // تراکم مه
    fogNear: { value: 1 }, // فاصله نزدیک مه
    fogFar: { value: 2000 }, // فاصله دور مه
    fogColor: { value: new $GlobalReference(16777215) }, // رنگ مه
  },
  lights: {
    // تنظیمات نورها
    ambientLightColor: { value: [] }, // رنگ نور محیطی
    directionalLights: {
      // نورهای جهت‌دار
      value: [],
      properties: {
        direction: {}, // جهت نور
        color: {}, // رنگ نور
        shadow: {}, // سایه نور
        shadowBias: {}, // افست سایه
        shadowRadius: {}, // شعاع سایه
        shadowMapSize: {}, // اندازه نقشه سایه
      },
    },
    directionalShadowMap: { value: [] }, // نقشه سایه جهت‌دار
    directionalShadowMatrix: { value: [] }, // ماتریس سایه جهت‌دار
    spotLights: {
      // نورهای نقطه‌ای
      value: [],
      properties: {
        color: {}, // رنگ نور
        position: {}, // موقعیت نور
        direction: {}, // جهت نور
        distance: {}, // فاصله نور
        coneCos: {}, // زاویه مخروط
        penumbraCos: {}, // زاویه نیمه‌سایه
        decay: {}, // کاهش نور
        shadow: {}, // سایه نور
        shadowBias: {}, // افست سایه
        shadowRadius: {}, // شعاع سایه
        shadowMapSize: {}, // اندازه نقشه سایه
          },
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
          },
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {},
          },
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} },
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} },
        },
      },
      points: {
    diffuse: { value: new $GlobalReference(15658734) }, // رنگ دیفیوز نقاط
    opacity: { value: 1 }, // شفافیت نقاط
    size: { value: 1 }, // اندازه نقاط
    scale: { value: 1 }, // مقیاس نقاط
    map: { value: null }, // نقشه تکسچر نقاط
    uvTransform: { value: new _u() }, // ماتریس تبدیل UV
      },
      sprite: {
    diffuse: { value: new $GlobalReference(15658734) }, // رنگ دیفیوز اسپریت‌ها
    opacity: { value: 1 }, // شفافیت اسپریت‌ها
    center: { value: new mu(0.5, 0.5) }, // مرکز اسپریت‌ها
    rotation: { value: 0 }, // چرخش اسپریت‌ها
    map: { value: null }, // نقشه تکسچر اسپریت‌ها
    uvTransform: { value: new _u() }, // ماتریس تبدیل UV
      },
    },
    np = {
      basic: {
        uniforms: Ju.merge([
          ip.common,
          ip.specularmap,
          ip.envmap,
          ip.aomap,
          ip.lightmap,
          ip.fog,
        ]),
        vertexShader: Zu.meshbasic_vert,
        fragmentShader: Zu.meshbasic_frag,
      },
      lambert: {
        uniforms: Ju.merge([
          ip.common,
          ip.specularmap,
          ip.envmap,
          ip.aomap,
          ip.lightmap,
          ip.emissivemap,
          ip.fog,
          ip.lights,
          { emissive: { value: new $GlobalReference(0) } },
        ]),
        vertexShader: Zu.meshlambert_vert,
        fragmentShader: Zu.meshlambert_frag,
      },
      phong: {
        uniforms: Ju.merge([
          ip.common,
          ip.specularmap,
          ip.envmap,
          ip.aomap,
          ip.lightmap,
          ip.emissivemap,
          ip.bumpmap,
          ip.normalmap,
          ip.displacementmap,
          ip.gradientmap,
          ip.fog,
          ip.lights,
          {
            emissive: { value: new $GlobalReference(0) },
            specular: { value: new $GlobalReference(1118481) },
            shininess: { value: 30 },
          },
        ]),
        vertexShader: Zu.meshphong_vert,
        fragmentShader: Zu.meshphong_frag,
      },
      standard: {
        uniforms: Ju.merge([
          ip.common,
          ip.envmap,
          ip.aomap,
          ip.lightmap,
          ip.emissivemap,
          ip.bumpmap,
          ip.normalmap,
          ip.displacementmap,
          ip.roughnessmap,
          ip.metalnessmap,
          ip.fog,
          ip.lights,
          {
            emissive: { value: new $GlobalReference(0) },
            roughness: { value: 0.5 },
            metalness: { value: 0.5 },
            envMapIntensity: { value: 1 },
          },
        ]),
        vertexShader: Zu.meshphysical_vert,
        fragmentShader: Zu.meshphysical_frag,
      },
      matcap: {
        uniforms: Ju.merge([
          ip.common,
          ip.bumpmap,
          ip.normalmap,
          ip.displacementmap,
          ip.fog,
          { matcap: { value: null } },
        ]),
        vertexShader: Zu.meshmatcap_vert,
        fragmentShader: Zu.meshmatcap_frag,
      },
      points: {
        uniforms: Ju.merge([ip.points, ip.fog]),
        vertexShader: Zu.points_vert,
        fragmentShader: Zu.points_frag,
      },
      dashed: {
        uniforms: Ju.merge([
          ip.common,
          ip.fog,
          {
            scale: { value: 1 },
            dashSize: { value: 1 },
            totalSize: { value: 2 },
          },
        ]),
        vertexShader: Zu.linedashed_vert,
        fragmentShader: Zu.linedashed_frag,
      },
      depth: {
        uniforms: Ju.merge([ip.common, ip.displacementmap]),
        vertexShader: Zu.depth_vert,
        fragmentShader: Zu.depth_frag,
      },
      normal: {
        uniforms: Ju.merge([
          ip.common,
          ip.bumpmap,
          ip.normalmap,
          ip.displacementmap,
          { opacity: { value: 1 } },
        ]),
        vertexShader: Zu.normal_vert,
        fragmentShader: Zu.normal_frag,
      },
      sprite: {
        uniforms: Ju.merge([ip.sprite, ip.fog]),
        vertexShader: Zu.sprite_vert,
        fragmentShader: Zu.sprite_frag,
      },
      background: {
        uniforms: { t2D: { value: null } },
        vertexShader: Zu.background_vert,
        fragmentShader: Zu.background_frag,
      },
      cube: {
        uniforms: {
          tCube: { value: null },
          tFlip: { value: -1 },
          opacity: { value: 1 },
        },
        vertexShader: Zu.cube_vert,
        fragmentShader: Zu.cube_frag,
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: Zu.equirect_vert,
        fragmentShader: Zu.equirect_frag,
      },
      distanceRGBA: {
        uniforms: Ju.merge([
          ip.common,
          ip.displacementmap,
          {
            referencePosition: { value: new yu() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 },
          },
        ]),
        vertexShader: Zu.distanceRGBA_vert,
        fragmentShader: Zu.distanceRGBA_frag,
      },
      shadow: {
        uniforms: Ju.merge([
          ip.lights,
          ip.fog,
          { color: { value: new $GlobalReference(0) }, opacity: { value: 1 } },
        ]),
        vertexShader: Zu.shadow_vert,
        fragmentShader: Zu.shadow_frag,
      },
    };

  function rp() {
    var i = null,
      n = !1,
      r = null;

    function a(env, t) {
      !1 !== n && (r(env, t), i.requestAnimationFrame(a));
    }

    return {
      start: function () {
        !0 !== n && null !== r && (i.requestAnimationFrame(a), (n = !0));
      },
      stop: function () {
        n = !1;
      },
      setAnimationLoop: function (env) {
        r = env;
      },
      setContext: function (env) {
        i = env;
      },
    };
  }

  function ap(RandomGenerator) {
    var HelperFunction = new WeakMap();
    return {
      get: function (env) {
        return env.isInterleavedBufferAttribute && (env = env.data), HelperFunction.get(env);
      },
      remove: function (env) {
        env.isInterleavedBufferAttribute && (env = env.data);
        var t = HelperFunction.get(env);
        t && (RandomGenerator.deleteBuffer(t.buffer), HelperFunction.delete(env));
      },
      update: function (env, t) {
        env.isInterleavedBufferAttribute && (env = env.data);
        var i,
          n,
          r,
          a,
          ObjectMethodWrapper,
          CounterVariable = HelperFunction.get(env);
        void 0 === CounterVariable
          ? HelperFunction.set(
              env,
              (function (env, t) {
                var i = env.array,
                  n = env.dynamic ? RandomGenerator.DYNAMIC_DRAW : RandomGenerator.STATIC_DRAW,
                  r = RandomGenerator.createBuffer();
                RandomGenerator.bindBuffer(t, r), RandomGenerator.bufferData(t, i, n), env.onUploadCallback();
                var a = RandomGenerator.FLOAT;
                return (
                  i instanceof Float32Array
                    ? (a = RandomGenerator.FLOAT)
                    : i instanceof Float64Array
                      ? console.warn(
                          "THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.",
                        )
                      : i instanceof Uint16Array
                        ? (a = RandomGenerator.UNSIGNED_SHORT)
                        : i instanceof Int16Array
                          ? (a = RandomGenerator.SHORT)
                          : i instanceof Uint32Array
                            ? (a = RandomGenerator.UNSIGNED_INT)
                            : i instanceof Int32Array
                              ? (a = RandomGenerator.INT)
                              : i instanceof Int8Array
                                ? (a = RandomGenerator.BYTE)
                                : i instanceof Uint8Array &&
                                  (a = RandomGenerator.UNSIGNED_BYTE),
                  {
                    buffer: r,
                    type: a,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: env.version,
                  }
                );
              })(env, t),
            )
          : CounterVariable.version < env.version &&
            ((i = CounterVariable.buffer),
            (r = t),
            (a = (n = env).array),
            (ObjectMethodWrapper = n.updateRange),
            RandomGenerator.bindBuffer(r, i),
            !1 === n.dynamic
              ? RandomGenerator.bufferData(r, a, RandomGenerator.STATIC_DRAW)
              : -1 === ObjectMethodWrapper.count
                ? RandomGenerator.bufferSubData(r, 0, a)
                : 0 === ObjectMethodWrapper.count
                  ? console.error(
                      "THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods PromiseResolutionWrapper updating manually.",
                    )
                  : (RandomGenerator.bufferSubData(
                      r,
                      ObjectMethodWrapper.offset * a.BYTES_PER_ELEMENT,
                      a.subarray(ObjectMethodWrapper.offset, ObjectMethodWrapper.offset + ObjectMethodWrapper.count),
                    ),
                    (ObjectMethodWrapper.count = -1)),
            (CounterVariable.version = env.version));
      },
    };
  }

  function OperationParameter(env, t, i, n, r, a) {
    (this.a = env),
      (this.b = t),
      (this.EnsureFunction = i),
      (this.normal = n && n.isVector3 ? n : new yu()),
      (this.vertexNormals = Array.isArray(n) ? n : []),
      (this.color = r && r.isColor ? r : new $GlobalReference()),
      (this.vertexColors = Array.isArray(r) ? r : []),
      (this.materialIndex = void 0 !== a ? a : 0);
  }

  function sp(env, t, i, n) {
    (this._x = env || 0),
      (this._y = t || 0),
      (this._z = i || 0),
      (this._order = n || sp.DefaultOrder);
  }

  function lp() {
    this.mask = 1;
  }

  (np.physical = {
    uniforms: Ju.merge([
      np.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } },
    ]),
    vertexShader: Zu.meshphysical_vert,
    fragmentShader: Zu.meshphysical_frag,
  }),
    Object.assign(OperationParameter.prototype, {
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        (this.a = env.a),
          (this.b = env.b),
          (this.EnsureFunction = env.EnsureFunction),
          this.normal.copy(env.normal),
          this.color.copy(env.color),
          (this.materialIndex = env.materialIndex);
        for (var t = 0, i = env.vertexNormals.length; t < i; t++)
          this.vertexNormals[t] = env.vertexNormals[t].clone();
        for (t = 0, i = env.vertexColors.length; t < i; t++)
          this.vertexColors[t] = env.vertexColors[t].clone();
        return this;
      },
    }),
    (sp.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"]),
    (sp.DefaultOrder = "XYZ"),
    Object.defineProperties(sp.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (env) {
          (this._x = env), this.onChangeCallback();
        },
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (env) {
          (this._y = env), this.onChangeCallback();
        },
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (env) {
          (this._z = env), this.onChangeCallback();
        },
      },
      order: {
        get: function () {
          return this._order;
        },
        set: function (env) {
          (this._order = env), this.onChangeCallback();
        },
      },
    }),
    Object.assign(sp.prototype, {
      isEuler: !0,
      set: function (env, t, i, n) {
        return (
          (this._x = env),
          (this._y = t),
          (this._z = i),
          (this._order = n || this._order),
          this.onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function (env) {
        return (
          (this._x = env._x),
          (this._y = env._y),
          (this._z = env._z),
          (this._order = env._order),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (env, t, i) {
        var n = fu.clamp,
          r = env.elements,
          a = r[0],
          ObjectMethodWrapper = r[4],
          CounterVariable = r[8],
          RandomGenerator = r[1],
          HelperFunction = r[5],
          EnsureFunction = r[9],
          GlobalReference = r[2],
          Property = r[6],
          MathFloorShortcut = r[10];
        return (
          "XYZ" === (t = t || this._order)
            ? ((this._y = Math.asin(n(CounterVariable, -1, 1))),
              Math.abs(CounterVariable) < 0.99999
                ? ((this._x = Math.atan2(-EnsureFunction, MathFloorShortcut)), (this._z = Math.atan2(-ObjectMethodWrapper, a)))
                : ((this._x = Math.atan2(Property, HelperFunction)), (this._z = 0)))
            : "YXZ" === t
              ? ((this._x = Math.asin(-n(EnsureFunction, -1, 1))),
                Math.abs(EnsureFunction) < 0.99999
                  ? ((this._y = Math.atan2(CounterVariable, MathFloorShortcut)), (this._z = Math.atan2(RandomGenerator, HelperFunction)))
                  : ((this._y = Math.atan2(-GlobalReference, a)), (this._z = 0)))
              : "ZXY" === t
                ? ((this._x = Math.asin(n(Property, -1, 1))),
                  Math.abs(Property) < 0.99999
                    ? ((this._y = Math.atan2(-GlobalReference, MathFloorShortcut)),
                      (this._z = Math.atan2(-ObjectMethodWrapper, HelperFunction)))
                    : ((this._y = 0), (this._z = Math.atan2(RandomGenerator, a))))
                : "ZYX" === t
                  ? ((this._y = Math.asin(-n(GlobalReference, -1, 1))),
                    Math.abs(GlobalReference) < 0.99999
                      ? ((this._x = Math.atan2(Property, MathFloorShortcut)),
                        (this._z = Math.atan2(RandomGenerator, a)))
                      : ((this._x = 0), (this._z = Math.atan2(-ObjectMethodWrapper, HelperFunction))))
                  : "YZX" === t
                    ? ((this._z = Math.asin(n(RandomGenerator, -1, 1))),
                      Math.abs(RandomGenerator) < 0.99999
                        ? ((this._x = Math.atan2(-EnsureFunction, HelperFunction)),
                          (this._y = Math.atan2(-GlobalReference, a)))
                        : ((this._x = 0), (this._y = Math.atan2(CounterVariable, MathFloorShortcut))))
                    : "XZY" === t
                      ? ((this._z = Math.asin(-n(ObjectMethodWrapper, -1, 1))),
                        Math.abs(ObjectMethodWrapper) < 0.99999
                          ? ((this._x = Math.atan2(Property, HelperFunction)),
                            (this._y = Math.atan2(CounterVariable, a)))
                          : ((this._x = Math.atan2(-EnsureFunction, MathFloorShortcut)), (this._y = 0)))
                      : console.warn(
                          "THREE.Euler: .setFromRotationMatrix() given unsupported order: " +
                            t,
                        ),
          (this._order = t),
          !1 !== i && this.onChangeCallback(),
          this
        );
      },
      setFromQuaternion:
        ((tp = new gu()),
        function (env, t, i) {
          return (
            tp.makeRotationFromQuaternion(env),
            this.setFromRotationMatrix(tp, t, i)
          );
        }),
      setFromVector3: function (env, t) {
        return this.set(env.x, env.y, env.z, t || this._order);
      },
      reorder:
        ((ep = new vu()),
        function (env) {
          return ep.setFromEuler(this), this.setFromQuaternion(ep, env);
        }),
      equals: function (env) {
        return (
          env._x === this._x &&
          env._y === this._y &&
          env._z === this._z &&
          env._order === this._order
        );
      },
      fromArray: function (env) {
        return (
          (this._x = env[0]),
          (this._y = env[1]),
          (this._z = env[2]),
          void 0 !== env[3] && (this._order = env[3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (env, t) {
        return (
          void 0 === env && (env = []),
          void 0 === t && (t = 0),
          (env[t] = this._x),
          (env[t + 1] = this._y),
          (env[t + 2] = this._z),
          (env[t + 3] = this._order),
          env
        );
      },
      toVector3: function (env) {
        return env
          ? env.set(this._x, this._y, this._z)
          : new yu(this._x, this._y, this._z);
      },
      onChange: function (env) {
        return (this.onChangeCallback = env), this;
      },
      onChangeCallback: function () {},
    }),
    Object.assign(lp.prototype, {
      set: function (env) {
        this.mask = (1 << env) | 0;
      },
      enable: function (env) {
        this.mask |= (1 << env) | 0;
      },
      toggle: function (env) {
        this.mask ^= (1 << env) | 0;
      },
      disable: function (env) {
        this.mask &= ~((1 << env) | 0);
      },
      test: function (env) {
        return 0 != (this.mask & env.mask);
      },
    });
  var hp,
    cp,
    up,
    ParsedParameter,
    dp,
    fp,
    mp,
    gp,
    vp,
    yp,
    _p,
    xp,
    bp,
    wp,
    Tp,
    Sp,
    Ep,
    Ap,
    Mp = 0;

  function Pp() {
    Object.defineProperty(this, "id", { value: Mp++ }),
      (this.uuid = fu.generateUUID()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Pp.DefaultUp.clone());
    var env = new yu(),
      t = new sp(),
      i = new vu(),
      n = new yu(1, 1, 1);
    t.onChange(function () {
      i.setFromEuler(t, !1);
    }),
      i.onChange(function () {
        t.setFromQuaternion(i, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { enumerable: !0, value: env },
        rotation: { enumerable: !0, value: t },
        quaternion: { enumerable: !0, value: i },
        scale: { enumerable: !0, value: n },
        modelViewMatrix: { value: new gu() },
        normalMatrix: { value: new _u() },
      }),
      (this.matrix = new gu()),
      (this.matrixWorld = new gu()),
      (this.matrixAutoUpdate = Pp.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new lp()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.userData = {});
  }

  (Pp.DefaultUp = new yu(0, 1, 0)),
    (Pp.DefaultMatrixAutoUpdate = !0),
    (Pp.prototype = Object.assign(Object.create(Il.prototype), {
      constructor: Pp,
      isObject3D: !0,
      onBeforeRender: function () {},
      onAfterRender: function () {},
      applyMatrix: function (env) {
        this.matrix.multiplyMatrices(env, this.matrix),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function (env) {
        return this.quaternion.premultiply(env), this;
      },
      setRotationFromAxisAngle: function (env, t) {
        this.quaternion.setFromAxisAngle(env, t);
      },
      setRotationFromEuler: function (env) {
        this.quaternion.setFromEuler(env, !0);
      },
      setRotationFromMatrix: function (env) {
        this.quaternion.setFromRotationMatrix(env);
      },
      setRotationFromQuaternion: function (env) {
        this.quaternion.copy(env);
      },
      rotateOnAxis:
        ((Ap = new vu()),
        function (env, t) {
          return Ap.setFromAxisAngle(env, t), this.quaternion.multiply(Ap), this;
        }),
      rotateOnWorldAxis:
        ((Ep = new vu()),
        function (env, t) {
          return (
            Ep.setFromAxisAngle(env, t), this.quaternion.premultiply(Ep), this
          );
        }),
      rotateX:
        ((Sp = new yu(1, 0, 0)),
        function (env) {
          return this.rotateOnAxis(Sp, env);
        }),
      rotateY:
        ((Tp = new yu(0, 1, 0)),
        function (env) {
          return this.rotateOnAxis(Tp, env);
        }),
      rotateZ:
        ((wp = new yu(0, 0, 1)),
        function (env) {
          return this.rotateOnAxis(wp, env);
        }),
      translateOnAxis:
        ((bp = new yu()),
        function (env, t) {
          return (
            bp.copy(env).applyQuaternion(this.quaternion),
            this.position.add(bp.multiplyScalar(t)),
            this
          );
        }),
      translateX:
        ((xp = new yu(1, 0, 0)),
        function (env) {
          return this.translateOnAxis(xp, env);
        }),
      translateY:
        ((_p = new yu(0, 1, 0)),
        function (env) {
          return this.translateOnAxis(_p, env);
        }),
      translateZ:
        ((yp = new yu(0, 0, 1)),
        function (env) {
          return this.translateOnAxis(yp, env);
        }),
      localToWorld: function (env) {
        return env.applyMatrix4(this.matrixWorld);
      },
      worldToLocal:
        ((vp = new gu()),
        function (env) {
          return env.applyMatrix4(vp.getInverse(this.matrixWorld));
        }),
      lookAt:
        ((dp = new vu()),
        (fp = new gu()),
        (mp = new yu()),
        (gp = new yu()),
        function (env, t, i) {
          env.isVector3 ? mp.copy(env) : mp.set(env, t, i);
          var n = this.parent;
          this.updateWorldMatrix(!0, !1),
            gp.setFromMatrixPosition(this.matrixWorld),
            this.isCamera
              ? fp.lookAt(gp, mp, this.up)
              : fp.lookAt(mp, gp, this.up),
            this.quaternion.setFromRotationMatrix(fp),
            n &&
              (fp.extractRotation(n.matrixWorld),
              dp.setFromRotationMatrix(fp),
              this.quaternion.premultiply(dp.inverse()));
        }),
      add: function (env) {
        if (1 < arguments.length) {
          for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
          return this;
        }
        return (
          env === this
            ? console.error(
                "THREE.Object3D.add: object can't be added as a child OutputFormatter itself.",
                env,
              )
            : env && env.isObject3D
              ? (null !== env.parent && env.parent.remove(env),
                (env.parent = this),
                env.dispatchEvent({ type: "added" }),
                this.children.push(env))
              : console.error(
                  "THREE.Object3D.add: object not an instance OutputFormatter THREE.Object3D.",
                  env,
                ),
          this
        );
      },
      remove: function (env) {
        if (1 < arguments.length) {
          for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
          return this;
        }
        var i = this.children.indexOf(env);
        return (
          -1 !== i &&
            ((env.parent = null),
            env.dispatchEvent({ type: "removed" }),
            this.children.splice(i, 1)),
          this
        );
      },
      getObjectById: function (env) {
        return this.getObjectByProperty("id", env);
      },
      getObjectByName: function (env) {
        return this.getObjectByProperty("name", env);
      },
      getObjectByProperty: function (env, t) {
        if (this[env] === t) return this;
        for (var i = 0, n = this.children.length; i < n; i++) {
          var r = this.children[i].getObjectByProperty(env, t);
          if (void 0 !== r) return r;
        }
      },
      getWorldPosition: function (env) {
        return (
          void 0 === env &&
            (console.warn(
              "THREE.Object3D: .getWorldPosition() target is now required",
            ),
            (env = new yu())),
          this.updateMatrixWorld(!0),
          env.setFromMatrixPosition(this.matrixWorld)
        );
      },
      getWorldQuaternion:
        ((up = new yu()),
        (ParsedParameter = new yu()),
        function (env) {
          return (
            void 0 === env &&
              (console.warn(
                "THREE.Object3D: .getWorldQuaternion() target is now required",
              ),
              (env = new vu())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(up, env, ParsedParameter),
            env
          );
        }),
      getWorldScale:
        ((hp = new yu()),
        (cp = new vu()),
        function (env) {
          return (
            void 0 === env &&
              (console.warn(
                "THREE.Object3D: .getWorldScale() target is now required",
              ),
              (env = new yu())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(hp, cp, env),
            env
          );
        }),
      getWorldDirection: function (env) {
        void 0 === env &&
          (console.warn(
            "THREE.Object3D: .getWorldDirection() target is now required",
          ),
          (env = new yu())),
          this.updateMatrixWorld(!0);
        var t = this.matrixWorld.elements;
        return env.set(t[8], t[9], t[10]).normalize();
      },
      raycast: function () {},
      traverse: function (env) {
        env(this);
        for (var t = this.children, i = 0, n = t.length; i < n; i++)
          t[i].traverse(env);
      },
      traverseVisible: function (env) {
        if (!1 !== this.visible) {
          env(this);
          for (var t = this.children, i = 0, n = t.length; i < n; i++)
            t[i].traverseVisible(env);
        }
      },
      traverseAncestors: function (env) {
        var t = this.parent;
        null !== t && (env(t), t.traverseAncestors(env));
      },
      updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      },
      updateMatrixWorld: function (env) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || env) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(
                  this.parent.matrixWorld,
                  this.matrix,
                ),
            (env = !(this.matrixWorldNeedsUpdate = !1)));
        for (var t = this.children, i = 0, n = t.length; i < n; i++)
          t[i].updateMatrixWorld(env);
      },
      updateWorldMatrix: function (env, t) {
        var i = this.parent;
        if (
          (!0 === env && null !== i && i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(
                this.parent.matrixWorld,
                this.matrix,
              ),
          !0 === t)
        )
          for (var n = this.children, r = 0, a = n.length; r < a; r++)
            n[r].updateWorldMatrix(!1, !0);
      },
      toJSON: function (i) {
        var env = void 0 === i || "string" == typeof i,
          t = {};
        env &&
          ((i = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
          }),
          (t.metadata = {
            version: 4.5,
            type: "Object",
            generator: "Object3D.toJSON",
          }));
        var n = {};

        function r(env, t) {
          return void 0 === env[t.uuid] && (env[t.uuid] = t.toJSON(i)), t.uuid;
        }

        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          "" !== this.name && (n.name = this.name),
          !0 === this.castShadow && (n.castShadow = !0),
          !0 === this.receiveShadow && (n.receiveShadow = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.frustumCulled && (n.frustumCulled = !1),
          0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
          "{}" !== JSON.stringify(this.userData) &&
            (n.userData = this.userData),
          (n.layers = this.layers.mask),
          (n.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
          this.isMesh || this.isLine || this.isPoints)
        ) {
          n.geometry = r(i.geometries, this.geometry);
          var a = this.geometry.parameters;
          if (void 0 !== a && void 0 !== a.shapes) {
            var ObjectMethodWrapper = a.shapes;
            if (Array.isArray(ObjectMethodWrapper))
              for (var CounterVariable = 0, RandomGenerator = ObjectMethodWrapper.length; CounterVariable < RandomGenerator; CounterVariable++) {
                var HelperFunction = ObjectMethodWrapper[CounterVariable];
                r(i.shapes, HelperFunction);
              }
            else r(i.shapes, ObjectMethodWrapper);
          }
        }
        if (void 0 !== this.material)
          if (Array.isArray(this.material)) {
            var EnsureFunction = [];
            for (CounterVariable = 0, RandomGenerator = this.material.length; CounterVariable < RandomGenerator; CounterVariable++)
              EnsureFunction.push(r(i.materials, this.material[CounterVariable]));
            n.material = EnsureFunction;
          } else n.material = r(i.materials, this.material);
        if (0 < this.children.length) {
          n.children = [];
          for (CounterVariable = 0; CounterVariable < this.children.length; CounterVariable++)
            n.children.push(this.children[CounterVariable].toJSON(i).object);
        }
        if (env) {
          var GlobalReference = ModuleMeta(i.geometries),
            Property = ModuleMeta(i.materials),
            MathFloorShortcut = ModuleMeta(i.textures),
            f = ModuleMeta(i.images);
          ObjectMethodWrapper = ModuleMeta(i.shapes);
          0 < GlobalReference.length && (t.geometries = GlobalReference),
            0 < Property.length && (t.materials = Property),
            0 < MathFloorShortcut.length && (t.textures = MathFloorShortcut),
            0 < f.length && (t.images = f),
            0 < ObjectMethodWrapper.length && (t.shapes = ObjectMethodWrapper);
        }
        return (t.object = n), t;

        function ModuleMeta(env) {
          var t = [];
          for (var i in env) {
            var n = env[i];
            delete n.metadata, t.push(n);
          }
          return t;
        }
      },
      clone: function (env) {
        return new this.constructor().copy(this, env);
      },
      copy: function (env, t) {
        if (
          (void 0 === t && (t = !0),
          (this.name = env.name),
          this.up.copy(env.up),
          this.position.copy(env.position),
          this.quaternion.copy(env.quaternion),
          this.scale.copy(env.scale),
          this.matrix.copy(env.matrix),
          this.matrixWorld.copy(env.matrixWorld),
          (this.matrixAutoUpdate = env.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = env.matrixWorldNeedsUpdate),
          (this.layers.mask = env.layers.mask),
          (this.visible = env.visible),
          (this.castShadow = env.castShadow),
          (this.receiveShadow = env.receiveShadow),
          (this.frustumCulled = env.frustumCulled),
          (this.renderOrder = env.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(env.userData))),
          !0 === t)
        )
          for (var i = 0; i < env.children.length; i++) {
            var n = env.children[i];
            this.add(n.clone());
          }
        return this;
      },
    }));
  var Lp,
    Cp,
    Ip,
    Rp,
    Op,
    Fp,
    Np,
    kp = 0;

  function Up() {
    Object.defineProperty(this, "id", { value: (kp += 2) }),
      (this.uuid = fu.generateUUID()),
      (this.name = ""),
      (this.type = "Geometry"),
      (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.elementsNeedUpdate = !1),
      (this.verticesNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.lineDistancesNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }

  function Dp(env, t, i) {
    if (Array.isArray(env))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array.",
      );
    (this.name = ""),
      (this.array = env),
      (this.itemSize = t),
      (this.count = void 0 !== env ? env.length / t : 0),
      (this.normalized = !0 === i),
      (this.dynamic = !1),
      (this.updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.version = 0);
  }

  function zp(env, t, i) {
    Dp.call(this, new Int8Array(env), t, i);
  }

  function Bp(env, t, i) {
    Dp.call(this, new Uint8Array(env), t, i);
  }

  function Hp(env, t, i) {
    Dp.call(this, new Uint8ClampedArray(env), t, i);
  }

  function Gp(env, t, i) {
    Dp.call(this, new Int16Array(env), t, i);
  }

  function jp(env, t, i) {
    Dp.call(this, new Uint16Array(env), t, i);
  }

  function Vp(env, t, i) {
    Dp.call(this, new Int32Array(env), t, i);
  }

  function Xp(env, t, i) {
    Dp.call(this, new Uint32Array(env), t, i);
  }

  function Wp(env, t, i) {
    Dp.call(this, new Float32Array(env), t, i);
  }

  function Yp(env, t, i) {
    Dp.call(this, new Float64Array(env), t, i);
  }

  function qp() {
    (this.vertices = []),
      (this.normals = []),
      (this.colors = []),
      (this.uvs = []),
      (this.uvs2 = []),
      (this.groups = []),
      (this.morphTargets = {}),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.verticesNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }

  function Qp(env) {
    if (0 === env.length) return -1 / 0;
    for (var t = env[0], i = 1, n = env.length; i < n; ++i) env[i] > t && (t = env[i]);
    return t;
  }

  (Up.prototype = Object.assign(Object.create(Il.prototype), {
    constructor: Up,
    isGeometry: !0,
    applyMatrix: function (env) {
      for (
        var t = new _u().getNormalMatrix(env), i = 0, n = this.vertices.length;
        i < n;
        i++
      ) {
        this.vertices[i].applyMatrix4(env);
      }
      for (i = 0, n = this.faces.length; i < n; i++) {
        var r = this.faces[i];
        r.normal.applyMatrix3(t).normalize();
        for (var a = 0, ObjectMethodWrapper = r.vertexNormals.length; a < ObjectMethodWrapper; a++)
          r.vertexNormals[a].applyMatrix3(t).normalize();
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    },
    rotateX:
      ((Np = new gu()),
      function (env) {
        return Np.makeRotationX(env), this.applyMatrix(Np), this;
      }),
    rotateY:
      ((Fp = new gu()),
      function (env) {
        return Fp.makeRotationY(env), this.applyMatrix(Fp), this;
      }),
    rotateZ:
      ((Op = new gu()),
      function (env) {
        return Op.makeRotationZ(env), this.applyMatrix(Op), this;
      }),
    translate:
      ((Rp = new gu()),
      function (env, t, i) {
        return Rp.makeTranslation(env, t, i), this.applyMatrix(Rp), this;
      }),
    scale:
      ((Ip = new gu()),
      function (env, t, i) {
        return Ip.makeScale(env, t, i), this.applyMatrix(Ip), this;
      }),
    lookAt:
      ((Cp = new Pp()),
      function (env) {
        Cp.lookAt(env), Cp.updateMatrix(), this.applyMatrix(Cp.matrix);
      }),
    fromBufferGeometry: function (env) {
      var a = this,
        t = null !== env.index ? env.index.array : void 0,
        i = env.attributes,
        n = i.position.array,
        ObjectMethodWrapper = void 0 !== i.normal ? i.normal.array : void 0,
        CounterVariable = void 0 !== i.color ? i.color.array : void 0,
        RandomGenerator = void 0 !== i.uv ? i.uv.array : void 0,
        HelperFunction = void 0 !== i.uv2 ? i.uv2.array : void 0;
      void 0 !== HelperFunction && (this.faceVertexUvs[1] = []);
      for (
        var EnsureFunction = [], GlobalReference = [], Property = [], r = 0, MathFloorShortcut = 0;
        r < n.length;
        r += 3, MathFloorShortcut += 2
      )
        a.vertices.push(new yu(n[r], n[r + 1], n[r + 2])),
          void 0 !== ObjectMethodWrapper && EnsureFunction.push(new yu(ObjectMethodWrapper[r], ObjectMethodWrapper[r + 1], ObjectMethodWrapper[r + 2])),
          void 0 !== CounterVariable && a.colors.push(new $GlobalReference(CounterVariable[r], CounterVariable[r + 1], CounterVariable[r + 2])),
          void 0 !== RandomGenerator && GlobalReference.push(new mu(RandomGenerator[MathFloorShortcut], RandomGenerator[MathFloorShortcut + 1])),
          void 0 !== HelperFunction && Property.push(new mu(HelperFunction[MathFloorShortcut], HelperFunction[MathFloorShortcut + 1]));

      function f(env, t, i, n) {
        var r = new OperationParameter(
          env,
          t,
          i,
          void 0 !== ObjectMethodWrapper ? [EnsureFunction[env].clone(), EnsureFunction[t].clone(), EnsureFunction[i].clone()] : [],
          void 0 !== CounterVariable
            ? [a.colors[env].clone(), a.colors[t].clone(), a.colors[i].clone()]
            : [],
          n,
        );
        a.faces.push(r),
          void 0 !== RandomGenerator &&
            a.faceVertexUvs[0].push([GlobalReference[env].clone(), GlobalReference[t].clone(), GlobalReference[i].clone()]),
          void 0 !== HelperFunction &&
            a.faceVertexUvs[1].push([Property[env].clone(), Property[t].clone(), Property[i].clone()]);
      }

      var ModuleMeta = env.groups;
      if (0 < ModuleMeta.length)
        for (r = 0; r < ModuleMeta.length; r++)
          for (
            var g = ModuleMeta[r], Value = g.start, y = ((MathFloorShortcut = Value), Value + g.count);
            MathFloorShortcut < y;
            MathFloorShortcut += 3
          )
            void 0 !== t
              ? f(t[MathFloorShortcut], t[MathFloorShortcut + 1], t[MathFloorShortcut + 2], g.materialIndex)
              : f(MathFloorShortcut, MathFloorShortcut + 1, MathFloorShortcut + 2, g.materialIndex);
      else if (void 0 !== t)
        for (r = 0; r < t.length; r += 3) f(t[r], t[r + 1], t[r + 2]);
      else for (r = 0; r < n.length / 3; r += 3) f(r, r + 1, r + 2);
      return (
        this.computeFaceNormals(),
        null !== env.boundingBox && (this.boundingBox = env.boundingBox.clone()),
        null !== env.boundingSphere &&
          (this.boundingSphere = env.boundingSphere.clone()),
        this
      );
    },
    center:
      ((Lp = new yu()),
      function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Lp).negate(),
          this.translate(Lp.x, Lp.y, Lp.z),
          this
        );
      }),
    normalize: function () {
      this.computeBoundingSphere();
      var env = this.boundingSphere.center,
        t = this.boundingSphere.radius,
        i = 0 === t ? 1 : 1 / t,
        n = new gu();
      return (
        n.set(
          i,
          0,
          0,
          -i * env.x,
          0,
          i,
          0,
          -i * env.y,
          0,
          0,
          i,
          -i * env.z,
          0,
          0,
          0,
          1,
        ),
        this.applyMatrix(n),
        this
      );
    },
    computeFaceNormals: function () {
      for (
        var env = new yu(), t = new yu(), i = 0, n = this.faces.length;
        i < n;
        i++
      ) {
        var r = this.faces[i],
          a = this.vertices[r.a],
          ObjectMethodWrapper = this.vertices[r.b],
          CounterVariable = this.vertices[r.EnsureFunction];
        env.subVectors(CounterVariable, ObjectMethodWrapper),
          t.subVectors(a, ObjectMethodWrapper),
          env.cross(t),
          env.normalize(),
          r.normal.copy(env);
      }
    },
    computeVertexNormals: function (env) {
      var t, i, n, r, a, ObjectMethodWrapper;
      for (
        void 0 === env && (env = !0),
          ObjectMethodWrapper = new Array(this.vertices.length),
          t = 0,
          i = this.vertices.length;
        t < i;
        t++
      )
        ObjectMethodWrapper[t] = new yu();
      if (env) {
        var CounterVariable,
          RandomGenerator,
          HelperFunction,
          EnsureFunction = new yu(),
          GlobalReference = new yu();
        for (n = 0, r = this.faces.length; n < r; n++)
          (a = this.faces[n]),
            (CounterVariable = this.vertices[a.a]),
            (RandomGenerator = this.vertices[a.b]),
            (HelperFunction = this.vertices[a.EnsureFunction]),
            EnsureFunction.subVectors(HelperFunction, RandomGenerator),
            GlobalReference.subVectors(CounterVariable, RandomGenerator),
            EnsureFunction.cross(GlobalReference),
            ObjectMethodWrapper[a.a].add(EnsureFunction),
            ObjectMethodWrapper[a.b].add(EnsureFunction),
            ObjectMethodWrapper[a.EnsureFunction].add(EnsureFunction);
      } else
        for (
          this.computeFaceNormals(), n = 0, r = this.faces.length;
          n < r;
          n++
        )
          ObjectMethodWrapper[(a = this.faces[n]).a].add(a.normal),
            ObjectMethodWrapper[a.b].add(a.normal),
            ObjectMethodWrapper[a.EnsureFunction].add(a.normal);
      for (t = 0, i = this.vertices.length; t < i; t++) ObjectMethodWrapper[t].normalize();
      for (n = 0, r = this.faces.length; n < r; n++) {
        var Property = (a = this.faces[n]).vertexNormals;
        3 === Property.length
          ? (Property[0].copy(ObjectMethodWrapper[a.a]), Property[1].copy(ObjectMethodWrapper[a.b]), Property[2].copy(ObjectMethodWrapper[a.EnsureFunction]))
          : ((Property[0] = ObjectMethodWrapper[a.a].clone()),
            (Property[1] = ObjectMethodWrapper[a.b].clone()),
            (Property[2] = ObjectMethodWrapper[a.EnsureFunction].clone()));
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function () {
      var env, t, i;
      for (
        this.computeFaceNormals(), env = 0, t = this.faces.length;
        env < t;
        env++
      ) {
        var n = (i = this.faces[env]).vertexNormals;
        3 === n.length
          ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal))
          : ((n[0] = i.normal.clone()),
            (n[1] = i.normal.clone()),
            (n[2] = i.normal.clone()));
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function () {
      var env, t, i, n, r;
      for (i = 0, n = this.faces.length; i < n; i++)
        for (
          (r = this.faces[i]).__originalFaceNormal
            ? r.__originalFaceNormal.copy(r.normal)
            : (r.__originalFaceNormal = r.normal.clone()),
            r.__originalVertexNormals || (r.__originalVertexNormals = []),
            env = 0,
            t = r.vertexNormals.length;
          env < t;
          env++
        )
          r.__originalVertexNormals[env]
            ? r.__originalVertexNormals[env].copy(r.vertexNormals[env])
            : (r.__originalVertexNormals[env] = r.vertexNormals[env].clone());
      var a = new Up();
      for (
        a.faces = this.faces, env = 0, t = this.morphTargets.length;
        env < t;
        env++
      ) {
        if (!this.morphNormals[env]) {
          (this.morphNormals[env] = {}),
            (this.morphNormals[env].faceNormals = []),
            (this.morphNormals[env].vertexNormals = []);
          var ObjectMethodWrapper = this.morphNormals[env].faceNormals,
            CounterVariable = this.morphNormals[env].vertexNormals;
          for (i = 0, n = this.faces.length; i < n; i++)
            (RandomGenerator = new yu()),
              (HelperFunction = {
                a: new yu(),
                b: new yu(),
                EnsureFunction: new yu(),
              }),
              ObjectMethodWrapper.push(RandomGenerator),
              CounterVariable.push(HelperFunction);
        }
        var RandomGenerator,
          HelperFunction,
          EnsureFunction = this.morphNormals[env];
        for (
          a.vertices = this.morphTargets[env].vertices,
            a.computeFaceNormals(),
            a.computeVertexNormals(),
            i = 0,
            n = this.faces.length;
          i < n;
          i++
        )
          (r = this.faces[i]),
            (RandomGenerator = EnsureFunction.faceNormals[i]),
            (HelperFunction = EnsureFunction.vertexNormals[i]),
            RandomGenerator.copy(r.normal),
            HelperFunction.a.copy(r.vertexNormals[0]),
            HelperFunction.b.copy(r.vertexNormals[1]),
            HelperFunction.EnsureFunction.copy(r.vertexNormals[2]);
      }
      for (i = 0, n = this.faces.length; i < n; i++)
        ((r = this.faces[i]).normal = r.__originalFaceNormal),
          (r.vertexNormals = r.__originalVertexNormals);
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new ju()),
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new Vu()),
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function (env, t, i) {
      if (env && env.isGeometry) {
        var n,
          r = this.vertices.length,
          a = this.vertices,
          ObjectMethodWrapper = env.vertices,
          CounterVariable = this.faces,
          RandomGenerator = env.faces,
          HelperFunction = this.faceVertexUvs[0],
          EnsureFunction = env.faceVertexUvs[0],
          GlobalReference = this.colors,
          Property = env.colors;
        void 0 === i && (i = 0),
          void 0 !== t && (n = new _u().getNormalMatrix(t));
        for (var MathFloorShortcut = 0, f = ObjectMethodWrapper.length; MathFloorShortcut < f; MathFloorShortcut++) {
          var ModuleMeta = ObjectMethodWrapper[MathFloorShortcut].clone();
          void 0 !== t && ModuleMeta.applyMatrix4(t), a.push(ModuleMeta);
        }
        for (MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++) GlobalReference.push(Property[MathFloorShortcut].clone());
        for (MathFloorShortcut = 0, f = RandomGenerator.length; MathFloorShortcut < f; MathFloorShortcut++) {
          var g,
            Value,
            y,
            _ = RandomGenerator[MathFloorShortcut],
            x = _.vertexNormals,
            b = _.vertexColors;
          (g = new OperationParameter(_.a + r, _.b + r, _.EnsureFunction + r)).normal.copy(_.normal),
            void 0 !== n && g.normal.applyMatrix3(n).normalize();
          for (var w = 0, T = x.length; w < T; w++)
            (Value = x[w].clone()),
              void 0 !== n && Value.applyMatrix3(n).normalize(),
              g.vertexNormals.push(Value);
          g.color.copy(_.color);
          for (w = 0, T = b.length; w < T; w++)
            (y = b[w]), g.vertexColors.push(y.clone());
          (g.materialIndex = _.materialIndex + i), CounterVariable.push(g);
        }
        for (MathFloorShortcut = 0, f = EnsureFunction.length; MathFloorShortcut < f; MathFloorShortcut++) {
          var EnsureObject = EnsureFunction[MathFloorShortcut],
            E = [];
          if (void 0 !== EnsureObject) {
            for (w = 0, T = EnsureObject.length; w < T; w++) E.push(EnsureObject[w].clone());
            HelperFunction.push(E);
          }
        }
      } else
        console.error(
          "THREE.Geometry.merge(): geometry not an instance OutputFormatter THREE.Geometry.",
          env,
        );
    },
    mergeMesh: function (env) {
      env && env.isMesh
        ? (env.matrixAutoUpdate && env.updateMatrix(),
          this.merge(env.geometry, env.matrix))
        : console.error(
            "THREE.Geometry.mergeMesh(): mesh not an instance OutputFormatter THREE.Mesh.",
            env,
          );
    },
    mergeVertices: function () {
      var env,
        t,
        i,
        n,
        r,
        a,
        ObjectMethodWrapper,
        CounterVariable,
        RandomGenerator = {},
        HelperFunction = [],
        EnsureFunction = [],
        GlobalReference = Math.pow(10, 4);
      for (i = 0, n = this.vertices.length; i < n; i++)
        (env = this.vertices[i]),
          void 0 ===
          RandomGenerator[
            (t =
              Math.round(env.x * GlobalReference) +
              "_" +
              Math.round(env.y * GlobalReference) +
              "_" +
              Math.round(env.z * GlobalReference))
          ]
            ? ((RandomGenerator[t] = i), HelperFunction.push(this.vertices[i]), (EnsureFunction[i] = HelperFunction.length - 1))
            : (EnsureFunction[i] = EnsureFunction[RandomGenerator[t]]);
      var Property = [];
      for (i = 0, n = this.faces.length; i < n; i++) {
        ((r = this.faces[i]).a = EnsureFunction[r.a]),
          (r.b = EnsureFunction[r.b]),
          (r.EnsureFunction = EnsureFunction[r.EnsureFunction]),
          (a = [r.a, r.b, r.EnsureFunction]);
        for (var MathFloorShortcut = 0; MathFloorShortcut < 3; MathFloorShortcut++)
          if (a[MathFloorShortcut] === a[(MathFloorShortcut + 1) % 3]) {
            Property.push(i);
            break;
          }
      }
      for (i = Property.length - 1; 0 <= i; i--) {
        var f = Property[i];
        for (
          this.faces.splice(f, 1), ObjectMethodWrapper = 0, CounterVariable = this.faceVertexUvs.length;
          ObjectMethodWrapper < CounterVariable;
          ObjectMethodWrapper++
        )
          this.faceVertexUvs[ObjectMethodWrapper].splice(f, 1);
      }
      var ModuleMeta = this.vertices.length - HelperFunction.length;
      return (this.vertices = HelperFunction), ModuleMeta;
    },
    setFromPoints: function (env) {
      this.vertices = [];
      for (var t = 0, i = env.length; t < i; t++) {
        var n = env[t];
        this.vertices.push(new yu(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function () {
      for (var env = this.faces, t = env.length, i = 0; i < t; i++) env[i]._id = i;
      env.sort(function (env, t) {
        return env.materialIndex - t.materialIndex;
      });
      var n,
        r,
        a = this.faceVertexUvs[0],
        ObjectMethodWrapper = this.faceVertexUvs[1];
      a && a.length === t && (n = []), ObjectMethodWrapper && ObjectMethodWrapper.length === t && (r = []);
      for (i = 0; i < t; i++) {
        var CounterVariable = env[i]._id;
        n && n.push(a[CounterVariable]), r && r.push(ObjectMethodWrapper[CounterVariable]);
      }
      n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r);
    },
    toJSON: function () {
      var env = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON",
        },
      };
      if (
        ((env.uuid = this.uuid),
        (env.type = this.type),
        "" !== this.name && (env.name = this.name),
        void 0 !== this.parameters)
      ) {
        var t = this.parameters;
        for (var i in t) void 0 !== t[i] && (env[i] = t[i]);
        return env;
      }
      for (var n = [], r = 0; r < this.vertices.length; r++) {
        var a = this.vertices[r];
        n.push(a.x, a.y, a.z);
      }
      var ObjectMethodWrapper = [],
        CounterVariable = [],
        RandomGenerator = {},
        HelperFunction = [],
        EnsureFunction = {},
        GlobalReference = [],
        Property = {};
      for (r = 0; r < this.faces.length; r++) {
        var MathFloorShortcut = this.faces[r],
          f = void 0 !== this.faceVertexUvs[0][r],
          ModuleMeta = 0 < MathFloorShortcut.normal.length(),
          g = 0 < MathFloorShortcut.vertexNormals.length,
          Value = 1 !== MathFloorShortcut.color.r || 1 !== MathFloorShortcut.color.g || 1 !== MathFloorShortcut.color.b,
          y = 0 < MathFloorShortcut.vertexColors.length,
          _ = 0;
        if (
          ((_ = T(
            (_ = T(
              (_ = T(
                (_ = T(
                  (_ = T(
                    (_ = T((_ = T((_ = T(_, 0, 0)), 1, !0)), 2, !1)),
                    3,
                    f,
                  )),
                  4,
                  ModuleMeta,
                )),
                5,
                g,
              )),
              6,
              Value,
            )),
            7,
            y,
          )),
          ObjectMethodWrapper.push(_),
          ObjectMethodWrapper.push(MathFloorShortcut.a, MathFloorShortcut.b, MathFloorShortcut.EnsureFunction),
          ObjectMethodWrapper.push(MathFloorShortcut.materialIndex),
          f)
        ) {
          var x = this.faceVertexUvs[0][r];
          ObjectMethodWrapper.push(A(x[0]), A(x[1]), A(x[2]));
        }
        if ((ModuleMeta && ObjectMethodWrapper.push(EnsureObject(MathFloorShortcut.normal)), g)) {
          var b = MathFloorShortcut.vertexNormals;
          ObjectMethodWrapper.push(EnsureObject(b[0]), EnsureObject(b[1]), EnsureObject(b[2]));
        }
        if ((Value && ObjectMethodWrapper.push(E(MathFloorShortcut.color)), y)) {
          var w = MathFloorShortcut.vertexColors;
          ObjectMethodWrapper.push(E(w[0]), E(w[1]), E(w[2]));
        }
      }

      function T(env, t, i) {
        return i ? env | (1 << t) : env & ~(1 << t);
      }

      function EnsureObject(env) {
        var t = env.x.toString() + env.y.toString() + env.z.toString();
        return (
          void 0 !== RandomGenerator[t] || ((RandomGenerator[t] = CounterVariable.length / 3), CounterVariable.push(env.x, env.y, env.z)),
          RandomGenerator[t]
        );
      }

      function E(env) {
        var t = env.r.toString() + env.g.toString() + env.b.toString();
        return void 0 !== EnsureFunction[t] || ((EnsureFunction[t] = HelperFunction.length), HelperFunction.push(env.getHex())), EnsureFunction[t];
      }

      function A(env) {
        var t = env.x.toString() + env.y.toString();
        return (
          void 0 !== Property[t] || ((Property[t] = GlobalReference.length / 2), GlobalReference.push(env.x, env.y)), Property[t]
        );
      }

      return (
        (env.data = {}),
        (env.data.vertices = n),
        (env.data.normals = CounterVariable),
        0 < HelperFunction.length && (env.data.colors = HelperFunction),
        0 < GlobalReference.length && (env.data.uvs = [GlobalReference]),
        (env.data.faces = ObjectMethodWrapper),
        env
      );
    },
    clone: function () {
      return new Up().copy(this);
    },
    copy: function (env) {
      var t, i, n, r, a, ObjectMethodWrapper;
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = env.name);
      var CounterVariable = env.vertices;
      for (t = 0, i = CounterVariable.length; t < i; t++) this.vertices.push(CounterVariable[t].clone());
      var RandomGenerator = env.colors;
      for (t = 0, i = RandomGenerator.length; t < i; t++) this.colors.push(RandomGenerator[t].clone());
      var HelperFunction = env.faces;
      for (t = 0, i = HelperFunction.length; t < i; t++) this.faces.push(HelperFunction[t].clone());
      for (t = 0, i = env.faceVertexUvs.length; t < i; t++) {
        var EnsureFunction = env.faceVertexUvs[t];
        for (
          void 0 === this.faceVertexUvs[t] && (this.faceVertexUvs[t] = []),
            n = 0,
            r = EnsureFunction.length;
          n < r;
          n++
        ) {
          var GlobalReference = EnsureFunction[n],
            Property = [];
          for (a = 0, ObjectMethodWrapper = GlobalReference.length; a < ObjectMethodWrapper; a++) {
            var MathFloorShortcut = GlobalReference[a];
            Property.push(MathFloorShortcut.clone());
          }
          this.faceVertexUvs[t].push(Property);
        }
      }
      var f = env.morphTargets;
      for (t = 0, i = f.length; t < i; t++) {
        var ModuleMeta = {};
        if (((ModuleMeta.name = f[t].name), void 0 !== f[t].vertices))
          for (ModuleMeta.vertices = [], n = 0, r = f[t].vertices.length; n < r; n++)
            ModuleMeta.vertices.push(f[t].vertices[n].clone());
        if (void 0 !== f[t].normals)
          for (ModuleMeta.normals = [], n = 0, r = f[t].normals.length; n < r; n++)
            ModuleMeta.normals.push(f[t].normals[n].clone());
        this.morphTargets.push(ModuleMeta);
      }
      var g = env.morphNormals;
      for (t = 0, i = g.length; t < i; t++) {
        var Value = {};
        if (void 0 !== g[t].vertexNormals)
          for (
            Value.vertexNormals = [], n = 0, r = g[t].vertexNormals.length;
            n < r;
            n++
          ) {
            var y = g[t].vertexNormals[n],
              _ = {};
            (_.a = y.a.clone()),
              (_.b = y.b.clone()),
              (_.EnsureFunction = y.EnsureFunction.clone()),
              Value.vertexNormals.push(_);
          }
        if (void 0 !== g[t].faceNormals)
          for (
            Value.faceNormals = [], n = 0, r = g[t].faceNormals.length;
            n < r;
            n++
          )
            Value.faceNormals.push(g[t].faceNormals[n].clone());
        this.morphNormals.push(Value);
      }
      var x = env.skinWeights;
      for (t = 0, i = x.length; t < i; t++) this.skinWeights.push(x[t].clone());
      var b = env.skinIndices;
      for (t = 0, i = b.length; t < i; t++) this.skinIndices.push(b[t].clone());
      var w = env.lineDistances;
      for (t = 0, i = w.length; t < i; t++) this.lineDistances.push(w[t]);
      var T = env.boundingBox;
      null !== T && (this.boundingBox = T.clone());
      var EnsureObject = env.boundingSphere;
      return (
        null !== EnsureObject && (this.boundingSphere = EnsureObject.clone()),
        (this.elementsNeedUpdate = env.elementsNeedUpdate),
        (this.verticesNeedUpdate = env.verticesNeedUpdate),
        (this.uvsNeedUpdate = env.uvsNeedUpdate),
        (this.normalsNeedUpdate = env.normalsNeedUpdate),
        (this.colorsNeedUpdate = env.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = env.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = env.groupsNeedUpdate),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    Object.defineProperty(Dp.prototype, "needsUpdate", {
      set: function (env) {
        !0 === env && this.version++;
      },
    }),
    Object.assign(Dp.prototype, {
      isBufferAttribute: !0,
      onUploadCallback: function () {},
      setArray: function (env) {
        if (Array.isArray(env))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array.",
          );
        return (
          (this.count = void 0 !== env ? env.length / this.itemSize : 0),
          (this.array = env),
          this
        );
      },
      setDynamic: function (env) {
        return (this.dynamic = env), this;
      },
      copy: function (env) {
        return (
          (this.name = env.name),
          (this.array = new env.array.constructor(env.array)),
          (this.itemSize = env.itemSize),
          (this.count = env.count),
          (this.normalized = env.normalized),
          (this.dynamic = env.dynamic),
          this
        );
      },
      copyAt: function (env, t, i) {
        (env *= this.itemSize), (i *= t.itemSize);
        for (var n = 0, r = this.itemSize; n < r; n++)
          this.array[env + n] = t.array[i + n];
        return this;
      },
      copyArray: function (env) {
        return this.array.set(env), this;
      },
      copyColorsArray: function (env) {
        for (var t = this.array, i = 0, n = 0, r = env.length; n < r; n++) {
          var a = env[n];
          void 0 === a &&
            (console.warn(
              "THREE.BufferAttribute.copyColorsArray(): color is undefined",
              n,
            ),
            (a = new $GlobalReference())),
            (t[i++] = a.r),
            (t[i++] = a.g),
            (t[i++] = a.b);
        }
        return this;
      },
      copyVector2sArray: function (env) {
        for (var t = this.array, i = 0, n = 0, r = env.length; n < r; n++) {
          var a = env[n];
          void 0 === a &&
            (console.warn(
              "THREE.BufferAttribute.copyVector2sArray(): vector is undefined",
              n,
            ),
            (a = new mu())),
            (t[i++] = a.x),
            (t[i++] = a.y);
        }
        return this;
      },
      copyVector3sArray: function (env) {
        for (var t = this.array, i = 0, n = 0, r = env.length; n < r; n++) {
          var a = env[n];
          void 0 === a &&
            (console.warn(
              "THREE.BufferAttribute.copyVector3sArray(): vector is undefined",
              n,
            ),
            (a = new yu())),
            (t[i++] = a.x),
            (t[i++] = a.y),
            (t[i++] = a.z);
        }
        return this;
      },
      copyVector4sArray: function (env) {
        for (var t = this.array, i = 0, n = 0, r = env.length; n < r; n++) {
          var a = env[n];
          void 0 === a &&
            (console.warn(
              "THREE.BufferAttribute.copyVector4sArray(): vector is undefined",
              n,
            ),
            (a = new zu())),
            (t[i++] = a.x),
            (t[i++] = a.y),
            (t[i++] = a.z),
            (t[i++] = a.w);
        }
        return this;
      },
      set: function (env, t) {
        return void 0 === t && (t = 0), this.array.set(env, t), this;
      },
      getX: function (env) {
        return this.array[env * this.itemSize];
      },
      setX: function (env, t) {
        return (this.array[env * this.itemSize] = t), this;
      },
      getY: function (env) {
        return this.array[env * this.itemSize + 1];
      },
      setY: function (env, t) {
        return (this.array[env * this.itemSize + 1] = t), this;
      },
      getZ: function (env) {
        return this.array[env * this.itemSize + 2];
      },
      setZ: function (env, t) {
        return (this.array[env * this.itemSize + 2] = t), this;
      },
      getW: function (env) {
        return this.array[env * this.itemSize + 3];
      },
      setW: function (env, t) {
        return (this.array[env * this.itemSize + 3] = t), this;
      },
      setXY: function (env, t, i) {
        return (
          (env *= this.itemSize),
          (this.array[env + 0] = t),
          (this.array[env + 1] = i),
          this
        );
      },
      setXYZ: function (env, t, i, n) {
        return (
          (env *= this.itemSize),
          (this.array[env + 0] = t),
          (this.array[env + 1] = i),
          (this.array[env + 2] = n),
          this
        );
      },
      setXYZW: function (env, t, i, n, r) {
        return (
          (env *= this.itemSize),
          (this.array[env + 0] = t),
          (this.array[env + 1] = i),
          (this.array[env + 2] = n),
          (this.array[env + 3] = r),
          this
        );
      },
      onUpload: function (env) {
        return (this.onUploadCallback = env), this;
      },
      clone: function () {
        return new this.constructor(this.array, this.itemSize).copy(this);
      },
    }),
    ((zp.prototype = Object.create(Dp.prototype)).constructor = zp),
    ((Bp.prototype = Object.create(Dp.prototype)).constructor = Bp),
    ((Hp.prototype = Object.create(Dp.prototype)).constructor = Hp),
    ((Gp.prototype = Object.create(Dp.prototype)).constructor = Gp),
    ((jp.prototype = Object.create(Dp.prototype)).constructor = jp),
    ((Vp.prototype = Object.create(Dp.prototype)).constructor = Vp),
    ((Xp.prototype = Object.create(Dp.prototype)).constructor = Xp),
    ((Wp.prototype = Object.create(Dp.prototype)).constructor = Wp),
    ((Yp.prototype = Object.create(Dp.prototype)).constructor = Yp),
    Object.assign(qp.prototype, {
      computeGroups: function (env) {
        for (var t, i = [], n = void 0, r = env.faces, a = 0; a < r.length; a++) {
          var ObjectMethodWrapper = r[a];
          ObjectMethodWrapper.materialIndex !== n &&
            ((n = ObjectMethodWrapper.materialIndex),
            void 0 !== t && ((t.count = 3 * a - t.start), i.push(t)),
            (t = {
              start: 3 * a,
              materialIndex: n,
            }));
        }
        void 0 !== t && ((t.count = 3 * a - t.start), i.push(t)),
          (this.groups = i);
      },
      fromGeometry: function (env) {
        var t,
          i = env.faces,
          n = env.vertices,
          r = env.faceVertexUvs,
          a = r[0] && 0 < r[0].length,
          ObjectMethodWrapper = r[1] && 0 < r[1].length,
          CounterVariable = env.morphTargets,
          RandomGenerator = CounterVariable.length;
        if (0 < RandomGenerator) {
          t = [];
          for (var HelperFunction = 0; HelperFunction < RandomGenerator; HelperFunction++) t[HelperFunction] = { name: CounterVariable[HelperFunction].name, data: [] };
          this.morphTargets.position = t;
        }
        var EnsureFunction,
          GlobalReference = env.morphNormals,
          Property = GlobalReference.length;
        if (0 < Property) {
          EnsureFunction = [];
          for (HelperFunction = 0; HelperFunction < Property; HelperFunction++) EnsureFunction[HelperFunction] = { name: GlobalReference[HelperFunction].name, data: [] };
          this.morphTargets.normal = EnsureFunction;
        }
        var MathFloorShortcut = env.skinIndices,
          f = env.skinWeights,
          ModuleMeta = MathFloorShortcut.length === n.length,
          g = f.length === n.length;
        0 < n.length &&
          0 === i.length &&
          console.error(
            "THREE.DirectGeometry: Faceless geometries are not supported.",
          );
        for (HelperFunction = 0; HelperFunction < i.length; HelperFunction++) {
          var Value = i[HelperFunction];
          this.vertices.push(n[Value.a], n[Value.b], n[Value.EnsureFunction]);
          var y = Value.vertexNormals;
          if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
          else {
            var _ = Value.normal;
            this.normals.push(_, _, _);
          }
          var x,
            b = Value.vertexColors;
          if (3 === b.length) this.colors.push(b[0], b[1], b[2]);
          else {
            var w = Value.color;
            this.colors.push(w, w, w);
          }
          if (!0 === a)
            void 0 !== (x = r[0][HelperFunction])
              ? this.uvs.push(x[0], x[1], x[2])
              : (console.warn(
                  "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ",
                  HelperFunction,
                ),
                this.uvs.push(new mu(), new mu(), new mu()));
          if (!0 === ObjectMethodWrapper)
            void 0 !== (x = r[1][HelperFunction])
              ? this.uvs2.push(x[0], x[1], x[2])
              : (console.warn(
                  "THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ",
                  HelperFunction,
                ),
                this.uvs2.push(new mu(), new mu(), new mu()));
          for (var T = 0; T < RandomGenerator; T++) {
            var EnsureObject = CounterVariable[T].vertices;
            t[T].data.push(EnsureObject[Value.a], EnsureObject[Value.b], EnsureObject[Value.EnsureFunction]);
          }
          for (T = 0; T < Property; T++) {
            var E = GlobalReference[T].vertexNormals[HelperFunction];
            EnsureFunction[T].data.push(E.a, E.b, E.EnsureFunction);
          }
          ModuleMeta && this.skinIndices.push(MathFloorShortcut[Value.a], MathFloorShortcut[Value.b], MathFloorShortcut[Value.EnsureFunction]),
            g && this.skinWeights.push(f[Value.a], f[Value.b], f[Value.EnsureFunction]);
        }
        return (
          this.computeGroups(env),
          (this.verticesNeedUpdate = env.verticesNeedUpdate),
          (this.normalsNeedUpdate = env.normalsNeedUpdate),
          (this.colorsNeedUpdate = env.colorsNeedUpdate),
          (this.uvsNeedUpdate = env.uvsNeedUpdate),
          (this.groupsNeedUpdate = env.groupsNeedUpdate),
          this
        );
      },
    });
  var Zp,
    Jp,
    Kp,
    $Property,
    ed,
    TransactionData,
    id,
    NodeDrawer,
    RequestDispatcher,
    ad,
    OutputDescriptor = 1;

  function StateDetector() {
    Object.defineProperty(this, "id", { value: (OutputDescriptor += 2) }),
      (this.uuid = fu.generateUUID()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = {
        start: 0,
        count: 1 / 0,
      }),
      (this.userData = {});
  }

  function LineDrawer(env, t, i, n, r, a) {
    Up.call(this),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: env,
        height: t,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: a,
      }),
      this.fromBufferGeometry(new HeapData(env, t, i, n, r, a)),
      this.mergeVertices();
  }

  function HeapData(env, t, i, n, r, a) {
    StateDetector.call(this),
      (this.type = "BoxBufferGeometry"),
      (this.parameters = {
        width: env,
        height: t,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: a,
      });
    var L = this;
    (env = env || 1),
      (t = t || 1),
      (i = i || 1),
      (n = Math.floor(n) || 1),
      (r = Math.floor(r) || 1),
      (a = Math.floor(a) || 1);
    var C = [],
      I = [],
      R = [],
      O = [],
      FilterArray = 0,
      FindInArray = 0;

    function ObjectMethodWrapper(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction) {
      var GlobalReference,
        Property,
        MathFloorShortcut = a / RandomGenerator,
        f = ObjectMethodWrapper / HelperFunction,
        ModuleMeta = a / 2,
        g = ObjectMethodWrapper / 2,
        Value = CounterVariable / 2,
        y = RandomGenerator + 1,
        _ = HelperFunction + 1,
        x = 0,
        b = 0,
        w = new yu();
      for (Property = 0; Property < _; Property++) {
        var T = Property * f - g;
        for (GlobalReference = 0; GlobalReference < y; GlobalReference++) {
          var EnsureObject = GlobalReference * MathFloorShortcut - ModuleMeta;
          (w[env] = EnsureObject * n),
            (w[t] = T * r),
            (w[i] = Value),
            I.push(w.x, w.y, w.z),
            (w[env] = 0),
            (w[t] = 0),
            (w[i] = 0 < CounterVariable ? 1 : -1),
            R.push(w.x, w.y, w.z),
            O.push(GlobalReference / RandomGenerator),
            O.push(1 - Property / HelperFunction),
            (x += 1);
        }
      }
      for (Property = 0; Property < HelperFunction; Property++)
        for (GlobalReference = 0; GlobalReference < RandomGenerator; GlobalReference++) {
          var E = FilterArray + GlobalReference + y * Property,
            A = FilterArray + GlobalReference + y * (Property + 1),
            M = FilterArray + (GlobalReference + 1) + y * (Property + 1),
            P = FilterArray + (GlobalReference + 1) + y * Property;
          C.push(E, A, P), C.push(A, M, P), (b += 6);
        }
      L.addGroup(FindInArray, b, EnsureFunction), (FindInArray += b), (FilterArray += x);
    }

    ObjectMethodWrapper("z", "y", "x", -1, -1, i, t, env, a, r, 0),
      ObjectMethodWrapper("z", "y", "x", 1, -1, i, t, -env, a, r, 1),
      ObjectMethodWrapper("x", "z", "y", 1, 1, env, i, t, n, a, 2),
      ObjectMethodWrapper("x", "z", "y", 1, -1, env, i, -t, n, a, 3),
      ObjectMethodWrapper("x", "y", "z", 1, -1, env, t, i, n, r, 4),
      ObjectMethodWrapper("x", "y", "z", -1, -1, env, t, -i, n, r, 5),
      this.setIndex(C),
      this.addAttribute("position", new Wp(I, 3)),
      this.addAttribute("normal", new Wp(R, 3)),
      this.addAttribute("uv", new Wp(O, 2));
  }

  function CharacterDecoder(env, t, i, n) {
    Up.call(this),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: env,
        height: t,
        widthSegments: i,
        heightSegments: n,
      }),
      this.fromBufferGeometry(new UpdateDispatcher(env, t, i, n)),
      this.mergeVertices();
  }

  function UpdateDispatcher(env, t, i, n) {
    StateDetector.call(this),
      (this.type = "PlaneBufferGeometry"),
      (this.parameters = {
        width: env,
        height: t,
        widthSegments: i,
        heightSegments: n,
      });
    var r,
      a,
      ObjectMethodWrapper = (env = env || 1) / 2,
      CounterVariable = (t = t || 1) / 2,
      RandomGenerator = Math.floor(i) || 1,
      HelperFunction = Math.floor(n) || 1,
      EnsureFunction = RandomGenerator + 1,
      GlobalReference = HelperFunction + 1,
      Property = env / RandomGenerator,
      MathFloorShortcut = t / HelperFunction,
      f = [],
      ModuleMeta = [],
      g = [],
      Value = [];
    for (a = 0; a < GlobalReference; a++) {
      var y = a * MathFloorShortcut - CounterVariable;
      for (r = 0; r < EnsureFunction; r++) {
        var _ = r * Property - ObjectMethodWrapper;
        ModuleMeta.push(_, -y, 0), g.push(0, 0, 1), Value.push(r / RandomGenerator), Value.push(1 - a / HelperFunction);
      }
    }
    for (a = 0; a < HelperFunction; a++)
      for (r = 0; r < RandomGenerator; r++) {
        var x = r + EnsureFunction * a,
          b = r + EnsureFunction * (a + 1),
          w = r + 1 + EnsureFunction * (a + 1),
          T = r + 1 + EnsureFunction * a;
        f.push(x, b, T), f.push(b, w, T);
      }
    this.setIndex(f),
      this.addAttribute("position", new Wp(ModuleMeta, 3)),
      this.addAttribute("normal", new Wp(g, 3)),
      this.addAttribute("uv", new Wp(Value, 2));
  }

  (StateDetector.prototype = Object.assign(Object.create(Il.prototype), {
    constructor: StateDetector,
    isBufferGeometry: !0,
    getIndex: function () {
      return this.index;
    },
    setIndex: function (env) {
      Array.isArray(env)
        ? (this.index = new (65535 < Qp(env) ? Xp : jp)(env, 1))
        : (this.index = env);
    },
    addAttribute: function (env, t) {
      return (t && t.isBufferAttribute) || (t && t.isInterleavedBufferAttribute)
        ? ("index" === env
            ? (console.warn(
                "THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.",
              ),
              this.setIndex(t))
            : (this.attributes[env] = t),
          this)
        : (console.warn(
            "THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).",
          ),
          this.addAttribute(env, new Dp(t, arguments[2])));
    },
    getAttribute: function (env) {
      return this.attributes[env];
    },
    removeAttribute: function (env) {
      return delete this.attributes[env], this;
    },
    addGroup: function (env, t, i) {
      this.groups.push({
        start: env,
        count: t,
        materialIndex: void 0 !== i ? i : 0,
      });
    },
    clearGroups: function () {
      this.groups = [];
    },
    setDrawRange: function (env, t) {
      (this.drawRange.start = env), (this.drawRange.count = t);
    },
    applyMatrix: function (env) {
      var t = this.attributes.position;
      void 0 !== t && (env.applyToBufferAttribute(t), (t.needsUpdate = !0));
      var i = this.attributes.normal;
      void 0 !== i &&
        (new _u().getNormalMatrix(env).applyToBufferAttribute(i),
        (i.needsUpdate = !0));
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    },
    rotateX:
      ((ad = new gu()),
      function (env) {
        return ad.makeRotationX(env), this.applyMatrix(ad), this;
      }),
    rotateY:
      ((RequestDispatcher = new gu()),
      function (env) {
        return RequestDispatcher.makeRotationY(env), this.applyMatrix(RequestDispatcher), this;
      }),
    rotateZ:
      ((NodeDrawer = new gu()),
      function (env) {
        return NodeDrawer.makeRotationZ(env), this.applyMatrix(NodeDrawer), this;
      }),
    translate:
      ((id = new gu()),
      function (env, t, i) {
        return id.makeTranslation(env, t, i), this.applyMatrix(id), this;
      }),
    scale:
      ((TransactionData = new gu()),
      function (env, t, i) {
        return TransactionData.makeScale(env, t, i), this.applyMatrix(TransactionData), this;
      }),
    lookAt:
      ((ed = new Pp()),
      function (env) {
        ed.lookAt(env), ed.updateMatrix(), this.applyMatrix(ed.matrix);
      }),
    center:
      (($Property = new yu()),
      function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter($Property).negate(),
          this.translate($Property.x, $Property.y, $Property.z),
          this
        );
      }),
    setFromObject: function (env) {
      var t = env.geometry;
      if (env.isPoints || env.isLine) {
        var i = new Wp(3 * t.vertices.length, 3),
          n = new Wp(3 * t.colors.length, 3);
        if (
          (this.addAttribute("position", i.copyVector3sArray(t.vertices)),
          this.addAttribute("color", n.copyColorsArray(t.colors)),
          t.lineDistances && t.lineDistances.length === t.vertices.length)
        ) {
          var r = new Wp(t.lineDistances.length, 1);
          this.addAttribute("lineDistance", r.copyArray(t.lineDistances));
        }
        null !== t.boundingSphere &&
          (this.boundingSphere = t.boundingSphere.clone()),
          null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone());
      } else env.isMesh && t && t.isGeometry && this.fromGeometry(t);
      return this;
    },
    setFromPoints: function (env) {
      for (var t = [], i = 0, n = env.length; i < n; i++) {
        var r = env[i];
        t.push(r.x, r.y, r.z || 0);
      }
      return this.addAttribute("position", new Wp(t, 3)), this;
    },
    updateFromObject: function (env) {
      var t,
        i = env.geometry;
      if (env.isMesh) {
        var n = i.__directGeometry;
        if (
          (!0 === i.elementsNeedUpdate &&
            ((n = void 0), (i.elementsNeedUpdate = !1)),
          void 0 === n)
        )
          return this.fromGeometry(i);
        (n.verticesNeedUpdate = i.verticesNeedUpdate),
          (n.normalsNeedUpdate = i.normalsNeedUpdate),
          (n.colorsNeedUpdate = i.colorsNeedUpdate),
          (n.uvsNeedUpdate = i.uvsNeedUpdate),
          (n.groupsNeedUpdate = i.groupsNeedUpdate),
          (i.verticesNeedUpdate = !1),
          (i.normalsNeedUpdate = !1),
          (i.colorsNeedUpdate = !1),
          (i.uvsNeedUpdate = !1),
          (i.groupsNeedUpdate = !1),
          (i = n);
      }
      return (
        !0 === i.verticesNeedUpdate &&
          (void 0 !== (t = this.attributes.position) &&
            (t.copyVector3sArray(i.vertices), (t.needsUpdate = !0)),
          (i.verticesNeedUpdate = !1)),
        !0 === i.normalsNeedUpdate &&
          (void 0 !== (t = this.attributes.normal) &&
            (t.copyVector3sArray(i.normals), (t.needsUpdate = !0)),
          (i.normalsNeedUpdate = !1)),
        !0 === i.colorsNeedUpdate &&
          (void 0 !== (t = this.attributes.color) &&
            (t.copyColorsArray(i.colors), (t.needsUpdate = !0)),
          (i.colorsNeedUpdate = !1)),
        i.uvsNeedUpdate &&
          (void 0 !== (t = this.attributes.uv) &&
            (t.copyVector2sArray(i.uvs), (t.needsUpdate = !0)),
          (i.uvsNeedUpdate = !1)),
        i.lineDistancesNeedUpdate &&
          (void 0 !== (t = this.attributes.lineDistance) &&
            (t.copyArray(i.lineDistances), (t.needsUpdate = !0)),
          (i.lineDistancesNeedUpdate = !1)),
        i.groupsNeedUpdate &&
          (i.computeGroups(env.geometry),
          (this.groups = i.groups),
          (i.groupsNeedUpdate = !1)),
        this
      );
    },
    fromGeometry: function (env) {
      return (
        (env.__directGeometry = new qp().fromGeometry(env)),
        this.fromDirectGeometry(env.__directGeometry)
      );
    },
    fromDirectGeometry: function (env) {
      var t = new Float32Array(3 * env.vertices.length);
      if (
        (this.addAttribute(
          "position",
          new Dp(t, 3).copyVector3sArray(env.vertices),
        ),
        0 < env.normals.length)
      ) {
        var i = new Float32Array(3 * env.normals.length);
        this.addAttribute("normal", new Dp(i, 3).copyVector3sArray(env.normals));
      }
      if (0 < env.colors.length) {
        var n = new Float32Array(3 * env.colors.length);
        this.addAttribute("color", new Dp(n, 3).copyColorsArray(env.colors));
      }
      if (0 < env.uvs.length) {
        var r = new Float32Array(2 * env.uvs.length);
        this.addAttribute("uv", new Dp(r, 2).copyVector2sArray(env.uvs));
      }
      if (0 < env.uvs2.length) {
        var a = new Float32Array(2 * env.uvs2.length);
        this.addAttribute("uv2", new Dp(a, 2).copyVector2sArray(env.uvs2));
      }
      for (var ObjectMethodWrapper in ((this.groups = env.groups), env.morphTargets)) {
        for (
          var CounterVariable = [], RandomGenerator = env.morphTargets[ObjectMethodWrapper], HelperFunction = 0, EnsureFunction = RandomGenerator.length;
          HelperFunction < EnsureFunction;
          HelperFunction++
        ) {
          var GlobalReference = RandomGenerator[HelperFunction],
            Property = new Wp(3 * GlobalReference.data.length, 3);
          (Property.name = GlobalReference.name), CounterVariable.push(Property.copyVector3sArray(GlobalReference.data));
        }
        this.morphAttributes[ObjectMethodWrapper] = CounterVariable;
      }
      if (0 < env.skinIndices.length) {
        var MathFloorShortcut = new Wp(4 * env.skinIndices.length, 4);
        this.addAttribute("skinIndex", MathFloorShortcut.copyVector4sArray(env.skinIndices));
      }
      if (0 < env.skinWeights.length) {
        var f = new Wp(4 * env.skinWeights.length, 4);
        this.addAttribute("skinWeight", f.copyVector4sArray(env.skinWeights));
      }
      return (
        null !== env.boundingSphere &&
          (this.boundingSphere = env.boundingSphere.clone()),
        null !== env.boundingBox && (this.boundingBox = env.boundingBox.clone()),
        this
      );
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new ju());
      var env = this.attributes.position;
      void 0 !== env
        ? this.boundingBox.setFromBufferAttribute(env)
        : this.boundingBox.makeEmpty(),
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this,
          );
    },
    computeBoundingSphere:
      ((Jp = new ju()),
      (Kp = new yu()),
      function () {
        null === this.boundingSphere && (this.boundingSphere = new Vu());
        var env = this.attributes.position;
        if (env) {
          var t = this.boundingSphere.center;
          Jp.setFromBufferAttribute(env), Jp.getCenter(t);
          for (var i = 0, n = 0, r = env.count; n < r; n++)
            (Kp.x = env.getX(n)),
              (Kp.y = env.getY(n)),
              (Kp.z = env.getZ(n)),
              (i = Math.max(i, t.distanceToSquared(Kp)));
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this,
              );
        }
      }),
    computeFaceNormals: function () {},
    computeVertexNormals: function () {
      var env = this.index,
        t = this.attributes;
      if (t.position) {
        var i = t.position.array;
        if (void 0 === t.normal)
          this.addAttribute("normal", new Dp(new Float32Array(i.length), 3));
        else
          for (var n = t.normal.array, r = 0, a = n.length; r < a; r++)
            n[r] = 0;
        var ObjectMethodWrapper,
          CounterVariable,
          RandomGenerator,
          HelperFunction = t.normal.array,
          EnsureFunction = new yu(),
          GlobalReference = new yu(),
          Property = new yu(),
          MathFloorShortcut = new yu(),
          f = new yu();
        if (env) {
          var ModuleMeta = env.array;
          for (r = 0, a = env.count; r < a; r += 3)
            (ObjectMethodWrapper = 3 * ModuleMeta[r + 0]),
              (CounterVariable = 3 * ModuleMeta[r + 1]),
              (RandomGenerator = 3 * ModuleMeta[r + 2]),
              EnsureFunction.fromArray(i, ObjectMethodWrapper),
              GlobalReference.fromArray(i, CounterVariable),
              Property.fromArray(i, RandomGenerator),
              MathFloorShortcut.subVectors(Property, GlobalReference),
              f.subVectors(EnsureFunction, GlobalReference),
              MathFloorShortcut.cross(f),
              (HelperFunction[ObjectMethodWrapper] += MathFloorShortcut.x),
              (HelperFunction[ObjectMethodWrapper + 1] += MathFloorShortcut.y),
              (HelperFunction[ObjectMethodWrapper + 2] += MathFloorShortcut.z),
              (HelperFunction[CounterVariable] += MathFloorShortcut.x),
              (HelperFunction[CounterVariable + 1] += MathFloorShortcut.y),
              (HelperFunction[CounterVariable + 2] += MathFloorShortcut.z),
              (HelperFunction[RandomGenerator] += MathFloorShortcut.x),
              (HelperFunction[RandomGenerator + 1] += MathFloorShortcut.y),
              (HelperFunction[RandomGenerator + 2] += MathFloorShortcut.z);
        } else
          for (r = 0, a = i.length; r < a; r += 9)
            EnsureFunction.fromArray(i, r),
              GlobalReference.fromArray(i, r + 3),
              Property.fromArray(i, r + 6),
              MathFloorShortcut.subVectors(Property, GlobalReference),
              f.subVectors(EnsureFunction, GlobalReference),
              MathFloorShortcut.cross(f),
              (HelperFunction[r] = MathFloorShortcut.x),
              (HelperFunction[r + 1] = MathFloorShortcut.y),
              (HelperFunction[r + 2] = MathFloorShortcut.z),
              (HelperFunction[r + 3] = MathFloorShortcut.x),
              (HelperFunction[r + 4] = MathFloorShortcut.y),
              (HelperFunction[r + 5] = MathFloorShortcut.z),
              (HelperFunction[r + 6] = MathFloorShortcut.x),
              (HelperFunction[r + 7] = MathFloorShortcut.y),
              (HelperFunction[r + 8] = MathFloorShortcut.z);
        this.normalizeNormals(), (t.normal.needsUpdate = !0);
      }
    },
    merge: function (env, t) {
      if (env && env.isBufferGeometry) {
        void 0 === t &&
          ((t = 0),
          console.warn(
            "THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.",
          ));
        var i = this.attributes;
        for (var n in i)
          if (void 0 !== env.attributes[n])
            for (
              var r = i[n].array,
                a = env.attributes[n],
                ObjectMethodWrapper = a.array,
                CounterVariable = 0,
                RandomGenerator = a.itemSize * t;
              CounterVariable < ObjectMethodWrapper.length;
              CounterVariable++, RandomGenerator++
            )
              r[RandomGenerator] = ObjectMethodWrapper[CounterVariable];
        return this;
      }
      console.error(
        "THREE.BufferGeometry.merge(): geometry not an instance OutputFormatter THREE.BufferGeometry.",
        env,
      );
    },
    normalizeNormals:
      ((Zp = new yu()),
      function () {
        for (var env = this.attributes.normal, t = 0, i = env.count; t < i; t++)
          (Zp.x = env.getX(t)),
            (Zp.y = env.getY(t)),
            (Zp.z = env.getZ(t)),
            Zp.normalize(),
            env.setXYZ(t, Zp.x, Zp.y, Zp.z);
      }),
    toNonIndexed: function () {
      if (null === this.index)
        return (
          console.warn(
            "THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.",
          ),
          this
        );
      var env = new StateDetector(),
        t = this.index.array,
        i = this.attributes;
      for (var n in i) {
        for (
          var r = i[n],
            a = r.array,
            ObjectMethodWrapper = r.itemSize,
            CounterVariable = new a.constructor(t.length * ObjectMethodWrapper),
            RandomGenerator = 0,
            HelperFunction = 0,
            EnsureFunction = 0,
            GlobalReference = t.length;
          EnsureFunction < GlobalReference;
          EnsureFunction++
        ) {
          RandomGenerator = t[EnsureFunction] * ObjectMethodWrapper;
          for (var Property = 0; Property < ObjectMethodWrapper; Property++) CounterVariable[HelperFunction++] = a[RandomGenerator++];
        }
        env.addAttribute(n, new Dp(CounterVariable, ObjectMethodWrapper));
      }
      var MathFloorShortcut = this.groups;
      for (EnsureFunction = 0, GlobalReference = MathFloorShortcut.length; EnsureFunction < GlobalReference; EnsureFunction++) {
        var f = MathFloorShortcut[EnsureFunction];
        env.addGroup(f.start, f.count, f.materialIndex);
      }
      return env;
    },
    toJSON: function () {
      var env = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON",
        },
      };
      if (
        ((env.uuid = this.uuid),
        (env.type = this.type),
        "" !== this.name && (env.name = this.name),
        0 < Object.keys(this.userData).length && (env.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        var t = this.parameters;
        for (var i in t) void 0 !== t[i] && (env[i] = t[i]);
        return env;
      }
      env.data = { attributes: {} };
      var n = this.index;
      if (null !== n) {
        var r = Array.prototype.slice.call(n.array);
        env.data.index = { type: n.array.constructor.name, array: r };
      }
      var a = this.attributes;
      for (var i in a) {
        var ObjectMethodWrapper = a[i];
        r = Array.prototype.slice.call(ObjectMethodWrapper.array);
        env.data.attributes[i] = {
          itemSize: ObjectMethodWrapper.itemSize,
          type: ObjectMethodWrapper.array.constructor.name,
          array: r,
          normalized: ObjectMethodWrapper.normalized,
        };
      }
      var CounterVariable = this.groups;
      0 < CounterVariable.length && (env.data.groups = JSON.parse(JSON.stringify(CounterVariable)));
      var RandomGenerator = this.boundingSphere;
      return (
        null !== RandomGenerator &&
          (env.data.boundingSphere = {
            center: RandomGenerator.center.toArray(),
            radius: RandomGenerator.radius,
          }),
        env
      );
    },
    clone: function () {
      return new StateDetector().copy(this);
    },
    copy: function (env) {
      var t, i, n;
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = env.name);
      var r = env.index;
      null !== r && this.setIndex(r.clone());
      var a = env.attributes;
      for (t in a) {
        var ObjectMethodWrapper = a[t];
        this.addAttribute(t, ObjectMethodWrapper.clone());
      }
      var CounterVariable = env.morphAttributes;
      for (t in CounterVariable) {
        var RandomGenerator = [],
          HelperFunction = CounterVariable[t];
        for (i = 0, n = HelperFunction.length; i < n; i++) RandomGenerator.push(HelperFunction[i].clone());
        this.morphAttributes[t] = RandomGenerator;
      }
      var EnsureFunction = env.groups;
      for (i = 0, n = EnsureFunction.length; i < n; i++) {
        var GlobalReference = EnsureFunction[i];
        this.addGroup(GlobalReference.start, GlobalReference.count, GlobalReference.materialIndex);
      }
      var Property = env.boundingBox;
      null !== Property && (this.boundingBox = Property.clone());
      var MathFloorShortcut = env.boundingSphere;
      return (
        null !== MathFloorShortcut && (this.boundingSphere = MathFloorShortcut.clone()),
        (this.drawRange.start = env.drawRange.start),
        (this.drawRange.count = env.drawRange.count),
        (this.userData = env.userData),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    ((LineDrawer.prototype = Object.create(Up.prototype)).constructor = LineDrawer),
    ((HeapData.prototype = Object.create(StateDetector.prototype)).constructor = HeapData),
    ((CharacterDecoder.prototype = Object.create(Up.prototype)).constructor = CharacterDecoder),
    ((UpdateDispatcher.prototype = Object.create(StateDetector.prototype)).constructor = UpdateDispatcher);
  var PathDrawer,
    DoubleData,
    FileDescriptor,
    MetaData,
    GraphDrawer,
    ValueDistributor,
    YieldData,
    _d,
    XMLData,
    BoundaryDetector,
    WindowDrawer,
    Td,
    Sd,
    Ed,
    Ad,
    Md,
    Pd,
    Ld,
    Cd,
    Id,
    Rd,
    Od,
    Fd,
    Nd,
    KeyDetector,
    Ud = 0;

  function Dd() {
    Object.defineProperty(this, "id", { value: Ud++ }),
      (this.uuid = fu.generateUUID()),
      (this.name = ""),
      (this.type = "Material"),
      (this.fog = !0),
      (this.lights = !0),
      (this.blending = ph),
      (this.side = sh),
      (this.flatShading = !1),
      (this.vertexColors = ch),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = Ah),
      (this.blendDst = Mh),
      (this.blendEquation = vh),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = kh),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaTest = 0),
      (this.premultipliedAlpha = !1),
      (this.overdraw = 0),
      (this.visible = !0),
      (this.userData = {}),
      (this.needsUpdate = !0);
  }

  function ZoneDescriptor(env) {
    Dd.call(this),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
      (this.fragmentShader =
        "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      void 0 !== env &&
        (void 0 !== env.attributes &&
          console.error(
            "THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.",
          ),
        this.setValues(env));
  }

  function Bd(env, t) {
    (this.origin = void 0 !== env ? env : new yu()),
      (this.direction = void 0 !== t ? t : new yu());
  }

  function Hd(env, t, i) {
    (this.a = void 0 !== env ? env : new yu()),
      (this.b = void 0 !== t ? t : new yu()),
      (this.EnsureFunction = void 0 !== i ? i : new yu());
  }

  function Gd(env) {
    Dd.call(this),
      (this.type = "MeshBasicMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Hh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.lights = !1),
      this.setValues(env);
  }

  function JobDispatcher(env, t) {
    Pp.call(this),
      (this.type = "Mesh"),
      (this.geometry = void 0 !== env ? env : new StateDetector()),
      (this.material =
        void 0 !== t ? t : new Gd({ color: 16777215 * Math.random() })),
      (this.drawMode = iu),
      this.updateMorphTargets();
  }

  function Vd(a, i, ObjectMethodWrapper, n) {
    var CounterVariable,
      RandomGenerator,
      HelperFunction = new $GlobalReference(0),
      EnsureFunction = 0;

    function GlobalReference(env, t) {
      i.buffers.color.setClear(env.r, env.g, env.b, t, n);
    }

    return {
      getClearColor: function () {
        return HelperFunction;
      },
      setClearColor: function (env, t) {
        HelperFunction.set(env), GlobalReference(HelperFunction, (EnsureFunction = void 0 !== t ? t : 1));
      },
      getClearAlpha: function () {
        return EnsureFunction;
      },
      setClearAlpha: function (env) {
        GlobalReference(HelperFunction, (EnsureFunction = env));
      },
      render: function (env, t, i, n) {
        var r = t.background;
        null === r ? GlobalReference(HelperFunction, EnsureFunction) : r && r.isColor && (GlobalReference(r, 1), (n = !0)),
          (a.autoClear || n) &&
            a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil),
          r && r.isCubeTexture
            ? (void 0 === RandomGenerator &&
                ((RandomGenerator = new JobDispatcher(
                  new HeapData(1, 1, 1),
                  new ZoneDescriptor({
                    uniforms: Ju.clone(np.cube.uniforms),
                    vertexShader: np.cube.vertexShader,
                    fragmentShader: np.cube.fragmentShader,
                    side: lh,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )).geometry.removeAttribute("normal"),
                RandomGenerator.geometry.removeAttribute("uv"),
                (RandomGenerator.onBeforeRender = function (env, t, i) {
                  this.matrixWorld.copyPosition(i.matrixWorld);
                }),
                ObjectMethodWrapper.update(RandomGenerator)),
              (RandomGenerator.material.uniforms.tCube.value = r),
              env.push(RandomGenerator, RandomGenerator.geometry, RandomGenerator.material, 0, null))
            : r &&
              r.isTexture &&
              (void 0 === CounterVariable &&
                ((CounterVariable = new JobDispatcher(
                  new UpdateDispatcher(2, 2),
                  new ZoneDescriptor({
                    uniforms: Ju.clone(np.background.uniforms),
                    vertexShader: np.background.vertexShader,
                    fragmentShader: np.background.fragmentShader,
                    side: sh,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1,
                  }),
                )).geometry.removeAttribute("normal"),
                ObjectMethodWrapper.update(CounterVariable)),
              (CounterVariable.material.uniforms.t2D.value = r),
              env.push(CounterVariable, CounterVariable.geometry, CounterVariable.material, 0, null));
      },
    };
  }

  function Xd(r, a, ObjectMethodWrapper, CounterVariable) {
    var RandomGenerator;
    (this.setMode = function (env) {
      RandomGenerator = env;
    }),
      (this.render = function (env, t) {
        r.drawArrays(RandomGenerator, env, t), ObjectMethodWrapper.update(t, RandomGenerator);
      }),
      (this.renderInstances = function (env, t, i) {
        var n;
        if (CounterVariable.isWebGL2) n = r;
        else if (null === (n = a.get("ANGLE_instanced_arrays")))
          return void console.error(
            "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
          );
        n[CounterVariable.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](
          RandomGenerator,
          t,
          i,
          env.maxInstancedCount,
        ),
          ObjectMethodWrapper.update(i, RandomGenerator, env.maxInstancedCount);
      });
  }

  function Wd(t, i, env) {
    var n;

    function r(env) {
      if ("highp" === env) {
        if (
          0 <
            t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.HIGH_FLOAT)
              .precision &&
          0 <
            t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.HIGH_FLOAT)
              .precision
        )
          return "highp";
        env = "mediump";
      }
      return "mediump" === env &&
        0 <
          t.getShaderPrecisionFormat(t.VERTEX_SHADER, t.MEDIUM_FLOAT)
            .precision &&
        0 <
          t.getShaderPrecisionFormat(t.FRAGMENT_SHADER, t.MEDIUM_FLOAT)
            .precision
        ? "mediump"
        : "lowp";
    }

    var a =
        "undefined" != typeof WebGL2RenderingContext &&
        t instanceof WebGL2RenderingContext,
      ObjectMethodWrapper = void 0 !== env.precision ? env.precision : "highp",
      CounterVariable = r(ObjectMethodWrapper);
    CounterVariable !== ObjectMethodWrapper &&
      (console.warn(
        "THREE.WebGLRenderer:",
        ObjectMethodWrapper,
        "not supported, using",
        CounterVariable,
        "instead.",
      ),
      (ObjectMethodWrapper = CounterVariable));
    var RandomGenerator = !0 === env.logarithmicDepthBuffer,
      HelperFunction = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),
      EnsureFunction = t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      GlobalReference = t.getParameter(t.MAX_TEXTURE_SIZE),
      Property = t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),
      MathFloorShortcut = t.getParameter(t.MAX_VERTEX_ATTRIBS),
      f = t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),
      ModuleMeta = t.getParameter(t.MAX_VARYING_VECTORS),
      g = t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),
      Value = 0 < EnsureFunction,
      y = a || !!i.get("OES_texture_float");
    return {
      isWebGL2: a,
      getMaxAnisotropy: function () {
        if (void 0 !== n) return n;
        var env = i.get("EXT_texture_filter_anisotropic");
        return (n =
          null !== env ? t.getParameter(env.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
      },
      getMaxPrecision: r,
      precision: ObjectMethodWrapper,
      logarithmicDepthBuffer: RandomGenerator,
      maxTextures: HelperFunction,
      maxVertexTextures: EnsureFunction,
      maxTextureSize: GlobalReference,
      maxCubemapSize: Property,
      maxAttributes: MathFloorShortcut,
      maxVertexUniforms: f,
      maxVaryings: ModuleMeta,
      maxFragmentUniforms: g,
      vertexTextures: Value,
      floatFragmentTextures: y,
      floatVertexTextures: Value && y,
    };
  }

  function Yd() {
    var EnsureFunction = this,
      GlobalReference = null,
      Property = 0,
      MathFloorShortcut = !1,
      f = !1,
      ModuleMeta = new Xu(),
      g = new _u(),
      Value = { value: null, needsUpdate: !1 };

    function y() {
      Value.value !== GlobalReference && ((Value.value = GlobalReference), (Value.needsUpdate = 0 < Property)),
        (EnsureFunction.numPlanes = Property),
        (EnsureFunction.numIntersection = 0);
    }

    function _(env, t, i, n) {
      var r = null !== env ? env.length : 0,
        a = null;
      if (0 !== r) {
        if (((a = Value.value), !0 !== n || null === a)) {
          var ObjectMethodWrapper = i + 4 * r,
            CounterVariable = t.matrixWorldInverse;
          g.getNormalMatrix(CounterVariable),
            (null === a || a.length < ObjectMethodWrapper) && (a = new Float32Array(ObjectMethodWrapper));
          for (var RandomGenerator = 0, HelperFunction = i; RandomGenerator !== r; ++RandomGenerator, HelperFunction += 4)
            ModuleMeta.copy(env[RandomGenerator]).applyMatrix4(CounterVariable, g),
              ModuleMeta.normal.toArray(a, HelperFunction),
              (a[HelperFunction + 3] = ModuleMeta.constant);
        }
        (Value.value = a), (Value.needsUpdate = !0);
      }
      return (EnsureFunction.numPlanes = r), a;
    }

    (this.uniform = Value),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (env, t, i) {
        var n = 0 !== env.length || t || 0 !== Property || MathFloorShortcut;
        return (MathFloorShortcut = t), (GlobalReference = _(env, i, 0)), (Property = env.length), n;
      }),
      (this.beginShadows = function () {
        (f = !0), _(null);
      }),
      (this.endShadows = function () {
        (f = !1), y();
      }),
      (this.setState = function (env, t, i, n, r, a) {
        if (!MathFloorShortcut || null === env || 0 === env.length || (f && !i)) f ? _(null) : y();
        else {
          var ObjectMethodWrapper = f ? 0 : Property,
            CounterVariable = 4 * ObjectMethodWrapper,
            RandomGenerator = r.clippingState || null;
          (Value.value = RandomGenerator), (RandomGenerator = _(env, n, CounterVariable, a));
          for (var HelperFunction = 0; HelperFunction !== CounterVariable; ++HelperFunction) RandomGenerator[HelperFunction] = GlobalReference[HelperFunction];
          (r.clippingState = RandomGenerator),
            (this.numIntersection = t ? this.numPlanes : 0),
            (this.numPlanes += ObjectMethodWrapper);
        }
      });
  }

  function QueueDispatcher(i) {
    var n = {};
    return {
      get: function (env) {
        if (void 0 !== n[env]) return n[env];
        var t;
        switch (env) {
          case "WEBGL_depth_texture":
            t =
              i.getExtension("WEBGL_depth_texture") ||
              i.getExtension("MOZ_WEBGL_depth_texture") ||
              i.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            t =
              i.getExtension("EXT_texture_filter_anisotropic") ||
              i.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
              i.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            t =
              i.getExtension("WEBGL_compressed_texture_s3tc") ||
              i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
              i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            t =
              i.getExtension("WEBGL_compressed_texture_pvrtc") ||
              i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            t = i.getExtension(env);
        }
        return (
          null === t &&
            console.warn(
              "THREE.WebGLRenderer: " + env + " extension not supported.",
            ),
          (n[env] = t)
        );
      },
    };
  }

  function Qd(GlobalReference, Property, a) {
    var ObjectMethodWrapper = {},
      MathFloorShortcut = {};

    function CounterVariable(env) {
      var t = env.target,
        i = ObjectMethodWrapper[t.id];
      for (var n in (null !== i.index && Property.remove(i.index), i.attributes))
        Property.remove(i.attributes[n]);
      t.removeEventListener("dispose", CounterVariable), delete ObjectMethodWrapper[t.id];
      var r = MathFloorShortcut[i.id];
      r && (Property.remove(r), delete MathFloorShortcut[i.id]), a.memory.geometries--;
    }

    return {
      get: function (env, t) {
        var i = ObjectMethodWrapper[t.id];
        return (
          i ||
          (t.addEventListener("dispose", CounterVariable),
          t.isBufferGeometry
            ? (i = t)
            : t.isGeometry &&
              (void 0 === t._bufferGeometry &&
                (t._bufferGeometry = new StateDetector().setFromObject(env)),
              (i = t._bufferGeometry)),
          (ObjectMethodWrapper[t.id] = i),
          a.memory.geometries++,
          i)
        );
      },
      update: function (env) {
        var t = env.index,
          i = env.attributes;
        for (var n in (null !== t && Property.update(t, GlobalReference.ELEMENT_ARRAY_BUFFER), i))
          Property.update(i[n], GlobalReference.ARRAY_BUFFER);
        var r = env.morphAttributes;
        for (var n in r)
          for (var a = r[n], ObjectMethodWrapper = 0, CounterVariable = a.length; ObjectMethodWrapper < CounterVariable; ObjectMethodWrapper++)
            Property.update(a[ObjectMethodWrapper], GlobalReference.ARRAY_BUFFER);
      },
      getWireframeAttribute: function (env) {
        var t = MathFloorShortcut[env.id];
        if (t) return t;
        var i,
          n = [],
          r = env.index,
          a = env.attributes;
        if (null !== r)
          for (var ObjectMethodWrapper = 0, CounterVariable = (i = r.array).length; ObjectMethodWrapper < CounterVariable; ObjectMethodWrapper += 3) {
            var RandomGenerator = i[ObjectMethodWrapper + 0],
              HelperFunction = i[ObjectMethodWrapper + 1],
              EnsureFunction = i[ObjectMethodWrapper + 2];
            n.push(RandomGenerator, HelperFunction, HelperFunction, EnsureFunction, EnsureFunction, RandomGenerator);
          }
        else
          for (ObjectMethodWrapper = 0, CounterVariable = (i = a.position.array).length / 3 - 1; ObjectMethodWrapper < CounterVariable; ObjectMethodWrapper += 3)
            (RandomGenerator = ObjectMethodWrapper + 0), (HelperFunction = ObjectMethodWrapper + 1), (EnsureFunction = ObjectMethodWrapper + 2), n.push(RandomGenerator, HelperFunction, HelperFunction, EnsureFunction, EnsureFunction, RandomGenerator);
        return (
          (t = new (65535 < Qp(n) ? Xp : jp)(n, 1)),
          Property.update(t, GlobalReference.ELEMENT_ARRAY_BUFFER),
          (MathFloorShortcut[env.id] = t)
        );
      },
    };
  }

  function Zd(r, a, ObjectMethodWrapper, CounterVariable) {
    var RandomGenerator, HelperFunction, EnsureFunction;
    (this.setMode = function (env) {
      RandomGenerator = env;
    }),
      (this.setIndex = function (env) {
        (HelperFunction = env.type), (EnsureFunction = env.bytesPerElement);
      }),
      (this.render = function (env, t) {
        r.drawElements(RandomGenerator, t, HelperFunction, env * EnsureFunction), ObjectMethodWrapper.update(t, RandomGenerator);
      }),
      (this.renderInstances = function (env, t, i) {
        var n;
        if (CounterVariable.isWebGL2) n = r;
        else if (null === (n = a.get("ANGLE_instanced_arrays")))
          return void console.error(
            "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
          );
        n[CounterVariable.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](
          RandomGenerator,
          i,
          HelperFunction,
          t * EnsureFunction,
          env.maxInstancedCount,
        ),
          ObjectMethodWrapper.update(i, RandomGenerator, env.maxInstancedCount);
      });
  }

  function Jd(n) {
    var r = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: r,
      programs: null,
      autoReset: !0,
      reset: function () {
        r.frame++,
          (r.calls = 0),
          (r.triangles = 0),
          (r.points = 0),
          (r.lines = 0);
      },
      update: function (env, t, i) {
        switch (((i = i || 1), r.calls++, t)) {
          case n.TRIANGLES:
            r.triangles += i * (env / 3);
            break;
          case n.TRIANGLE_STRIP:
          case n.TRIANGLE_FAN:
            r.triangles += i * (env - 2);
            break;
          case n.LINES:
            r.lines += i * (env / 2);
            break;
          case n.LINE_STRIP:
            r.lines += i * (env - 1);
            break;
          case n.LINE_LOOP:
            r.lines += i * env;
            break;
          case n.POINTS:
            r.points += i * env;
            break;
          default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", t);
        }
      },
    };
  }

  function Kd(env, t) {
    return Math.abs(t[1]) - Math.abs(env[1]);
  }

  function $MathFloorShortcut(MathFloorShortcut) {
    var f = {},
      ModuleMeta = new Float32Array(8);
    return {
      update: function (env, t, i, n) {
        var r = env.morphTargetInfluences,
          a = r.length,
          ObjectMethodWrapper = f[t.id];
        if (void 0 === ObjectMethodWrapper) {
          ObjectMethodWrapper = [];
          for (var CounterVariable = 0; CounterVariable < a; CounterVariable++) ObjectMethodWrapper[CounterVariable] = [CounterVariable, 0];
          f[t.id] = ObjectMethodWrapper;
        }
        var RandomGenerator = i.morphTargets && t.morphAttributes.position,
          HelperFunction = i.morphNormals && t.morphAttributes.normal;
        for (CounterVariable = 0; CounterVariable < a; CounterVariable++)
          0 !== (EnsureFunction = ObjectMethodWrapper[CounterVariable])[1] &&
            (RandomGenerator && t.removeAttribute("morphTarget" + CounterVariable),
            HelperFunction && t.removeAttribute("morphNormal" + CounterVariable));
        for (CounterVariable = 0; CounterVariable < a; CounterVariable++) ((EnsureFunction = ObjectMethodWrapper[CounterVariable])[0] = CounterVariable), (EnsureFunction[1] = r[CounterVariable]);
        for (ObjectMethodWrapper.sort(Kd), CounterVariable = 0; CounterVariable < 8; CounterVariable++) {
          var EnsureFunction;
          if ((EnsureFunction = ObjectMethodWrapper[CounterVariable])) {
            var GlobalReference = EnsureFunction[0],
              Property = EnsureFunction[1];
            if (Property) {
              RandomGenerator && t.addAttribute("morphTarget" + CounterVariable, RandomGenerator[GlobalReference]),
                HelperFunction && t.addAttribute("morphNormal" + CounterVariable, HelperFunction[GlobalReference]),
                (ModuleMeta[CounterVariable] = Property);
              continue;
            }
          }
          ModuleMeta[CounterVariable] = 0;
        }
        n.getUniforms().setValue(MathFloorShortcut, "morphTargetInfluences", ModuleMeta);
      },
    };
  }

  function ErrorFlag(r, a) {
    var ObjectMethodWrapper = {};
    return {
      update: function (env) {
        var t = a.render.frame,
          i = env.geometry,
          n = r.get(env, i);
        return (
          ObjectMethodWrapper[n.id] !== t &&
            (i.isGeometry && n.updateFromObject(env), r.update(n), (ObjectMethodWrapper[n.id] = t)),
          n
        );
      },
      dispose: function () {
        ObjectMethodWrapper = {};
      },
    };
  }

  function TransactionFormatter(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction) {
    Du.call(
      this,
      (env = void 0 !== env ? env : []),
      (t = void 0 !== t ? t : Qh),
      i,
      n,
      r,
      a,
      ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
    ),
      (this.flipY = !1);
  }

  function NodeFormatter(env, t, i, n) {
    Du.call(this, null),
      (this.image = {
        data: env,
        width: t,
        height: i,
        depth: n,
      }),
      (this.magFilter = ac),
      (this.minFilter = ac),
      (this.generateMipmaps = !1),
      (this.flipY = !1);
  }

  (Dd.prototype = Object.assign(Object.create(Il.prototype), {
    constructor: Dd,
    isMaterial: !0,
    onBeforeCompile: function () {},
    setValues: function (env) {
      if (void 0 !== env)
        for (var t in env) {
          var i = env[t];
          if (void 0 !== i)
            if ("shading" !== t) {
              var n = this[t];
              void 0 !== n
                ? n && n.isColor
                  ? n.set(i)
                  : n && n.isVector3 && i && i.isVector3
                    ? n.copy(i)
                    : (this[t] = "overdraw" === t ? Number(i) : i)
                : console.warn(
                    "THREE." +
                      this.type +
                      ": '" +
                      t +
                      "' is not a property OutputFormatter this material.",
                  );
            } else
              console.warn(
                "THREE." +
                  this.type +
                  ": .shading has been removed. Use the boolean .flatShading instead.",
              ),
                (this.flatShading = 1 === i);
          else
            console.warn("THREE.Material: '" + t + "' parameter is undefined.");
        }
    },
    toJSON: function (env) {
      var t = void 0 === env || "string" == typeof env;
      t && (env = { textures: {}, images: {} });
      var i = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON",
        },
      };

      function n(env) {
        var t = [];
        for (var i in env) {
          var n = env[i];
          delete n.metadata, t.push(n);
        }
        return t;
      }

      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        "" !== this.name && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        void 0 !== this.roughness && (i.roughness = this.roughness),
        void 0 !== this.metalness && (i.metalness = this.metalness),
        this.emissive &&
          this.emissive.isColor &&
          (i.emissive = this.emissive.getHex()),
        1 !== this.emissiveIntensity &&
          (i.emissiveIntensity = this.emissiveIntensity),
        this.specular &&
          this.specular.isColor &&
          (i.specular = this.specular.getHex()),
        void 0 !== this.shininess && (i.shininess = this.shininess),
        void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
        void 0 !== this.clearCoatRoughness &&
          (i.clearCoatRoughness = this.clearCoatRoughness),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(env).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (i.alphaMap = this.alphaMap.toJSON(env).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          (i.lightMap = this.lightMap.toJSON(env).uuid),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((i.aoMap = this.aoMap.toJSON(env).uuid),
          (i.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((i.bumpMap = this.bumpMap.toJSON(env).uuid),
          (i.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((i.normalMap = this.normalMap.toJSON(env).uuid),
          (i.normalMapType = this.normalMapType),
          (i.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((i.displacementMap = this.displacementMap.toJSON(env).uuid),
          (i.displacementScale = this.displacementScale),
          (i.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (i.roughnessMap = this.roughnessMap.toJSON(env).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (i.metalnessMap = this.metalnessMap.toJSON(env).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (i.emissiveMap = this.emissiveMap.toJSON(env).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (i.specularMap = this.specularMap.toJSON(env).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((i.envMap = this.envMap.toJSON(env).uuid),
          (i.reflectivity = this.reflectivity),
          void 0 !== this.combine && (i.combine = this.combine),
          void 0 !== this.envMapIntensity &&
            (i.envMapIntensity = this.envMapIntensity)),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (i.gradientMap = this.gradientMap.toJSON(env).uuid),
        void 0 !== this.size && (i.size = this.size),
        void 0 !== this.sizeAttenuation &&
          (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== ph && (i.blending = this.blending),
        !0 === this.flatShading && (i.flatShading = this.flatShading),
        this.side !== sh && (i.side = this.side),
        this.vertexColors !== ch && (i.vertexColors = this.vertexColors),
        this.opacity < 1 && (i.opacity = this.opacity),
        !0 === this.transparent && (i.transparent = this.transparent),
        (i.depthFunc = this.depthFunc),
        (i.depthTest = this.depthTest),
        (i.depthWrite = this.depthWrite),
        0 !== this.rotation && (i.rotation = this.rotation),
        !0 === this.polygonOffset && (i.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (i.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits &&
          (i.polygonOffsetUnits = this.polygonOffsetUnits),
        1 !== this.linewidth && (i.linewidth = this.linewidth),
        void 0 !== this.dashSize && (i.dashSize = this.dashSize),
        void 0 !== this.gapSize && (i.gapSize = this.gapSize),
        void 0 !== this.scale && (i.scale = this.scale),
        !0 === this.dithering && (i.dithering = !0),
        0 < this.alphaTest && (i.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha &&
          (i.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (i.wireframe = this.wireframe),
        1 < this.wireframeLinewidth &&
          (i.wireframeLinewidth = this.wireframeLinewidth),
        "round" !== this.wireframeLinecap &&
          (i.wireframeLinecap = this.wireframeLinecap),
        "round" !== this.wireframeLinejoin &&
          (i.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.morphTargets && (i.morphTargets = !0),
        !0 === this.skinning && (i.skinning = !0),
        !1 === this.visible && (i.visible = !1),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        t)
      ) {
        var r = n(env.textures),
          a = n(env.images);
        0 < r.length && (i.textures = r), 0 < a.length && (i.images = a);
      }
      return i;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (env) {
      (this.name = env.name),
        (this.fog = env.fog),
        (this.lights = env.lights),
        (this.blending = env.blending),
        (this.side = env.side),
        (this.flatShading = env.flatShading),
        (this.vertexColors = env.vertexColors),
        (this.opacity = env.opacity),
        (this.transparent = env.transparent),
        (this.blendSrc = env.blendSrc),
        (this.blendDst = env.blendDst),
        (this.blendEquation = env.blendEquation),
        (this.blendSrcAlpha = env.blendSrcAlpha),
        (this.blendDstAlpha = env.blendDstAlpha),
        (this.blendEquationAlpha = env.blendEquationAlpha),
        (this.depthFunc = env.depthFunc),
        (this.depthTest = env.depthTest),
        (this.depthWrite = env.depthWrite),
        (this.colorWrite = env.colorWrite),
        (this.precision = env.precision),
        (this.polygonOffset = env.polygonOffset),
        (this.polygonOffsetFactor = env.polygonOffsetFactor),
        (this.polygonOffsetUnits = env.polygonOffsetUnits),
        (this.dithering = env.dithering),
        (this.alphaTest = env.alphaTest),
        (this.premultipliedAlpha = env.premultipliedAlpha),
        (this.overdraw = env.overdraw),
        (this.visible = env.visible),
        (this.userData = JSON.parse(JSON.stringify(env.userData))),
        (this.clipShadows = env.clipShadows),
        (this.clipIntersection = env.clipIntersection);
      var t = env.clippingPlanes,
        i = null;
      if (null !== t) {
        var n = t.length;
        i = new Array(n);
        for (var r = 0; r !== n; ++r) i[r] = t[r].clone();
      }
      return (this.clippingPlanes = i), (this.shadowSide = env.shadowSide), this;
    },
    dispose: function () {
      this.dispatchEvent({ type: "dispose" });
    },
  })),
    (((ZoneDescriptor.prototype = Object.create(Dd.prototype)).constructor =
      ZoneDescriptor).prototype.isShaderMaterial = !0),
    (ZoneDescriptor.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        (this.fragmentShader = env.fragmentShader),
        (this.vertexShader = env.vertexShader),
        (this.uniforms = Ju.clone(env.uniforms)),
        (this.defines = Object.assign({}, env.defines)),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.lights = env.lights),
        (this.clipping = env.clipping),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        (this.extensions = env.extensions),
        this
      );
    }),
    (ZoneDescriptor.prototype.toJSON = function (env) {
      var t = Dd.prototype.toJSON.call(this, env);
      for (var i in ((t.uniforms = {}), this.uniforms)) {
        var n = this.uniforms[i].value;
        n.isTexture
          ? (t.uniforms[i] = { type: "t", value: n.toJSON(env).uuid })
          : n.isColor
            ? (t.uniforms[i] = {
                type: "EnsureFunction",
                value: n.getHex(),
              })
            : n.isVector2
              ? (t.uniforms[i] = {
                  type: "v2",
                  value: n.toArray(),
                })
              : n.isVector3
                ? (t.uniforms[i] = {
                    type: "v3",
                    value: n.toArray(),
                  })
                : n.isVector4
                  ? (t.uniforms[i] = {
                      type: "v4",
                      value: n.toArray(),
                    })
                  : n.isMatrix4
                    ? (t.uniforms[i] = { type: "m4", value: n.toArray() })
                    : (t.uniforms[i] = { value: n });
      }
      return (
        0 < Object.keys(this.defines).length && (t.defines = this.defines),
        (t.vertexShader = this.vertexShader),
        (t.fragmentShader = this.fragmentShader),
        t
      );
    }),
    Object.assign(Bd.prototype, {
      set: function (env, t) {
        return this.origin.copy(env), this.direction.copy(t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return (
          this.origin.copy(env.origin), this.direction.copy(env.direction), this
        );
      },
      at: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Ray: .at() target is now required"),
            (t = new yu())),
          t.copy(this.direction).multiplyScalar(env).add(this.origin)
        );
      },
      lookAt: function (env) {
        return this.direction.copy(env).sub(this.origin).normalize(), this;
      },
      recast:
        ((WindowDrawer = new yu()),
        function (env) {
          return this.origin.copy(this.at(env, WindowDrawer)), this;
        }),
      closestPointToPoint: function (env, t) {
        void 0 === t &&
          (console.warn(
            "THREE.Ray: .closestPointToPoint() target is now required",
          ),
          (t = new yu())),
          t.subVectors(env, this.origin);
        var i = t.dot(this.direction);
        return i < 0
          ? t.copy(this.origin)
          : t.copy(this.direction).multiplyScalar(i).add(this.origin);
      },
      distanceToPoint: function (env) {
        return Math.sqrt(this.distanceSqToPoint(env));
      },
      distanceSqToPoint:
        ((BoundaryDetector = new yu()),
        function (env) {
          var t = BoundaryDetector.subVectors(env, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(env)
            : (BoundaryDetector.copy(this.direction).multiplyScalar(t).add(this.origin),
              BoundaryDetector.distanceToSquared(env));
        }),
      distanceSqToSegment:
        ((YieldData = new yu()),
        (_d = new yu()),
        (XMLData = new yu()),
        function (env, t, i, n) {
          YieldData.copy(env).add(t).multiplyScalar(0.5),
            _d.copy(t).sub(env).normalize(),
            XMLData.copy(this.origin).sub(YieldData);
          var r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator = 0.5 * env.distanceTo(t),
            HelperFunction = -this.direction.dot(_d),
            EnsureFunction = XMLData.dot(this.direction),
            GlobalReference = -XMLData.dot(_d),
            Property = XMLData.lengthSq(),
            MathFloorShortcut = Math.abs(1 - HelperFunction * HelperFunction);
          if (0 < MathFloorShortcut)
            if (((a = HelperFunction * EnsureFunction - GlobalReference), (CounterVariable = RandomGenerator * MathFloorShortcut), 0 <= (r = HelperFunction * GlobalReference - EnsureFunction)))
              if (-CounterVariable <= a)
                if (a <= CounterVariable) {
                  var f = 1 / MathFloorShortcut;
                  ObjectMethodWrapper =
                    (r *= f) * (r + HelperFunction * (a *= f) + 2 * EnsureFunction) +
                    a * (HelperFunction * r + a + 2 * GlobalReference) +
                    Property;
                } else
                  (a = RandomGenerator),
                    (ObjectMethodWrapper =
                      -(r = Math.max(0, -(HelperFunction * a + EnsureFunction))) * r +
                      a * (a + 2 * GlobalReference) +
                      Property);
              else
                (a = -RandomGenerator),
                  (ObjectMethodWrapper =
                    -(r = Math.max(0, -(HelperFunction * a + EnsureFunction))) * r + a * (a + 2 * GlobalReference) + Property);
            else
              ObjectMethodWrapper =
                a <= -CounterVariable
                  ? -(r = Math.max(0, -(-HelperFunction * RandomGenerator + EnsureFunction))) * r +
                    (a = 0 < r ? -RandomGenerator : Math.min(Math.max(-RandomGenerator, -GlobalReference), RandomGenerator)) *
                      (a + 2 * GlobalReference) +
                    Property
                  : a <= CounterVariable
                    ? ((r = 0),
                      (a = Math.min(Math.max(-RandomGenerator, -GlobalReference), RandomGenerator)) * (a + 2 * GlobalReference) + Property)
                    : -(r = Math.max(0, -(HelperFunction * RandomGenerator + EnsureFunction))) * r +
                      (a = 0 < r ? RandomGenerator : Math.min(Math.max(-RandomGenerator, -GlobalReference), RandomGenerator)) *
                        (a + 2 * GlobalReference) +
                      Property;
          else
            (a = 0 < HelperFunction ? -RandomGenerator : RandomGenerator),
              (ObjectMethodWrapper = -(r = Math.max(0, -(HelperFunction * a + EnsureFunction))) * r + a * (a + 2 * GlobalReference) + Property);
          return (
            i && i.copy(this.direction).multiplyScalar(r).add(this.origin),
            n && n.copy(_d).multiplyScalar(a).add(YieldData),
            ObjectMethodWrapper
          );
        }),
      intersectSphere:
        ((ValueDistributor = new yu()),
        function (env, t) {
          ValueDistributor.subVectors(env.center, this.origin);
          var i = ValueDistributor.dot(this.direction),
            n = ValueDistributor.dot(ValueDistributor) - i * i,
            r = env.radius * env.radius;
          if (r < n) return null;
          var a = Math.sqrt(r - n),
            ObjectMethodWrapper = i - a,
            CounterVariable = i + a;
          return ObjectMethodWrapper < 0 && CounterVariable < 0 ? null : ObjectMethodWrapper < 0 ? this.at(CounterVariable, t) : this.at(ObjectMethodWrapper, t);
        }),
      intersectsSphere: function (env) {
        return this.distanceSqToPoint(env.center) <= env.radius * env.radius;
      },
      distanceToPlane: function (env) {
        var t = env.normal.dot(this.direction);
        if (0 === t) return 0 === env.distanceToPoint(this.origin) ? 0 : null;
        var i = -(this.origin.dot(env.normal) + env.constant) / t;
        return 0 <= i ? i : null;
      },
      intersectPlane: function (env, t) {
        var i = this.distanceToPlane(env);
        return null === i ? null : this.at(i, t);
      },
      intersectsPlane: function (env) {
        var t = env.distanceToPoint(this.origin);
        return 0 === t || env.normal.dot(this.direction) * t < 0;
      },
      intersectBox: function (env, t) {
        var i,
          n,
          r,
          a,
          ObjectMethodWrapper,
          CounterVariable,
          RandomGenerator = 1 / this.direction.x,
          HelperFunction = 1 / this.direction.y,
          EnsureFunction = 1 / this.direction.z,
          GlobalReference = this.origin;
        return (
          (n =
            0 <= RandomGenerator
              ? ((i = (env.min.x - GlobalReference.x) * RandomGenerator), (env.max.x - GlobalReference.x) * RandomGenerator)
              : ((i = (env.max.x - GlobalReference.x) * RandomGenerator), (env.min.x - GlobalReference.x) * RandomGenerator)),
          (a =
            0 <= HelperFunction
              ? ((r = (env.min.y - GlobalReference.y) * HelperFunction), (env.max.y - GlobalReference.y) * HelperFunction)
              : ((r = (env.max.y - GlobalReference.y) * HelperFunction), (env.min.y - GlobalReference.y) * HelperFunction)) < i || n < r
            ? null
            : ((i < r || i != i) && (i = r),
              (a < n || n != n) && (n = a),
              (CounterVariable =
                0 <= EnsureFunction
                  ? ((ObjectMethodWrapper = (env.min.z - GlobalReference.z) * EnsureFunction), (env.max.z - GlobalReference.z) * EnsureFunction)
                  : ((ObjectMethodWrapper = (env.max.z - GlobalReference.z) * EnsureFunction), (env.min.z - GlobalReference.z) * EnsureFunction)) < i ||
              n < ObjectMethodWrapper
                ? null
                : ((i < ObjectMethodWrapper || i != i) && (i = ObjectMethodWrapper),
                  (CounterVariable < n || n != n) && (n = CounterVariable),
                  n < 0 ? null : this.at(0 <= i ? i : n, t)))
        );
      },
      intersectsBox:
        ((GraphDrawer = new yu()),
        function (env) {
          return null !== this.intersectBox(env, GraphDrawer);
        }),
      intersectTriangle:
        ((PathDrawer = new yu()),
        (DoubleData = new yu()),
        (FileDescriptor = new yu()),
        (MetaData = new yu()),
        function (env, t, i, n, r) {
          DoubleData.subVectors(t, env), FileDescriptor.subVectors(i, env), MetaData.crossVectors(DoubleData, FileDescriptor);
          var a,
            ObjectMethodWrapper = this.direction.dot(MetaData);
          if (0 < ObjectMethodWrapper) {
            if (n) return null;
            a = 1;
          } else {
            if (!(ObjectMethodWrapper < 0)) return null;
            (a = -1), (ObjectMethodWrapper = -ObjectMethodWrapper);
          }
          PathDrawer.subVectors(this.origin, env);
          var CounterVariable = a * this.direction.dot(FileDescriptor.crossVectors(PathDrawer, FileDescriptor));
          if (CounterVariable < 0) return null;
          var RandomGenerator = a * this.direction.dot(DoubleData.cross(PathDrawer));
          if (RandomGenerator < 0) return null;
          if (ObjectMethodWrapper < CounterVariable + RandomGenerator) return null;
          var HelperFunction = -a * PathDrawer.dot(MetaData);
          return HelperFunction < 0 ? null : this.at(HelperFunction / ObjectMethodWrapper, r);
        }),
      applyMatrix4: function (env) {
        return (
          this.origin.applyMatrix4(env),
          this.direction.transformDirection(env),
          this
        );
      },
      equals: function (env) {
        return (
          env.origin.equals(this.origin) && env.direction.equals(this.direction)
        );
      },
    }),
    Object.assign(Hd, {
      getNormal:
        ((Pd = new yu()),
        function (env, t, i, n) {
          void 0 === n &&
            (console.warn(
              "THREE.Triangle: .getNormal() target is now required",
            ),
            (n = new yu())),
            n.subVectors(i, t),
            Pd.subVectors(env, t),
            n.cross(Pd);
          var r = n.lengthSq();
          return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }),
      getBarycoord:
        ((Ed = new yu()),
        (Ad = new yu()),
        (Md = new yu()),
        function (env, t, i, n, r) {
          Ed.subVectors(n, t), Ad.subVectors(i, t), Md.subVectors(env, t);
          var a = Ed.dot(Ed),
            ObjectMethodWrapper = Ed.dot(Ad),
            CounterVariable = Ed.dot(Md),
            RandomGenerator = Ad.dot(Ad),
            HelperFunction = Ad.dot(Md),
            EnsureFunction = a * RandomGenerator - ObjectMethodWrapper * ObjectMethodWrapper;
          if (
            (void 0 === r &&
              (console.warn(
                "THREE.Triangle: .getBarycoord() target is now required",
              ),
              (r = new yu())),
            0 === EnsureFunction)
          )
            return r.set(-2, -1, -1);
          var GlobalReference = 1 / EnsureFunction,
            Property = (RandomGenerator * CounterVariable - ObjectMethodWrapper * HelperFunction) * GlobalReference,
            MathFloorShortcut = (a * HelperFunction - ObjectMethodWrapper * CounterVariable) * GlobalReference;
          return r.set(1 - Property - MathFloorShortcut, MathFloorShortcut, Property);
        }),
      containsPoint:
        ((Sd = new yu()),
        function (env, t, i, n) {
          return (
            Hd.getBarycoord(env, t, i, n, Sd),
            0 <= Sd.x && 0 <= Sd.y && Sd.x + Sd.y <= 1
          );
        }),
      getUV:
        ((Td = new yu()),
        function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
          return (
            this.getBarycoord(env, t, i, n, Td),
            CounterVariable.set(0, 0),
            CounterVariable.addScaledVector(r, Td.x),
            CounterVariable.addScaledVector(a, Td.y),
            CounterVariable.addScaledVector(ObjectMethodWrapper, Td.z),
            CounterVariable
          );
        }),
    }),
    Object.assign(Hd.prototype, {
      set: function (env, t, i) {
        return this.a.copy(env), this.b.copy(t), this.EnsureFunction.copy(i), this;
      },
      setFromPointsAndIndices: function (env, t, i, n) {
        return this.a.copy(env[t]), this.b.copy(env[i]), this.EnsureFunction.copy(env[n]), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.a.copy(env.a), this.b.copy(env.b), this.EnsureFunction.copy(env.EnsureFunction), this;
      },
      getArea:
        ((Nd = new yu()),
        (KeyDetector = new yu()),
        function () {
          return (
            Nd.subVectors(this.EnsureFunction, this.b),
            KeyDetector.subVectors(this.a, this.b),
            0.5 * Nd.cross(KeyDetector).length()
          );
        }),
      getMidpoint: function (env) {
        return (
          void 0 === env &&
            (console.warn(
              "THREE.Triangle: .getMidpoint() target is now required",
            ),
            (env = new yu())),
          env
            .addVectors(this.a, this.b)
            .add(this.EnsureFunction)
            .multiplyScalar(1 / 3)
        );
      },
      getNormal: function (env) {
        return Hd.getNormal(this.a, this.b, this.EnsureFunction, env);
      },
      getPlane: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Triangle: .getPlane() target is now required"),
            (env = new yu())),
          env.setFromCoplanarPoints(this.a, this.b, this.EnsureFunction)
        );
      },
      getBarycoord: function (env, t) {
        return Hd.getBarycoord(env, this.a, this.b, this.EnsureFunction, t);
      },
      containsPoint: function (env) {
        return Hd.containsPoint(env, this.a, this.b, this.EnsureFunction);
      },
      getUV: function (env, t, i, n, r) {
        return Hd.getUV(env, this.a, this.b, this.EnsureFunction, t, i, n, r);
      },
      intersectsBox: function (env) {
        return env.intersectsTriangle(this);
      },
      closestPointToPoint:
        ((Ld = new yu()),
        (Cd = new yu()),
        (Id = new yu()),
        (Rd = new yu()),
        (Od = new yu()),
        (Fd = new yu()),
        function (env, t) {
          void 0 === t &&
            (console.warn(
              "THREE.Triangle: .closestPointToPoint() target is now required",
            ),
            (t = new yu()));
          var i,
            n,
            r = this.a,
            a = this.b,
            ObjectMethodWrapper = this.EnsureFunction;
          Ld.subVectors(a, r), Cd.subVectors(ObjectMethodWrapper, r), Rd.subVectors(env, r);
          var CounterVariable = Ld.dot(Rd),
            RandomGenerator = Cd.dot(Rd);
          if (CounterVariable <= 0 && RandomGenerator <= 0) return t.copy(r);
          Od.subVectors(env, a);
          var HelperFunction = Ld.dot(Od),
            EnsureFunction = Cd.dot(Od);
          if (0 <= HelperFunction && EnsureFunction <= HelperFunction) return t.copy(a);
          var GlobalReference = CounterVariable * EnsureFunction - HelperFunction * RandomGenerator;
          if (GlobalReference <= 0 && 0 <= CounterVariable && HelperFunction <= 0)
            return (i = CounterVariable / (CounterVariable - HelperFunction)), t.copy(r).addScaledVector(Ld, i);
          Fd.subVectors(env, ObjectMethodWrapper);
          var Property = Ld.dot(Fd),
            MathFloorShortcut = Cd.dot(Fd);
          if (0 <= MathFloorShortcut && Property <= MathFloorShortcut) return t.copy(ObjectMethodWrapper);
          var f = Property * RandomGenerator - CounterVariable * MathFloorShortcut;
          if (f <= 0 && 0 <= RandomGenerator && MathFloorShortcut <= 0)
            return (n = RandomGenerator / (RandomGenerator - MathFloorShortcut)), t.copy(r).addScaledVector(Cd, n);
          var ModuleMeta = HelperFunction * MathFloorShortcut - Property * EnsureFunction;
          if (ModuleMeta <= 0 && 0 <= EnsureFunction - HelperFunction && 0 <= Property - MathFloorShortcut)
            return (
              Id.subVectors(ObjectMethodWrapper, a),
              (n = (EnsureFunction - HelperFunction) / (EnsureFunction - HelperFunction + (Property - MathFloorShortcut))),
              t.copy(a).addScaledVector(Id, n)
            );
          var g = 1 / (ModuleMeta + f + GlobalReference);
          return (
            (i = f * g),
            (n = GlobalReference * g),
            t.copy(r).addScaledVector(Ld, i).addScaledVector(Cd, n)
          );
        }),
      equals: function (env) {
        return env.a.equals(this.a) && env.b.equals(this.b) && env.EnsureFunction.equals(this.EnsureFunction);
      },
    }),
    (((Gd.prototype = Object.create(Dd.prototype)).constructor =
      Gd).prototype.isMeshBasicMaterial = !0),
    (Gd.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        (this.map = env.map),
        (this.lightMap = env.lightMap),
        (this.lightMapIntensity = env.lightMapIntensity),
        (this.aoMap = env.aoMap),
        (this.aoMapIntensity = env.aoMapIntensity),
        (this.specularMap = env.specularMap),
        (this.alphaMap = env.alphaMap),
        (this.envMap = env.envMap),
        (this.combine = env.combine),
        (this.reflectivity = env.reflectivity),
        (this.refractionRatio = env.refractionRatio),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.wireframeLinecap = env.wireframeLinecap),
        (this.wireframeLinejoin = env.wireframeLinejoin),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        this
      );
    }),
    (JobDispatcher.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: JobDispatcher,
      isMesh: !0,
      setDrawMode: function (env) {
        this.drawMode = env;
      },
      copy: function (env) {
        return (
          Pp.prototype.copy.call(this, env),
          (this.drawMode = env.drawMode),
          void 0 !== env.morphTargetInfluences &&
            (this.morphTargetInfluences = env.morphTargetInfluences.slice()),
          void 0 !== env.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign(
              {},
              env.morphTargetDictionary,
            )),
          this
        );
      },
      updateMorphTargets: function () {
        var env,
          t,
          i,
          n = this.geometry;
        if (n.isBufferGeometry) {
          var r = n.morphAttributes,
            a = Object.keys(r);
          if (0 < a.length) {
            var ObjectMethodWrapper = r[a[0]];
            if (void 0 !== ObjectMethodWrapper)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  env = 0,
                  t = ObjectMethodWrapper.length;
                env < t;
                env++
              )
                (i = ObjectMethodWrapper[env].name || String(env)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = env);
          }
        } else {
          var CounterVariable = n.morphTargets;
          if (void 0 !== CounterVariable && 0 < CounterVariable.length)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                env = 0,
                t = CounterVariable.length;
              env < t;
              env++
            )
              (i = CounterVariable[env].name || String(env)),
                this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[i] = env);
        }
      },
      raycast: (function () {
        var z = new gu(),
          B = new Bd(),
          ForEachElement = new Vu(),
          G = new yu(),
          Iterator = new yu(),
          IsIterable = new yu(),
          ObjectKeys = new yu(),
          W = new yu(),
          ToStringTag = new yu(),
          IsArgumentsObject = new mu(),
          Q = new mu(),
          Z = new mu(),
          J = new yu(),
          HelperFunction = new yu();

        function ArrayOrStringObject(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
          if (
            null ===
            (t.side === lh
              ? n.intersectTriangle(ObjectMethodWrapper, a, r, !0, CounterVariable)
              : n.intersectTriangle(r, a, ObjectMethodWrapper, t.side !== hh, CounterVariable))
          )
            return null;
          HelperFunction.copy(CounterVariable), HelperFunction.applyMatrix4(env.matrixWorld);
          var RandomGenerator = i.ray.origin.distanceTo(HelperFunction);
          return RandomGenerator < i.near || RandomGenerator > i.far
            ? null
            : { distance: RandomGenerator, point: HelperFunction.clone(), object: env };
        }

        function $(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
          G.fromBufferAttribute(r, ObjectMethodWrapper),
            Iterator.fromBufferAttribute(r, CounterVariable),
            IsIterable.fromBufferAttribute(r, RandomGenerator);
          var HelperFunction = ArrayOrStringObject(env, t, i, n, G, Iterator, IsIterable, J);
          if (HelperFunction) {
            a &&
              (IsArgumentsObject.fromBufferAttribute(a, ObjectMethodWrapper),
              Q.fromBufferAttribute(a, CounterVariable),
              Z.fromBufferAttribute(a, RandomGenerator),
              (HelperFunction.uv = Hd.getUV(J, G, Iterator, IsIterable, IsArgumentsObject, Q, Z, new mu())));
            var EnsureFunction = new OperationParameter(ObjectMethodWrapper, CounterVariable, RandomGenerator);
            Hd.getNormal(G, Iterator, IsIterable, EnsureFunction.normal), (HelperFunction.face = EnsureFunction);
          }
          return HelperFunction;
        }

        return function (env, t) {
          var i,
            n = this.geometry,
            r = this.material,
            a = this.matrixWorld;
          if (
            void 0 !== r &&
            (null === n.boundingSphere && n.computeBoundingSphere(),
            ForEachElement.copy(n.boundingSphere),
            ForEachElement.applyMatrix4(a),
            !1 !== env.ray.intersectsSphere(ForEachElement) &&
              (z.getInverse(a),
              B.copy(env.ray).applyMatrix4(z),
              null === n.boundingBox || !1 !== B.intersectsBox(n.boundingBox)))
          )
            if (n.isBufferGeometry) {
              var ObjectMethodWrapper,
                CounterVariable,
                RandomGenerator,
                HelperFunction,
                EnsureFunction,
                GlobalReference,
                Property,
                MathFloorShortcut,
                f,
                ModuleMeta = n.index,
                g = n.attributes.position,
                Value = n.attributes.uv,
                y = n.groups,
                _ = n.drawRange;
              if (null !== ModuleMeta)
                if (Array.isArray(r))
                  for (HelperFunction = 0, GlobalReference = y.length; HelperFunction < GlobalReference; HelperFunction++)
                    for (
                      f = r[(MathFloorShortcut = y[HelperFunction]).materialIndex],
                        EnsureFunction = Math.max(MathFloorShortcut.start, _.start),
                        Property = Math.min(MathFloorShortcut.start + MathFloorShortcut.count, _.start + _.count);
                      EnsureFunction < Property;
                      EnsureFunction += 3
                    )
                      (ObjectMethodWrapper = ModuleMeta.getX(EnsureFunction)),
                        (CounterVariable = ModuleMeta.getX(EnsureFunction + 1)),
                        (RandomGenerator = ModuleMeta.getX(EnsureFunction + 2)),
                        (i = $(this, f, env, B, g, Value, ObjectMethodWrapper, CounterVariable, RandomGenerator)) &&
                          ((i.faceIndex = Math.floor(EnsureFunction / 3)), t.push(i));
                else
                  for (
                    HelperFunction = Math.max(0, _.start),
                      GlobalReference = Math.min(ModuleMeta.count, _.start + _.count);
                    HelperFunction < GlobalReference;
                    HelperFunction += 3
                  )
                    (ObjectMethodWrapper = ModuleMeta.getX(HelperFunction)),
                      (CounterVariable = ModuleMeta.getX(HelperFunction + 1)),
                      (RandomGenerator = ModuleMeta.getX(HelperFunction + 2)),
                      (i = $(this, r, env, B, g, Value, ObjectMethodWrapper, CounterVariable, RandomGenerator)) &&
                        ((i.faceIndex = Math.floor(HelperFunction / 3)), t.push(i));
              else if (void 0 !== g)
                if (Array.isArray(r))
                  for (HelperFunction = 0, GlobalReference = y.length; HelperFunction < GlobalReference; HelperFunction++)
                    for (
                      f = r[(MathFloorShortcut = y[HelperFunction]).materialIndex],
                        EnsureFunction = Math.max(MathFloorShortcut.start, _.start),
                        Property = Math.min(MathFloorShortcut.start + MathFloorShortcut.count, _.start + _.count);
                      EnsureFunction < Property;
                      EnsureFunction += 3
                    )
                      (i = $(
                        this,
                        f,
                        env,
                        B,
                        g,
                        Value,
                        (ObjectMethodWrapper = EnsureFunction),
                        (CounterVariable = EnsureFunction + 1),
                        (RandomGenerator = EnsureFunction + 2),
                      )) && ((i.faceIndex = Math.floor(EnsureFunction / 3)), t.push(i));
                else
                  for (
                    HelperFunction = Math.max(0, _.start),
                      GlobalReference = Math.min(g.count, _.start + _.count);
                    HelperFunction < GlobalReference;
                    HelperFunction += 3
                  )
                    (i = $(
                      this,
                      r,
                      env,
                      B,
                      g,
                      Value,
                      (ObjectMethodWrapper = HelperFunction),
                      (CounterVariable = HelperFunction + 1),
                      (RandomGenerator = HelperFunction + 2),
                    )) && ((i.faceIndex = Math.floor(HelperFunction / 3)), t.push(i));
            } else if (n.isGeometry) {
              var x,
                b,
                w,
                T,
                EnsureObject = Array.isArray(r),
                E = n.vertices,
                A = n.faces,
                M = n.faceVertexUvs[0];
              0 < M.length && (T = M);
              for (var P = 0, L = A.length; P < L; P++) {
                var C = A[P],
                  I = EnsureObject ? r[C.materialIndex] : r;
                if (void 0 !== I) {
                  if (
                    ((x = E[C.a]),
                    (b = E[C.b]),
                    (w = E[C.EnsureFunction]),
                    !0 === I.morphTargets)
                  ) {
                    var R = n.morphTargets,
                      O = this.morphTargetInfluences;
                    G.set(0, 0, 0), Iterator.set(0, 0, 0), IsIterable.set(0, 0, 0);
                    for (var FilterArray = 0, FindInArray = R.length; FilterArray < FindInArray; FilterArray++) {
                      var Key = O[FilterArray];
                      if (0 !== Key) {
                        var U = R[FilterArray].vertices;
                        G.addScaledVector(ObjectKeys.subVectors(U[C.a], x), Key),
                          Iterator.addScaledVector(W.subVectors(U[C.b], b), Key),
                          IsIterable.addScaledVector(ToStringTag.subVectors(U[C.EnsureFunction], w), Key);
                      }
                    }
                    G.add(x), Iterator.add(b), IsIterable.add(w), (x = G), (b = Iterator), (w = IsIterable);
                  }
                  if ((i = ArrayOrStringObject(this, I, env, B, x, b, w, J))) {
                    if (T && T[P]) {
                      var D = T[P];
                      IsArgumentsObject.copy(D[0]),
                        Q.copy(D[1]),
                        Z.copy(D[2]),
                        (i.uv = Hd.getUV(J, x, b, w, IsArgumentsObject, Q, Z, new mu()));
                    }
                    (i.face = C), (i.faceIndex = P), t.push(i);
                  }
                }
              }
            }
        };
      })(),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (((TransactionFormatter.prototype = Object.create(Du.prototype)).constructor =
      TransactionFormatter).prototype.isCubeTexture = !0),
    Object.defineProperty(TransactionFormatter.prototype, "images", {
      get: function () {
        return this.image;
      },
      set: function (env) {
        this.image = env;
      },
    }),
    (((NodeFormatter.prototype = Object.create(Du.prototype)).constructor =
      NodeFormatter).prototype.isDataTexture3D = !0);
  var RequestFormatter = new Du(),
    af = new NodeFormatter(),
    OutputFormatter = new TransactionFormatter();

  function StateFormatter() {
    (this.seq = []), (this.map = {});
  }

  var LogFormatter = [],
    HeapFormatte = [],
    ColumnFormatter = new Float32Array(16),
    UpdateFormatter = new Float32Array(9),
    PathFormatter = new Float32Array(4);

  function DeltaFormatter(env, t, i) {
    var n = env[0];
    if (n <= 0 || 0 < n) return env;
    var r = t * i,
      a = LogFormatter[r];
    if ((void 0 === a && ((a = new Float32Array(r)), (LogFormatter[r] = a)), 0 !== t)) {
      n.toArray(a, 0);
      for (var ObjectMethodWrapper = 1, CounterVariable = 0; ObjectMethodWrapper !== t; ++ObjectMethodWrapper) (CounterVariable += i), env[ObjectMethodWrapper].toArray(a, CounterVariable);
    }
    return a;
  }

  function FormattedFunction(env, t) {
    if (env.length !== t.length) return !1;
    for (var i = 0, n = env.length; i < n; i++) if (env[i] !== t[i]) return !1;
    return !0;
  }

  function MapFormatter(env, t) {
    for (var i = 0, n = t.length; i < n; i++) env[i] = t[i];
  }

  function GraphFormatter(env, t) {
    var i = HeapFormatte[t];
    void 0 === i && ((i = new Int32Array(t)), (HeapFormatte[t] = i));
    for (var n = 0; n !== t; ++n) i[n] = env.allocTextureUnit();
    return i;
  }

  function ValueFormatter(env, t) {
    var i = this.cache;
    i[0] !== t && (env.uniform1f(this.addr, t), (i[0] = t));
  }

  function SetUniform1i(env, t) {
    var i = this.cache;
    i[0] !== t && (env.uniform1i(this.addr, t), (i[0] = t));
  }

  function SetUniform2f(env, t) {
    var i = this.cache;
    if (void 0 !== t.x)
      (i[0] === t.x && i[1] === t.y) ||
        (env.uniform2f(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
    else {
      if (FormattedFunction(i, t)) return;
      env.uniform2fv(this.addr, t), MapFormatter(i, t);
    }
  }

  function SetUniform3f(env, t) {
    var i = this.cache;
    if (void 0 !== t.x)
      (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
        (env.uniform3f(this.addr, t.x, t.y, t.z),
        (i[0] = t.x),
        (i[1] = t.y),
        (i[2] = t.z));
    else if (void 0 !== t.r)
      (i[0] === t.r && i[1] === t.g && i[2] === t.b) ||
        (env.uniform3f(this.addr, t.r, t.g, t.b),
        (i[0] = t.r),
        (i[1] = t.g),
        (i[2] = t.b));
    else {
      if (FormattedFunction(i, t)) return;
      env.uniform3fv(this.addr, t), MapFormatter(i, t);
    }
  }

  function SetUniform4f (env, t) {
    var i = this.cache;
    if (void 0 !== t.x)
      (i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w) ||
        (env.uniform4f(this.addr, t.x, t.y, t.z, t.w),
        (i[0] = t.x),
        (i[1] = t.y),
        (i[2] = t.z),
        (i[3] = t.w));
    else {
      if (FormattedFunction(i, t)) return;
      env.uniform4fv(this.addr, t), MapFormatter(i, t);
    }
  }

  function SetMatrix2Uniform(env, t) {
    var i = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (FormattedFunction(i, t)) return;
      env.uniformMatrix2fv(this.addr, !1, t), MapFormatter(i, t);
    } else {
      if (FormattedFunction(i, n)) return;
      PathFormatter.set(n), env.uniformMatrix2fv(this.addr, !1, PathFormatter), MapFormatter(i, n);
    }
  }

  function SetMatrix3Uniform(env, t) {
    var i = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (FormattedFunction(i, t)) return;
      env.uniformMatrix3fv(this.addr, !1, t), MapFormatter(i, t);
    } else {
      if (FormattedFunction(i, n)) return;
      UpdateFormatter.set(n), env.uniformMatrix3fv(this.addr, !1, UpdateFormatter), MapFormatter(i, n);
    }
  }

  function SetMatrix4Uniform(env, t) {
    var i = this.cache,
      n = t.elements;
    if (void 0 === n) {
      if (FormattedFunction(i, t)) return;
      env.uniformMatrix4fv(this.addr, !1, t), MapFormatter(i, t);
    } else {
      if (FormattedFunction(i, n)) return;
      ColumnFormatter.set(n), env.uniformMatrix4fv(this.addr, !1, ColumnFormatter), MapFormatter(i, n);
    }
  }

  function SetTexture2D(env, t, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (env.uniform1i(this.addr, r), (n[0] = r)),
      i.setTexture2D(t || RequestFormatter, r);
  }

  function SetTexture3D(env, t, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (env.uniform1i(this.addr, r), (n[0] = r)),
      i.setTexture3D(t || af, r);
  }

  function SetCubeTexture(env, t, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (env.uniform1i(this.addr, r), (n[0] = r)),
      i.setTextureCube(t || OutputFormatter, r);
  }

  function SetUniform2iv(env, t) {
    var i = this.cache;
    FormattedFunction(i, t) || (env.uniform2iv(this.addr, t), MapFormatter(i, t));
  }

  function SetUniform3iv(env, t) {
    var i = this.cache;
    FormattedFunction(i, t) || (env.uniform3iv(this.addr, t), MapFormatter(i, t));
  }

  function SetUniform4iv(env, t) {
    var i = this.cache;
    FormattedFunction(i, t) || (env.uniform4iv(this.addr, t), MapFormatter(i, t));
  }

  function If(env, t) {
    var i = this.cache;
    FormattedFunction(i, t) || (env.uniform1fv(this.addr, t), MapFormatter(i, t));
  }

  function Rf(env, t) {
    var i = this.cache;
    FormattedFunction(i, t) || (env.uniform1iv(this.addr, t), MapFormatter(i, t));
  }

  function Of(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 2);
    FormattedFunction(i, n) || (env.uniform2fv(this.addr, n), this.updateCache(n));
  }

  function Ff(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 3);
    FormattedFunction(i, n) || (env.uniform3fv(this.addr, n), this.updateCache(n));
  }

  function Nf(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 4);
    FormattedFunction(i, n) || (env.uniform4fv(this.addr, n), this.updateCache(n));
  }

  function KeyFormatter(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 4);
    FormattedFunction(i, n) || (env.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n));
  }

  function Uf(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 9);
    FormattedFunction(i, n) || (env.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n));
  }

  function Df(env, t) {
    var i = this.cache,
      n = DeltaFormatter(t, this.size, 16);
    FormattedFunction(i, n) || (env.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n));
  }

  function zf(env, t, i) {
    var n = this.cache,
      r = t.length,
      a = GraphFormatter(i, r);
    !1 === FormattedFunction(n, a) && (env.uniform1iv(this.addr, a), MapFormatter(n, a));
    for (var ObjectMethodWrapper = 0; ObjectMethodWrapper !== r; ++ObjectMethodWrapper) i.setTexture2D(t[ObjectMethodWrapper] || RequestFormatter, a[ObjectMethodWrapper]);
  }

  function Bf(env, t, i) {
    var n = this.cache,
      r = t.length,
      a = GraphFormatter(i, r);
    !1 === FormattedFunction(n, a) && (env.uniform1iv(this.addr, a), MapFormatter(n, a));
    for (var ObjectMethodWrapper = 0; ObjectMethodWrapper !== r; ++ObjectMethodWrapper) i.setTextureCube(t[ObjectMethodWrapper] || OutputFormatter, a[ObjectMethodWrapper]);
  }

  function Hf(env, t, i) {
    (this.id = env),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = (function (env) {
        switch (env) {
          case 5126:
            return ValueFormatter;
          case 35664:
            return SetUniform2f;
          case 35665:
            return SetUniform3f;
          case 35666:
            return SetUniform4f ;
          case 35674:
            return SetMatrix2Uniform;
          case 35675:
            return SetMatrix3Uniform;
          case 35676:
            return SetMatrix4Uniform;
          case 35678:
          case 36198:
            return SetTexture2D;
          case 35679:
            return SetTexture3D;
          case 35680:
            return SetCubeTexture;
          case 5124:
          case 35670:
            return SetUniform1i;
          case 35667:
          case 35671:
            return SetUniform2iv;
          case 35668:
          case 35672:
            return SetUniform3iv;
          case 35669:
          case 35673:
            return SetUniform4iv;
        }
      })(t.type));
  }

  function Gf(env, t, i) {
    (this.id = env),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = (function (env) {
        switch (env) {
          case 5126:
            return If;
          case 35664:
            return Of;
          case 35665:
            return Ff;
          case 35666:
            return Nf;
          case 35674:
            return KeyFormatter;
          case 35675:
            return Uf;
          case 35676:
            return Df;
          case 35678:
            return zf;
          case 35680:
            return Bf;
          case 5124:
          case 35670:
            return Rf;
          case 35667:
          case 35671:
            return SetUniform2iv;
          case 35668:
          case 35672:
            return SetUniform3iv;
          case 35669:
          case 35673:
            return SetUniform4iv;
        }
      })(t.type));
  }

  function JobFormatter(env) {
    (this.id = env), StateFormatter.call(this);
  }

  (Gf.prototype.updateCache = function (env) {
    var t = this.cache;
    env instanceof Float32Array &&
      t.length !== env.length &&
      (this.cache = new Float32Array(env.length)),
      MapFormatter(t, env);
  }),
    (JobFormatter.prototype.setValue = function (env, t, i) {
      for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
        var ObjectMethodWrapper = n[r];
        ObjectMethodWrapper.setValue(env, t[ObjectMethodWrapper.id], i);
      }
    });
  var Vf = /([\w\d_]+)(\])?(\[|\.)?/g;

  function Xf(env, t) {
    env.seq.push(t), (env.map[t.id] = t);
  }

  function Wf(env, t, i) {
    var n = env.name,
      r = n.length;
    for (Vf.lastIndex = 0; ; ) {
      var a = Vf.exec(n),
        ObjectMethodWrapper = Vf.lastIndex,
        CounterVariable = a[1],
        RandomGenerator = "]" === a[2],
        HelperFunction = a[3];
      if ((RandomGenerator && (CounterVariable |= 0), void 0 === HelperFunction || ("[" === HelperFunction && ObjectMethodWrapper + 2 === r))) {
        Xf(i, void 0 === HelperFunction ? new Hf(CounterVariable, env, t) : new Gf(CounterVariable, env, t));
        break;
      }
      var EnsureFunction = i.map[CounterVariable];
      void 0 === EnsureFunction && Xf(i, (EnsureFunction = new JobFormatter(CounterVariable))), (i = EnsureFunction);
    }
  }

  function Yf(env, t, i) {
    StateFormatter.call(this), (this.renderer = i);
    for (
      var n = env.getProgramParameter(t, env.ACTIVE_UNIFORMS), r = 0;
      r < n;
      ++r
    ) {
      var a = env.getActiveUniform(t, r);
      Wf(a, env.getUniformLocation(t, a.name), this);
    }
  }

  function qf(env, t, i) {
    var n = env.createShader(t);
    return (
      env.shaderSource(n, i),
      env.compileShader(n),
      !1 === env.getShaderParameter(n, env.COMPILE_STATUS) &&
        console.error("THREE.WebGLShader: Shader couldn't compile."),
      "" !== env.getShaderInfoLog(n) &&
        console.warn(
          "THREE.WebGLShader: GlobalReference.getShaderInfoLog()",
          t === env.VERTEX_SHADER ? "vertex" : "fragment",
          env.getShaderInfoLog(n),
          (function (env) {
            for (var t = env.split("\n"), i = 0; i < t.length; i++)
              t[i] = i + 1 + ": " + t[i];
            return t.join("\n");
          })(i),
        ),
      n
    );
  }

  (Yf.prototype.setValue = function (env, t, i) {
    var n = this.map[t];
    void 0 !== n && n.setValue(env, i, this.renderer);
  }),
    (Yf.prototype.setOptional = function (env, t, i) {
      var n = t[i];
      void 0 !== n && this.setValue(env, i, n);
    }),
    (Yf.upload = function (env, t, i, n) {
      for (var r = 0, a = t.length; r !== a; ++r) {
        var ObjectMethodWrapper = t[r],
          CounterVariable = i[ObjectMethodWrapper.id];
        !1 !== CounterVariable.needsUpdate && ObjectMethodWrapper.setValue(env, CounterVariable.value, n);
      }
    }),
    (Yf.seqWithValue = function (env, t) {
      for (var i = [], n = 0, r = env.length; n !== r; ++n) {
        var a = env[n];
        a.id in t && i.push(a);
      }
      return i;
    });
  var Qf = 0;

  function Zf(env) {
    switch (env) {
      case nu:
        return ["Linear", "( value )"];
      case ru:
        return ["sRGB", "( value )"];
      case ou:
        return ["RGBE", "( value )"];
      case su:
        return ["RGBM", "( value, 7.0 )"];
      case lu:
        return ["RGBM", "( value, 16.0 )"];
      case hu:
        return ["RGBD", "( value, 256.0 )"];
      case au:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw new Error("unsupported encoding: " + env);
    }
  }

  function Jf(env, t) {
    var i = Zf(t);
    return (
      "vec4 " +
      env +
      "( vec4 value ) { return " +
      i[0] +
      "ToLinear" +
      i[1] +
      "; }"
    );
  }

  function Kf(env) {
    return "" !== env;
  }

  function $f(env, t) {
    return env
      .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights);
  }

  function em(env, t) {
    return env
      .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
      .replace(
        /UNION_CLIPPING_PLANES/g,
        t.numClippingPlanes - t.numClipIntersection,
      );
  }

  function tm(env) {
    return env.replace(/^[ \t]*#include +<([\w\MathFloorShortcut./]+)>/gm, function (env, t) {
      var i = Zu[t];
      if (void 0 === i) throw new Error("Can not resolve #include <" + t + ">");
      return tm(i);
    });
  }

  function im(env) {
    return env.replace(
      /#pragma unroll_loop[\CounterVariable]+?for \( int i \= (\MathFloorShortcut+)\; i < (\MathFloorShortcut+)\; i \+\+ \) \{([\CounterVariable\EnsureObject]+?)(?=\})\}/g,
      function (env, t, i, n) {
        for (var r = "", a = parseInt(t); a < parseInt(i); a++)
          r += n.replace(/\[ i \]/g, "[ " + a + " ]");
        return r;
      },
    );
  }

  function nm(env, t, i, n, r, a, ObjectMethodWrapper) {
    var CounterVariable = env.context,
      RandomGenerator = n.defines,
      HelperFunction = r.vertexShader,
      EnsureFunction = r.fragmentShader,
      GlobalReference = "SHADOWMAP_TYPE_BASIC";
    a.shadowMapType === ah
      ? (GlobalReference = "SHADOWMAP_TYPE_PCF")
      : a.shadowMapType === oh && (GlobalReference = "SHADOWMAP_TYPE_PCF_SOFT");
    var Property = "ENVMAP_TYPE_CUBE",
      MathFloorShortcut = "ENVMAP_MODE_REFLECTION",
      f = "ENVMAP_BLENDING_MULTIPLY";
    if (a.envMap) {
      switch (n.envMap.mapping) {
        case Qh:
        case Zh:
          Property = "ENVMAP_TYPE_CUBE";
          break;
        case ErrorChecker:
        case TypeChecker:
          Property = "ENVMAP_TYPE_CUBE_UV";
          break;
        case Jh:
        case Kh:
          Property = "ENVMAP_TYPE_EQUIREC";
          break;
        case $HelperFunction:
          Property = "ENVMAP_TYPE_SPHERE";
      }
      switch (n.envMap.mapping) {
        case Zh:
        case Kh:
          MathFloorShortcut = "ENVMAP_MODE_REFRACTION";
      }
      switch (n.combine) {
        case Hh:
          f = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case Gh:
          f = "ENVMAP_BLENDING_MIX";
          break;
        case jh:
          f = "ENVMAP_BLENDING_ADD";
      }
    }
    var ModuleMeta,
      g,
      Value,
      y,
      _,
      x,
      b,
      w,
      T = 0 < env.gammaFactor ? env.gammaFactor : 1,
      EnsureObject = ObjectMethodWrapper.isWebGL2
        ? ""
        : ((ModuleMeta = n.extensions),
          (g = a),
          (Value = t),
          [
            (ModuleMeta = ModuleMeta || {}).derivatives ||
            g.envMapCubeUV ||
            g.bumpMap ||
            (g.normalMap && !g.objectSpaceNormalMap) ||
            g.flatShading
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (ModuleMeta.fragDepth || g.logarithmicDepthBuffer) && Value.get("EXT_frag_depth")
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            ModuleMeta.drawBuffers && Value.get("WEBGL_draw_buffers")
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (ModuleMeta.shaderTextureLOD || g.envMap) && Value.get("EXT_shader_texture_lod")
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(Kf)
            .join("\n")),
      E = (function (env) {
        var t = [];
        for (var i in env) {
          var n = env[i];
          !1 !== n && t.push("#define " + i + " " + n);
        }
        return t.join("\n");
      })(RandomGenerator),
      A = CounterVariable.createProgram();
    if (
      (n.isRawShaderMaterial
        ? (0 < (y = [E].filter(Kf).join("\n")).length && (y += "\n"),
          0 < (_ = [EnsureObject, E].filter(Kf).join("\n")).length && (_ += "\n"))
        : ((y = [
// تنظیم دقت برای متغیرهای Float و Int در شیدرها
"precision " + a.precision + " float;", // دقت متغیرهای float
"precision " + a.precision + " int;", // دقت متغیرهای int

// تعریف نام شیدر
"#define SHADER_NAME " + r.name, // تعریف نام شیدر از طریق مقدار r.name

// فعال‌سازی تنظیمات مختلف شیدر بر اساس ویژگی‌های مواد (Materials)
a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", // پشتیبانی از بافت‌های ورتکس
"#define GAMMA_FACTOR " + T, // مقدار فاکتور گاما
"#define MAX_BONES " + a.maxBones, // تعداد حداکثر استخوان‌ها برای skinning
a.useFog && a.fog ? "#define USE_FOG" : "", // استفاده از مه (Fog)
a.useFog && a.fogExp ? "#define FOG_EXP2" : "", // استفاده از مه نمایی (Exponential Fog)
a.map ? "#define USE_MAP" : "", // استفاده از بافت Map
a.envMap ? "#define USE_ENVMAP" : "", // استفاده از EnvMap
a.lightMap ? "#define USE_LIGHTMAP" : "", // استفاده از LightMap
a.aoMap ? "#define USE_AOMAP" : "", // استفاده از Ambient Occlusion Map
a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", // استفاده از Emissive Map
a.bumpMap ? "#define USE_BUMPMAP" : "", // استفاده از Bump Map
a.normalMap ? "#define USE_NORMALMAP" : "", // استفاده از Normal Map
a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", // Normal Map در فضای شیء
a.specularMap ? "#define USE_SPECULARMAP" : "", // استفاده از Specular Map
a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", // استفاده از Roughness Map
a.metalnessMap ? "#define USE_METALNESSMAP" : "", // استفاده از Metalness Map
a.alphaMap ? "#define USE_ALPHAMAP" : "", // استفاده از Alpha Map
a.vertexColors ? "#define USE_COLOR" : "", // استفاده از رنگ‌های ورتکس
a.flatShading ? "#define FLAT_SHADED" : "", // استفاده از Flat Shading
a.skinning ? "#define USE_SKINNING" : "", // استفاده از Skinning
a.useVertexTexture ? "#define BONE_TEXTURE" : "", // استفاده از Texture برای استخوان‌ها
a.morphTargets ? "#define USE_MORPHTARGETS" : "", // استفاده از Morph Targets
a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", // استفاده از Morph Normals
a.doubleSided ? "#define DOUBLE_SIDED" : "", // استفاده از مواد دوطرفه
a.flipSided ? "#define FLIP_SIDED" : "", // مواد با جهت معکوس
a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", // فعال کردن Shadow Map
a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", // استفاده از Depth Buffer لگاریتمی
            a.logarithmicDepthBuffer && (ObjectMethodWrapper.isWebGL2 || t.get("EXT_frag_depth"))
              ? "#define USE_LOGDEPTHBUF_EXT"
              : "",
// تعریف Uniformها
"uniform mat4 modelMatrix;", // ماتریس مدل
"uniform mat4 modelViewMatrix;", // ماتریس مدل-ویو
"uniform mat4 projectionMatrix;", // ماتریس پروجکشن
"uniform mat4 viewMatrix;", // ماتریس ویو
"uniform mat3 normalMatrix;", // ماتریس نرمال
"uniform vec3 cameraPosition;", // موقعیت دوربین

// تعریف Attributeها
"attribute vec3 position;", // موقعیت ورتکس
"attribute vec3 normal;", // نرمال ورتکس
"attribute vec2 uv;", // مختصات UV

// رنگ‌های ورتکس (در صورت فعال بودن)
"#ifdef USE_COLOR",
"\tattribute vec3 color;", // رنگ ورتکس
"#endif",

// Morph Targets و Normals (در صورت فعال بودن)
"#ifdef USE_MORPHTARGETS",
"\tattribute vec3 morphTarget0;",
"\tattribute vec3 morphTarget1;",
"\tattribute vec3 morphTarget2;",
"\tattribute vec3 morphTarget3;",
"\t#ifdef USE_MORPHNORMALS",
"\t\tattribute vec3 morphNormal0;",
"\t\tattribute vec3 morphNormal1;",
"\t\tattribute vec3 morphNormal2;",
"\t\tattribute vec3 morphNormal3;",
"\t#else",
"\t\tattribute vec3 morphTarget4;",
"\t\tattribute vec3 morphTarget5;",
"\t\tattribute vec3 morphTarget6;",
"\t\tattribute vec3 morphTarget7;",
"\t#endif",
"#endif",

// Skinning (در صورت فعال بودن)
"#ifdef USE_SKINNING",
"\tattribute vec4 skinIndex;", // ایندکس‌های استخوان
"\tattribute vec4 skinWeight;", // وزن‌های استخوان
"#endif",

"\n",
          ]
            .filter(Kf)
            .join("\n")),
          (_ = [
            EnsureObject,
            "precision " + a.precision + " float;",
            "precision " + a.precision + " int;",
            "#define SHADER_NAME " + r.name,
            E,
            a.alphaTest
              ? "#define ALPHATEST " +
                a.alphaTest +
                (a.alphaTest % 1 ? "" : ".0")
              : "",
            "#define GAMMA_FACTOR " + T,
// فعال کردن ویژگی‌های مختلف شیدر بر اساس ویژگی‌های مواد (Materials)
a.useFog && a.fog ? "#define USE_FOG" : "", // فعال کردن مه (Fog)
a.useFog && a.fogExp ? "#define FOG_EXP2" : "", // فعال کردن مه نمایی
a.map ? "#define USE_MAP" : "", // استفاده از بافت Map
a.envMap ? "#define USE_ENVMAP" : "", // استفاده از EnvMap
a.envMap ? "#define " + Property : "", // تعریف ماکرو برای EnvMap
a.envMap ? "#define " + MathFloorShortcut : "", // حالت Mapping برای EnvMap
a.envMap ? "#define " + f : "", // تنظیم اضافی برای EnvMap
a.lightMap ? "#define USE_LIGHTMAP" : "", // استفاده از LightMap
a.aoMap ? "#define USE_AOMAP" : "", // استفاده از Ambient Occlusion Map
a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", // استفاده از Emissive Map
a.bumpMap ? "#define USE_BUMPMAP" : "", // استفاده از Bump Map
a.normalMap ? "#define USE_NORMALMAP" : "", // استفاده از Normal Map
a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", // Normal Map در فضای شیء
a.specularMap ? "#define USE_SPECULARMAP" : "", // استفاده از Specular Map
a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", // استفاده از Roughness Map
a.metalnessMap ? "#define USE_METALNESSMAP" : "", // استفاده از Metalness Map
a.alphaMap ? "#define USE_ALPHAMAP" : "", // استفاده از Alpha Map
a.vertexColors ? "#define USE_COLOR" : "", // استفاده از رنگ‌های ورتکس
a.gradientMap ? "#define USE_GRADIENTMAP" : "", // استفاده از Gradient Map
a.flatShading ? "#define FLAT_SHADED" : "", // استفاده از Flat Shading
a.doubleSided ? "#define DOUBLE_SIDED" : "", // مواد دوطرفه
a.flipSided ? "#define FLIP_SIDED" : "", // مواد با جهت معکوس
a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", // فعال کردن Shadow Map
a.shadowMapEnabled ? "#define " + GlobalReference : "", // تنظیم Shadow Map
a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", // فعال کردن Premultiplied Alpha
a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", // استفاده از نورپردازی فیزیکی
a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", // بافر عمق لگاریتمی
a.logarithmicDepthBuffer && (ObjectMethodWrapper.isWebGL2 || t.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", // پشتیبانی از عمق در WebGL2
a.envMap && (ObjectMethodWrapper.isWebGL2 || t.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", // استفاده از LOD برای بافت

// تعریف Uniformهای عمومی شیدر
"uniform mat4 viewMatrix;", // ماتریس دید
"uniform vec3 cameraPosition;", // موقعیت دوربین

// فعال کردن Tone Mapping
a.toneMapping !== Vh ? "#define TONE_MAPPING" : "",
a.toneMapping !== Vh ? Zu.tonemapping_pars_fragment : "",
// پیاده‌سازی انواع مختلف Tone Mapping
a.toneMapping !== Vh
  ? (function (env, t) {
      var i;
      switch (t) {
        case Xh:
          i = "Linear"; // Tone Mapping خطی
          break;
        case Wh:
          i = "Reinhard"; // Tone Mapping مدل Reinhard
          break;
        case Yh:
          i = "Uncharted2"; // Tone Mapping مدل Uncharted2
          break;
        case qh:
          i = "OptimizedCineon"; // Tone Mapping مدل Optimized Cineon
          break;
        default:
          throw new Error("unsupported toneMapping: " + t); // خطا در صورت Tone Mapping نامعتبر
      }
      return (
        "vec3 " +
        env +
        "( vec3 color ) { return " +
        i +
        "ToneMapping( color ); }"
      );
    })("toneMapping", a.toneMapping)
  : "",

            a.dithering ? "#define DITHERING" : "",
            a.outputEncoding ||
            a.mapEncoding ||
            a.matcapEncoding ||
            a.envMapEncoding ||
            a.emissiveMapEncoding
              ? Zu.encodings_pars_fragment
              : "",
            a.mapEncoding ? Jf("mapTexelToLinear", a.mapEncoding) : "",
            a.matcapEncoding ? Jf("matcapTexelToLinear", a.matcapEncoding) : "",
            a.envMapEncoding ? Jf("envMapTexelToLinear", a.envMapEncoding) : "",
            a.emissiveMapEncoding
              ? Jf("emissiveMapTexelToLinear", a.emissiveMapEncoding)
              : "",
            a.outputEncoding
              ? ((x = "linearToOutputTexel"),
                (b = a.outputEncoding),
                (w = Zf(b)),
                "vec4 " +
                  x +
                  "( vec4 value ) { return LinearTo" +
                  w[0] +
                  w[1] +
                  "; }")
              : "",
            a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "",
            "\n",
          ]
            .filter(Kf)
            .join("\n"))),
      (HelperFunction = em((HelperFunction = $f((HelperFunction = tm(HelperFunction)), a)), a)),
      (EnsureFunction = em((EnsureFunction = $f((EnsureFunction = tm(EnsureFunction)), a)), a)),
      (HelperFunction = im(HelperFunction)),
      (EnsureFunction = im(EnsureFunction)),
      ObjectMethodWrapper.isWebGL2 && !n.isRawShaderMaterial)
    ) {
      var M = !1,
        P = /^\CounterVariable*#version\CounterVariable+300\CounterVariable+es\CounterVariable*\n/;
      n.isShaderMaterial &&
        null !== HelperFunction.match(P) &&
        null !== EnsureFunction.match(P) &&
        ((M = !0), (HelperFunction = HelperFunction.replace(P, "")), (EnsureFunction = EnsureFunction.replace(P, ""))),
        (y =
          [
  "#version 300 es\n", // تعیین نسخه GLSL 300 ES
  "#define attribute in", // تبدیل کلیدواژه `attribute` به `in` (برای مشخص کردن ورودی‌ها)
  "#define varying out", // تبدیل کلیدواژه `varying` به `out` (برای انتقال داده بین ورتکس و فرگمنت شیدر)
  "#define texture2D texture", // تبدیل تابع قدیمی `texture2D` به تابع استاندارد `texture`
].join("\n") + // اتصال خطوط به یکدیگر
          "\n" +
          y),
        (_ =
          [
  "#version 300 es\n", // تعیین نسخه GLSL 300 ES
  "#define varying in", // تبدیل کلیدواژه `varying` به `in` (برای دریافت داده از ورتکس شیدر)
  M ? "" : "out highp vec4 pc_fragColor;", // تعریف متغیر خروجی رنگ (pc_fragColor) در صورتی که `M` فعال نباشد
  M ? "" : "#define gl_FragColor pc_fragColor", // تبدیل `gl_FragColor` به `pc_fragColor` در صورت نیاز
  "#define gl_FragDepthEXT gl_FragDepth", // استفاده از عمق فرگمنت با تعریف جدید
  "#define texture2D texture", // تبدیل `texture2D` به `texture`
  "#define textureCube texture", // تبدیل `textureCube` به `texture`
  "#define texture2DProj textureProj", // تبدیل `texture2DProj` به `textureProj`
  "#define texture2DLodEXT textureLod", // تبدیل `texture2DLodEXT` به `textureLod` (برای استفاده از سطح جزئیات)
  "#define texture2DProjLodEXT textureProjLod", // تبدیل `texture2DProjLodEXT` به `textureProjLod`
  "#define textureCubeLodEXT textureLod", // تبدیل `textureCubeLodEXT` به `textureLod`
  "#define texture2DGradEXT textureGrad", // تبدیل `texture2DGradEXT` به `textureGrad` (برای گرادیان‌ها)
  "#define texture2DProjGradEXT textureProjGrad", // تبدیل `texture2DProjGradEXT` به `textureProjGrad`
  "#define textureCubeGradEXT textureGrad", // تبدیل `textureCubeGradEXT` به `textureGrad`
          ].join("\n") +
          "\n" +
          _);
    }
    var L = y + HelperFunction,
      C = _ + EnsureFunction,
      I = qf(CounterVariable, CounterVariable.VERTEX_SHADER, L),
      R = qf(CounterVariable, CounterVariable.FRAGMENT_SHADER, C);
    CounterVariable.attachShader(A, I),
      CounterVariable.attachShader(A, R),
      void 0 !== n.index0AttributeName
        ? CounterVariable.bindAttribLocation(A, 0, n.index0AttributeName)
        : !0 === a.morphTargets && CounterVariable.bindAttribLocation(A, 0, "position"),
      CounterVariable.linkProgram(A);
    var O,
      FilterArray,
      FindInArray = CounterVariable.getProgramInfoLog(A).trim(),
      Key = CounterVariable.getShaderInfoLog(I).trim(),
      U = CounterVariable.getShaderInfoLog(R).trim(),
      D = !0,
      z = !0;
    return (
      !1 === CounterVariable.getProgramParameter(A, CounterVariable.LINK_STATUS)
        ? ((D = !1),
          console.error(
            "THREE.WebGLProgram: shader error: ",
            CounterVariable.getError(),
            "GlobalReference.VALIDATE_STATUS",
            CounterVariable.getProgramParameter(A, CounterVariable.VALIDATE_STATUS),
            "GlobalReference.getProgramInfoLog",
            FindInArray,
            Key,
            U,
          ))
        : "" !== FindInArray
          ? console.warn("THREE.WebGLProgram: GlobalReference.getProgramInfoLog()", FindInArray)
          : ("" !== Key && "" !== U) || (z = !1),
      z &&
        (this.diagnostics = {
          runnable: D,
          material: n,
          programLog: FindInArray,
          vertexShader: { log: Key, prefix: y },
          fragmentShader: { log: U, prefix: _ },
        }),
      CounterVariable.deleteShader(I),
      CounterVariable.deleteShader(R),
      (this.getUniforms = function () {
        return void 0 === O && (O = new Yf(CounterVariable, A, env)), O;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === FilterArray &&
            (FilterArray = (function (env, t) {
              for (
                var i = {},
                  n = env.getProgramParameter(t, env.ACTIVE_ATTRIBUTES),
                  r = 0;
                r < n;
                r++
              ) {
                var a = env.getActiveAttrib(t, r).name;
                i[a] = env.getAttribLocation(t, a);
              }
              return i;
            })(CounterVariable, A)),
          FilterArray
        );
      }),
      (this.destroy = function () {
        CounterVariable.deleteProgram(A), (this.program = void 0);
      }),
      Object.defineProperties(this, {
        uniforms: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLProgram: .uniforms is now .getUniforms().",
              ),
              this.getUniforms()
            );
          },
        },
        attributes: {
          get: function () {
            return (
              console.warn(
                "THREE.WebGLProgram: .attributes is now .getAttributes().",
              ),
              this.getAttributes()
            );
          },
        },
      }),
      (this.name = r.name),
      (this.id = Qf++),
      (this.code = i),
      (this.usedTimes = 1),
      (this.program = A),
      (this.vertexShader = I),
      (this.fragmentShader = R),
      this
    );
  }

  function rm(GlobalReference, RandomGenerator, Property) {
    var HelperFunction = [],
      MathFloorShortcut = {
        // تعریف نام شیدرها برای مواد مختلف Mesh
MeshDepthMaterial: "depth", // شیدر برای مواد عمق
MeshDistanceMaterial: "distanceRGBA", // شیدر برای فاصله
MeshNormalMaterial: "normal", // شیدر برای مواد نرمال
MeshBasicMaterial: "basic", // شیدر برای مواد پایه
MeshLambertMaterial: "lambert", // شیدر برای مدل نورپردازی لمبرت
MeshPhongMaterial: "phong", // شیدر برای مدل نورپردازی فونگ
MeshToonMaterial: "phong", // شیدر برای مواد Toon (فونگ)
MeshStandardMaterial: "physical", // شیدر استاندارد برای مواد فیزیکی
MeshPhysicalMaterial: "physical", // شیدر فیزیکی برای مواد فیزیکی پیشرفته
MeshMatcapMaterial: "matcap", // شیدر برای مواد Matcap
LineBasicMaterial: "basic", // شیدر برای خطوط پایه
LineDashedMaterial: "dashed", // شیدر برای خطوط خط‌چین
PointsMaterial: "points", // شیدر برای مواد نقاط
ShadowMaterial: "shadow", // شیدر برای مواد سایه
SpriteMaterial: "sprite", // شیدر برای مواد اسپریت

      },
      a = [
  "precision", // دقت برای محاسبات شیدر
  "supportsVertexTextures", // پشتیبانی از بافت‌های ورتکس
  "map", // استفاده از Map
  "mapEncoding", // رمزگذاری Map
  "matcapEncoding", // رمزگذاری Matcap
  "envMap", // استفاده از EnvMap
  "envMapMode", // حالت EnvMap
  "envMapEncoding", // رمزگذاری EnvMap
  "lightMap", // استفاده از LightMap
  "aoMap", // استفاده از Ambient Occlusion Map
  "emissiveMap", // استفاده از Emissive Map
  "emissiveMapEncoding", // رمزگذاری Emissive Map
  "bumpMap", // استفاده از Bump Map
  "normalMap", // استفاده از Normal Map
  "objectSpaceNormalMap", // استفاده از Normal Map در فضای شیء
  "displacementMap", // استفاده از Displacement Map
  "specularMap", // استفاده از Specular Map
  "roughnessMap", // استفاده از Roughness Map
  "metalnessMap", // استفاده از Metalness Map
  "gradientMap", // استفاده از Gradient Map
  "alphaMap", // استفاده از Alpha Map
  "combine", // نحوه ترکیب مواد
  "vertexColors", // استفاده از رنگ‌های ورتکس
  "fog", // استفاده از مه
  "useFog", // بررسی استفاده از مه
  "fogExp", // استفاده از مه نمایی
  "flatShading", // استفاده از Flat Shading
  "sizeAttenuation", // کاهش اندازه بر اساس فاصله
  "logarithmicDepthBuffer", // استفاده از بافر عمق لگاریتمی
  "skinning", // استفاده از Skinning
  "maxBones", // تعداد حداکثر استخوان‌ها
  "useVertexTexture", // استفاده از Texture برای ورتکس
  "morphTargets", // استفاده از Morph Targets
  "morphNormals", // استفاده از Morph Normals
  "maxMorphTargets", // تعداد حداکثر Morph Targets
  "maxMorphNormals", // تعداد حداکثر Morph Normals
  "premultipliedAlpha", // استفاده از Premultiplied Alpha
  "numDirLights", // تعداد نورهای جهت‌دار
  "numPointLights", // تعداد نورهای نقطه‌ای
  "numSpotLights", // تعداد نورهای نقطه‌ای متمرکز
  "numHemiLights", // تعداد نورهای نیم‌کره‌ای
  "numRectAreaLights", // تعداد نورهای مستطیلی
  "shadowMapEnabled", // فعال بودن Shadow Map
  "shadowMapType", // نوع Shadow Map
  "toneMapping", // استفاده از Tone Mapping
  "physicallyCorrectLights", // نورپردازی فیزیکی
  "alphaTest", // مقدار تست آلفا
  "doubleSided", // استفاده از مواد دوطرفه
  "flipSided", // مواد با جهت معکوس
  "numClippingPlanes", // تعداد صفحات برش
  "numClipIntersection", // تعداد تداخل صفحات برش
  "depthPacking", // استفاده از Depth Packing
  "dithering", // فعال کردن Dithering
      ];

    function f(env, t) {
      var i;
      return (
        env
          ? env.isTexture
            ? (i = env.encoding)
            : env.isWebGLRenderTarget &&
              (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.",
              ),
              (i = env.texture.encoding))
          : (i = nu),
        i === nu && t && (i = au),
        i
      );
    }

    (this.getParameters = function (env, t, i, n, r, a, ObjectMethodWrapper) {
      var CounterVariable = MathFloorShortcut[env.type],
        RandomGenerator = ObjectMethodWrapper.isSkinnedMesh
          ? (function (env) {
              var t = env.skeleton.bones;
              if (Property.floatVertexTextures) return 1024;
              var i = Property.maxVertexUniforms,
                n = Math.floor((i - 20) / 4),
                r = Math.min(n, t.length);
              return r < t.length
                ? (console.warn(
                    "THREE.WebGLRenderer: Skeleton has " +
                      t.length +
                      " bones. This GPU supports " +
                      r +
                      ".",
                  ),
                  0)
                : r;
            })(ObjectMethodWrapper)
          : 0,
        HelperFunction = Property.precision;
      null !== env.precision &&
        (HelperFunction = Property.getMaxPrecision(env.precision)) !== env.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          env.precision,
          "not supported, using",
          HelperFunction,
          "instead.",
        );
      var EnsureFunction = GlobalReference.getRenderTarget();
      return {
        // تنظیمات مرتبط با شیدر و ویژگی‌های متریال
shaderID: CounterVariable, // شناسه شیدر که از متغیر CounterVariable تنظیم می‌شود.
precision: HelperFunction, // سطح دقت برای شیدرها (مانند lowp, mediump, highp).
supportsVertexTextures: Property.vertexTextures, // آیا بافت‌های ورتکس پشتیبانی می‌شوند یا خیر.
outputEncoding: f(EnsureFunction ? EnsureFunction.texture : null, GlobalReference.gammaOutput), // رمزگذاری خروجی، معمولاً برای کنترل گاما.
map: !!env.map, // بررسی اینکه آیا متریال دارای map است.
mapEncoding: f(env.map, GlobalReference.gammaInput), // تنظیم رمزگذاری map.
matcap: !!env.matcap, // بررسی اینکه آیا متریال دارای matcap است.
matcapEncoding: f(env.matcap, GlobalReference.gammaInput), // رمزگذاری matcap.
envMap: !!env.envMap, // بررسی اینکه آیا متریال دارای envMap است.
envMapMode: env.envMap && env.envMap.mapping, // تنظیم حالت mapping برای envMap.
envMapEncoding: f(env.envMap, GlobalReference.gammaInput), // رمزگذاری envMap.
envMapCubeUV: !!env.envMap && (env.envMap.mapping === ErrorChecker || env.envMap.mapping === TypeChecker), // بررسی حالت cube UV برای envMap.

lightMap: !!env.lightMap, // بررسی اینکه آیا lightMap تنظیم شده است.
aoMap: !!env.aoMap, // بررسی اینکه آیا aoMap تنظیم شده است.
emissiveMap: !!env.emissiveMap, // بررسی اینکه آیا emissiveMap تنظیم شده است.
emissiveMapEncoding: f(env.emissiveMap, GlobalReference.gammaInput), // رمزگذاری emissiveMap.

bumpMap: !!env.bumpMap, // بررسی اینکه آیا bumpMap تنظیم شده است.
normalMap: !!env.normalMap, // بررسی اینکه آیا normalMap تنظیم شده است.
objectSpaceNormalMap: env.normalMapType === du, // استفاده از normalMap در فضای شیء.
displacementMap: !!env.displacementMap, // بررسی اینکه آیا displacementMap تنظیم شده است.
roughnessMap: !!env.roughnessMap, // بررسی اینکه آیا roughnessMap تنظیم شده است.
metalnessMap: !!env.metalnessMap, // بررسی اینکه آیا metalnessMap تنظیم شده است.
specularMap: !!env.specularMap, // بررسی اینکه آیا specularMap تنظیم شده است.
alphaMap: !!env.alphaMap, // بررسی اینکه آیا alphaMap تنظیم شده است.
gradientMap: !!env.gradientMap, // بررسی اینکه آیا gradientMap تنظیم شده است.

combine: env.combine, // نحوه ترکیب متریال‌ها.
vertexColors: env.vertexColors, // آیا از رنگ‌های ورتکس استفاده می‌شود یا خیر.
fog: !!n, // بررسی اینکه آیا مه (fog) تنظیم شده است.
useFog: env.fog, // استفاده از مه بر اساس تنظیمات متریال.
fogExp: n && n.isFogExp2, // بررسی استفاده از مه نمایی (Exponential Fog).

flatShading: env.flatShading, // استفاده از flat shading.
sizeAttenuation: env.sizeAttenuation, // کاهش اندازه بر اساس فاصله دوربین.
logarithmicDepthBuffer: Property.logarithmicDepthBuffer, // استفاده از بافر عمق لگاریتمی.

skinning: env.skinning && 0 < RandomGenerator, // بررسی اینکه آیا از skinning استفاده می‌شود.
maxBones: RandomGenerator, // تعداد حداکثر استخوان‌ها برای skinning.
useVertexTexture: Property.floatVertexTextures, // استفاده از texture برای ورتکس‌ها.

morphTargets: env.morphTargets, // بررسی اینکه آیا از morph targets استفاده می‌شود.
morphNormals: env.morphNormals, // بررسی اینکه آیا از morph normals استفاده می‌شود.
maxMorphTargets: GlobalReference.maxMorphTargets, // تعداد حداکثر morph targets.
maxMorphNormals: GlobalReference.maxMorphNormals, // تعداد حداکثر morph normals.

numDirLights: t.directional.length, // تعداد نورهای جهت‌دار.
numPointLights: t.point.length, // تعداد نورهای نقطه‌ای.
numSpotLights: t.spot.length, // تعداد نورهای نقطه‌ای متمرکز (spotlights).
numRectAreaLights: t.rectArea.length, // تعداد نورهای مستطیلی.
numHemiLights: t.hemi.length, // تعداد نورهای نیم‌کره‌ای.

numClippingPlanes: r, // تعداد صفحات برش.
numClipIntersection: a, // تعداد تداخل‌های برش.

dithering: env.dithering, // استفاده از dithering برای متریال.
shadowMapEnabled: GlobalReference.shadowMap.enabled && ObjectMethodWrapper.receiveShadow && 0 < i.length, // بررسی فعال بودن shadow map.
shadowMapType: GlobalReference.shadowMap.type, // نوع shadow map.

toneMapping: GlobalReference.toneMapping, // استفاده از تنظیمات tone mapping.
physicallyCorrectLights: GlobalReference.physicallyCorrectLights, // بررسی استفاده از نورهای فیزیکی.
premultipliedAlpha: env.premultipliedAlpha, // استفاده از alpha premultiplication.
alphaTest: env.alphaTest, // مقدار تست آلفا.

doubleSided: env.side === hh, // بررسی اینکه آیا متریال دوطرفه است.
flipSided: env.side === lh, // بررسی اینکه آیا متریال flip sided است.
depthPacking: void 0 !== env.depthPacking && env.depthPacking, // تنظیم depth packing برای متریال.

      };
    }),
      (this.getProgramCode = function (env, t) {
        var i = [];
        if (
          (t.shaderID
            ? i.push(t.shaderID)
            : (i.push(env.fragmentShader), i.push(env.vertexShader)),
          void 0 !== env.defines)
        )
          for (var n in env.defines) i.push(n), i.push(env.defines[n]);
        for (var r = 0; r < a.length; r++) i.push(t[a[r]]);
        return (
          i.push(env.onBeforeCompile.toString()), i.push(GlobalReference.gammaOutput), i.join()
        );
      }),
      (this.acquireProgram = function (env, t, i, n) {
        for (var r, a = 0, ObjectMethodWrapper = HelperFunction.length; a < ObjectMethodWrapper; a++) {
          var CounterVariable = HelperFunction[a];
          if (CounterVariable.code === n) {
            ++(r = CounterVariable).usedTimes;
            break;
          }
        }
        return (
          void 0 === r && ((r = new nm(GlobalReference, RandomGenerator, n, env, t, i, Property)), HelperFunction.push(r)), r
        );
      }),
      (this.releaseProgram = function (env) {
        if (0 == --env.usedTimes) {
          var t = HelperFunction.indexOf(env);
          (HelperFunction[t] = HelperFunction[HelperFunction.length - 1]), HelperFunction.pop(), env.destroy();
        }
      }),
      (this.programs = HelperFunction);
  }

  function am() {
    var n = new WeakMap();
    return {
      get: function (env) {
        var t = n.get(env);
        return void 0 === t && ((t = {}), n.set(env, t)), t;
      },
      remove: function (env) {
        n.delete(env);
      },
      update: function (env, t, i) {
        n.get(env)[t] = i;
      },
      dispose: function () {
        n = new WeakMap();
      },
    };
  }

  function om(env, t) {
    return env.renderOrder !== t.renderOrder
      ? env.renderOrder - t.renderOrder
      : env.program && t.program && env.program !== t.program
        ? env.program.id - t.program.id
        : env.material.id !== t.material.id
          ? env.material.id - t.material.id
          : env.z !== t.z
            ? env.z - t.z
            : env.id - t.id;
  }

  function sm(env, t) {
    return env.renderOrder !== t.renderOrder
      ? env.renderOrder - t.renderOrder
      : env.z !== t.z
        ? t.z - env.z
        : env.id - t.id;
  }

  function lm() {
    var ObjectMethodWrapper = [],
      CounterVariable = 0,
      RandomGenerator = [],
      HelperFunction = [];
    return {
      opaque: RandomGenerator,
      transparent: HelperFunction,
      init: function () {
        (CounterVariable = 0), (RandomGenerator.length = 0), (HelperFunction.length = 0);
      },
      push: function (env, t, i, n, r) {
        var a = ObjectMethodWrapper[CounterVariable];
        void 0 === a
          ? ((a = {
              id: env.id,
              object: env,
              geometry: t,
              material: i,
              program: i.program,
              renderOrder: env.renderOrder,
              z: n,
              group: r,
            }),
            (ObjectMethodWrapper[CounterVariable] = a))
          : ((a.id = env.id),
            (a.object = env),
            (a.geometry = t),
            (a.material = i),
            (a.program = i.program),
            (a.renderOrder = env.renderOrder),
            (a.z = n),
            (a.group = r)),
          (!0 === i.transparent ? HelperFunction : RandomGenerator).push(a),
          CounterVariable++;
      },
      sort: function () {
        1 < RandomGenerator.length && RandomGenerator.sort(om), 1 < HelperFunction.length && HelperFunction.sort(sm);
      },
    };
  }

  function hm() {
    var r = {};
    return {
      get: function (env, t) {
        var i = env.id + "," + t.id,
          n = r[i];
        return void 0 === n && ((n = new lm()), (r[i] = n)), n;
      },
      dispose: function () {
        r = {};
      },
    };
  }

  function cm() {
    var i = {};
    return {
      get: function (env) {
        if (void 0 !== i[env.id]) return i[env.id];
        var t;
        switch (env.type) {
          case "DirectionalLight":
            t = {
              direction: new yu(),
              color: new $GlobalReference(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new mu(),
            };
            break;
          case "SpotLight":
            t = {
              position: new yu(),
              direction: new yu(),
              color: new $GlobalReference(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new mu(),
            };
            break;
          case "PointLight":
            t = {
              position: new yu(),
              color: new $GlobalReference(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new mu(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3,
            };
            break;
          case "HemisphereLight":
            t = {
              direction: new yu(),
              skyColor: new $GlobalReference(),
              groundColor: new $GlobalReference(),
            };
            break;
          case "RectAreaLight":
            t = {
              color: new $GlobalReference(),
              position: new yu(),
              halfWidth: new yu(),
              halfHeight: new yu(),
            };
        }
        return (i[env.id] = t);
      },
    };
  }

  var um,
    pm,
    dm,
    fm,
    mm,
    gm,
    vm,
    ym,
    _m,
    xm,
    bm,
    wm,
    Tm,
    Sm,
    Em,
    Am,
    Mm = 0;

  function Pm() {
    var b = new cm(),
      w = {
        id: Mm++,
        hash: {
          stateID: -1,
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          shadowsLength: -1,
        },
        ambient: [0, 0, 0],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
      },
      T = new yu(),
      EnsureObject = new gu(),
      E = new gu();
    return {
      setup: function (env, t, i) {
        for (
          var n = 0,
            r = 0,
            a = 0,
            ObjectMethodWrapper = 0,
            CounterVariable = 0,
            RandomGenerator = 0,
            HelperFunction = 0,
            EnsureFunction = 0,
            GlobalReference = i.matrixWorldInverse,
            Property = 0,
            MathFloorShortcut = env.length;
          Property < MathFloorShortcut;
          Property++
        ) {
          var f = env[Property],
            ModuleMeta = f.color,
            g = f.intensity,
            Value = f.distance,
            y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
          if (f.isAmbientLight) (n += ModuleMeta.r * g), (r += ModuleMeta.g * g), (a += ModuleMeta.b * g);
          else if (f.isDirectionalLight) {
            if (
              ((x = b.get(f)).color.copy(f.color).multiplyScalar(f.intensity),
              x.direction.setFromMatrixPosition(f.matrixWorld),
              T.setFromMatrixPosition(f.target.matrixWorld),
              x.direction.sub(T),
              x.direction.transformDirection(GlobalReference),
              (x.shadow = f.castShadow),
              f.castShadow)
            ) {
              var _ = f.shadow;
              (x.shadowBias = _.bias),
                (x.shadowRadius = _.radius),
                (x.shadowMapSize = _.mapSize);
            }
            (w.directionalShadowMap[ObjectMethodWrapper] = y),
              (w.directionalShadowMatrix[ObjectMethodWrapper] = f.shadow.matrix),
              (w.directional[ObjectMethodWrapper] = x),
              ObjectMethodWrapper++;
          } else if (f.isSpotLight)
            (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld),
              x.position.applyMatrix4(GlobalReference),
              x.color.copy(ModuleMeta).multiplyScalar(g),
              (x.distance = Value),
              x.direction.setFromMatrixPosition(f.matrixWorld),
              T.setFromMatrixPosition(f.target.matrixWorld),
              x.direction.sub(T),
              x.direction.transformDirection(GlobalReference),
              (x.coneCos = Math.cos(f.angle)),
              (x.penumbraCos = Math.cos(f.angle * (1 - f.penumbra))),
              (x.decay = f.decay),
              (x.shadow = f.castShadow),
              f.castShadow &&
                ((_ = f.shadow),
                (x.shadowBias = _.bias),
                (x.shadowRadius = _.radius),
                (x.shadowMapSize = _.mapSize)),
              (w.spotShadowMap[RandomGenerator] = y),
              (w.spotShadowMatrix[RandomGenerator] = f.shadow.matrix),
              (w.spot[RandomGenerator] = x),
              RandomGenerator++;
          else if (f.isRectAreaLight)
            (x = b.get(f)).color.copy(ModuleMeta).multiplyScalar(g),
              x.position.setFromMatrixPosition(f.matrixWorld),
              x.position.applyMatrix4(GlobalReference),
              E.identity(),
              EnsureObject.copy(f.matrixWorld),
              EnsureObject.premultiply(GlobalReference),
              E.extractRotation(EnsureObject),
              x.halfWidth.set(0.5 * f.width, 0, 0),
              x.halfHeight.set(0, 0.5 * f.height, 0),
              x.halfWidth.applyMatrix4(E),
              x.halfHeight.applyMatrix4(E),
              (w.rectArea[HelperFunction] = x),
              HelperFunction++;
          else if (f.isPointLight)
            (x = b.get(f)).position.setFromMatrixPosition(f.matrixWorld),
              x.position.applyMatrix4(GlobalReference),
              x.color.copy(f.color).multiplyScalar(f.intensity),
              (x.distance = f.distance),
              (x.decay = f.decay),
              (x.shadow = f.castShadow),
              f.castShadow &&
                ((_ = f.shadow),
                (x.shadowBias = _.bias),
                (x.shadowRadius = _.radius),
                (x.shadowMapSize = _.mapSize),
                (x.shadowCameraNear = _.camera.near),
                (x.shadowCameraFar = _.camera.far)),
              (w.pointShadowMap[CounterVariable] = y),
              (w.pointShadowMatrix[CounterVariable] = f.shadow.matrix),
              (w.point[CounterVariable] = x),
              CounterVariable++;
          else if (f.isHemisphereLight) {
            var x;
            (x = b.get(f)).direction.setFromMatrixPosition(f.matrixWorld),
              x.direction.transformDirection(GlobalReference),
              x.direction.normalize(),
              x.skyColor.copy(f.color).multiplyScalar(g),
              x.groundColor.copy(f.groundColor).multiplyScalar(g),
              (w.hemi[EnsureFunction] = x),
              EnsureFunction++;
          }
        }
        (w.ambient[0] = n),
          (w.ambient[1] = r),
          (w.ambient[2] = a),
          (w.directional.length = ObjectMethodWrapper),
          (w.spot.length = RandomGenerator),
          (w.rectArea.length = HelperFunction),
          (w.point.length = CounterVariable),
          (w.hemi.length = EnsureFunction),
          (w.hash.stateID = w.id),
          (w.hash.directionalLength = ObjectMethodWrapper),
          (w.hash.pointLength = CounterVariable),
          (w.hash.spotLength = RandomGenerator),
          (w.hash.rectAreaLength = HelperFunction),
          (w.hash.hemiLength = EnsureFunction),
          (w.hash.shadowsLength = t.length);
      },
      state: w,
    };
  }

  function Lm() {
    var t = new Pm(),
      i = [],
      n = [];
    return {
      init: function () {
        (i.length = 0), (n.length = 0);
      },
      state: { lightsArray: i, shadowsArray: n, lights: t },
      setupLights: function (env) {
        t.setup(i, n, env);
      },
      pushLight: function (env) {
        i.push(env);
      },
      pushShadow: function (env) {
        n.push(env);
      },
    };
  }

  function Cm() {
    var n = {};
    return {
      get: function (env, t) {
        var i;
        return (
          void 0 === n[env.id]
            ? ((i = new Lm()), (n[env.id] = {}), (n[env.id][t.id] = i))
            : void 0 === n[env.id][t.id]
              ? ((i = new Lm()), (n[env.id][t.id] = i))
              : (i = n[env.id][t.id]),
          i
        );
      },
      dispose: function () {
        n = {};
      },
    };
  }

  function Im(env) {
    Dd.call(this),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = cu),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(env);
  }

  function Rm(env) {
    Dd.call(this),
      (this.type = "MeshDistanceMaterial"),
      (this.referencePosition = new yu()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(env);
  }

  function Om(_, ModuleMeta, env) {
    for (
      var x = new Wu(),
        b = new gu(),
        w = new mu(),
        T = new mu(env, env),
        EnsureObject = new yu(),
        E = new yu(),
        Value = 1,
        y = 2,
        t = 1 + (Value | y),
        A = new Array(t),
        M = new Array(t),
        P = {},
        L = {
          0: lh,
          1: sh,
          2: hh,
        },
        C = [
          new yu(1, 0, 0),
          new yu(-1, 0, 0),
          new yu(0, 0, 1),
          new yu(0, 0, -1),
          new yu(0, 1, 0),
          new yu(0, -1, 0),
        ],
        I = [
          new yu(0, 1, 0),
          new yu(0, 1, 0),
          new yu(0, 1, 0),
          new yu(0, 1, 0),
          new yu(0, 0, 1),
          new yu(0, 0, -1),
        ],
        R = [new zu(), new zu(), new zu(), new zu(), new zu(), new zu()],
        i = 0;
      i !== t;
      ++i
    ) {
      var n = 0 != (i & Value),
        r = 0 != (i & y),
        a = new Im({ depthPacking: URLUtils, morphTargets: n, skinning: r });
      A[i] = a;
      var ObjectMethodWrapper = new Rm({ morphTargets: n, skinning: r });
      M[i] = ObjectMethodWrapper;
    }
    var O = this;

    function g(env, t, i, n, r, a) {
      var ObjectMethodWrapper = env.geometry,
        CounterVariable = null,
        RandomGenerator = A,
        HelperFunction = env.customDepthMaterial;
      if ((i && ((RandomGenerator = M), (HelperFunction = env.customDistanceMaterial)), HelperFunction)) CounterVariable = HelperFunction;
      else {
        var EnsureFunction = !1;
        t.morphTargets &&
          (ObjectMethodWrapper && ObjectMethodWrapper.isBufferGeometry
            ? (EnsureFunction =
                ObjectMethodWrapper.morphAttributes &&
                ObjectMethodWrapper.morphAttributes.position &&
                0 < ObjectMethodWrapper.morphAttributes.position.length)
            : ObjectMethodWrapper &&
              ObjectMethodWrapper.isGeometry &&
              (EnsureFunction = ObjectMethodWrapper.morphTargets && 0 < ObjectMethodWrapper.morphTargets.length)),
          env.isSkinnedMesh &&
            !1 === t.skinning &&
            console.warn(
              "THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:",
              env,
            );
        var GlobalReference = env.isSkinnedMesh && t.skinning,
          Property = 0;
        EnsureFunction && (Property |= Value), GlobalReference && (Property |= y), (CounterVariable = RandomGenerator[Property]);
      }
      if (
        _.localClippingEnabled &&
        !0 === t.clipShadows &&
        0 !== t.clippingPlanes.length
      ) {
        var MathFloorShortcut = CounterVariable.uuid,
          f = t.uuid,
          ModuleMeta = P[MathFloorShortcut];
        void 0 === ModuleMeta && ((ModuleMeta = {}), (P[MathFloorShortcut] = ModuleMeta));
        var g = ModuleMeta[f];
        void 0 === g && ((g = CounterVariable.clone()), (ModuleMeta[f] = g)), (CounterVariable = g);
      }
      return (
        (CounterVariable.visible = t.visible),
        (CounterVariable.wireframe = t.wireframe),
        (CounterVariable.side = null != t.shadowSide ? t.shadowSide : L[t.side]),
        (CounterVariable.clipShadows = t.clipShadows),
        (CounterVariable.clippingPlanes = t.clippingPlanes),
        (CounterVariable.clipIntersection = t.clipIntersection),
        (CounterVariable.wireframeLinewidth = t.wireframeLinewidth),
        (CounterVariable.linewidth = t.linewidth),
        i &&
          CounterVariable.isMeshDistanceMaterial &&
          (CounterVariable.referencePosition.copy(n),
          (CounterVariable.nearDistance = r),
          (CounterVariable.farDistance = a)),
        CounterVariable
      );
    }

    function FilterArray(env, t, i, n) {
      if (!1 !== env.visible) {
        if (
          env.layers.test(t.layers) &&
          (env.isMesh || env.isLine || env.isPoints) &&
          env.castShadow &&
          (!env.frustumCulled || x.intersectsObject(env))
        ) {
          env.modelViewMatrix.multiplyMatrices(
            i.matrixWorldInverse,
            env.matrixWorld,
          );
          var r = ModuleMeta.update(env),
            a = env.material;
          if (Array.isArray(a))
            for (var ObjectMethodWrapper = r.groups, CounterVariable = 0, RandomGenerator = ObjectMethodWrapper.length; CounterVariable < RandomGenerator; CounterVariable++) {
              var HelperFunction = ObjectMethodWrapper[CounterVariable],
                EnsureFunction = a[HelperFunction.materialIndex];
              if (EnsureFunction && EnsureFunction.visible) {
                var GlobalReference = g(env, EnsureFunction, n, E, i.near, i.far);
                _.renderBufferDirect(i, null, r, GlobalReference, env, HelperFunction);
              }
            }
          else if (a.visible) {
            GlobalReference = g(env, a, n, E, i.near, i.far);
            _.renderBufferDirect(i, null, r, GlobalReference, env, null);
          }
        }
        for (var Property = env.children, MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++)
          FilterArray(Property[MathFloorShortcut], t, i, n);
      }
    }

    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = ah),
      (this.render = function (env, t, i) {
        if (
          !1 !== O.enabled &&
          (!1 !== O.autoUpdate || !1 !== O.needsUpdate) &&
          0 !== env.length
        ) {
          var n,
            r = _.context,
            a = _.state;
          a.disable(r.BLEND),
            a.buffers.color.setClear(1, 1, 1, 1),
            a.buffers.depth.setTest(!0),
            a.setScissorTest(!1);
          for (var ObjectMethodWrapper = 0, CounterVariable = env.length; ObjectMethodWrapper < CounterVariable; ObjectMethodWrapper++) {
            var RandomGenerator = env[ObjectMethodWrapper],
              HelperFunction = RandomGenerator.shadow,
              EnsureFunction = RandomGenerator && RandomGenerator.isPointLight;
            if (void 0 !== HelperFunction) {
              var GlobalReference = HelperFunction.camera;
              if ((w.copy(HelperFunction.mapSize), w.min(T), EnsureFunction)) {
                var Property = w.x,
                  MathFloorShortcut = w.y;
                R[0].set(2 * Property, MathFloorShortcut, Property, MathFloorShortcut),
                  R[1].set(0, MathFloorShortcut, Property, MathFloorShortcut),
                  R[2].set(3 * Property, MathFloorShortcut, Property, MathFloorShortcut),
                  R[3].set(Property, MathFloorShortcut, Property, MathFloorShortcut),
                  R[4].set(3 * Property, 0, Property, MathFloorShortcut),
                  R[5].set(Property, 0, Property, MathFloorShortcut),
                  (w.x *= 4),
                  (w.y *= 2);
              }
              if (null === HelperFunction.map) {
                var f = { minFilter: ac, magFilter: ac, format: Ec };
                (HelperFunction.map = new Bu(w.x, w.y, f)),
                  (HelperFunction.map.texture.name = RandomGenerator.name + ".shadowMap"),
                  GlobalReference.updateProjectionMatrix();
              }
              HelperFunction.isSpotLightShadow && HelperFunction.update(RandomGenerator);
              var ModuleMeta = HelperFunction.map,
                g = HelperFunction.matrix;
              E.setFromMatrixPosition(RandomGenerator.matrixWorld),
                GlobalReference.position.copy(E),
                EnsureFunction
                  ? ((n = 6), g.makeTranslation(-E.x, -E.y, -E.z))
                  : ((n = 1),
                    EnsureObject.setFromMatrixPosition(RandomGenerator.target.matrixWorld),
                    GlobalReference.lookAt(EnsureObject),
                    GlobalReference.updateMatrixWorld(),
                    g.set(
                      0.5,
                      0,
                      0,
                      0.5,
                      0,
                      0.5,
                      0,
                      0.5,
                      0,
                      0,
                      0.5,
                      0.5,
                      0,
                      0,
                      0,
                      1,
                    ),
                    g.multiply(GlobalReference.projectionMatrix),
                    g.multiply(GlobalReference.matrixWorldInverse)),
                _.setRenderTarget(ModuleMeta),
                _.clear();
              for (var Value = 0; Value < n; Value++) {
                if (EnsureFunction) {
                  EnsureObject.copy(GlobalReference.position),
                    EnsureObject.add(C[Value]),
                    GlobalReference.up.copy(I[Value]),
                    GlobalReference.lookAt(EnsureObject),
                    GlobalReference.updateMatrixWorld();
                  var y = R[Value];
                  a.viewport(y);
                }
                b.multiplyMatrices(GlobalReference.projectionMatrix, GlobalReference.matrixWorldInverse),
                  x.setFromMatrix(b),
                  FilterArray(t, i, GlobalReference, EnsureFunction);
              }
            } else console.warn("THREE.WebGLShadowMap:", RandomGenerator, "has no shadow.");
          }
          O.needsUpdate = !1;
        }
      });
  }

  function Fm(EnsureFunction, i, RandomGenerator, n) {
    var r = new (function () {
        var t = !1,
          a = new zu(),
          i = null,
          ObjectMethodWrapper = new zu(0, 0, 0, 0);
        return {
          setMask: function (env) {
            i === env || t || (EnsureFunction.colorMask(env, env, env, env), (i = env));
          },
          setLocked: function (env) {
            t = env;
          },
          setClear: function (env, t, i, n, r) {
            !0 === r && ((env *= n), (t *= n), (i *= n)),
              a.set(env, t, i, n),
              !1 === ObjectMethodWrapper.equals(a) && (EnsureFunction.clearColor(env, t, i, n), ObjectMethodWrapper.copy(a));
          },
          reset: function () {
            (t = !1), (i = null), ObjectMethodWrapper.set(-1, 0, 0, 0);
          },
        };
      })(),
      a = new (function () {
        var t = !1,
          i = null,
          n = null,
          r = null;
        return {
          setTest: function (env) {
            env ? z(EnsureFunction.DEPTH_TEST) : B(EnsureFunction.DEPTH_TEST);
          },
          setMask: function (env) {
            i === env || t || (EnsureFunction.depthMask(env), (i = env));
          },
          setFunc: function (env) {
            if (n !== env) {
              if (env)
                switch (env) {
                  case Oh:
                    EnsureFunction.depthFunc(EnsureFunction.NEVER);
                    break;
                  case Fh:
                    EnsureFunction.depthFunc(EnsureFunction.ALWAYS);
                    break;
                  case Nh:
                    EnsureFunction.depthFunc(EnsureFunction.LESS);
                    break;
                  case kh:
                    EnsureFunction.depthFunc(EnsureFunction.LEQUAL);
                    break;
                  case Uh:
                    EnsureFunction.depthFunc(EnsureFunction.EQUAL);
                    break;
                  case Dh:
                    EnsureFunction.depthFunc(EnsureFunction.GEQUAL);
                    break;
                  case zh:
                    EnsureFunction.depthFunc(EnsureFunction.GREATER);
                    break;
                  case Bh:
                    EnsureFunction.depthFunc(EnsureFunction.NOTEQUAL);
                    break;
                  default:
                    EnsureFunction.depthFunc(EnsureFunction.LEQUAL);
                }
              else EnsureFunction.depthFunc(EnsureFunction.LEQUAL);
              n = env;
            }
          },
          setLocked: function (env) {
            t = env;
          },
          setClear: function (env) {
            r !== env && (EnsureFunction.clearDepth(env), (r = env));
          },
          reset: function () {
            (t = !1), (r = n = i = null);
          },
        };
      })(),
      t = new (function () {
        var t = !1,
          i = null,
          n = null,
          r = null,
          a = null,
          ObjectMethodWrapper = null,
          CounterVariable = null,
          RandomGenerator = null,
          HelperFunction = null;
        return {
          setTest: function (env) {
            env ? z(EnsureFunction.STENCIL_TEST) : B(EnsureFunction.STENCIL_TEST);
          },
          setMask: function (env) {
            i === env || t || (EnsureFunction.stencilMask(env), (i = env));
          },
          setFunc: function (env, t, i) {
            (n === env && r === t && a === i) ||
              (EnsureFunction.stencilFunc(env, t, i), (n = env), (r = t), (a = i));
          },
          setOp: function (env, t, i) {
            (ObjectMethodWrapper === env && CounterVariable === t && RandomGenerator === i) ||
              (EnsureFunction.stencilOp(env, t, i), (ObjectMethodWrapper = env), (CounterVariable = t), (RandomGenerator = i));
          },
          setLocked: function (env) {
            t = env;
          },
          setClear: function (env) {
            HelperFunction !== env && (EnsureFunction.clearStencil(env), (HelperFunction = env));
          },
          reset: function () {
            (t = !1), (HelperFunction = RandomGenerator = CounterVariable = ObjectMethodWrapper = a = r = n = i = null);
          },
        };
      })(),
      env = EnsureFunction.getParameter(EnsureFunction.MAX_VERTEX_ATTRIBS),
      ObjectMethodWrapper = new Uint8Array(env),
      CounterVariable = new Uint8Array(env),
      HelperFunction = new Uint8Array(env),
      GlobalReference = {},
      Property = null,
      MathFloorShortcut = null,
      f = null,
      ModuleMeta = null,
      g = null,
      Value = null,
      y = null,
      _ = null,
      x = null,
      b = null,
      w = !1,
      T = null,
      EnsureObject = null,
      E = null,
      A = null,
      M = null,
      P = EnsureFunction.getParameter(EnsureFunction.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      L = !1,
      C = 0,
      I = EnsureFunction.getParameter(EnsureFunction.VERSION);
    -1 !== I.indexOf("WebGL")
      ? ((C = parseFloat(/^WebGL\ ([0-9])/.exec(I)[1])), (L = 1 <= C))
      : -1 !== I.indexOf("OpenGL ES") &&
        ((C = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(I)[1])), (L = 2 <= C));
    var R = null,
      O = {},
      FilterArray = new zu(),
      FindInArray = new zu();

    function Key(env, t, i) {
      var n = new Uint8Array(4),
        r = EnsureFunction.createTexture();
      EnsureFunction.bindTexture(env, r),
        EnsureFunction.texParameteri(env, EnsureFunction.TEXTURE_MIN_FILTER, EnsureFunction.NEAREST),
        EnsureFunction.texParameteri(env, EnsureFunction.TEXTURE_MAG_FILTER, EnsureFunction.NEAREST);
      for (var a = 0; a < i; a++)
        EnsureFunction.texImage2D(t + a, 0, EnsureFunction.RGBA, 1, 1, 0, EnsureFunction.RGBA, EnsureFunction.UNSIGNED_BYTE, n);
      return r;
    }

    var U = {};

    function D(env, t) {
      ((ObjectMethodWrapper[env] = 1),
      0 === CounterVariable[env] && (EnsureFunction.enableVertexAttribArray(env), (CounterVariable[env] = 1)),
      HelperFunction[env] !== t) &&
        ((n.isWebGL2 ? EnsureFunction : i.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](env, t),
        (HelperFunction[env] = t));
    }

    function z(env) {
      !0 !== GlobalReference[env] && (EnsureFunction.enable(env), (GlobalReference[env] = !0));
    }

    function B(env) {
      !1 !== GlobalReference[env] && (EnsureFunction.disable(env), (GlobalReference[env] = !1));
    }

    function ForEachElement(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
      if (env !== uh) {
        if ((f || (z(EnsureFunction.BLEND), (f = !0)), env === GraphHandler))
          (r = r || t),
            (a = a || i),
            (ObjectMethodWrapper = ObjectMethodWrapper || n),
            (t === g && r === _) ||
              (EnsureFunction.blendEquationSeparate(RandomGenerator.convert(t), RandomGenerator.convert(r)),
              (g = t),
              (_ = r)),
            (i === Value && n === y && a === x && ObjectMethodWrapper === b) ||
              (EnsureFunction.blendFuncSeparate(
                RandomGenerator.convert(i),
                RandomGenerator.convert(n),
                RandomGenerator.convert(a),
                RandomGenerator.convert(ObjectMethodWrapper),
              ),
              (Value = i),
              (y = n),
              (x = a),
              (b = ObjectMethodWrapper)),
            (ModuleMeta = env),
            (w = null);
        else if (env !== ModuleMeta || CounterVariable !== w) {
          if (
            ((g === vh && _ === vh) ||
              (EnsureFunction.blendEquation(EnsureFunction.FUNC_ADD), (_ = g = vh)),
            CounterVariable)
          )
            switch (env) {
              case ph:
                EnsureFunction.blendFuncSeparate(
                  EnsureFunction.ONE,
                  EnsureFunction.ONE_MINUS_SRC_ALPHA,
                  EnsureFunction.ONE,
                  EnsureFunction.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case dh:
                EnsureFunction.blendFunc(EnsureFunction.ONE, EnsureFunction.ONE);
                break;
              case fh:
                EnsureFunction.blendFuncSeparate(
                  EnsureFunction.ZERO,
                  EnsureFunction.ZERO,
                  EnsureFunction.ONE_MINUS_SRC_COLOR,
                  EnsureFunction.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case mh:
                EnsureFunction.blendFuncSeparate(EnsureFunction.ZERO, EnsureFunction.SRC_COLOR, EnsureFunction.ZERO, EnsureFunction.SRC_ALPHA);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", env);
            }
          else
            switch (env) {
              case ph:
                EnsureFunction.blendFuncSeparate(
                  EnsureFunction.SRC_ALPHA,
                  EnsureFunction.ONE_MINUS_SRC_ALPHA,
                  EnsureFunction.ONE,
                  EnsureFunction.ONE_MINUS_SRC_ALPHA,
                );
                break;
              case dh:
                EnsureFunction.blendFunc(EnsureFunction.SRC_ALPHA, EnsureFunction.ONE);
                break;
              case fh:
                EnsureFunction.blendFunc(EnsureFunction.ZERO, EnsureFunction.ONE_MINUS_SRC_COLOR);
                break;
              case mh:
                EnsureFunction.blendFunc(EnsureFunction.ZERO, EnsureFunction.SRC_COLOR);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", env);
            }
          (b = x = y = Value = null), (ModuleMeta = env), (w = CounterVariable);
        }
      } else f && (B(EnsureFunction.BLEND), (f = !1));
    }

    function G(env) {
      T !== env && (env ? EnsureFunction.frontFace(EnsureFunction.CW) : EnsureFunction.frontFace(EnsureFunction.CCW), (T = env));
    }

    function Iterator(env) {
      env !== ih
        ? (z(EnsureFunction.CULL_FACE),
          env !== EnsureObject &&
            (env === nh
              ? EnsureFunction.cullFace(EnsureFunction.BACK)
              : env === rh
                ? EnsureFunction.cullFace(EnsureFunction.FRONT)
                : EnsureFunction.cullFace(EnsureFunction.FRONT_AND_BACK)))
        : B(EnsureFunction.CULL_FACE),
        (EnsureObject = env);
    }

    function IsIterable(env, t, i) {
      env
        ? (z(EnsureFunction.POLYGON_OFFSET_FILL),
          (A === t && M === i) || (EnsureFunction.polygonOffset(t, i), (A = t), (M = i)))
        : B(EnsureFunction.POLYGON_OFFSET_FILL);
    }

    function ObjectKeys(env) {
      void 0 === env && (env = EnsureFunction.TEXTURE0 + P - 1),
        R !== env && (EnsureFunction.activeTexture(env), (R = env));
    }

    return (
      (U[EnsureFunction.TEXTURE_2D] = Key(EnsureFunction.TEXTURE_2D, EnsureFunction.TEXTURE_2D, 1)),
      (U[EnsureFunction.TEXTURE_CUBE_MAP] = Key(
        EnsureFunction.TEXTURE_CUBE_MAP,
        EnsureFunction.TEXTURE_CUBE_MAP_POSITIVE_X,
        6,
      )),
      r.setClear(0, 0, 0, 1),
      a.setClear(1),
      t.setClear(0),
      z(EnsureFunction.DEPTH_TEST),
      a.setFunc(kh),
      G(!1),
      Iterator(nh),
      z(EnsureFunction.CULL_FACE),
      ForEachElement(uh),
      {
        buffers: { color: r, depth: a, stencil: t },
        initAttributes: function () {
          for (var env = 0, t = ObjectMethodWrapper.length; env < t; env++) ObjectMethodWrapper[env] = 0;
        },
        enableAttribute: function (env) {
          D(env, 0);
        },
        enableAttributeAndDivisor: D,
        disableUnusedAttributes: function () {
          for (var env = 0, t = CounterVariable.length; env !== t; ++env)
            CounterVariable[env] !== ObjectMethodWrapper[env] && (EnsureFunction.disableVertexAttribArray(env), (CounterVariable[env] = 0));
        },
        enable: z,
        disable: B,
        getCompressedTextureFormats: function () {
          if (
            null === Property &&
            ((Property = []),
            i.get("WEBGL_compressed_texture_pvrtc") ||
              i.get("WEBGL_compressed_texture_s3tc") ||
              i.get("WEBGL_compressed_texture_etc1") ||
              i.get("WEBGL_compressed_texture_astc"))
          )
            for (
              var env = EnsureFunction.getParameter(EnsureFunction.COMPRESSED_TEXTURE_FORMATS), t = 0;
              t < env.length;
              t++
            )
              Property.push(env[t]);
          return Property;
        },
        useProgram: function (env) {
          return MathFloorShortcut !== env && (EnsureFunction.useProgram(env), (MathFloorShortcut = env), !0);
        },
        setBlending: ForEachElement,
        setMaterial: function (env, t) {
          env.side === hh ? B(EnsureFunction.CULL_FACE) : z(EnsureFunction.CULL_FACE);
          var i = env.side === lh;
          t && (i = !i),
            G(i),
            env.blending === ph && !1 === env.transparent
              ? ForEachElement(uh)
              : ForEachElement(
                  env.blending,
                  env.blendEquation,
                  env.blendSrc,
                  env.blendDst,
                  env.blendEquationAlpha,
                  env.blendSrcAlpha,
                  env.blendDstAlpha,
                  env.premultipliedAlpha,
                ),
            a.setFunc(env.depthFunc),
            a.setTest(env.depthTest),
            a.setMask(env.depthWrite),
            r.setMask(env.colorWrite),
            IsIterable(env.polygonOffset, env.polygonOffsetFactor, env.polygonOffsetUnits);
        },
        setFlipSided: G,
        setCullFace: Iterator,
        setLineWidth: function (env) {
          env !== E && (L && EnsureFunction.lineWidth(env), (E = env));
        },
        setPolygonOffset: IsIterable,
        setScissorTest: function (env) {
          env ? z(EnsureFunction.SCISSOR_TEST) : B(EnsureFunction.SCISSOR_TEST);
        },
        activeTexture: ObjectKeys,
        bindTexture: function (env, t) {
          null === R && ObjectKeys();
          var i = O[R];
          void 0 === i &&
            ((i = {
              type: void 0,
              texture: void 0,
            }),
            (O[R] = i)),
            (i.type === env && i.texture === t) ||
              (EnsureFunction.bindTexture(env, t || U[env]), (i.type = env), (i.texture = t));
        },
        compressedTexImage2D: function () {
          try {
            EnsureFunction.compressedTexImage2D.apply(EnsureFunction, arguments);
          } catch (env) {
            console.error("THREE.WebGLState:", env);
          }
        },
        texImage2D: function () {
          try {
            EnsureFunction.texImage2D.apply(EnsureFunction, arguments);
          } catch (env) {
            console.error("THREE.WebGLState:", env);
          }
        },
        texImage3D: function () {
          try {
            EnsureFunction.texImage3D.apply(EnsureFunction, arguments);
          } catch (env) {
            console.error("THREE.WebGLState:", env);
          }
        },
        scissor: function (env) {
          !1 === FilterArray.equals(env) && (EnsureFunction.scissor(env.x, env.y, env.z, env.w), FilterArray.copy(env));
        },
        viewport: function (env) {
          !1 === FindInArray.equals(env) && (EnsureFunction.viewport(env.x, env.y, env.z, env.w), FindInArray.copy(env));
        },
        reset: function () {
          for (var env = 0; env < CounterVariable.length; env++)
            1 === CounterVariable[env] && (EnsureFunction.disableVertexAttribArray(env), (CounterVariable[env] = 0));
          (GlobalReference = {}),
            (O = {}),
            (EnsureObject = T = ModuleMeta = MathFloorShortcut = R = Property = null),
            r.reset(),
            a.reset(),
            t.reset();
        },
      }
    );
  }

  function Nm(g, r, Value, y, _, x, b) {
    var ModuleMeta,
      CounterVariable = {};

    function w(env, t) {
      if (env.width > t || env.height > t) {
        if ("data" in env)
          return void console.warn(
            "THREE.WebGLRenderer: image in DataTexture is too big (" +
              env.width +
              "x" +
              env.height +
              ").",
          );
        var i = t / Math.max(env.width, env.height),
          n = document.createElementNS(
            "http://www.w3.org/1999/xhtml",
            "canvas",
          );
        return (
          (n.width = Math.floor(env.width * i)),
          (n.height = Math.floor(env.height * i)),
          n
            .getContext("2d")
            .drawImage(env, 0, 0, env.width, env.height, 0, 0, n.width, n.height),
          console.warn(
            "THREE.WebGLRenderer: image is too big (" +
              env.width +
              "x" +
              env.height +
              "). Resized to " +
              n.width +
              "x" +
              n.height,
          ),
          n
        );
      }
      return env;
    }

    function T(env) {
      return fu.isPowerOfTwo(env.width) && fu.isPowerOfTwo(env.height);
    }

    function EnsureObject(env, t) {
      return env.generateMipmaps && t && env.minFilter !== ac && env.minFilter !== LineCounter;
    }

    function E(env, t, i, n) {
      g.generateMipmap(env),
        (y.get(t).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E);
    }

/**
 * تابع `A` برای تعیین فرمت مناسب WebGL2 بر اساس نوع داده‌ها و فرمت ورودی استفاده می‌شود.
 * این تابع اطمینان حاصل می‌کند که از فرمت‌های پیشرفته WebGL2 (در صورت پشتیبانی) استفاده شود.
 * 
 * @param {GLenum} env - فرمت اولیه (مانند g.RED، g.RGB یا g.RGBA).
 * @param {GLenum} t - نوع داده (مانند g.FLOAT، g.HALF_FLOAT یا g.UNSIGNED_BYTE).
 * @returns {GLenum} - فرمت مناسب WebGL2 (در صورت پشتیبانی) یا فرمت اصلی.
 */
function A(env, t) {
  // اگر WebGL2 پشتیبانی نمی‌شود، همان فرمت اولیه بازگردانده می‌شود.
  if (!_.isWebGL2) return env;

  // بررسی فرمت اولیه و تعیین فرمت مناسب برای WebGL2
  if (env === g.RED) {
    // تعیین فرمت برای رنگ قرمز (RED) بر اساس نوع داده
    if (t === g.FLOAT) return g.R32F; // فرمت 32 بیتی شناور
    if (t === g.HALF_FLOAT) return g.R16F; // فرمت 16 بیتی شناور
    if (t === g.UNSIGNED_BYTE) return g.R8; // فرمت 8 بیتی عدد صحیح بدون علامت
  }

  if (env === g.RGB) {
    // تعیین فرمت برای RGB بر اساس نوع داده
    if (t === g.FLOAT) return g.RGB32F; // فرمت 32 بیتی شناور برای هر کانال
    if (t === g.HALF_FLOAT) return g.RGB16F; // فرمت 16 بیتی شناور برای هر کانال
    if (t === g.UNSIGNED_BYTE) return g.RGB8; // فرمت 8 بیتی عدد صحیح بدون علامت برای هر کانال
  }

  if (env === g.RGBA) {
    // تعیین فرمت برای RGBA بر اساس نوع داده
    if (t === g.FLOAT) return g.RGBA32F; // فرمت 32 بیتی شناور برای هر کانال
    if (t === g.HALF_FLOAT) return g.RGBA16F; // فرمت 16 بیتی شناور برای هر کانال
    if (t === g.UNSIGNED_BYTE) return g.RGBA8; // فرمت 8 بیتی عدد صحیح بدون علامت برای هر کانال
  }

  // اگر هیچ شرطی مطابقت نداشت، همان فرمت اولیه بازگردانده می‌شود.
  return env;
}


    function a(env) {
      return env === ac || env === OperationCounter || env === StringConverter ? g.NEAREST : g.LINEAR;
    }

    function M(env) {
      var t = env.target;
      t.removeEventListener("dispose", M),
        (function (env) {
          var t = y.get(env);
          if (env.image && t.__image__webglTextureCube)
            g.deleteTexture(t.__image__webglTextureCube);
          else {
            if (void 0 === t.__webglInit) return;
            g.deleteTexture(t.__webglTexture);
          }
          y.remove(env);
        })(t),
        t.isVideoTexture && delete CounterVariable[t.id],
        b.memory.textures--;
    }

    function ObjectMethodWrapper(env) {
      var t = env.target;
      t.removeEventListener("dispose", ObjectMethodWrapper),
        (function (env) {
          var t = y.get(env),
            i = y.get(env.texture);
          if (!env) return;
          void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture);
          env.depthTexture && env.depthTexture.dispose();
          if (env.isWebGLRenderTargetCube)
            for (var n = 0; n < 6; n++)
              g.deleteFramebuffer(t.__webglFramebuffer[n]),
                t.__webglDepthbuffer &&
                  g.deleteRenderbuffer(t.__webglDepthbuffer[n]);
          else
            g.deleteFramebuffer(t.__webglFramebuffer),
              t.__webglDepthbuffer &&
                g.deleteRenderbuffer(t.__webglDepthbuffer);
          y.remove(env.texture), y.remove(env);
        })(t),
        b.memory.textures--;
    }

    function RandomGenerator(env, t) {
      var i,
        n,
        r,
        a = y.get(env);
      if (
        (env.isVideoTexture &&
          ((n = (i = env).id),
          (r = b.render.frame),
          CounterVariable[n] !== r && ((CounterVariable[n] = r), i.update())),
        0 < env.version && a.__version !== env.version)
      ) {
        var ObjectMethodWrapper = env.image;
        if (void 0 === ObjectMethodWrapper)
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is undefined",
          );
        else {
          if (!1 !== ObjectMethodWrapper.complete) return void HelperFunction(a, env, t);
          console.warn(
            "THREE.WebGLRenderer: Texture marked for update but image is incomplete",
          );
        }
      }
      Value.activeTexture(g.TEXTURE0 + t),
        Value.bindTexture(g.TEXTURE_2D, a.__webglTexture);
    }

    function P(env, t, i) {
      var n;
      if (
        (i
          ? (g.texParameteri(env, g.TEXTURE_WRAP_S, x.convert(t.wrapS)),
            g.texParameteri(env, g.TEXTURE_WRAP_T, x.convert(t.wrapT)),
            g.texParameteri(env, g.TEXTURE_MAG_FILTER, x.convert(t.magFilter)),
            g.texParameteri(env, g.TEXTURE_MIN_FILTER, x.convert(t.minFilter)))
          : (g.texParameteri(env, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE),
            g.texParameteri(env, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE),
            (t.wrapS === nc && t.wrapT === nc) ||
              console.warn(
                "THREE.WebGLRenderer: Texture is not power OutputFormatter two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.",
              ),
            g.texParameteri(env, g.TEXTURE_MAG_FILTER, a(t.magFilter)),
            g.texParameteri(env, g.TEXTURE_MIN_FILTER, a(t.minFilter)),
            t.minFilter !== ac &&
              t.minFilter !== LineCounter &&
              console.warn(
                "THREE.WebGLRenderer: Texture is not power OutputFormatter two. Texture.minFilter should be set to THREE.NearestFilter PromiseResolutionWrapper THREE.LinearFilter.",
              )),
        (n = r.get("EXT_texture_filter_anisotropic")))
      ) {
        if (t.type === ValueCache && null === r.get("OES_texture_float_linear")) return;
        if (
          t.type === YieldCounter &&
          null === (_.isWebGL2 || r.get("OES_texture_half_float_linear"))
        )
          return;
        (1 < t.anisotropy || y.get(t).__currentAnisotropy) &&
          (g.texParameterf(
            env,
            n.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(t.anisotropy, _.getMaxAnisotropy()),
          ),
          (y.get(t).__currentAnisotropy = t.anisotropy));
      }
    }

    function HelperFunction(env, t, i) {
      var n;
      (n = t.isDataTexture3D ? g.TEXTURE_3D : g.TEXTURE_2D),
        void 0 === env.__webglInit &&
          ((env.__webglInit = !0),
          t.addEventListener("dispose", M),
          (env.__webglTexture = g.createTexture()),
          b.memory.textures++),
        Value.activeTexture(g.TEXTURE0 + i),
        Value.bindTexture(n, env.__webglTexture),
        g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, t.flipY),
        g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha),
        g.pixelStorei(g.UNPACK_ALIGNMENT, t.unpackAlignment);
      var r,
        a,
        ObjectMethodWrapper = w(t.image, _.maxTextureSize);
      (a = t),
        _.isWebGL2 ||
          (a.wrapS === nc &&
            a.wrapT === nc &&
            (a.minFilter === ac || a.minFilter === LineCounter)) ||
          !1 !== T(ObjectMethodWrapper) ||
          (ObjectMethodWrapper =
            (r = ObjectMethodWrapper) instanceof HTMLImageElement ||
            r instanceof HTMLCanvasElement ||
            r instanceof ImageBitmap
              ? (void 0 === ModuleMeta &&
                  (ModuleMeta = document.createElementNS(
                    "http://www.w3.org/1999/xhtml",
                    "canvas",
                  )),
                (ModuleMeta.width = fu.floorPowerOfTwo(r.width)),
                (ModuleMeta.height = fu.floorPowerOfTwo(r.height)),
                ModuleMeta.getContext("2d").drawImage(r, 0, 0, ModuleMeta.width, ModuleMeta.height),
                console.warn(
                  "THREE.WebGLRenderer: image is not power OutputFormatter two (" +
                    r.width +
                    "x" +
                    r.height +
                    "). Resized to " +
                    ModuleMeta.width +
                    "x" +
                    ModuleMeta.height,
                ),
                ModuleMeta)
              : r);
      var CounterVariable = T(ObjectMethodWrapper),
        RandomGenerator = x.convert(t.format),
        HelperFunction = x.convert(t.type),
        EnsureFunction = A(RandomGenerator, HelperFunction);
      P(n, t, CounterVariable);
      var GlobalReference,
        Property = t.mipmaps;
      if (t.isDepthTexture) {
        if (((EnsureFunction = g.DEPTH_COMPONENT), t.type === ValueCache)) {
          if (!_.isWebGL2)
            throw new Error("Float Depth Texture only supported in WebGL2.0");
          EnsureFunction = g.DEPTH_COMPONENT32F;
        } else _.isWebGL2 && (EnsureFunction = g.DEPTH_COMPONENT16);
        t.format === Pc &&
          EnsureFunction === g.DEPTH_COMPONENT &&
          t.type !== fc &&
          t.type !== GlobalCounter &&
          (console.warn(
            "THREE.WebGLRenderer: Use UnsignedShortType PromiseResolutionWrapper UnsignedIntType for DepthFormat DepthTexture.",
          ),
          (t.type = fc),
          (HelperFunction = x.convert(t.type))),
          t.format === Lc &&
            ((EnsureFunction = g.DEPTH_STENCIL),
            t.type !== WrapperCache &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.",
              ),
              (t.type = WrapperCache),
              (HelperFunction = x.convert(t.type)))),
          Value.texImage2D(g.TEXTURE_2D, 0, EnsureFunction, ObjectMethodWrapper.width, ObjectMethodWrapper.height, 0, RandomGenerator, HelperFunction, null);
      } else if (t.isDataTexture)
        if (0 < Property.length && CounterVariable) {
          for (var MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++)
            (GlobalReference = Property[MathFloorShortcut]),
              Value.texImage2D(
                g.TEXTURE_2D,
                MathFloorShortcut,
                EnsureFunction,
                GlobalReference.width,
                GlobalReference.height,
                0,
                RandomGenerator,
                HelperFunction,
                GlobalReference.data,
              );
          (t.generateMipmaps = !1), (env.__maxMipLevel = Property.length - 1);
        } else
          Value.texImage2D(g.TEXTURE_2D, 0, EnsureFunction, ObjectMethodWrapper.width, ObjectMethodWrapper.height, 0, RandomGenerator, HelperFunction, ObjectMethodWrapper.data),
            (env.__maxMipLevel = 0);
      else if (t.isCompressedTexture) {
        for (MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++)
          (GlobalReference = Property[MathFloorShortcut]),
            t.format !== Ec && t.format !== Sc
              ? -1 < Value.getCompressedTextureFormats().indexOf(RandomGenerator)
                ? Value.compressedTexImage2D(
                    g.TEXTURE_2D,
                    MathFloorShortcut,
                    EnsureFunction,
                    GlobalReference.width,
                    GlobalReference.height,
                    0,
                    GlobalReference.data,
                  )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()",
                  )
              : Value.texImage2D(
                  g.TEXTURE_2D,
                  MathFloorShortcut,
                  EnsureFunction,
                  GlobalReference.width,
                  GlobalReference.height,
                  0,
                  RandomGenerator,
                  HelperFunction,
                  GlobalReference.data,
                );
        env.__maxMipLevel = Property.length - 1;
      } else if (t.isDataTexture3D)
        Value.texImage3D(
          g.TEXTURE_3D,
          0,
          EnsureFunction,
          ObjectMethodWrapper.width,
          ObjectMethodWrapper.height,
          ObjectMethodWrapper.depth,
          0,
          RandomGenerator,
          HelperFunction,
          ObjectMethodWrapper.data,
        ),
          (env.__maxMipLevel = 0);
      else if (0 < Property.length && CounterVariable) {
        for (MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++)
          (GlobalReference = Property[MathFloorShortcut]), Value.texImage2D(g.TEXTURE_2D, MathFloorShortcut, EnsureFunction, RandomGenerator, HelperFunction, GlobalReference);
        (t.generateMipmaps = !1), (env.__maxMipLevel = Property.length - 1);
      } else Value.texImage2D(g.TEXTURE_2D, 0, EnsureFunction, RandomGenerator, HelperFunction, ObjectMethodWrapper), (env.__maxMipLevel = 0);
      EnsureObject(t, CounterVariable) && E(g.TEXTURE_2D, t, ObjectMethodWrapper.width, ObjectMethodWrapper.height),
        (env.__version = t.version),
        t.onUpdate && t.onUpdate(t);
    }

    function EnsureFunction(env, t, i, n) {
      var r = x.convert(t.texture.format),
        a = x.convert(t.texture.type),
        ObjectMethodWrapper = A(r, a);
      Value.texImage2D(n, 0, ObjectMethodWrapper, t.width, t.height, 0, r, a, null),
        g.bindFramebuffer(g.FRAMEBUFFER, env),
        g.framebufferTexture2D(
          g.FRAMEBUFFER,
          i,
          n,
          y.get(t.texture).__webglTexture,
          0,
        ),
        g.bindFramebuffer(g.FRAMEBUFFER, null);
    }

/**
 * تابع `GlobalReference` برای پیکربندی و اتصال یک Renderbuffer به Framebuffer در WebGL استفاده می‌شود.
 * این تابع تعیین می‌کند که آیا Buffer باید دارای Depth، Stencil، یا ترکیبی از آن‌ها باشد و تنظیمات ذخیره‌سازی را اعمال می‌کند.
 * 
 * @param {WebGLRenderbuffer} env - شیء Renderbuffer که باید پیکربندی شود.
 * @param {Object} t - تنظیمات مربوط به ابعاد و نوع بافر.
 * @param {boolean} t.depthBuffer - آیا Buffer باید دارای Depth باشد.
 * @param {boolean} t.stencilBuffer - آیا Buffer باید دارای Stencil باشد.
 * @param {number} t.width - عرض Buffer.
 * @param {number} t.height - ارتفاع Buffer.
 */
function GlobalReference(env, t) {
  // بایند کردن (متصل کردن) Renderbuffer به WebGL context
  g.bindRenderbuffer(g.RENDERBUFFER, env);

  // بررسی اینکه آیا Depth و Stencil فعال هستند یا خیر
  if (t.depthBuffer && !t.stencilBuffer) {
    // اگر فقط Depth فعال باشد:
    g.renderbufferStorage(
      g.RENDERBUFFER,
      g.DEPTH_COMPONENT16, // فرمت ذخیره‌سازی 16 بیتی برای Depth
      t.width, // تنظیم عرض Renderbuffer
      t.height, // تنظیم ارتفاع Renderbuffer
    );
    g.framebufferRenderbuffer(
      g.FRAMEBUFFER,
      g.DEPTH_ATTACHMENT, // اتصال به Depth Attachment
      g.RENDERBUFFER,
      env, // ارجاع به Renderbuffer
    );
  } else if (t.depthBuffer && t.stencilBuffer) {
    // اگر Depth و Stencil هر دو فعال باشند:
    g.renderbufferStorage(
      g.RENDERBUFFER,
      g.DEPTH_STENCIL, // فرمت ذخیره‌سازی ترکیبی Depth و Stencil
      t.width, // تنظیم عرض Renderbuffer
      t.height, // تنظیم ارتفاع Renderbuffer
    );
    g.framebufferRenderbuffer(
      g.FRAMEBUFFER,
      g.DEPTH_STENCIL_ATTACHMENT, // اتصال به Depth-Stencil Attachment
      g.RENDERBUFFER,
      env, // ارجاع به Renderbuffer
    );
  } else {
    // اگر هیچ‌یک از Depth یا Stencil فعال نباشند (تنها رنگ RGBA استفاده شود):
    g.renderbufferStorage(
      g.RENDERBUFFER,
      g.RGBA4, // فرمت ذخیره‌سازی RGBA4 (4 بیتی برای هر کانال رنگی)
      t.width, // تنظیم عرض Renderbuffer
      t.height, // تنظیم ارتفاع Renderbuffer
    );
  }

  // جدا کردن Renderbuffer از Context
  g.bindRenderbuffer(g.RENDERBUFFER, null);
}

    function Property(env) {
      var t = y.get(env),
        i = !0 === env.isWebGLRenderTargetCube;
      if (env.depthTexture) {
        if (i)
          throw new Error(
            "target.depthTexture not supported in Cube render targets",
          );
        !(function (env, t) {
          if (t && t.isWebGLRenderTargetCube)
            throw new Error(
              "Depth Texture with cube render targets is not supported",
            );
          if (
            (g.bindFramebuffer(g.FRAMEBUFFER, env),
            !t.depthTexture || !t.depthTexture.isDepthTexture)
          )
            throw new Error(
              "renderTarget.depthTexture must be an instance OutputFormatter THREE.DepthTexture",
            );
          (y.get(t.depthTexture).__webglTexture &&
            t.depthTexture.image.width === t.width &&
            t.depthTexture.image.height === t.height) ||
            ((t.depthTexture.image.width = t.width),
            (t.depthTexture.image.height = t.height),
            (t.depthTexture.needsUpdate = !0)),
            RandomGenerator(t.depthTexture, 0);
          var i = y.get(t.depthTexture).__webglTexture;
          if (t.depthTexture.format === Pc)
            g.framebufferTexture2D(
              g.FRAMEBUFFER,
              g.DEPTH_ATTACHMENT,
              g.TEXTURE_2D,
              i,
              0,
            );
          else {
            if (t.depthTexture.format !== Lc)
              throw new Error("Unknown depthTexture format");
            g.framebufferTexture2D(
              g.FRAMEBUFFER,
              g.DEPTH_STENCIL_ATTACHMENT,
              g.TEXTURE_2D,
              i,
              0,
            );
          }
        })(t.__webglFramebuffer, env);
      } else if (i) {
        t.__webglDepthbuffer = [];
        for (var n = 0; n < 6; n++)
          g.bindFramebuffer(g.FRAMEBUFFER, t.__webglFramebuffer[n]),
            (t.__webglDepthbuffer[n] = g.createRenderbuffer()),
            GlobalReference(t.__webglDepthbuffer[n], env);
      } else
        g.bindFramebuffer(g.FRAMEBUFFER, t.__webglFramebuffer),
          (t.__webglDepthbuffer = g.createRenderbuffer()),
          GlobalReference(t.__webglDepthbuffer, env);
      g.bindFramebuffer(g.FRAMEBUFFER, null);
    }

    (this.setTexture2D = RandomGenerator),
      (this.setTexture3D = function (env, t) {
        var i = y.get(env);
        0 < env.version && i.__version !== env.version
          ? HelperFunction(i, env, t)
          : (Value.activeTexture(g.TEXTURE0 + t),
            Value.bindTexture(g.TEXTURE_3D, i.__webglTexture));
      }),
      (this.setTextureCube = function (env, t) {
        var i = y.get(env);
        if (6 === env.image.length)
          if (0 < env.version && i.__version !== env.version) {
            i.__image__webglTextureCube ||
              (env.addEventListener("dispose", M),
              (i.__image__webglTextureCube = g.createTexture()),
              b.memory.textures++),
              Value.activeTexture(g.TEXTURE0 + t),
              Value.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube),
              g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, env.flipY);
            for (
              var n = env && env.isCompressedTexture,
                r = env.image[0] && env.image[0].isDataTexture,
                a = [],
                ObjectMethodWrapper = 0;
              ObjectMethodWrapper < 6;
              ObjectMethodWrapper++
            )
              a[ObjectMethodWrapper] =
                n || r
                  ? r
                    ? env.image[ObjectMethodWrapper].image
                    : env.image[ObjectMethodWrapper]
                  : w(env.image[ObjectMethodWrapper], _.maxCubemapSize);
            var CounterVariable = a[0],
              RandomGenerator = T(CounterVariable),
              HelperFunction = x.convert(env.format),
              EnsureFunction = x.convert(env.type),
              GlobalReference = A(HelperFunction, EnsureFunction);
            for (P(g.TEXTURE_CUBE_MAP, env, RandomGenerator), ObjectMethodWrapper = 0; ObjectMethodWrapper < 6; ObjectMethodWrapper++)
              if (n)
                for (var Property, MathFloorShortcut = a[ObjectMethodWrapper].mipmaps, f = 0, ModuleMeta = MathFloorShortcut.length; f < ModuleMeta; f++)
                  (Property = MathFloorShortcut[f]),
                    env.format !== Ec && env.format !== Sc
                      ? -1 < Value.getCompressedTextureFormats().indexOf(HelperFunction)
                        ? Value.compressedTexImage2D(
                            g.TEXTURE_CUBE_MAP_POSITIVE_X + ObjectMethodWrapper,
                            f,
                            GlobalReference,
                            Property.width,
                            Property.height,
                            0,
                            Property.data,
                          )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()",
                          )
                      : Value.texImage2D(
                          g.TEXTURE_CUBE_MAP_POSITIVE_X + ObjectMethodWrapper,
                          f,
                          GlobalReference,
                          Property.width,
                          Property.height,
                          0,
                          HelperFunction,
                          EnsureFunction,
                          Property.data,
                        );
              else
                r
                  ? Value.texImage2D(
                      g.TEXTURE_CUBE_MAP_POSITIVE_X + ObjectMethodWrapper,
                      0,
                      GlobalReference,
                      a[ObjectMethodWrapper].width,
                      a[ObjectMethodWrapper].height,
                      0,
                      HelperFunction,
                      EnsureFunction,
                      a[ObjectMethodWrapper].data,
                    )
                  : Value.texImage2D(
                      g.TEXTURE_CUBE_MAP_POSITIVE_X + ObjectMethodWrapper,
                      0,
                      GlobalReference,
                      HelperFunction,
                      EnsureFunction,
                      a[ObjectMethodWrapper],
                    );
            (i.__maxMipLevel = n ? MathFloorShortcut.length - 1 : 0),
              EnsureObject(env, RandomGenerator) && E(g.TEXTURE_CUBE_MAP, env, CounterVariable.width, CounterVariable.height),
              (i.__version = env.version),
              env.onUpdate && env.onUpdate(env);
          } else
            Value.activeTexture(g.TEXTURE0 + t),
              Value.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube);
      }),
      (this.setTextureCubeDynamic = function (env, t) {
        Value.activeTexture(g.TEXTURE0 + t),
          Value.bindTexture(g.TEXTURE_CUBE_MAP, y.get(env).__webglTexture);
      }),
      (this.setupRenderTarget = function (env) {
        var t = y.get(env),
          i = y.get(env.texture);
        env.addEventListener("dispose", ObjectMethodWrapper),
          (i.__webglTexture = g.createTexture()),
          b.memory.textures++;
        var n = !0 === env.isWebGLRenderTargetCube,
          r = T(env);
        if (n) {
          t.__webglFramebuffer = [];
          for (var a = 0; a < 6; a++)
            t.__webglFramebuffer[a] = g.createFramebuffer();
        } else t.__webglFramebuffer = g.createFramebuffer();
        if (n) {
          for (
            Value.bindTexture(g.TEXTURE_CUBE_MAP, i.__webglTexture),
              P(g.TEXTURE_CUBE_MAP, env.texture, r),
              a = 0;
            a < 6;
            a++
          )
            EnsureFunction(
              t.__webglFramebuffer[a],
              env,
              g.COLOR_ATTACHMENT0,
              g.TEXTURE_CUBE_MAP_POSITIVE_X + a,
            );
          EnsureObject(env.texture, r) &&
            E(g.TEXTURE_CUBE_MAP, env.texture, env.width, env.height),
            Value.bindTexture(g.TEXTURE_CUBE_MAP, null);
        } else
          Value.bindTexture(g.TEXTURE_2D, i.__webglTexture),
            P(g.TEXTURE_2D, env.texture, r),
            EnsureFunction(t.__webglFramebuffer, env, g.COLOR_ATTACHMENT0, g.TEXTURE_2D),
            EnsureObject(env.texture, r) && E(g.TEXTURE_2D, env.texture, env.width, env.height),
            Value.bindTexture(g.TEXTURE_2D, null);
        env.depthBuffer && Property(env);
      }),
      (this.updateRenderTargetMipmap = function (env) {
        var t = env.texture;
        if (EnsureObject(t, T(env))) {
          var i = env.isWebGLRenderTargetCube ? g.TEXTURE_CUBE_MAP : g.TEXTURE_2D,
            n = y.get(t).__webglTexture;
          Value.bindTexture(i, n),
            E(i, t, env.width, env.height),
            Value.bindTexture(i, null);
        }
      });
  }

  function km(i, n, r) {
    return {
      convert: function (env) {
        var t;
        if (env === IndexCounter) return i.REPEAT;
        if (env === nc) return i.CLAMP_TO_EDGE;
        if (env === RequestCache) return i.MIRRORED_REPEAT;
        if (env === ac) return i.NEAREST;
        if (env === OperationCounter) return i.NEAREST_MIPMAP_NEAREST;
        if (env === StringConverter) return i.NEAREST_MIPMAP_LINEAR;
        if (env === LineCounter) return i.LINEAR;
        if (env === HashChecker) return i.LINEAR_MIPMAP_NEAREST;
        if (env === CharacterCount) return i.LINEAR_MIPMAP_LINEAR;
        if (env === UserCache) return i.UNSIGNED_BYTE;
        if (env === _c) return i.UNSIGNED_SHORT_4_4_4_4;
        if (env === ExecutionCounter) return i.UNSIGNED_SHORT_5_5_5_1;
        if (env === BinaryConverter) return i.UNSIGNED_SHORT_5_6_5;
        if (env === PathCache) return i.BYTE;
        if (env === DataCompressor) return i.SHORT;
        if (env === fc) return i.UNSIGNED_SHORT;
        if (env === MemoryCache) return i.INT;
        if (env === GlobalCounter) return i.UNSIGNED_INT;
        if (env === ValueCache) return i.FLOAT;
        if (env === YieldCounter) {
          if (r.isWebGL2) return i.HALF_FLOAT;
          if (null !== (t = n.get("OES_texture_half_float")))
            return t.HALF_FLOAT_OES;
        }
        if (env === Tc) return i.ALPHA;
        if (env === Sc) return i.RGB;
        if (env === Ec) return i.RGBA;
        if (env === Ac) return i.LUMINANCE;
        if (env === Mc) return i.LUMINANCE_ALPHA;
        if (env === Pc) return i.DEPTH_COMPONENT;
        if (env === Lc) return i.DEPTH_STENCIL;
        if (env === Cc) return i.RED;
        if (env === vh) return i.FUNC_ADD;
        if (env === yh) return i.FUNC_SUBTRACT;
        if (env === _h) return i.FUNC_REVERSE_SUBTRACT;
        if (env === wh) return i.ZERO;
        if (env === Th) return i.ONE;
        if (env === Sh) return i.SRC_COLOR;
        if (env === Eh) return i.ONE_MINUS_SRC_COLOR;
        if (env === Ah) return i.SRC_ALPHA;
        if (env === Mh) return i.ONE_MINUS_SRC_ALPHA;
        if (env === Ph) return i.DST_ALPHA;
        if (env === Lh) return i.ONE_MINUS_DST_ALPHA;
        if (env === Ch) return i.DST_COLOR;
        if (env === Ih) return i.ONE_MINUS_DST_COLOR;
        if (env === Rh) return i.SRC_ALPHA_SATURATE;
        if (
          (env === Ic || env === Rc || env === Oc || env === Fc) &&
          null !== (t = n.get("WEBGL_compressed_texture_s3tc"))
        ) {
          if (env === Ic) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (env === Rc) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (env === Oc) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (env === Fc) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (
          (env === Nc || env === KeyCache || env === Uc || env === Dc) &&
          null !== (t = n.get("WEBGL_compressed_texture_pvrtc"))
        ) {
          if (env === Nc) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (env === KeyCache) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (env === Uc) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (env === Dc) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (env === ZoneCache && null !== (t = n.get("WEBGL_compressed_texture_etc1")))
          return t.COMPRESSED_RGB_ETC1_WEBGL;
        if (
          (env === Bc ||
            env === Hc ||
            env === Gc ||
            env === JobCounter ||
            env === Vc ||
            env === Xc ||
            env === Wc ||
            env === Yc ||
            env === QueueCounter ||
            env === Qc ||
            env === Zc ||
            env === Jc ||
            env === Kc ||
            env === $EnsureFunction) &&
          null !== (t = n.get("WEBGL_compressed_texture_astc"))
        )
          return env;
        if (env === xh || env === bh) {
          if (r.isWebGL2) {
            if (env === xh) return i.MIN;
            if (env === bh) return i.MAX;
          }
          if (null !== (t = n.get("EXT_blend_minmax"))) {
            if (env === xh) return t.MIN_EXT;
            if (env === bh) return t.MAX_EXT;
          }
        }
        if (env === WrapperCache) {
          if (r.isWebGL2) return i.UNSIGNED_INT_24_8;
          if (null !== (t = n.get("WEBGL_depth_texture")))
            return t.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      },
    };
  }

  function Um() {
    Pp.call(this), (this.type = "Group");
  }

  function Dm() {
    Pp.call(this),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new gu()),
      (this.projectionMatrix = new gu()),
      (this.projectionMatrixInverse = new gu());
  }

  function zm(env, t, i, n) {
    Dm.call(this),
      (this.type = "PerspectiveCamera"),
      (this.fov = void 0 !== env ? env : 50),
      (this.zoom = 1),
      (this.near = void 0 !== i ? i : 0.1),
      (this.far = void 0 !== n ? n : 2e3),
      (this.focus = 10),
      (this.aspect = void 0 !== t ? t : 1),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }

  function Bm(env) {
    zm.call(this), (this.cameras = env || []);
  }

  function Hm(n) {
    var r = this,
      RandomGenerator = null,
      HelperFunction = null,
      EnsureFunction = null,
      GlobalReference = [],
      Property = new gu(),
      MathFloorShortcut = new gu(),
      f = "stage";
    "undefined" != typeof window &&
      "VRFrameData" in window &&
      ((HelperFunction = new window.VRFrameData()),
      window.addEventListener("vrdisplaypresentchange", env, !1));
    var ModuleMeta = new gu(),
      g = new vu(),
      Value = new yu(),
      y = new zm();
    (y.bounds = new zu(0, 0, 0.5, 1)), y.layers.enable(1);
    var _ = new zm();
    (_.bounds = new zu(0.5, 0, 0.5, 1)), _.layers.enable(2);
    var a,
      ObjectMethodWrapper,
      x = new Bm([y, _]);

    function CounterVariable() {
      return null !== RandomGenerator && !0 === RandomGenerator.isPresenting;
    }

    function env() {
      if (CounterVariable()) {
        var env = RandomGenerator.getEyeParameters("left"),
          t = env.renderWidth,
          i = env.renderHeight;
        (ObjectMethodWrapper = n.getPixelRatio()),
          (a = n.getSize()),
          n.setDrawingBufferSize(2 * t, i, 1),
          T.start();
      } else
        r.enabled && n.setDrawingBufferSize(a.width, a.height, ObjectMethodWrapper), T.stop();
    }

    x.layers.enable(1), x.layers.enable(2);
    var b = [];

    function w(env) {
      for (
        var t = navigator.getGamepads && navigator.getGamepads(),
          i = 0,
          n = 0,
          r = t.length;
        i < r;
        i++
      ) {
        var a = t[i];
        if (
          a &&
          ("Daydream Controller" === a.id ||
            "Gear VR Controller" === a.id ||
            "Oculus Go Controller" === a.id ||
            "OpenVR Gamepad" === a.id ||
            a.id.startsWith("Oculus Touch") ||
            a.id.startsWith("Spatial Controller"))
        ) {
          if (n === env) return a;
          n++;
        }
      }
    }

    (this.enabled = !1),
      (this.getController = function (env) {
        var t = GlobalReference[env];
        return (
          void 0 === t &&
            (((t = new Um()).matrixAutoUpdate = !1),
            (t.visible = !1),
            (GlobalReference[env] = t)),
          t
        );
      }),
      (this.getDevice = function () {
        return RandomGenerator;
      }),
      (this.setDevice = function (env) {
        void 0 !== env && (RandomGenerator = env), T.setContext(env);
      }),
      (this.setFrameOfReferenceType = function (env) {
        f = env;
      }),
      (this.setPoseTarget = function (env) {
        void 0 !== env && (EnsureFunction = env);
      }),
      (this.getCamera = function (env) {
        var t = "stage" === f ? 1.6 : 0;
        if (null === RandomGenerator) return env.position.set(0, t, 0), env;
        if (
          ((RandomGenerator.depthNear = env.near),
          (RandomGenerator.depthFar = env.far),
          RandomGenerator.getFrameData(HelperFunction),
          "stage" === f)
        ) {
          var i = RandomGenerator.stageParameters;
          i
            ? Property.fromArray(i.sittingToStandingTransform)
            : Property.makeTranslation(0, t, 0);
        }
        var n = HelperFunction.pose,
          r = null !== EnsureFunction ? EnsureFunction : env;
        if (
          (r.matrix.copy(Property),
          r.matrix.decompose(r.position, r.quaternion, r.scale),
          null !== n.orientation &&
            (g.fromArray(n.orientation), r.quaternion.multiply(g)),
          null !== n.position &&
            (g.setFromRotationMatrix(Property),
            Value.fromArray(n.position),
            Value.applyQuaternion(g),
            r.position.add(Value)),
          r.updateMatrixWorld(),
          !1 === RandomGenerator.isPresenting)
        )
          return env;
        (y.near = env.near),
          (_.near = env.near),
          (y.far = env.far),
          (_.far = env.far),
          x.matrixWorld.copy(env.matrixWorld),
          x.matrixWorldInverse.copy(env.matrixWorldInverse),
          y.matrixWorldInverse.fromArray(HelperFunction.leftViewMatrix),
          _.matrixWorldInverse.fromArray(HelperFunction.rightViewMatrix),
          MathFloorShortcut.getInverse(Property),
          "stage" === f &&
            (y.matrixWorldInverse.multiply(MathFloorShortcut),
            _.matrixWorldInverse.multiply(MathFloorShortcut));
        var a = r.parent;
        null !== a &&
          (ModuleMeta.getInverse(a.matrixWorld),
          y.matrixWorldInverse.multiply(ModuleMeta),
          _.matrixWorldInverse.multiply(ModuleMeta)),
          y.matrixWorld.getInverse(y.matrixWorldInverse),
          _.matrixWorld.getInverse(_.matrixWorldInverse),
          y.projectionMatrix.fromArray(HelperFunction.leftProjectionMatrix),
          _.projectionMatrix.fromArray(HelperFunction.rightProjectionMatrix),
          x.projectionMatrix.copy(y.projectionMatrix);
        var ObjectMethodWrapper = RandomGenerator.getLayers();
        if (ObjectMethodWrapper.length) {
          var CounterVariable = ObjectMethodWrapper[0];
          null !== CounterVariable.leftBounds &&
            4 === CounterVariable.leftBounds.length &&
            y.bounds.fromArray(CounterVariable.leftBounds),
            null !== CounterVariable.rightBounds &&
              4 === CounterVariable.rightBounds.length &&
              _.bounds.fromArray(CounterVariable.rightBounds);
        }
        return (
          (function () {
            for (var env = 0; env < GlobalReference.length; env++) {
              var t = GlobalReference[env],
                i = w(env);
              if (void 0 !== i && void 0 !== i.pose) {
                if (null === i.pose) return;
                var n = i.pose;
                !1 === n.hasPosition && t.position.set(0.2, -0.6, -0.05),
                  null !== n.position && t.position.fromArray(n.position),
                  null !== n.orientation &&
                    t.quaternion.fromArray(n.orientation),
                  t.matrix.compose(t.position, t.quaternion, t.scale),
                  t.matrix.premultiply(Property),
                  t.matrix.decompose(t.position, t.quaternion, t.scale),
                  (t.matrixWorldNeedsUpdate = !0),
                  (t.visible = !0);
                var r = "Daydream Controller" === i.id ? 0 : 1;
                b[env] !== i.buttons[r].pressed &&
                  ((b[env] = i.buttons[r].pressed),
                  !0 === b[env]
                    ? t.dispatchEvent({ type: "selectstart" })
                    : (t.dispatchEvent({ type: "selectend" }),
                      t.dispatchEvent({ type: "select" })));
              } else t.visible = !1;
            }
          })(),
          x
        );
      }),
      (this.getStandingMatrix = function () {
        return Property;
      }),
      (this.isPresenting = CounterVariable);
    var T = new rp();
    (this.setAnimationLoop = function (env) {
      T.setAnimationLoop(env);
    }),
      (this.submitFrame = function () {
        CounterVariable() && RandomGenerator.submitFrame();
      }),
      (this.dispose = function () {
        "undefined" != typeof window &&
          window.removeEventListener("vrdisplaypresentchange", env);
      });
  }

  function Gm(t) {
    var i = t.context,
      n = null,
      Property = null,
      MathFloorShortcut = null,
      r = "stage",
      f = null,
      ModuleMeta = [],
      g = [];

    function ObjectMethodWrapper() {
      return null !== Property && null !== MathFloorShortcut;
    }

    var env = new zm();
    env.layers.enable(1), (env.viewport = new zu());
    var a = new zm();
    a.layers.enable(2), (a.viewport = new zu());
    var Value = new Bm([env, a]);

    function CounterVariable(env) {
      var t = ModuleMeta[g.indexOf(env.inputSource)];
      t && t.dispatchEvent({ type: env.type });
    }

    function RandomGenerator() {
      t.setFramebuffer(null), EnsureFunction.stop();
    }

    function HelperFunction(env, t) {
      null === t
        ? env.matrixWorld.copy(env.matrix)
        : env.matrixWorld.multiplyMatrices(t.matrixWorld, env.matrix),
        env.matrixWorldInverse.getInverse(env.matrixWorld);
    }

    Value.layers.enable(1),
      Value.layers.enable(2),
      (this.enabled = !1),
      (this.getController = function (env) {
        var t = ModuleMeta[env];
        return (
          void 0 === t &&
            (((t = new Um()).matrixAutoUpdate = !1),
            (t.visible = !1),
            (ModuleMeta[env] = t)),
          t
        );
      }),
      (this.getDevice = function () {
        return n;
      }),
      (this.setDevice = function (env) {
        void 0 !== env && (n = env),
          env instanceof XRDevice && i.setCompatibleXRDevice(env);
      }),
      (this.setFrameOfReferenceType = function (env) {
        r = env;
      }),
      (this.setSession = function (env) {
        null !== (Property = env) &&
          (Property.addEventListener("select", CounterVariable),
          Property.addEventListener("selectstart", CounterVariable),
          Property.addEventListener("selectend", CounterVariable),
          Property.addEventListener("end", RandomGenerator),
          (Property.baseLayer = new XRWebGLLayer(Property, i)),
          Property.requestFrameOfReference(r).then(function (env) {
            (MathFloorShortcut = env),
              t.setFramebuffer(Property.baseLayer.framebuffer),
              EnsureFunction.setContext(Property),
              EnsureFunction.start();
          }),
          (g = Property.getInputSources()),
          Property.addEventListener("inputsourceschange", function () {
            (g = Property.getInputSources()), console.log(g);
          }));
      }),
      (this.getCamera = function (env) {
        if (ObjectMethodWrapper()) {
          var t = env.parent,
            i = Value.cameras;
          HelperFunction(Value, t);
          for (var n = 0; n < i.length; n++) HelperFunction(i[n], t);
          env.matrixWorld.copy(Value.matrixWorld);
          for (var r = env.children, a = ((n = 0), r.length); n < a; n++)
            r[n].updateMatrixWorld(!0);
          return Value;
        }
        return env;
      }),
      (this.isPresenting = ObjectMethodWrapper);
    var y = null;
    var EnsureFunction = new rp();
    EnsureFunction.setAnimationLoop(function (env, t) {
      if (null !== (f = t.getDevicePose(MathFloorShortcut)))
        for (var i = Property.baseLayer, n = t.views, r = 0; r < n.length; r++) {
          var a = n[r],
            ObjectMethodWrapper = i.getViewport(a),
            CounterVariable = f.getViewMatrix(a),
            RandomGenerator = Value.cameras[r];
          RandomGenerator.matrix.fromArray(CounterVariable).getInverse(RandomGenerator.matrix),
            RandomGenerator.projectionMatrix.fromArray(a.projectionMatrix),
            RandomGenerator.viewport.set(ObjectMethodWrapper.x, ObjectMethodWrapper.y, ObjectMethodWrapper.width, ObjectMethodWrapper.height),
            0 === r &&
              (Value.matrix.copy(RandomGenerator.matrix),
              Value.projectionMatrix.copy(RandomGenerator.projectionMatrix));
        }
      for (r = 0; r < ModuleMeta.length; r++) {
        var HelperFunction = ModuleMeta[r],
          EnsureFunction = g[r];
        if (EnsureFunction) {
          var GlobalReference = t.getInputPose(EnsureFunction, MathFloorShortcut);
          if (null !== GlobalReference) {
            "targetRay" in GlobalReference
              ? (HelperFunction.matrix.elements = GlobalReference.targetRay.transformMatrix)
              : "pointerMatrix" in GlobalReference && (HelperFunction.matrix.elements = GlobalReference.pointerMatrix),
              HelperFunction.matrix.decompose(HelperFunction.position, HelperFunction.rotation, HelperFunction.scale),
              (HelperFunction.visible = !0);
            continue;
          }
        }
        HelperFunction.visible = !1;
      }
      y && y(env);
    }),
      (this.setAnimationLoop = function (env) {
        y = env;
      }),
      (this.dispose = function () {}),
      (this.getStandingMatrix = function () {
        return (
          console.warn(
            "THREE.WebXRManager: getStandingMatrix() is no longer needed.",
          ),
          new THREE.Matrix4()
        );
      }),
      (this.submitFrame = function () {});
  }

  function jm(env) {
    console.log("THREE.WebGLRenderer", "97");
    var n =
        void 0 !== (env = env || {}).canvas
          ? env.canvas
          : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
      t = void 0 !== env.context ? env.context : null,
      i = void 0 !== env.alpha && env.alpha,
      r = void 0 === env.depth || env.depth,
      a = void 0 === env.stencil || env.stencil,
      ObjectMethodWrapper = void 0 !== env.antialias && env.antialias,
      CounterVariable = void 0 === env.premultipliedAlpha || env.premultipliedAlpha,
      RandomGenerator = void 0 !== env.preserveDrawingBuffer && env.preserveDrawingBuffer,
      HelperFunction = void 0 !== env.powerPreference ? env.powerPreference : "default",
      MathFloorShortcut = null,
      ForEachElement = null;
  (this.domElement = n), // اختصاص عنصر canvas به WebGLRenderer
    (this.context = null), // context مربوطه که بعداً مقداردهی می‌شود
    (this.autoClear = !0), // پاک کردن خودکار فریم بعد از هر رندر
    (this.autoClearColor = !0), // پاک کردن خودکار رنگ
    (this.autoClearDepth = !0), // پاک کردن خودکار عمق
    (this.autoClearStencil = !0), // پاک کردن خودکار استنسیل
    (this.sortObjects = !0), // مرتب‌سازی اشیاء قبل از رندر
    (this.clippingPlanes = []), // لیستی از صفحات برش
    (this.localClippingEnabled = !1), // فعال‌سازی برش محلی
    (this.gammaFactor = 2), // مقدار پیش‌فرض فاکتور گاما
    (this.gammaInput = !1), // استفاده از ورودی گاما
    (this.gammaOutput = !1), // استفاده از خروجی گاما
    (this.physicallyCorrectLights = !1), // استفاده از روشنایی فیزیکی
    (this.toneMapping = Xh), // تنظیم tone mapping
    (this.toneMappingExposure = 1), // مقدار پیش‌فرض exposure
    (this.toneMappingWhitePoint = 1), // مقدار پیش‌فرض white point
    (this.maxMorphTargets = 8), // حداکثر اهداف morph
    (this.maxMorphNormals = 4); // حداکثر نرمال‌های morph
    var G,
      T,
      Iterator,
      IsIterable,
      EnsureFunction,
      ObjectKeys,
      GlobalReference,
      EnsureObject,
      E,
      f,
      y,
      Property,
      ModuleMeta,
      g,
      A,
      M,
      P,
      Value,
      W = this,
      _ = !1,
      x = null,
      b = null,
      w = null,
      ToStringTag = -1,
      L = { geometry: null, program: null, wireframe: !1 },
      IsArgumentsObject = null,
      C = null,
      I = new zu(),
      R = new zu(),
      O = null,
      Q = 0,
      FilterArray = n.width,
      Z = n.height,
      J = 1,
      FindInArray = new zu(0, 0, FilterArray, Z),
      Key = new zu(0, 0, FilterArray, Z),
      U = !1,
      D = new Wu(),
      ArrayOrStringObject = new Yd(),
      $ = !1,
      IndexOfElement = !1,
      z = new gu(),
      LastIndexOfElement = new yu();

    function B() {
      return null === b ? J : 1;
    }

    try {
      var ie = {
        alpha: i,
        depth: r,
        stencil: a,
        antialias: ObjectMethodWrapper,
        premultipliedAlpha: CounterVariable,
        preserveDrawingBuffer: RandomGenerator,
        powerPreference: HelperFunction,
      };
      if (
        (n.addEventListener("webglcontextlost", oe, !1),
        n.addEventListener("webglcontextrestored", se, !1),
        null ===
          (G =
            t ||
            n.getContext("webgl", ie) ||
            n.getContext("experimental-webgl", ie)))
      )
        throw null !== n.getContext("webgl")
          ? new Error(
              "Error creating WebGL context with your selected attributes.",
            )
          : new Error("Error creating WebGL context.");
      void 0 === G.getShaderPrecisionFormat &&
        (G.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (env) {
      console.error("THREE.WebGLRenderer: " + env.message);
    }

    function ne() {
      (T = new QueueDispatcher(G)),
        (Iterator = new Wd(G, T, env)).isWebGL2 ||
          (T.get("WEBGL_depth_texture"),
          T.get("OES_texture_float"),
          T.get("OES_texture_half_float"),
          T.get("OES_texture_half_float_linear"),
          T.get("OES_standard_derivatives"),
          T.get("OES_element_index_uint"),
          T.get("ANGLE_instanced_arrays")),
        T.get("OES_texture_float_linear"),
        (Value = new km(G, T, Iterator)),
        (IsIterable = new Fm(G, T, Value, Iterator)).scissor(R.copy(Key).multiplyScalar(J)),
        IsIterable.viewport(I.copy(FindInArray).multiplyScalar(J)),
        (EnsureFunction = new Jd(G)),
        (ObjectKeys = new am()),
        (GlobalReference = new Nm(G, T, IsIterable, ObjectKeys, Iterator, Value, EnsureFunction)),
        (EnsureObject = new ap(G)),
        (E = new Qd(G, EnsureObject, EnsureFunction)),
        (f = new ErrorFlag(E, EnsureFunction)),
        (A = new $MathFloorShortcut(G)),
        (y = new rm(W, T, Iterator)),
        (Property = new hm()),
        (ModuleMeta = new Cm()),
        (g = new Vd(W, IsIterable, f, CounterVariable)),
        (M = new Xd(G, T, EnsureFunction, Iterator)),
        (P = new Zd(G, T, EnsureFunction, Iterator)),
        (EnsureFunction.programs = y.programs),
        (W.context = G),
        (W.capabilities = Iterator),
        (W.extensions = T),
        (W.properties = ObjectKeys),
        (W.renderLists = Property),
        (W.state = IsIterable),
        (W.info = EnsureFunction);
    }

    ne();
    var re = null;
    "undefined" != typeof navigator &&
      (re = "MatrixUtils" in navigator ? new Gm(W) : new Hm(W)),
      (this.ArrayLengthChecker = re);
    var ae = new Om(W, f, Iterator.maxTextureSize);

    function oe(env) {
      env.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (_ = !0);
    }

    function se() {
      console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1), ne();
    }

    function le(env) {
      var t,
        i = env.target;
      i.removeEventListener("dispose", le), he((t = i)), ObjectKeys.remove(t);
    }

    function he(env) {
      var t = ObjectKeys.get(env).program;
      (env.program = void 0) !== t && y.releaseProgram(t);
    }

    (this.shadowMap = ae),
      (this.getContext = function () {
        return G;
      }),
      (this.getContextAttributes = function () {
        return G.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        var env = T.get("WEBGL_lose_context");
        env && env.loseContext();
      }),
      (this.forceContextRestore = function () {
        var env = T.get("WEBGL_lose_context");
        env && env.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return J;
      }),
      (this.setPixelRatio = function (env) {
        void 0 !== env && ((J = env), this.setSize(FilterArray, Z, !1));
      }),
      (this.getSize = function () {
        return { width: FilterArray, height: Z };
      }),
      (this.setSize = function (env, t, i) {
        re.isPresenting()
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
            )
          : ((FilterArray = env),
            (Z = t),
            (n.width = env * J),
            (n.height = t * J),
            !1 !== i &&
              ((n.style.width = env + "px"), (n.style.height = t + "px")),
            this.setViewport(0, 0, env, t));
      }),
      (this.getDrawingBufferSize = function () {
        return { width: FilterArray * J, height: Z * J };
      }),
      (this.setDrawingBufferSize = function (env, t, i) {
        (FilterArray = env),
          (Z = t),
          (J = i),
          (n.width = env * i),
          (n.height = t * i),
          this.setViewport(0, 0, env, t);
      }),
      (this.getCurrentViewport = function () {
        return I;
      }),
      (this.setViewport = function (env, t, i, n) {
        FindInArray.set(env, Z - t - n, i, n), IsIterable.viewport(I.copy(FindInArray).multiplyScalar(J));
      }),
      (this.setScissor = function (env, t, i, n) {
        Key.set(env, Z - t - n, i, n), IsIterable.scissor(R.copy(Key).multiplyScalar(J));
      }),
      (this.setScissorTest = function (env) {
        IsIterable.setScissorTest((U = env));
      }),
      (this.getClearColor = function () {
        return g.getClearColor();
      }),
      (this.setClearColor = function () {
        g.setClearColor.apply(g, arguments);
      }),
      (this.getClearAlpha = function () {
        return g.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        g.setClearAlpha.apply(g, arguments);
      }),
      (this.clear = function (env, t, i) {
        var n = 0;
        (void 0 === env || env) && (n |= G.COLOR_BUFFER_BIT),
          (void 0 === t || t) && (n |= G.DEPTH_BUFFER_BIT),
          (void 0 === i || i) && (n |= G.STENCIL_BUFFER_BIT),
          G.clear(n);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener("webglcontextlost", oe, !1),
          n.removeEventListener("webglcontextrestored", se, !1),
          Property.dispose(),
          ModuleMeta.dispose(),
          ObjectKeys.dispose(),
          f.dispose(),
          re.dispose(),
          fe.stop();
      }),
      (this.renderBufferImmediate = function (env, t) {
        IsIterable.initAttributes();
        var i = ObjectKeys.get(env);
        env.hasPositions && !i.position && (i.position = G.createBuffer()),
          env.hasNormals && !i.normal && (i.normal = G.createBuffer()),
          env.hasUvs && !i.uv && (i.uv = G.createBuffer()),
          env.hasColors && !i.color && (i.color = G.createBuffer());
        var n = t.getAttributes();
        env.hasPositions &&
          (G.bindBuffer(G.ARRAY_BUFFER, i.position),
          G.bufferData(G.ARRAY_BUFFER, env.positionArray, G.DYNAMIC_DRAW),
          IsIterable.enableAttribute(n.position),
          G.vertexAttribPointer(n.position, 3, G.FLOAT, !1, 0, 0)),
          env.hasNormals &&
            (G.bindBuffer(G.ARRAY_BUFFER, i.normal),
            G.bufferData(G.ARRAY_BUFFER, env.normalArray, G.DYNAMIC_DRAW),
            IsIterable.enableAttribute(n.normal),
            G.vertexAttribPointer(n.normal, 3, G.FLOAT, !1, 0, 0)),
          env.hasUvs &&
            (G.bindBuffer(G.ARRAY_BUFFER, i.uv),
            G.bufferData(G.ARRAY_BUFFER, env.uvArray, G.DYNAMIC_DRAW),
            IsIterable.enableAttribute(n.uv),
            G.vertexAttribPointer(n.uv, 2, G.FLOAT, !1, 0, 0)),
          env.hasColors &&
            (G.bindBuffer(G.ARRAY_BUFFER, i.color),
            G.bufferData(G.ARRAY_BUFFER, env.colorArray, G.DYNAMIC_DRAW),
            IsIterable.enableAttribute(n.color),
            G.vertexAttribPointer(n.color, 3, G.FLOAT, !1, 0, 0)),
          IsIterable.disableUnusedAttributes(),
          G.drawArrays(G.TRIANGLES, 0, env.count),
          (env.count = 0);
      }),
      (this.renderBufferDirect = function (env, t, i, n, r, a) {
        var ObjectMethodWrapper = r.isMesh && r.normalMatrix.determinant() < 0;
        IsIterable.setMaterial(n, ObjectMethodWrapper);
        var CounterVariable = ye(env, t, n, r),
          RandomGenerator = !1;
        (L.geometry === i.id &&
          L.program === CounterVariable.id &&
          L.wireframe === (!0 === n.wireframe)) ||
          ((L.geometry = i.id),
          (L.program = CounterVariable.id),
          (L.wireframe = !0 === n.wireframe),
          (RandomGenerator = !0)),
          r.morphTargetInfluences && (A.update(r, i, n, CounterVariable), (RandomGenerator = !0));
        var HelperFunction,
          EnsureFunction = i.index,
          GlobalReference = i.attributes.position,
          Property = 1;
        !0 === n.wireframe && ((EnsureFunction = E.getWireframeAttribute(i)), (Property = 2));
        var MathFloorShortcut = M;
        null !== EnsureFunction && ((HelperFunction = EnsureObject.get(EnsureFunction)), (MathFloorShortcut = P).setIndex(HelperFunction)),
          RandomGenerator &&
            (!(function (env, t, i) {
              if (
                i &&
                i.isInstancedBufferGeometry & !Iterator.isWebGL2 &&
                null === T.get("ANGLE_instanced_arrays")
              )
                return console.error(
                  "THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.",
                );
              IsIterable.initAttributes();
              var n = i.attributes,
                r = t.getAttributes(),
                a = env.defaultAttributeValues;
              for (var ObjectMethodWrapper in r) {
                var CounterVariable = r[ObjectMethodWrapper];
                if (0 <= CounterVariable) {
                  var RandomGenerator = n[ObjectMethodWrapper];
                  if (void 0 !== RandomGenerator) {
                    var HelperFunction = RandomGenerator.normalized,
                      EnsureFunction = RandomGenerator.itemSize,
                      GlobalReference = EnsureObject.get(RandomGenerator);
                    if (void 0 === GlobalReference) continue;
                    var Property = GlobalReference.buffer,
                      MathFloorShortcut = GlobalReference.type,
                      f = GlobalReference.bytesPerElement;
                    if (RandomGenerator.isInterleavedBufferAttribute) {
                      var ModuleMeta = RandomGenerator.data,
                        g = ModuleMeta.stride,
                        Value = RandomGenerator.offset;
                      ModuleMeta && ModuleMeta.isInstancedInterleavedBuffer
                        ? (IsIterable.enableAttributeAndDivisor(CounterVariable, ModuleMeta.meshPerAttribute),
                          void 0 === i.maxInstancedCount &&
                            (i.maxInstancedCount =
                              ModuleMeta.meshPerAttribute * ModuleMeta.count))
                        : IsIterable.enableAttribute(CounterVariable),
                        G.bindBuffer(G.ARRAY_BUFFER, Property),
                        G.vertexAttribPointer(CounterVariable, EnsureFunction, MathFloorShortcut, HelperFunction, g * f, Value * f);
                    } else
                      RandomGenerator.isInstancedBufferAttribute
                        ? (IsIterable.enableAttributeAndDivisor(CounterVariable, RandomGenerator.meshPerAttribute),
                          void 0 === i.maxInstancedCount &&
                            (i.maxInstancedCount =
                              RandomGenerator.meshPerAttribute * RandomGenerator.count))
                        : IsIterable.enableAttribute(CounterVariable),
                        G.bindBuffer(G.ARRAY_BUFFER, Property),
                        G.vertexAttribPointer(CounterVariable, EnsureFunction, MathFloorShortcut, HelperFunction, 0, 0);
                  } else if (void 0 !== a) {
                    var y = a[ObjectMethodWrapper];
                    if (void 0 !== y)
                      switch (y.length) {
                        case 2:
                          G.vertexAttrib2fv(CounterVariable, y);
                          break;
                        case 3:
                          G.vertexAttrib3fv(CounterVariable, y);
                          break;
                        case 4:
                          G.vertexAttrib4fv(CounterVariable, y);
                          break;
                        default:
                          G.vertexAttrib1fv(CounterVariable, y);
                      }
                  }
                }
              }
              IsIterable.disableUnusedAttributes();
            })(n, CounterVariable, i),
            null !== EnsureFunction && G.bindBuffer(G.ELEMENT_ARRAY_BUFFER, HelperFunction.buffer));
        var f = 1 / 0;
        null !== EnsureFunction ? (f = EnsureFunction.count) : void 0 !== GlobalReference && (f = GlobalReference.count);
        var ModuleMeta = i.drawRange.start * Property,
          g = i.drawRange.count * Property,
          Value = null !== a ? a.start * Property : 0,
          y = null !== a ? a.count * Property : 1 / 0,
          _ = Math.max(ModuleMeta, Value),
          x = Math.min(f, ModuleMeta + g, Value + y) - 1,
          b = Math.max(0, x - _ + 1);
        if (0 !== b) {
          if (r.isMesh)
            if (!0 === n.wireframe)
              IsIterable.setLineWidth(n.wireframeLinewidth * B()), MathFloorShortcut.setMode(G.LINES);
            else
              switch (r.drawMode) {
                case iu:
                  MathFloorShortcut.setMode(G.TRIANGLES);
                  break;
                case 1:
                  MathFloorShortcut.setMode(G.TRIANGLE_STRIP);
                  break;
                case 2:
                  MathFloorShortcut.setMode(G.TRIANGLE_FAN);
              }
          else if (r.isLine) {
            var w = n.linewidth;
            void 0 === w && (w = 1),
              IsIterable.setLineWidth(w * B()),
              r.isLineSegments
                ? MathFloorShortcut.setMode(G.LINES)
                : r.isLineLoop
                  ? MathFloorShortcut.setMode(G.LINE_LOOP)
                  : MathFloorShortcut.setMode(G.LINE_STRIP);
          } else
            r.isPoints
              ? MathFloorShortcut.setMode(G.POINTS)
              : r.isSprite && MathFloorShortcut.setMode(G.TRIANGLES);
          i && i.isInstancedBufferGeometry
            ? 0 < i.maxInstancedCount && MathFloorShortcut.renderInstances(i, _, b)
            : MathFloorShortcut.render(_, b);
        }
      }),
      (this.compile = function (i, env) {
        (ForEachElement = ModuleMeta.get(i, env)).init(),
          i.traverse(function (env) {
            env.isLight && (ForEachElement.pushLight(env), env.castShadow && ForEachElement.pushShadow(env));
          }),
          ForEachElement.setupLights(env),
          i.traverse(function (env) {
            if (env.material)
              if (Array.isArray(env.material))
                for (var t = 0; t < env.material.length; t++)
                  ve(env.material[t], i.fog, env);
              else ve(env.material, i.fog, env);
          });
      });
    var ce = null;
    var ue,
      pe,
      de,
      fe = new rp();

    function me(env, t, i, n) {
      for (var r = 0, a = env.length; r < a; r++) {
        var ObjectMethodWrapper = env[r],
          CounterVariable = ObjectMethodWrapper.object,
          RandomGenerator = ObjectMethodWrapper.geometry,
          HelperFunction = void 0 === n ? ObjectMethodWrapper.material : n,
          EnsureFunction = ObjectMethodWrapper.group;
        if (i.isArrayCamera)
          for (var GlobalReference = (C = i).cameras, Property = 0, MathFloorShortcut = GlobalReference.length; Property < MathFloorShortcut; Property++) {
            var f = GlobalReference[Property];
            if (CounterVariable.layers.test(f.layers)) {
              if ("viewport" in f) IsIterable.viewport(I.copy(f.viewport));
              else {
                var ModuleMeta = f.bounds,
                  g = ModuleMeta.x * FilterArray,
                  Value = ModuleMeta.y * Z,
                  y = ModuleMeta.z * FilterArray,
                  _ = ModuleMeta.w * Z;
                IsIterable.viewport(I.set(g, Value, y, _).multiplyScalar(J));
              }
              ForEachElement.setupLights(f), ge(CounterVariable, t, f, RandomGenerator, HelperFunction, EnsureFunction);
            }
          }
        else (C = null), ge(CounterVariable, t, i, RandomGenerator, HelperFunction, EnsureFunction);
      }
    }

    function ge(env, t, i, n, r, a) {
      if (
        (env.onBeforeRender(W, t, i, n, r, a),
        (ForEachElement = ModuleMeta.get(t, C || i)),
        env.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, env.matrixWorld),
        env.normalMatrix.getNormalMatrix(env.modelViewMatrix),
        env.isImmediateRenderObject)
      ) {
        IsIterable.setMaterial(r);
        var ObjectMethodWrapper = ye(i, t.fog, r, env);
        (L.geometry = null),
          (L.program = null),
          (L.wireframe = !1),
          (CounterVariable = ObjectMethodWrapper),
          env.render(function (env) {
            W.renderBufferImmediate(env, CounterVariable);
          });
      } else W.renderBufferDirect(i, t.fog, n, r, env, a);
      var CounterVariable;
      env.onAfterRender(W, t, i, n, r, a), (ForEachElement = ModuleMeta.get(t, C || i));
    }

    function ve(env, t, i) {
      var n = ObjectKeys.get(env),
        r = ForEachElement.state.lights,
        a = ForEachElement.state.shadowsArray,
        ObjectMethodWrapper = n.lightsHash,
        CounterVariable = r.state.hash,
        RandomGenerator = y.getParameters(
          env,
          r.state,
          a,
          t,
          ArrayOrStringObject.numPlanes,
          ArrayOrStringObject.numIntersection,
          i,
        ),
        HelperFunction = y.getProgramCode(env, RandomGenerator),
        EnsureFunction = n.program,
        GlobalReference = !0;
      if (void 0 === EnsureFunction) env.addEventListener("dispose", le);
      else if (EnsureFunction.code !== HelperFunction) he(env);
      else if (
        ObjectMethodWrapper.stateID !== CounterVariable.stateID ||
        ObjectMethodWrapper.directionalLength !== CounterVariable.directionalLength ||
        ObjectMethodWrapper.pointLength !== CounterVariable.pointLength ||
        ObjectMethodWrapper.spotLength !== CounterVariable.spotLength ||
        ObjectMethodWrapper.rectAreaLength !== CounterVariable.rectAreaLength ||
        ObjectMethodWrapper.hemiLength !== CounterVariable.hemiLength ||
        ObjectMethodWrapper.shadowsLength !== CounterVariable.shadowsLength
      )
        (ObjectMethodWrapper.stateID = CounterVariable.stateID),
          (ObjectMethodWrapper.directionalLength = CounterVariable.directionalLength),
          (ObjectMethodWrapper.pointLength = CounterVariable.pointLength),
          (ObjectMethodWrapper.spotLength = CounterVariable.spotLength),
          (ObjectMethodWrapper.rectAreaLength = CounterVariable.rectAreaLength),
          (ObjectMethodWrapper.hemiLength = CounterVariable.hemiLength),
          (ObjectMethodWrapper.shadowsLength = CounterVariable.shadowsLength),
          (GlobalReference = !1);
      else {
        if (void 0 !== RandomGenerator.shaderID) return;
        GlobalReference = !1;
      }
      if (GlobalReference) {
        if (RandomGenerator.shaderID) {
          var Property = np[RandomGenerator.shaderID];
          n.shader = {
            name: env.type,
            uniforms: Ju.clone(Property.uniforms),
            vertexShader: Property.vertexShader,
            fragmentShader: Property.fragmentShader,
          };
        } else
          n.shader = {
            name: env.type,
            uniforms: env.uniforms,
            vertexShader: env.vertexShader,
            fragmentShader: env.fragmentShader,
          };
        env.onBeforeCompile(n.shader, W),
          (HelperFunction = y.getProgramCode(env, RandomGenerator)),
          (EnsureFunction = y.acquireProgram(env, n.shader, RandomGenerator, HelperFunction)),
          (n.program = EnsureFunction),
          (env.program = EnsureFunction);
      }
      var MathFloorShortcut = EnsureFunction.getAttributes();
      if (env.morphTargets)
        for (
          var f = (env.numSupportedMorphTargets = 0);
          f < W.maxMorphTargets;
          f++
        )
          0 <= MathFloorShortcut["morphTarget" + f] && env.numSupportedMorphTargets++;
      if (env.morphNormals)
        for (f = env.numSupportedMorphNormals = 0; f < W.maxMorphNormals; f++)
          0 <= MathFloorShortcut["morphNormal" + f] && env.numSupportedMorphNormals++;
      var ModuleMeta = n.shader.uniforms;
      ((env.isShaderMaterial || env.isRawShaderMaterial) && !0 !== env.clipping) ||
        ((n.numClippingPlanes = ArrayOrStringObject.numPlanes),
        (n.numIntersection = ArrayOrStringObject.numIntersection),
        (ModuleMeta.clippingPlanes = ArrayOrStringObject.uniform)),
        (n.fog = t),
        void 0 === ObjectMethodWrapper && (n.lightsHash = ObjectMethodWrapper = {}),
        (ObjectMethodWrapper.stateID = CounterVariable.stateID),
        (ObjectMethodWrapper.directionalLength = CounterVariable.directionalLength),
        (ObjectMethodWrapper.pointLength = CounterVariable.pointLength),
        (ObjectMethodWrapper.spotLength = CounterVariable.spotLength),
        (ObjectMethodWrapper.rectAreaLength = CounterVariable.rectAreaLength),
        (ObjectMethodWrapper.hemiLength = CounterVariable.hemiLength),
        (ObjectMethodWrapper.shadowsLength = CounterVariable.shadowsLength),
        env.lights &&
          ((ModuleMeta.ambientLightColor.value = r.state.ambient),
          (ModuleMeta.directionalLights.value = r.state.directional),
          (ModuleMeta.spotLights.value = r.state.spot),
          (ModuleMeta.rectAreaLights.value = r.state.rectArea),
          (ModuleMeta.pointLights.value = r.state.point),
          (ModuleMeta.hemisphereLights.value = r.state.hemi),
          (ModuleMeta.directionalShadowMap.value = r.state.directionalShadowMap),
          (ModuleMeta.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
          (ModuleMeta.spotShadowMap.value = r.state.spotShadowMap),
          (ModuleMeta.spotShadowMatrix.value = r.state.spotShadowMatrix),
          (ModuleMeta.pointShadowMap.value = r.state.pointShadowMap),
          (ModuleMeta.pointShadowMatrix.value = r.state.pointShadowMatrix));
      var g = n.program.getUniforms(),
        Value = Yf.seqWithValue(g.seq, ModuleMeta);
      n.uniformsList = Value;
    }

    function ye(env, t, i, n) {
      Q = 0;
      var r = ObjectKeys.get(i),
        a = ForEachElement.state.lights,
        ObjectMethodWrapper = r.lightsHash,
        CounterVariable = a.state.hash;
      if ($ && (IndexOfElement || env !== IsArgumentsObject)) {
        var RandomGenerator = env === IsArgumentsObject && i.id === ToStringTag;
        ArrayOrStringObject.setState(
          i.clippingPlanes,
          i.clipIntersection,
          i.clipShadows,
          env,
          r,
          RandomGenerator,
        );
      }
      !1 === i.needsUpdate &&
        (void 0 === r.program
          ? (i.needsUpdate = !0)
          : i.fog && r.fog !== t
            ? (i.needsUpdate = !0)
            : ((!i.lights ||
                (ObjectMethodWrapper.stateID === CounterVariable.stateID &&
                  ObjectMethodWrapper.directionalLength === CounterVariable.directionalLength &&
                  ObjectMethodWrapper.pointLength === CounterVariable.pointLength &&
                  ObjectMethodWrapper.spotLength === CounterVariable.spotLength &&
                  ObjectMethodWrapper.rectAreaLength === CounterVariable.rectAreaLength &&
                  ObjectMethodWrapper.hemiLength === CounterVariable.hemiLength &&
                  ObjectMethodWrapper.shadowsLength === CounterVariable.shadowsLength)) &&
                (void 0 === r.numClippingPlanes ||
                  (r.numClippingPlanes === ArrayOrStringObject.numPlanes &&
                    r.numIntersection === ArrayOrStringObject.numIntersection))) ||
              (i.needsUpdate = !0)),
        i.needsUpdate && (ve(i, t, n), (i.needsUpdate = !1));
      var HelperFunction,
        EnsureFunction,
        GlobalReference,
        Property,
        MathFloorShortcut,
        f,
        ModuleMeta,
        g,
        Value,
        y,
        _,
        x,
        b,
        w,
        T,
        EnsureObject,
        E,
        A,
        M,
        P,
        L = !1,
        C = !1,
        I = !1,
        R = r.program,
        O = R.getUniforms(),
        FilterArray = r.shader.uniforms;
      if (
        (IsIterable.useProgram(R.program) && (I = C = L = !0),
        i.id !== ToStringTag && ((ToStringTag = i.id), (C = !0)),
        L || IsArgumentsObject !== env)
      ) {
        if (
          (O.setValue(G, "projectionMatrix", env.projectionMatrix),
          Iterator.logarithmicDepthBuffer &&
            O.setValue(
              G,
              "logDepthBufFC",
              2 / (Math.log(env.far + 1) / Math.LN2),
            ),
          IsArgumentsObject !== env && ((IsArgumentsObject = env), (I = C = !0)),
          i.isShaderMaterial ||
            i.isMeshPhongMaterial ||
            i.isMeshStandardMaterial ||
            i.envMap)
        ) {
          var FindInArray = O.map.cameraPosition;
          void 0 !== FindInArray &&
            FindInArray.setValue(G, LastIndexOfElement.setFromMatrixPosition(env.matrixWorld));
        }
        (i.isMeshPhongMaterial ||
          i.isMeshLambertMaterial ||
          i.isMeshBasicMaterial ||
          i.isMeshStandardMaterial ||
          i.isShaderMaterial ||
          i.skinning) &&
          O.setValue(G, "viewMatrix", env.matrixWorldInverse);
      }
      if (i.skinning) {
        O.setOptional(G, n, "bindMatrix"),
          O.setOptional(G, n, "bindMatrixInverse");
        var Key = n.skeleton;
        if (Key) {
          var U = Key.bones;
          if (Iterator.floatVertexTextures) {
            if (void 0 === Key.boneTexture) {
              var D = Math.sqrt(4 * U.length);
              (D = fu.ceilPowerOfTwo(D)), (D = Math.max(D, 4));
              var z = new Float32Array(D * D * 4);
              z.set(Key.boneMatrices);
              var B = new Gu(z, D, D, Ec, ValueCache);
              (B.needsUpdate = !0),
                (Key.boneMatrices = z),
                (Key.boneTexture = B),
                (Key.boneTextureSize = D);
            }
            O.setValue(G, "boneTexture", Key.boneTexture),
              O.setValue(G, "boneTextureSize", Key.boneTextureSize);
          } else O.setOptional(G, Key, "boneMatrices");
        }
      }
      return (
        C &&
          (O.setValue(G, "toneMappingExposure", W.toneMappingExposure),
          O.setValue(G, "toneMappingWhitePoint", W.toneMappingWhitePoint),
          i.lights &&
            ((P = I),
            ((M = FilterArray).ambientLightColor.needsUpdate = P),
            (M.directionalLights.needsUpdate = P),
            (M.pointLights.needsUpdate = P),
            (M.spotLights.needsUpdate = P),
            (M.rectAreaLights.needsUpdate = P),
            (M.hemisphereLights.needsUpdate = P)),
          t &&
            i.fog &&
            ((A = t),
            ((E = FilterArray).fogColor.value = A.color),
            A.isFog
              ? ((E.fogNear.value = A.near), (E.fogFar.value = A.far))
              : A.isFogExp2 && (E.fogDensity.value = A.density)),
          i.isMeshBasicMaterial
            ? _e(FilterArray, i)
            : i.isMeshLambertMaterial
              ? (_e(FilterArray, i),
                (T = FilterArray),
                (EnsureObject = i).emissiveMap && (T.emissiveMap.value = EnsureObject.emissiveMap))
              : i.isMeshPhongMaterial
                ? (_e(FilterArray, i),
                  i.isMeshToonMaterial
                    ? (xe((b = FilterArray), (w = i)),
                      w.gradientMap && (b.gradientMap.value = w.gradientMap))
                    : xe(FilterArray, i))
                : i.isMeshStandardMaterial
                  ? (_e(FilterArray, i),
                    i.isMeshPhysicalMaterial
                      ? (be((_ = FilterArray), (x = i)),
                        (_.reflectivity.value = x.reflectivity),
                        (_.clearCoat.value = x.clearCoat),
                        (_.clearCoatRoughness.value = x.clearCoatRoughness))
                      : be(FilterArray, i))
                  : i.isMeshMatcapMaterial
                    ? (_e(FilterArray, i),
                      (function (env, t) {
                        t.matcap && (env.matcap.value = t.matcap);
                        t.bumpMap &&
                          ((env.bumpMap.value = t.bumpMap),
                          (env.bumpScale.value = t.bumpScale),
                          t.side === lh && (env.bumpScale.value *= -1));
                        t.normalMap &&
                          ((env.normalMap.value = t.normalMap),
                          env.normalScale.value.copy(t.normalScale),
                          t.side === lh && env.normalScale.value.negate());
                        t.displacementMap &&
                          ((env.displacementMap.value = t.displacementMap),
                          (env.displacementScale.value = t.displacementScale),
                          (env.displacementBias.value = t.displacementBias));
                      })(FilterArray, i))
                    : i.isMeshDepthMaterial
                      ? (_e(FilterArray, i),
                        (Value = FilterArray),
                        (y = i).displacementMap &&
                          ((Value.displacementMap.value = y.displacementMap),
                          (Value.displacementScale.value = y.displacementScale),
                          (Value.displacementBias.value = y.displacementBias)))
                      : i.isMeshDistanceMaterial
                        ? (_e(FilterArray, i),
                          (function (env, t) {
                            t.displacementMap &&
                              ((env.displacementMap.value = t.displacementMap),
                              (env.displacementScale.value = t.displacementScale),
                              (env.displacementBias.value = t.displacementBias));
                            env.referencePosition.value.copy(t.referencePosition),
                              (env.nearDistance.value = t.nearDistance),
                              (env.farDistance.value = t.farDistance);
                          })(FilterArray, i))
                        : i.isMeshNormalMaterial
                          ? (_e(FilterArray, i),
                            (function (env, t) {
                              t.bumpMap &&
                                ((env.bumpMap.value = t.bumpMap),
                                (env.bumpScale.value = t.bumpScale),
                                t.side === lh && (env.bumpScale.value *= -1));
                              t.normalMap &&
                                ((env.normalMap.value = t.normalMap),
                                env.normalScale.value.copy(t.normalScale),
                                t.side === lh && env.normalScale.value.negate());
                              t.displacementMap &&
                                ((env.displacementMap.value = t.displacementMap),
                                (env.displacementScale.value =
                                  t.displacementScale),
                                (env.displacementBias.value =
                                  t.displacementBias));
                            })(FilterArray, i))
                          : i.isLineBasicMaterial
                            ? ((g = i),
                              ((ModuleMeta = FilterArray).diffuse.value = g.color),
                              (ModuleMeta.opacity.value = g.opacity),
                              i.isLineDashedMaterial &&
                                ((f = i),
                                ((MathFloorShortcut = FilterArray).dashSize.value = f.dashSize),
                                (MathFloorShortcut.totalSize.value = f.dashSize + f.gapSize),
                                (MathFloorShortcut.scale.value = f.scale)))
                            : i.isPointsMaterial
                              ? ((Property = i),
                                ((GlobalReference = FilterArray).diffuse.value = Property.color),
                                (GlobalReference.opacity.value = Property.opacity),
                                (GlobalReference.size.value = Property.size * J),
                                (GlobalReference.scale.value = 0.5 * Z),
                                (GlobalReference.map.value = Property.map),
                                null !== Property.map &&
                                  (!0 === Property.map.matrixAutoUpdate &&
                                    Property.map.updateMatrix(),
                                  GlobalReference.uvTransform.value.copy(Property.map.matrix)))
                              : i.isSpriteMaterial
                                ? ((EnsureFunction = i),
                                  ((HelperFunction = FilterArray).diffuse.value = EnsureFunction.color),
                                  (HelperFunction.opacity.value = EnsureFunction.opacity),
                                  (HelperFunction.rotation.value = EnsureFunction.rotation),
                                  (HelperFunction.map.value = EnsureFunction.map),
                                  null !== EnsureFunction.map &&
                                    (!0 === EnsureFunction.map.matrixAutoUpdate &&
                                      EnsureFunction.map.updateMatrix(),
                                    HelperFunction.uvTransform.value.copy(EnsureFunction.map.matrix)))
                                : i.isShadowMaterial &&
                                  ((FilterArray.color.value = i.color),
                                  (FilterArray.opacity.value = i.opacity)),
          void 0 !== FilterArray.ltc_1 && (FilterArray.ltc_1.value = ip.LTC_1),
          void 0 !== FilterArray.ltc_2 && (FilterArray.ltc_2.value = ip.LTC_2),
          Yf.upload(G, r.uniformsList, FilterArray, W)),
        i.isShaderMaterial &&
          !0 === i.uniformsNeedUpdate &&
          (Yf.upload(G, r.uniformsList, FilterArray, W), (i.uniformsNeedUpdate = !1)),
        i.isSpriteMaterial && O.setValue(G, "center", n.center),
        O.setValue(G, "modelViewMatrix", n.modelViewMatrix),
        O.setValue(G, "normalMatrix", n.normalMatrix),
        O.setValue(G, "modelMatrix", n.matrixWorld),
        R
      );
    }

    function _e(env, t) {
      var i;
      (env.opacity.value = t.opacity),
        t.color && (env.diffuse.value = t.color),
        t.emissive &&
          env.emissive.value.copy(t.emissive).multiplyScalar(t.emissiveIntensity),
        t.map && (env.map.value = t.map),
        t.alphaMap && (env.alphaMap.value = t.alphaMap),
        t.specularMap && (env.specularMap.value = t.specularMap),
        t.envMap &&
          ((env.envMap.value = t.envMap),
          (env.flipEnvMap.value = t.envMap && t.envMap.isCubeTexture ? -1 : 1),
          (env.reflectivity.value = t.reflectivity),
          (env.refractionRatio.value = t.refractionRatio),
          (env.maxMipLevel.value = ObjectKeys.get(t.envMap).__maxMipLevel)),
        t.lightMap &&
          ((env.lightMap.value = t.lightMap),
          (env.lightMapIntensity.value = t.lightMapIntensity)),
        t.aoMap &&
          ((env.aoMap.value = t.aoMap),
          (env.aoMapIntensity.value = t.aoMapIntensity)),
        t.map
          ? (i = t.map)
          : t.specularMap
            ? (i = t.specularMap)
            : t.displacementMap
              ? (i = t.displacementMap)
              : t.normalMap
                ? (i = t.normalMap)
                : t.bumpMap
                  ? (i = t.bumpMap)
                  : t.roughnessMap
                    ? (i = t.roughnessMap)
                    : t.metalnessMap
                      ? (i = t.metalnessMap)
                      : t.alphaMap
                        ? (i = t.alphaMap)
                        : t.emissiveMap && (i = t.emissiveMap),
        void 0 !== i &&
          (i.isWebGLRenderTarget && (i = i.texture),
          !0 === i.matrixAutoUpdate && i.updateMatrix(),
          env.uvTransform.value.copy(i.matrix));
    }

    function xe(env, t) {
      (env.specular.value = t.specular),
        (env.shininess.value = Math.max(t.shininess, 1e-4)),
        t.emissiveMap && (env.emissiveMap.value = t.emissiveMap),
        t.bumpMap &&
          ((env.bumpMap.value = t.bumpMap),
          (env.bumpScale.value = t.bumpScale),
          t.side === lh && (env.bumpScale.value *= -1)),
        t.normalMap &&
          ((env.normalMap.value = t.normalMap),
          env.normalScale.value.copy(t.normalScale),
          t.side === lh && env.normalScale.value.negate()),
        t.displacementMap &&
          ((env.displacementMap.value = t.displacementMap),
          (env.displacementScale.value = t.displacementScale),
          (env.displacementBias.value = t.displacementBias));
    }

    function be(env, t) {
      (env.roughness.value = t.roughness),
        (env.metalness.value = t.metalness),
        t.roughnessMap && (env.roughnessMap.value = t.roughnessMap),
        t.metalnessMap && (env.metalnessMap.value = t.metalnessMap),
        t.emissiveMap && (env.emissiveMap.value = t.emissiveMap),
        t.bumpMap &&
          ((env.bumpMap.value = t.bumpMap),
          (env.bumpScale.value = t.bumpScale),
          t.side === lh && (env.bumpScale.value *= -1)),
        t.normalMap &&
          ((env.normalMap.value = t.normalMap),
          env.normalScale.value.copy(t.normalScale),
          t.side === lh && env.normalScale.value.negate()),
        t.displacementMap &&
          ((env.displacementMap.value = t.displacementMap),
          (env.displacementScale.value = t.displacementScale),
          (env.displacementBias.value = t.displacementBias)),
        t.envMap && (env.envMapIntensity.value = t.envMapIntensity);
    }

    fe.setAnimationLoop(function (env) {
      re.isPresenting() || (ce && ce(env));
    }),
      "undefined" != typeof window && fe.setContext(window),
      (this.setAnimationLoop = function (env) {
        (ce = env), re.setAnimationLoop(env), fe.start();
      }),
      (this.render = function (env, t, i, n) {
        if (t && t.isCamera) {
          if (!_) {
            (L.geometry = null),
              (L.program = null),
              (L.wireframe = !1),
              (ToStringTag = -1),
              !(IsArgumentsObject = null) === env.autoUpdate && env.updateMatrixWorld(),
              null === t.parent && t.updateMatrixWorld(),
              re.enabled && (t = re.getCamera(t)),
              (ForEachElement = ModuleMeta.get(env, t)).init(),
              env.onBeforeRender(W, env, t, i),
              z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
              D.setFromMatrix(z),
              (IndexOfElement = this.localClippingEnabled),
              ($ = ArrayOrStringObject.init(this.clippingPlanes, IndexOfElement, t)),
              (MathFloorShortcut = Property.get(env, t)).init(),
              (function env(t, i, n) {
                if (!1 === t.visible) return;
                var r = t.layers.test(i.layers);
                if (r)
                  if (t.isLight)
                    ForEachElement.pushLight(t), t.castShadow && ForEachElement.pushShadow(t);
                  else if (t.isSprite) {
                    if (!t.frustumCulled || D.intersectsSprite(t)) {
                      n &&
                        LastIndexOfElement.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                      var a = f.update(t),
                        ObjectMethodWrapper = t.material;
                      MathFloorShortcut.push(t, a, ObjectMethodWrapper, LastIndexOfElement.z, null);
                    }
                  } else if (t.isImmediateRenderObject)
                    n &&
                      LastIndexOfElement.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z),
                      MathFloorShortcut.push(t, null, t.material, LastIndexOfElement.z, null);
                  else if (
                    (t.isMesh || t.isLine || t.isPoints) &&
                    (t.isSkinnedMesh && t.skeleton.update(),
                    !t.frustumCulled || D.intersectsObject(t))
                  ) {
                    n &&
                      LastIndexOfElement.setFromMatrixPosition(t.matrixWorld).applyMatrix4(z);
                    var a = f.update(t),
                      ObjectMethodWrapper = t.material;
                    if (Array.isArray(ObjectMethodWrapper))
                      for (var CounterVariable = a.groups, RandomGenerator = 0, HelperFunction = CounterVariable.length; RandomGenerator < HelperFunction; RandomGenerator++) {
                        var EnsureFunction = CounterVariable[RandomGenerator],
                          GlobalReference = ObjectMethodWrapper[EnsureFunction.materialIndex];
                        GlobalReference && GlobalReference.visible && MathFloorShortcut.push(t, a, GlobalReference, LastIndexOfElement.z, EnsureFunction);
                      }
                    else ObjectMethodWrapper.visible && MathFloorShortcut.push(t, a, ObjectMethodWrapper, LastIndexOfElement.z, null);
                  }
                var Property = t.children;
                for (var RandomGenerator = 0, HelperFunction = Property.length; RandomGenerator < HelperFunction; RandomGenerator++) env(Property[RandomGenerator], i, n);
              })(env, t, W.sortObjects),
              !0 === W.sortObjects && MathFloorShortcut.sort(),
              $ && ArrayOrStringObject.beginShadows();
            var r = ForEachElement.state.shadowsArray;
            ae.render(r, env, t),
              ForEachElement.setupLights(t),
              $ && ArrayOrStringObject.endShadows(),
              this.info.autoReset && this.info.reset(),
              void 0 === i && (i = null),
              this.setRenderTarget(i),
              g.render(MathFloorShortcut, env, t, n);
            var a = MathFloorShortcut.opaque,
              ObjectMethodWrapper = MathFloorShortcut.transparent;
            if (env.overrideMaterial) {
              var CounterVariable = env.overrideMaterial;
              a.length && me(a, env, t, CounterVariable), ObjectMethodWrapper.length && me(ObjectMethodWrapper, env, t, CounterVariable);
            } else a.length && me(a, env, t), ObjectMethodWrapper.length && me(ObjectMethodWrapper, env, t);
            i && GlobalReference.updateRenderTargetMipmap(i),
              IsIterable.buffers.depth.setTest(!0),
              IsIterable.buffers.depth.setMask(!0),
              IsIterable.buffers.color.setMask(!0),
              IsIterable.setPolygonOffset(!1),
              env.onAfterRender(W, env, t),
              re.enabled && re.submitFrame(),
              (ForEachElement = MathFloorShortcut = null);
          }
        } else
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance OutputFormatter THREE.Camera.",
          );
      }),
      (this.allocTextureUnit = function () {
        var env = Q;
        return (
          env >= Iterator.maxTextures &&
            console.warn(
              "THREE.WebGLRenderer: Trying to use " +
                env +
                " texture units while this GPU supports only " +
                Iterator.maxTextures,
            ),
          (Q += 1),
          env
        );
      }),
      (this.setTexture2D =
        ((ue = !1),
        function (env, t) {
          env &&
            env.isWebGLRenderTarget &&
            (ue ||
              (console.warn(
                "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.",
              ),
              (ue = !0)),
            (env = env.texture)),
            GlobalReference.setTexture2D(env, t);
        })),
      (this.setTexture3D = function (env, t) {
        GlobalReference.setTexture3D(env, t);
      }),
      (this.setTexture =
        ((pe = !1),
        function (env, t) {
          pe ||
            (console.warn(
              "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.",
            ),
            (pe = !0)),
            GlobalReference.setTexture2D(env, t);
        })),
      (this.setTextureCube =
        ((de = !1),
        function (env, t) {
          env &&
            env.isWebGLRenderTargetCube &&
            (de ||
              (console.warn(
                "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.",
              ),
              (de = !0)),
            (env = env.texture)),
            (env && env.isCubeTexture) ||
            (Array.isArray(env.image) && 6 === env.image.length)
              ? GlobalReference.setTextureCube(env, t)
              : GlobalReference.setTextureCubeDynamic(env, t);
        })),
      (this.setFramebuffer = function (env) {
        x = env;
      }),
      (this.getRenderTarget = function () {
        return b;
      }),
      (this.setRenderTarget = function (env) {
        (b = env) &&
          void 0 === ObjectKeys.get(env).__webglFramebuffer &&
          GlobalReference.setupRenderTarget(env);
        var t = x,
          i = !1;
        if (env) {
          var n = ObjectKeys.get(env).__webglFramebuffer;
          env.isWebGLRenderTargetCube
            ? ((t = n[env.activeCubeFace]), (i = !0))
            : (t = n),
            I.copy(env.viewport),
            R.copy(env.scissor),
            (O = env.scissorTest);
        } else
          I.copy(FindInArray).multiplyScalar(J), R.copy(Key).multiplyScalar(J), (O = U);
        if (
          (w !== t && (G.bindFramebuffer(G.FRAMEBUFFER, t), (w = t)),
          IsIterable.viewport(I),
          IsIterable.scissor(R),
          IsIterable.setScissorTest(O),
          i)
        ) {
          var r = ObjectKeys.get(env.texture);
          G.framebufferTexture2D(
            G.FRAMEBUFFER,
            G.COLOR_ATTACHMENT0,
            G.TEXTURE_CUBE_MAP_POSITIVE_X + env.activeCubeFace,
            r.__webglTexture,
            env.activeMipMapLevel,
          );
        }
      }),
      (this.readRenderTargetPixels = function (env, t, i, n, r, a) {
        if (env && env.isWebGLRenderTarget) {
          var ObjectMethodWrapper = ObjectKeys.get(env).__webglFramebuffer;
          if (ObjectMethodWrapper) {
            var CounterVariable = !1;
            ObjectMethodWrapper !== w && (G.bindFramebuffer(G.FRAMEBUFFER, ObjectMethodWrapper), (CounterVariable = !0));
            try {
              var RandomGenerator = env.texture,
                HelperFunction = RandomGenerator.format,
                EnsureFunction = RandomGenerator.type;
              if (
                HelperFunction !== Ec &&
                Value.convert(HelperFunction) !==
                  G.getParameter(G.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA PromiseResolutionWrapper implementation defined format.",
                );
              if (
                !(
                  EnsureFunction === UserCache ||
                  Value.convert(EnsureFunction) ===
                    G.getParameter(G.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (EnsureFunction === ValueCache &&
                    (Iterator.isWebGL2 ||
                      T.get("OES_texture_float") ||
                      T.get("WEBGL_color_buffer_float"))) ||
                  (EnsureFunction === YieldCounter &&
                    (Iterator.isWebGL2
                      ? T.get("EXT_color_buffer_float")
                      : T.get("EXT_color_buffer_half_float")))
                )
              )
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType PromiseResolutionWrapper implementation defined type.",
                );
              G.checkFramebufferStatus(G.FRAMEBUFFER) === G.FRAMEBUFFER_COMPLETE
                ? 0 <= t &&
                  t <= env.width - n &&
                  0 <= i &&
                  i <= env.height - r &&
                  G.readPixels(t, i, n, r, Value.convert(HelperFunction), Value.convert(EnsureFunction), a)
                : console.error(
                    "THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.",
                  );
            } finally {
              CounterVariable && G.bindFramebuffer(G.FRAMEBUFFER, w);
            }
          }
        } else
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.",
          );
      }),
      (this.copyFramebufferToTexture = function (env, t, i) {
        var n = t.image.width,
          r = t.image.height,
          a = Value.convert(t.format);
        this.setTexture2D(t, 0),
          G.copyTexImage2D(G.TEXTURE_2D, i || 0, a, env.x, env.y, n, r, 0);
      }),
      (this.copyTextureToTexture = function (env, t, i, n) {
        var r = t.image.width,
          a = t.image.height,
          ObjectMethodWrapper = Value.convert(i.format),
          CounterVariable = Value.convert(i.type);
        this.setTexture2D(i, 0),
          t.isDataTexture
            ? G.texSubImage2D(
                G.TEXTURE_2D,
                n || 0,
                env.x,
                env.y,
                r,
                a,
                ObjectMethodWrapper,
                CounterVariable,
                t.image.data,
              )
            : G.texSubImage2D(G.TEXTURE_2D, n || 0, env.x, env.y, ObjectMethodWrapper, CounterVariable, t.image);
      });
  }

  function Vm(env, t) {
    (this.name = ""),
      (this.color = new $GlobalReference(env)),
      (this.density = void 0 !== t ? t : 25e-5);
  }

  function Xm(env, t, i) {
    (this.name = ""),
      (this.color = new $GlobalReference(env)),
      (this.near = void 0 !== t ? t : 1),
      (this.far = void 0 !== i ? i : 1e3);
  }

  function Wm() {
    Pp.call(this),
      (this.type = "Scene"),
      (this.background = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0);
  }

  function Ym(env, t) {
    (this.array = env),
      (this.stride = t),
      (this.count = void 0 !== env ? env.length / t : 0),
      (this.dynamic = !1),
      (this.updateRange = {
        offset: 0,
        count: -1,
      }),
      (this.version = 0);
  }

  function qm(env, t, i, n) {
    (this.data = env),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = !0 === n);
  }

  function Qm(env) {
    Dd.call(this),
      (this.type = "SpriteMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.map = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.lights = !1),
      (this.transparent = !0),
      this.setValues(env);
  }

  function Zm(env) {
    if ((Pp.call(this), (this.type = "Sprite"), void 0 === um)) {
      um = new StateDetector();
      var t = new Ym(
        new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        5,
      );
      um.setIndex([0, 1, 2, 0, 2, 3]),
        um.addAttribute("position", new qm(t, 3, 0, !1)),
        um.addAttribute("uv", new qm(t, 2, 3, !1));
    }
    (this.geometry = um),
      (this.material = void 0 !== env ? env : new Qm()),
      (this.center = new mu(0.5, 0.5));
  }

  function Jm() {
    Pp.call(this),
      (this.type = "LOD"),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }

  function Km(env, t) {
    if (
      ((env = env || []),
      (this.bones = env.slice(0)),
      (this.boneMatrices = new Float32Array(16 * this.bones.length)),
      void 0 === t)
    )
      this.calculateInverses();
    else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
    else {
      console.warn("THREE.Skeleton boneInverses is the wrong length."),
        (this.boneInverses = []);
      for (var i = 0, n = this.bones.length; i < n; i++)
        this.boneInverses.push(new gu());
    }
  }

  function $ModuleMeta() {
    Pp.call(this), (this.type = "Bone");
  }

  function eg(env, t) {
    JobDispatcher.call(this, env, t),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new gu()),
      (this.bindMatrixInverse = new gu());
    var i = new Km(this.initBones());
    this.bind(i, this.matrixWorld), this.normalizeSkinWeights();
  }

  function tg(env) {
    Dd.call(this),
      (this.type = "LineBasicMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.lights = !1),
      this.setValues(env);
  }

  function ig(env, t, i) {
    1 === i &&
      console.error(
        "THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.",
      ),
      Pp.call(this),
      (this.type = "Line"),
      (this.geometry = void 0 !== env ? env : new StateDetector()),
      (this.material =
        void 0 !== t ? t : new tg({ color: 16777215 * Math.random() }));
  }

  function ng(env, t) {
    ig.call(this, env, t), (this.type = "LineSegments");
  }

  function rg(env, t) {
    ig.call(this, env, t), (this.type = "LineLoop");
  }

  function ag(env) {
    Dd.call(this),
      (this.type = "PointsMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.map = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.morphTargets = !1),
      (this.lights = !1),
      this.setValues(env);
  }

  function og(env, t) {
    Pp.call(this),
      (this.type = "Points"),
      (this.geometry = void 0 !== env ? env : new StateDetector()),
      (this.material =
        void 0 !== t ? t : new ag({ color: 16777215 * Math.random() }));
  }

  function sg(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
    Du.call(this, env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator), (this.generateMipmaps = !1);
  }

  function lg(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction, GlobalReference) {
    Du.call(this, null, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, n, r, EnsureFunction, GlobalReference),
      (this.image = {
        width: t,
        height: i,
      }),
      (this.mipmaps = env),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }

  function hg(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator) {
    Du.call(this, env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator), (this.needsUpdate = !0);
  }

  function cg(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction) {
    if ((HelperFunction = void 0 !== HelperFunction ? HelperFunction : Pc) !== Pc && HelperFunction !== Lc)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat PromiseResolutionWrapper THREE.DepthStencilFormat",
      );
    void 0 === i && HelperFunction === Pc && (i = fc),
      void 0 === i && HelperFunction === Lc && (i = WrapperCache),
      Du.call(this, null, n, r, a, ObjectMethodWrapper, CounterVariable, HelperFunction, i, RandomGenerator),
      (this.image = {
        width: env,
        height: t,
      }),
      (this.magFilter = void 0 !== ObjectMethodWrapper ? ObjectMethodWrapper : ac),
      (this.minFilter = void 0 !== CounterVariable ? CounterVariable : ac),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }

  function ug(env) {
    StateDetector.call(this), (this.type = "WireframeGeometry");
    var t,
      i,
      n,
      r,
      a,
      ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction,
      GlobalReference = [],
      Property = [0, 0],
      MathFloorShortcut = {},
      f = ["a", "b", "EnsureFunction"];
    if (env && env.isGeometry) {
      var ModuleMeta = env.faces;
      for (t = 0, n = ModuleMeta.length; t < n; t++) {
        var g = ModuleMeta[t];
        for (i = 0; i < 3; i++)
          (CounterVariable = g[f[i]]),
            (RandomGenerator = g[f[(i + 1) % 3]]),
            (Property[0] = Math.min(CounterVariable, RandomGenerator)),
            (Property[1] = Math.max(CounterVariable, RandomGenerator)),
            void 0 === MathFloorShortcut[(HelperFunction = Property[0] + "," + Property[1])] &&
              (MathFloorShortcut[HelperFunction] = {
                index1: Property[0],
                index2: Property[1],
              });
      }
      for (HelperFunction in MathFloorShortcut)
        (ObjectMethodWrapper = MathFloorShortcut[HelperFunction]),
          (EnsureFunction = env.vertices[ObjectMethodWrapper.index1]),
          GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z),
          (EnsureFunction = env.vertices[ObjectMethodWrapper.index2]),
          GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z);
    } else if (env && env.isBufferGeometry) {
      var Value, y, _, x, b, w;
      if (((EnsureFunction = new yu()), null !== env.index)) {
        for (
          Value = env.attributes.position,
            y = env.index,
            0 === (_ = env.groups).length &&
              (_ = [
                {
                  start: 0,
                  count: y.count,
                  materialIndex: 0,
                },
              ]),
            r = 0,
            a = _.length;
          r < a;
          ++r
        )
          for (n = (t = (x = _[r]).start) + x.count; t < n; t += 3)
            for (i = 0; i < 3; i++)
              (CounterVariable = y.getX(t + i)),
                (RandomGenerator = y.getX(t + ((i + 1) % 3))),
                (Property[0] = Math.min(CounterVariable, RandomGenerator)),
                (Property[1] = Math.max(CounterVariable, RandomGenerator)),
                void 0 === MathFloorShortcut[(HelperFunction = Property[0] + "," + Property[1])] &&
                  (MathFloorShortcut[HelperFunction] = {
                    index1: Property[0],
                    index2: Property[1],
                  });
        for (HelperFunction in MathFloorShortcut)
          (ObjectMethodWrapper = MathFloorShortcut[HelperFunction]),
            EnsureFunction.fromBufferAttribute(Value, ObjectMethodWrapper.index1),
            GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z),
            EnsureFunction.fromBufferAttribute(Value, ObjectMethodWrapper.index2),
            GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z);
      } else
        for (t = 0, n = (Value = env.attributes.position).count / 3; t < n; t++)
          for (i = 0; i < 3; i++)
            (b = 3 * t + i),
              EnsureFunction.fromBufferAttribute(Value, b),
              GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z),
              (w = 3 * t + ((i + 1) % 3)),
              EnsureFunction.fromBufferAttribute(Value, w),
              GlobalReference.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z);
    }
    this.addAttribute("position", new Wp(GlobalReference, 3));
  }

  function pg(env, t, i) {
    Up.call(this),
      (this.type = "ParametricGeometry"),
      (this.parameters = {
        func: env,
        slices: t,
        stacks: i,
      }),
      this.fromBufferGeometry(new dg(env, t, i)),
      this.mergeVertices();
  }

  function dg(env, t, i) {
    StateDetector.call(this),
      (this.type = "ParametricBufferGeometry"),
      (this.parameters = { func: env, slices: t, stacks: i });
    var n,
      r,
      a = [],
      ObjectMethodWrapper = [],
      CounterVariable = [],
      RandomGenerator = [],
      HelperFunction = new yu(),
      EnsureFunction = new yu(),
      GlobalReference = new yu(),
      Property = new yu(),
      MathFloorShortcut = new yu();
    env.length < 3 &&
      console.error(
        "THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.",
      );
    var f = t + 1;
    for (n = 0; n <= i; n++) {
      var ModuleMeta = n / i;
      for (r = 0; r <= t; r++) {
        var g = r / t;
        env(g, ModuleMeta, EnsureFunction),
          ObjectMethodWrapper.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z),
          0 <= g - 1e-5
            ? (env(g - 1e-5, ModuleMeta, GlobalReference), Property.subVectors(EnsureFunction, GlobalReference))
            : (env(g + 1e-5, ModuleMeta, GlobalReference), Property.subVectors(GlobalReference, EnsureFunction)),
          0 <= ModuleMeta - 1e-5
            ? (env(g, ModuleMeta - 1e-5, GlobalReference), MathFloorShortcut.subVectors(EnsureFunction, GlobalReference))
            : (env(g, ModuleMeta + 1e-5, GlobalReference), MathFloorShortcut.subVectors(GlobalReference, EnsureFunction)),
          HelperFunction.crossVectors(Property, MathFloorShortcut).normalize(),
          CounterVariable.push(HelperFunction.x, HelperFunction.y, HelperFunction.z),
          RandomGenerator.push(g, ModuleMeta);
      }
    }
    for (n = 0; n < i; n++)
      for (r = 0; r < t; r++) {
        var Value = n * f + r,
          y = n * f + r + 1,
          _ = (n + 1) * f + r + 1,
          x = (n + 1) * f + r;
        a.push(Value, y, x), a.push(y, _, x);
      }
    this.setIndex(a),
      this.addAttribute("position", new Wp(ObjectMethodWrapper, 3)),
      this.addAttribute("normal", new Wp(CounterVariable, 3)),
      this.addAttribute("uv", new Wp(RandomGenerator, 2));
  }

  function fg(env, t, i, n) {
    Up.call(this),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = {
        vertices: env,
        indices: t,
        radius: i,
        detail: n,
      }),
      this.fromBufferGeometry(new mg(env, t, i, n)),
      this.mergeVertices();
  }

  function mg(n, a, env, t) {
    StateDetector.call(this),
      (this.type = "PolyhedronBufferGeometry"),
      (this.parameters = {
        vertices: n,
        indices: a,
        radius: env,
        detail: t,
      }),
      (env = env || 1);
    var EnsureFunction = [],
      GlobalReference = [];

    function ObjectMethodWrapper(env, t, i, n) {
      var r,
        a,
        ObjectMethodWrapper = Math.pow(2, n),
        CounterVariable = [];
      for (r = 0; r <= ObjectMethodWrapper; r++) {
        CounterVariable[r] = [];
        var RandomGenerator = env.clone().lerp(i, r / ObjectMethodWrapper),
          HelperFunction = t.clone().lerp(i, r / ObjectMethodWrapper),
          EnsureFunction = ObjectMethodWrapper - r;
        for (a = 0; a <= EnsureFunction; a++)
          CounterVariable[r][a] = 0 === a && r === ObjectMethodWrapper ? RandomGenerator : RandomGenerator.clone().lerp(HelperFunction, a / EnsureFunction);
      }
      for (r = 0; r < ObjectMethodWrapper; r++)
        for (a = 0; a < 2 * (ObjectMethodWrapper - r) - 1; a++) {
          var GlobalReference = Math.floor(a / 2);
          a % 2 == 0
            ? (Property(CounterVariable[r][GlobalReference + 1]), Property(CounterVariable[r + 1][GlobalReference]), Property(CounterVariable[r][GlobalReference]))
            : (Property(CounterVariable[r][GlobalReference + 1]), Property(CounterVariable[r + 1][GlobalReference + 1]), Property(CounterVariable[r + 1][GlobalReference]));
        }
    }

    function Property(env) {
      EnsureFunction.push(env.x, env.y, env.z);
    }

    function CounterVariable(env, t) {
      var i = 3 * env;
      (t.x = n[i + 0]), (t.y = n[i + 1]), (t.z = n[i + 2]);
    }

    function MathFloorShortcut(env, t, i, n) {
      n < 0 && 1 === env.x && (GlobalReference[t] = env.x - 1),
        0 === i.x && 0 === i.z && (GlobalReference[t] = n / 2 / Math.PI + 0.5);
    }

    function f(env) {
      return Math.atan2(env.z, -env.x);
    }

    !(function (env) {
      for (
        var t = new yu(), i = new yu(), n = new yu(), r = 0;
        r < a.length;
        r += 3
      )
        CounterVariable(a[r + 0], t), CounterVariable(a[r + 1], i), CounterVariable(a[r + 2], n), ObjectMethodWrapper(t, i, n, env);
    })((t = t || 0)),
      (function (env) {
        for (var t = new yu(), i = 0; i < EnsureFunction.length; i += 3)
          (t.x = EnsureFunction[i + 0]),
            (t.y = EnsureFunction[i + 1]),
            (t.z = EnsureFunction[i + 2]),
            t.normalize().multiplyScalar(env),
            (EnsureFunction[i + 0] = t.x),
            (EnsureFunction[i + 1] = t.y),
            (EnsureFunction[i + 2] = t.z);
      })(env),
      (function () {
        for (var env = new yu(), t = 0; t < EnsureFunction.length; t += 3) {
          (env.x = EnsureFunction[t + 0]), (env.y = EnsureFunction[t + 1]), (env.z = EnsureFunction[t + 2]);
          var i = f(env) / 2 / Math.PI + 0.5,
            n =
              ((r = env),
              Math.atan2(-r.y, Math.sqrt(r.x * r.x + r.z * r.z)) / Math.PI +
                0.5);
          GlobalReference.push(i, 1 - n);
        }
        var r;
        (function () {
          for (
            var env = new yu(),
              t = new yu(),
              i = new yu(),
              n = new yu(),
              r = new mu(),
              a = new mu(),
              ObjectMethodWrapper = new mu(),
              CounterVariable = 0,
              RandomGenerator = 0;
            CounterVariable < EnsureFunction.length;
            CounterVariable += 9, RandomGenerator += 6
          ) {
            env.set(EnsureFunction[CounterVariable + 0], EnsureFunction[CounterVariable + 1], EnsureFunction[CounterVariable + 2]),
              t.set(EnsureFunction[CounterVariable + 3], EnsureFunction[CounterVariable + 4], EnsureFunction[CounterVariable + 5]),
              i.set(EnsureFunction[CounterVariable + 6], EnsureFunction[CounterVariable + 7], EnsureFunction[CounterVariable + 8]),
              r.set(GlobalReference[RandomGenerator + 0], GlobalReference[RandomGenerator + 1]),
              a.set(GlobalReference[RandomGenerator + 2], GlobalReference[RandomGenerator + 3]),
              ObjectMethodWrapper.set(GlobalReference[RandomGenerator + 4], GlobalReference[RandomGenerator + 5]),
              n.copy(env).add(t).add(i).divideScalar(3);
            var HelperFunction = f(n);
            MathFloorShortcut(r, RandomGenerator + 0, env, HelperFunction), MathFloorShortcut(a, RandomGenerator + 2, t, HelperFunction), MathFloorShortcut(ObjectMethodWrapper, RandomGenerator + 4, i, HelperFunction);
          }
        })(),
          (function () {
            for (var env = 0; env < GlobalReference.length; env += 6) {
              var t = GlobalReference[env + 0],
                i = GlobalReference[env + 2],
                n = GlobalReference[env + 4],
                r = Math.max(t, i, n),
                a = Math.min(t, i, n);
              0.9 < r &&
                a < 0.1 &&
                (t < 0.2 && (GlobalReference[env + 0] += 1),
                i < 0.2 && (GlobalReference[env + 2] += 1),
                n < 0.2 && (GlobalReference[env + 4] += 1));
            }
          })();
      })(),
      this.addAttribute("position", new Wp(EnsureFunction, 3)),
      this.addAttribute("normal", new Wp(EnsureFunction.slice(), 3)),
      this.addAttribute("uv", new Wp(GlobalReference, 2)),
      0 === t ? this.computeVertexNormals() : this.normalizeNormals();
  }

  function GlobalGetter(env, t) {
    Up.call(this),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      }),
      this.fromBufferGeometry(new vg(env, t)),
      this.mergeVertices();
  }

  function vg(env, t) {
    mg.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      env,
      t,
    ),
      (this.type = "TetrahedronBufferGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      });
  }

  function yg(env, t) {
    Up.call(this),
      (this.type = "OctahedronGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      }),
      this.fromBufferGeometry(new _g(env, t)),
      this.mergeVertices();
  }

  function _g(env, t) {
    mg.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      env,
      t,
    ),
      (this.type = "OctahedronBufferGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      });
  }

  function xg(env, t) {
    Up.call(this),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      }),
      this.fromBufferGeometry(new bg(env, t)),
      this.mergeVertices();
  }

  function bg(env, t) {
    var i = (1 + Math.sqrt(5)) / 2;
    mg.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ],
      env,
      t,
    ),
      (this.type = "IcosahedronBufferGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      });
  }

  function wg(env, t) {
    Up.call(this),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      }),
      this.fromBufferGeometry(new Tg(env, t)),
      this.mergeVertices();
  }

  function Tg(env, t) {
    var i = (1 + Math.sqrt(5)) / 2,
      n = 1 / i;
    mg.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n,
      ],
      [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ],
      env,
      t,
    ),
      (this.type = "DodecahedronBufferGeometry"),
      (this.parameters = {
        radius: env,
        detail: t,
      });
  }

  function Sg(env, t, i, n, r, a) {
    Up.call(this),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: env,
        tubularSegments: t,
        radius: i,
        radialSegments: n,
        closed: r,
      }),
      void 0 !== a &&
        console.warn("THREE.TubeGeometry: taper has been removed.");
    var ObjectMethodWrapper = new Eg(env, t, i, n, r);
    (this.tangents = ObjectMethodWrapper.tangents),
      (this.normals = ObjectMethodWrapper.normals),
      (this.binormals = ObjectMethodWrapper.binormals),
      this.fromBufferGeometry(ObjectMethodWrapper),
      this.mergeVertices();
  }

  function Eg(ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, env) {
    StateDetector.call(this),
      (this.type = "TubeBufferGeometry"),
      (this.parameters = {
        path: ObjectMethodWrapper,
        tubularSegments: CounterVariable,
        radius: RandomGenerator,
        radialSegments: HelperFunction,
        closed: env,
      }),
      (CounterVariable = CounterVariable || 64),
      (RandomGenerator = RandomGenerator || 1),
      (HelperFunction = HelperFunction || 8),
      (env = env || !1);
    var EnsureFunction = ObjectMethodWrapper.computeFrenetFrames(CounterVariable, env);
    (this.tangents = EnsureFunction.tangents),
      (this.normals = EnsureFunction.normals),
      (this.binormals = EnsureFunction.binormals);
    var r,
      GlobalReference,
      Property = new yu(),
      MathFloorShortcut = new yu(),
      t = new mu(),
      f = new yu(),
      ModuleMeta = [],
      g = [],
      i = [],
      a = [];

    function n(env) {
      f = ObjectMethodWrapper.getPointAt(env / CounterVariable, f);
      var t = EnsureFunction.normals[env],
        i = EnsureFunction.binormals[env];
      for (GlobalReference = 0; GlobalReference <= HelperFunction; GlobalReference++) {
        var n = (GlobalReference / HelperFunction) * Math.PI * 2,
          r = Math.sin(n),
          a = -Math.cos(n);
        (MathFloorShortcut.x = a * t.x + r * i.x),
          (MathFloorShortcut.y = a * t.y + r * i.y),
          (MathFloorShortcut.z = a * t.z + r * i.z),
          MathFloorShortcut.normalize(),
          g.push(MathFloorShortcut.x, MathFloorShortcut.y, MathFloorShortcut.z),
          (Property.x = f.x + RandomGenerator * MathFloorShortcut.x),
          (Property.y = f.y + RandomGenerator * MathFloorShortcut.y),
          (Property.z = f.z + RandomGenerator * MathFloorShortcut.z),
          ModuleMeta.push(Property.x, Property.y, Property.z);
      }
    }

    !(function () {
      for (r = 0; r < CounterVariable; r++) n(r);
      n(!1 === env ? CounterVariable : 0),
        (function () {
          for (r = 0; r <= CounterVariable; r++)
            for (GlobalReference = 0; GlobalReference <= HelperFunction; GlobalReference++)
              (t.x = r / CounterVariable), (t.y = GlobalReference / HelperFunction), i.push(t.x, t.y);
        })(),
        (function () {
          for (GlobalReference = 1; GlobalReference <= CounterVariable; GlobalReference++)
            for (r = 1; r <= HelperFunction; r++) {
              var env = (HelperFunction + 1) * (GlobalReference - 1) + (r - 1),
                t = (HelperFunction + 1) * GlobalReference + (r - 1),
                i = (HelperFunction + 1) * GlobalReference + r,
                n = (HelperFunction + 1) * (GlobalReference - 1) + r;
              a.push(env, t, n), a.push(t, i, n);
            }
        })();
    })(),
      this.setIndex(a),
      this.addAttribute("position", new Wp(ModuleMeta, 3)),
      this.addAttribute("normal", new Wp(g, 3)),
      this.addAttribute("uv", new Wp(i, 2));
  }

  function Ag(env, t, i, n, r, a, ObjectMethodWrapper) {
    Up.call(this),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: env,
        tube: t,
        tubularSegments: i,
        radialSegments: n,
        Property: r,
        IsArgumentsObject: a,
      }),
      void 0 !== ObjectMethodWrapper &&
        console.warn(
          "THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.",
        ),
      this.fromBufferGeometry(new Mg(env, t, i, n, r, a)),
      this.mergeVertices();
  }

  function Mg(env, t, i, n, r, a) {
    StateDetector.call(this),
      (this.type = "TorusKnotBufferGeometry"),
      (this.parameters = {
        radius: env,
        tube: t,
        tubularSegments: i,
        radialSegments: n,
        Property: r,
        IsArgumentsObject: a,
      }),
      (env = env || 1),
      (t = t || 0.4),
      (i = Math.floor(i) || 64),
      (n = Math.floor(n) || 8),
      (r = r || 2),
      (a = a || 3);
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator = [],
      HelperFunction = [],
      EnsureFunction = [],
      GlobalReference = [],
      Property = new yu(),
      MathFloorShortcut = new yu(),
      f = new yu(),
      ModuleMeta = new yu(),
      g = new yu(),
      Value = new yu(),
      y = new yu();
    for (ObjectMethodWrapper = 0; ObjectMethodWrapper <= i; ++ObjectMethodWrapper) {
      var _ = (ObjectMethodWrapper / i) * r * Math.PI * 2;
      for (
        M(_, r, a, env, f),
          M(_ + 0.01, r, a, env, ModuleMeta),
          Value.subVectors(ModuleMeta, f),
          y.addVectors(ModuleMeta, f),
          g.crossVectors(Value, y),
          y.crossVectors(g, Value),
          g.normalize(),
          y.normalize(),
          CounterVariable = 0;
        CounterVariable <= n;
        ++CounterVariable
      ) {
        var x = (CounterVariable / n) * Math.PI * 2,
          b = -t * Math.cos(x),
          w = t * Math.sin(x);
        (Property.x = f.x + (b * y.x + w * g.x)),
          (Property.y = f.y + (b * y.y + w * g.y)),
          (Property.z = f.z + (b * y.z + w * g.z)),
          HelperFunction.push(Property.x, Property.y, Property.z),
          MathFloorShortcut.subVectors(Property, f).normalize(),
          EnsureFunction.push(MathFloorShortcut.x, MathFloorShortcut.y, MathFloorShortcut.z),
          GlobalReference.push(ObjectMethodWrapper / i),
          GlobalReference.push(CounterVariable / n);
      }
    }
    for (CounterVariable = 1; CounterVariable <= i; CounterVariable++)
      for (ObjectMethodWrapper = 1; ObjectMethodWrapper <= n; ObjectMethodWrapper++) {
        var T = (n + 1) * (CounterVariable - 1) + (ObjectMethodWrapper - 1),
          EnsureObject = (n + 1) * CounterVariable + (ObjectMethodWrapper - 1),
          E = (n + 1) * CounterVariable + ObjectMethodWrapper,
          A = (n + 1) * (CounterVariable - 1) + ObjectMethodWrapper;
        RandomGenerator.push(T, EnsureObject, A), RandomGenerator.push(EnsureObject, E, A);
      }

    function M(env, t, i, n, r) {
      var a = Math.cos(env),
        ObjectMethodWrapper = Math.sin(env),
        CounterVariable = (i / t) * env,
        RandomGenerator = Math.cos(CounterVariable);
      (r.x = n * (2 + RandomGenerator) * 0.5 * a),
        (r.y = n * (2 + RandomGenerator) * ObjectMethodWrapper * 0.5),
        (r.z = n * Math.sin(CounterVariable) * 0.5);
    }

    this.setIndex(RandomGenerator),
      this.addAttribute("position", new Wp(HelperFunction, 3)),
      this.addAttribute("normal", new Wp(EnsureFunction, 3)),
      this.addAttribute("uv", new Wp(GlobalReference, 2));
  }

  function Pg(env, t, i, n, r) {
    Up.call(this),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: env,
        tube: t,
        radialSegments: i,
        tubularSegments: n,
        arc: r,
      }),
      this.fromBufferGeometry(new Lg(env, t, i, n, r)),
      this.mergeVertices();
  }

  function Lg(env, t, i, n, r) {
    StateDetector.call(this),
      (this.type = "TorusBufferGeometry"),
      (this.parameters = {
        radius: env,
        tube: t,
        radialSegments: i,
        tubularSegments: n,
        arc: r,
      }),
      (env = env || 1),
      (t = t || 0.4),
      (i = Math.floor(i) || 8),
      (n = Math.floor(n) || 6),
      (r = r || 2 * Math.PI);
    var a,
      ObjectMethodWrapper,
      CounterVariable = [],
      RandomGenerator = [],
      HelperFunction = [],
      EnsureFunction = [],
      GlobalReference = new yu(),
      Property = new yu(),
      MathFloorShortcut = new yu();
    for (a = 0; a <= i; a++)
      for (ObjectMethodWrapper = 0; ObjectMethodWrapper <= n; ObjectMethodWrapper++) {
        var f = (ObjectMethodWrapper / n) * r,
          ModuleMeta = (a / i) * Math.PI * 2;
        (Property.x = (env + t * Math.cos(ModuleMeta)) * Math.cos(f)),
          (Property.y = (env + t * Math.cos(ModuleMeta)) * Math.sin(f)),
          (Property.z = t * Math.sin(ModuleMeta)),
          RandomGenerator.push(Property.x, Property.y, Property.z),
          (GlobalReference.x = env * Math.cos(f)),
          (GlobalReference.y = env * Math.sin(f)),
          MathFloorShortcut.subVectors(Property, GlobalReference).normalize(),
          HelperFunction.push(MathFloorShortcut.x, MathFloorShortcut.y, MathFloorShortcut.z),
          EnsureFunction.push(ObjectMethodWrapper / n),
          EnsureFunction.push(a / i);
      }
    for (a = 1; a <= i; a++)
      for (ObjectMethodWrapper = 1; ObjectMethodWrapper <= n; ObjectMethodWrapper++) {
        var g = (n + 1) * a + ObjectMethodWrapper - 1,
          Value = (n + 1) * (a - 1) + ObjectMethodWrapper - 1,
          y = (n + 1) * (a - 1) + ObjectMethodWrapper,
          _ = (n + 1) * a + ObjectMethodWrapper;
        CounterVariable.push(g, Value, _), CounterVariable.push(Value, y, _);
      }
    this.setIndex(CounterVariable),
      this.addAttribute("position", new Wp(RandomGenerator, 3)),
      this.addAttribute("normal", new Wp(HelperFunction, 3)),
      this.addAttribute("uv", new Wp(EnsureFunction, 2));
  }

  (((Im.prototype = Object.create(Dd.prototype)).constructor =
    Im).prototype.isMeshDepthMaterial = !0),
    (Im.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        (this.depthPacking = env.depthPacking),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.map = env.map),
        (this.alphaMap = env.alphaMap),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        this
      );
    }),
    (((Rm.prototype = Object.create(Dd.prototype)).constructor =
      Rm).prototype.isMeshDistanceMaterial = !0),
    (Rm.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.referencePosition.copy(env.referencePosition),
        (this.nearDistance = env.nearDistance),
        (this.farDistance = env.farDistance),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.map = env.map),
        (this.alphaMap = env.alphaMap),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        this
      );
    }),
    (Um.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: Um,
      isGroup: !0,
    })),
    (Dm.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: Dm,
      isCamera: !0,
      copy: function (env, t) {
        return (
          Pp.prototype.copy.call(this, env, t),
          this.matrixWorldInverse.copy(env.matrixWorldInverse),
          this.projectionMatrix.copy(env.projectionMatrix),
          this.projectionMatrixInverse.copy(env.projectionMatrixInverse),
          this
        );
      },
      getWorldDirection: function (env) {
        void 0 === env &&
          (console.warn(
            "THREE.Camera: .getWorldDirection() target is now required",
          ),
          (env = new yu())),
          this.updateMatrixWorld(!0);
        var t = this.matrixWorld.elements;
        return env.set(-t[8], -t[9], -t[10]).normalize();
      },
      updateMatrixWorld: function (env) {
        Pp.prototype.updateMatrixWorld.call(this, env),
          this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (zm.prototype = Object.assign(Object.create(Dm.prototype), {
      constructor: zm,
      isPerspectiveCamera: !0,
      copy: function (env, t) {
        return (
          Dm.prototype.copy.call(this, env, t),
          (this.fov = env.fov),
          (this.zoom = env.zoom),
          (this.near = env.near),
          (this.far = env.far),
          (this.focus = env.focus),
          (this.aspect = env.aspect),
          (this.view = null === env.view ? null : Object.assign({}, env.view)),
          (this.filmGauge = env.filmGauge),
          (this.filmOffset = env.filmOffset),
          this
        );
      },
      setFocalLength: function (env) {
        var t = (0.5 * this.getFilmHeight()) / env;
        (this.fov = 2 * fu.RAD2DEG * Math.atan(t)),
          this.updateProjectionMatrix();
      },
      getFocalLength: function () {
        var env = Math.tan(0.5 * fu.DEG2RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / env;
      },
      getEffectiveFOV: function () {
        return (
          2 *
          fu.RAD2DEG *
          Math.atan(Math.tan(0.5 * fu.DEG2RAD * this.fov) / this.zoom)
        );
      },
      getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function (env, t, i, n, r, a) {
        (this.aspect = env / t),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = env),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = r),
          (this.view.height = a),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var env = this.near,
          t = (env * Math.tan(0.5 * fu.DEG2RAD * this.fov)) / this.zoom,
          i = 2 * t,
          n = this.aspect * i,
          r = -0.5 * n,
          a = this.view;
        if (null !== this.view && this.view.enabled) {
          var ObjectMethodWrapper = a.fullWidth,
            CounterVariable = a.fullHeight;
          (r += (a.offsetX * n) / ObjectMethodWrapper),
            (t -= (a.offsetY * i) / CounterVariable),
            (n *= a.width / ObjectMethodWrapper),
            (i *= a.height / CounterVariable);
        }
        var RandomGenerator = this.filmOffset;
        0 !== RandomGenerator && (r += (env * RandomGenerator) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(
            r,
            r + n,
            t,
            t - i,
            env,
            this.far,
          ),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (env) {
        var t = Pp.prototype.toJSON.call(this, env);
        return (
          (t.object.fov = this.fov),
          (t.object.zoom = this.zoom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          (t.object.focus = this.focus),
          (t.object.aspect = this.aspect),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          (t.object.filmGauge = this.filmGauge),
          (t.object.filmOffset = this.filmOffset),
          t
        );
      },
    })),
    (Bm.prototype = Object.assign(Object.create(zm.prototype), {
      constructor: Bm,
      isArrayCamera: !0,
    })),
    (Vm.prototype.isFogExp2 = !0),
    (Vm.prototype.clone = function () {
      return new Vm(this.color, this.density);
    }),
    (Vm.prototype.toJSON = function () {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density,
      };
    }),
    (Xm.prototype.isFog = !0),
    (Xm.prototype.clone = function () {
      return new Xm(this.color, this.near, this.far);
    }),
    (Xm.prototype.toJSON = function () {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far,
      };
    }),
    (Wm.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: Wm,
      copy: function (env, t) {
        return (
          Pp.prototype.copy.call(this, env, t),
          null !== env.background && (this.background = env.background.clone()),
          null !== env.fog && (this.fog = env.fog.clone()),
          null !== env.overrideMaterial &&
            (this.overrideMaterial = env.overrideMaterial.clone()),
          (this.autoUpdate = env.autoUpdate),
          (this.matrixAutoUpdate = env.matrixAutoUpdate),
          this
        );
      },
      toJSON: function (env) {
        var t = Pp.prototype.toJSON.call(this, env);
        return (
          null !== this.background &&
            (t.object.background = this.background.toJSON(env)),
          null !== this.fog && (t.object.fog = this.fog.toJSON()),
          t
        );
      },
    })),
    Object.defineProperty(Ym.prototype, "needsUpdate", {
      set: function (env) {
        !0 === env && this.version++;
      },
    }),
    Object.assign(Ym.prototype, {
      isInterleavedBuffer: !0,
      onUploadCallback: function () {},
      setArray: function (env) {
        if (Array.isArray(env))
          throw new TypeError(
            "THREE.BufferAttribute: array should be a Typed Array.",
          );
        return (
          (this.count = void 0 !== env ? env.length / this.stride : 0),
          (this.array = env),
          this
        );
      },
      setDynamic: function (env) {
        return (this.dynamic = env), this;
      },
      copy: function (env) {
        return (
          (this.array = new env.array.constructor(env.array)),
          (this.count = env.count),
          (this.stride = env.stride),
          (this.dynamic = env.dynamic),
          this
        );
      },
      copyAt: function (env, t, i) {
        (env *= this.stride), (i *= t.stride);
        for (var n = 0, r = this.stride; n < r; n++)
          this.array[env + n] = t.array[i + n];
        return this;
      },
      set: function (env, t) {
        return void 0 === t && (t = 0), this.array.set(env, t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      onUpload: function (env) {
        return (this.onUploadCallback = env), this;
      },
    }),
    Object.defineProperties(qm.prototype, {
      count: {
        get: function () {
          return this.data.count;
        },
      },
      array: {
        get: function () {
          return this.data.array;
        },
      },
    }),
    Object.assign(qm.prototype, {
      isInterleavedBufferAttribute: !0,
      setX: function (env, t) {
        return (this.data.array[env * this.data.stride + this.offset] = t), this;
      },
      setY: function (env, t) {
        return (
          (this.data.array[env * this.data.stride + this.offset + 1] = t), this
        );
      },
      setZ: function (env, t) {
        return (
          (this.data.array[env * this.data.stride + this.offset + 2] = t), this
        );
      },
      setW: function (env, t) {
        return (
          (this.data.array[env * this.data.stride + this.offset + 3] = t), this
        );
      },
      getX: function (env) {
        return this.data.array[env * this.data.stride + this.offset];
      },
      getY: function (env) {
        return this.data.array[env * this.data.stride + this.offset + 1];
      },
      getZ: function (env) {
        return this.data.array[env * this.data.stride + this.offset + 2];
      },
      getW: function (env) {
        return this.data.array[env * this.data.stride + this.offset + 3];
      },
      setXY: function (env, t, i) {
        return (
          (env = env * this.data.stride + this.offset),
          (this.data.array[env + 0] = t),
          (this.data.array[env + 1] = i),
          this
        );
      },
      setXYZ: function (env, t, i, n) {
        return (
          (env = env * this.data.stride + this.offset),
          (this.data.array[env + 0] = t),
          (this.data.array[env + 1] = i),
          (this.data.array[env + 2] = n),
          this
        );
      },
      setXYZW: function (env, t, i, n, r) {
        return (
          (env = env * this.data.stride + this.offset),
          (this.data.array[env + 0] = t),
          (this.data.array[env + 1] = i),
          (this.data.array[env + 2] = n),
          (this.data.array[env + 3] = r),
          this
        );
      },
    }),
    (((Qm.prototype = Object.create(Dd.prototype)).constructor =
      Qm).prototype.isSpriteMaterial = !0),
    (Qm.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        (this.map = env.map),
        (this.rotation = env.rotation),
        (this.sizeAttenuation = env.sizeAttenuation),
        this
      );
    }),
    (Zm.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: Zm,
      isSprite: !0,
      raycast: (function () {
        var RandomGenerator = new yu(),
          HelperFunction = new yu(),
          EnsureFunction = new yu(),
          ObjectMethodWrapper = new mu(),
          CounterVariable = new mu(),
          GlobalReference = new gu(),
          Property = new yu(),
          MathFloorShortcut = new yu(),
          f = new yu(),
          ModuleMeta = new mu(),
          g = new mu(),
          Value = new mu();

        function y(env, t, i, n, r, a) {
          ObjectMethodWrapper.subVectors(env, i).addScalar(0.5).multiply(n),
            void 0 !== r
              ? ((CounterVariable.x = a * ObjectMethodWrapper.x - r * ObjectMethodWrapper.y), (CounterVariable.y = r * ObjectMethodWrapper.x + a * ObjectMethodWrapper.y))
              : CounterVariable.copy(ObjectMethodWrapper),
            env.copy(t),
            (env.x += CounterVariable.x),
            (env.y += CounterVariable.y),
            env.applyMatrix4(GlobalReference);
        }

        return function (env, t) {
          HelperFunction.setFromMatrixScale(this.matrixWorld),
            GlobalReference.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
            EnsureFunction.setFromMatrixPosition(this.modelViewMatrix);
          var i,
            n,
            r = this.material.rotation;
          0 !== r && ((n = Math.cos(r)), (i = Math.sin(r)));
          var a = this.center;
          y(Property.set(-0.5, -0.5, 0), EnsureFunction, a, HelperFunction, i, n),
            y(MathFloorShortcut.set(0.5, -0.5, 0), EnsureFunction, a, HelperFunction, i, n),
            y(f.set(0.5, 0.5, 0), EnsureFunction, a, HelperFunction, i, n),
            ModuleMeta.set(0, 0),
            g.set(1, 0),
            Value.set(1, 1);
          var ObjectMethodWrapper = env.ray.intersectTriangle(Property, MathFloorShortcut, f, !1, RandomGenerator);
          if (
            null !== ObjectMethodWrapper ||
            (y(MathFloorShortcut.set(-0.5, 0.5, 0), EnsureFunction, a, HelperFunction, i, n),
            g.set(0, 1),
            null !== (ObjectMethodWrapper = env.ray.intersectTriangle(Property, f, MathFloorShortcut, !1, RandomGenerator)))
          ) {
            var CounterVariable = env.ray.origin.distanceTo(RandomGenerator);
            CounterVariable < env.near ||
              CounterVariable > env.far ||
              t.push({
                distance: CounterVariable,
                point: RandomGenerator.clone(),
                uv: Hd.getUV(RandomGenerator, Property, MathFloorShortcut, f, ModuleMeta, g, Value, new mu()),
                face: null,
                object: this,
              });
          }
        };
      })(),
      clone: function () {
        return new this.constructor(this.material).copy(this);
      },
      copy: function (env) {
        return (
          Pp.prototype.copy.call(this, env),
          void 0 !== env.center && this.center.copy(env.center),
          this
        );
      },
    })),
    (Jm.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: Jm,
      copy: function (env) {
        Pp.prototype.copy.call(this, env, !1);
        for (var t = env.levels, i = 0, n = t.length; i < n; i++) {
          var r = t[i];
          this.addLevel(r.object.clone(), r.distance);
        }
        return this;
      },
      addLevel: function (env, t) {
        void 0 === t && (t = 0), (t = Math.abs(t));
        for (
          var i = this.levels, n = 0;
          n < i.length && !(t < i[n].distance);
          n++
        );
        i.splice(n, 0, { distance: t, object: env }), this.add(env);
      },
      getObjectForDistance: function (env) {
        for (
          var t = this.levels, i = 1, n = t.length;
          i < n && !(env < t[i].distance);
          i++
        );
        return t[i - 1].object;
      },
      raycast:
        ((fm = new yu()),
        function (env, t) {
          fm.setFromMatrixPosition(this.matrixWorld);
          var i = env.ray.origin.distanceTo(fm);
          this.getObjectForDistance(i).raycast(env, t);
        }),
      update:
        ((pm = new yu()),
        (dm = new yu()),
        function (env) {
          var t = this.levels;
          if (1 < t.length) {
            pm.setFromMatrixPosition(env.matrixWorld),
              dm.setFromMatrixPosition(this.matrixWorld);
            var i = pm.distanceTo(dm);
            t[0].object.visible = !0;
            for (var n = 1, r = t.length; n < r && i >= t[n].distance; n++)
              (t[n - 1].object.visible = !1), (t[n].object.visible = !0);
            for (; n < r; n++) t[n].object.visible = !1;
          }
        }),
      toJSON: function (env) {
        var t = Pp.prototype.toJSON.call(this, env);
        t.object.levels = [];
        for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
          var a = i[n];
          t.object.levels.push({ object: a.object.uuid, distance: a.distance });
        }
        return t;
      },
    })),
    Object.assign(Km.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (var env = 0, t = this.bones.length; env < t; env++) {
          var i = new gu();
          this.bones[env] && i.getInverse(this.bones[env].matrixWorld),
            this.boneInverses.push(i);
        }
      },
      pose: function () {
        var env, t, i;
        for (t = 0, i = this.bones.length; t < i; t++)
          (env = this.bones[t]) && env.matrixWorld.getInverse(this.boneInverses[t]);
        for (t = 0, i = this.bones.length; t < i; t++)
          (env = this.bones[t]) &&
            (env.parent && env.parent.isBone
              ? (env.matrix.getInverse(env.parent.matrixWorld),
                env.matrix.multiply(env.matrixWorld))
              : env.matrix.copy(env.matrixWorld),
            env.matrix.decompose(env.position, env.quaternion, env.scale));
      },
      update:
        ((mm = new gu()),
        (gm = new gu()),
        function () {
          for (
            var env = this.bones,
              t = this.boneInverses,
              i = this.boneMatrices,
              n = this.boneTexture,
              r = 0,
              a = env.length;
            r < a;
            r++
          ) {
            var ObjectMethodWrapper = env[r] ? env[r].matrixWorld : gm;
            mm.multiplyMatrices(ObjectMethodWrapper, t[r]), mm.toArray(i, 16 * r);
          }
          void 0 !== n && (n.needsUpdate = !0);
        }),
      clone: function () {
        return new Km(this.bones, this.boneInverses);
      },
      getBoneByName: function (env) {
        for (var t = 0, i = this.bones.length; t < i; t++) {
          var n = this.bones[t];
          if (n.name === env) return n;
        }
      },
    }),
    ($ModuleMeta.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: $ModuleMeta,
      isBone: !0,
    })),
    (eg.prototype = Object.assign(Object.create(JobDispatcher.prototype), {
      constructor: eg,
      isSkinnedMesh: !0,
      initBones: function () {
        var env,
          t,
          i,
          n,
          r = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            (t = this.geometry.bones[i]),
              (env = new $ModuleMeta()),
              r.push(env),
              (env.name = t.name),
              env.position.fromArray(t.pos),
              env.quaternion.fromArray(t.rotq),
              void 0 !== t.scl && env.scale.fromArray(t.scl);
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            -1 !== (t = this.geometry.bones[i]).parent &&
            null !== t.parent &&
            void 0 !== r[t.parent]
              ? r[t.parent].add(r[i])
              : this.add(r[i]);
        }
        return this.updateMatrixWorld(!0), r;
      },
      bind: function (env, t) {
        (this.skeleton = env),
          void 0 === t &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (t = this.matrixWorld)),
          this.bindMatrix.copy(t),
          this.bindMatrixInverse.getInverse(t);
      },
      pose: function () {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function () {
        var env, t;
        if (this.geometry && this.geometry.isGeometry)
          for (t = 0; t < this.geometry.skinWeights.length; t++) {
            var i = this.geometry.skinWeights[t];
            (env = 1 / i.manhattanLength()) !== 1 / 0
              ? i.multiplyScalar(env)
              : i.set(1, 0, 0, 0);
          }
        else if (this.geometry && this.geometry.isBufferGeometry) {
          var n = new zu(),
            r = this.geometry.attributes.skinWeight;
          for (t = 0; t < r.count; t++)
            (n.x = r.getX(t)),
              (n.y = r.getY(t)),
              (n.z = r.getZ(t)),
              (n.w = r.getW(t)),
              (env = 1 / n.manhattanLength()) !== 1 / 0
                ? n.multiplyScalar(env)
                : n.set(1, 0, 0, 0),
              r.setXYZW(t, n.x, n.y, n.z, n.w);
        }
      },
      updateMatrixWorld: function (env) {
        JobDispatcher.prototype.updateMatrixWorld.call(this, env),
          "attached" === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.matrixWorld)
            : "detached" === this.bindMode
              ? this.bindMatrixInverse.getInverse(this.bindMatrix)
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode,
                );
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (((tg.prototype = Object.create(Dd.prototype)).constructor =
      tg).prototype.isLineBasicMaterial = !0),
    (tg.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        (this.linewidth = env.linewidth),
        (this.linecap = env.linecap),
        (this.linejoin = env.linejoin),
        this
      );
    }),
    (ig.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: ig,
      isLine: !0,
      computeLineDistances:
        ((xm = new yu()),
        (bm = new yu()),
        function () {
          var env = this.geometry;
          if (env.isBufferGeometry)
            if (null === env.index) {
              for (
                var t = env.attributes.position, i = [0], n = 1, r = t.count;
                n < r;
                n++
              )
                xm.fromBufferAttribute(t, n - 1),
                  bm.fromBufferAttribute(t, n),
                  (i[n] = i[n - 1]),
                  (i[n] += xm.distanceTo(bm));
              env.addAttribute("lineDistance", new Wp(i, 1));
            } else
              console.warn(
                "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
              );
          else if (env.isGeometry) {
            var a = env.vertices;
            for ((i = env.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++)
              (i[n] = i[n - 1]), (i[n] += a[n - 1].distanceTo(a[n]));
          }
          return this;
        }),
      raycast:
        ((vm = new gu()),
        (ym = new Bd()),
        (_m = new Vu()),
        function (env, t) {
          var i = env.linePrecision,
            n = this.geometry,
            r = this.matrixWorld;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            _m.copy(n.boundingSphere),
            _m.applyMatrix4(r),
            (_m.radius += i),
            !1 !== env.ray.intersectsSphere(_m))
          ) {
            vm.getInverse(r), ym.copy(env.ray).applyMatrix4(vm);
            var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              ObjectMethodWrapper = a * a,
              CounterVariable = new yu(),
              RandomGenerator = new yu(),
              HelperFunction = new yu(),
              EnsureFunction = new yu(),
              GlobalReference = this && this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              var Property = n.index,
                MathFloorShortcut = n.attributes.position.array;
              if (null !== Property)
                for (var f = Property.array, ModuleMeta = 0, g = f.length - 1; ModuleMeta < g; ModuleMeta += GlobalReference) {
                  var Value = f[ModuleMeta],
                    y = f[ModuleMeta + 1];
                  CounterVariable.fromArray(MathFloorShortcut, 3 * Value),
                    RandomGenerator.fromArray(MathFloorShortcut, 3 * y),
                    ObjectMethodWrapper < ym.distanceSqToSegment(CounterVariable, RandomGenerator, EnsureFunction, HelperFunction) ||
                      (EnsureFunction.applyMatrix4(this.matrixWorld),
                      (b = env.ray.origin.distanceTo(EnsureFunction)) < env.near ||
                        b > env.far ||
                        t.push({
                          distance: b,
                          point: HelperFunction.clone().applyMatrix4(this.matrixWorld),
                          index: ModuleMeta,
                          face: null,
                          faceIndex: null,
                          object: this,
                        }));
                }
              else
                for (ModuleMeta = 0, g = MathFloorShortcut.length / 3 - 1; ModuleMeta < g; ModuleMeta += GlobalReference)
                  CounterVariable.fromArray(MathFloorShortcut, 3 * ModuleMeta),
                    RandomGenerator.fromArray(MathFloorShortcut, 3 * ModuleMeta + 3),
                    ObjectMethodWrapper < ym.distanceSqToSegment(CounterVariable, RandomGenerator, EnsureFunction, HelperFunction) ||
                      (EnsureFunction.applyMatrix4(this.matrixWorld),
                      (b = env.ray.origin.distanceTo(EnsureFunction)) < env.near ||
                        b > env.far ||
                        t.push({
                          distance: b,
                          point: HelperFunction.clone().applyMatrix4(this.matrixWorld),
                          index: ModuleMeta,
                          face: null,
                          faceIndex: null,
                          object: this,
                        }));
            } else if (n.isGeometry) {
              var _ = n.vertices,
                x = _.length;
              for (ModuleMeta = 0; ModuleMeta < x - 1; ModuleMeta += GlobalReference) {
                var b;
                ObjectMethodWrapper < ym.distanceSqToSegment(_[ModuleMeta], _[ModuleMeta + 1], EnsureFunction, HelperFunction) ||
                  (EnsureFunction.applyMatrix4(this.matrixWorld),
                  (b = env.ray.origin.distanceTo(EnsureFunction)) < env.near ||
                    b > env.far ||
                    t.push({
                      distance: b,
                      point: HelperFunction.clone().applyMatrix4(this.matrixWorld),
                      index: ModuleMeta,
                      face: null,
                      faceIndex: null,
                      object: this,
                    }));
              }
            }
          }
        }),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (ng.prototype = Object.assign(Object.create(ig.prototype), {
      constructor: ng,
      isLineSegments: !0,
      computeLineDistances:
        ((wm = new yu()),
        (Tm = new yu()),
        function () {
          var env = this.geometry;
          if (env.isBufferGeometry)
            if (null === env.index) {
              for (
                var t = env.attributes.position, i = [], n = 0, r = t.count;
                n < r;
                n += 2
              )
                wm.fromBufferAttribute(t, n),
                  Tm.fromBufferAttribute(t, n + 1),
                  (i[n] = 0 === n ? 0 : i[n - 1]),
                  (i[n + 1] = i[n] + wm.distanceTo(Tm));
              env.addAttribute("lineDistance", new Wp(i, 1));
            } else
              console.warn(
                "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.",
              );
          else if (env.isGeometry) {
            var a = env.vertices;
            for (i = env.lineDistances, n = 0, r = a.length; n < r; n += 2)
              wm.copy(a[n]),
                Tm.copy(a[n + 1]),
                (i[n] = 0 === n ? 0 : i[n - 1]),
                (i[n + 1] = i[n] + wm.distanceTo(Tm));
          }
          return this;
        }),
    })),
    (rg.prototype = Object.assign(Object.create(ig.prototype), {
      constructor: rg,
      isLineLoop: !0,
    })),
    (((ag.prototype = Object.create(Dd.prototype)).constructor =
      ag).prototype.isPointsMaterial = !0),
    (ag.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        (this.map = env.map),
        (this.size = env.size),
        (this.sizeAttenuation = env.sizeAttenuation),
        (this.morphTargets = env.morphTargets),
        this
      );
    }),
    (og.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: og,
      isPoints: !0,
      raycast:
        ((Sm = new gu()),
        (Em = new Bd()),
        (Am = new Vu()),
        function (r, a) {
          var ObjectMethodWrapper = this,
            env = this.geometry,
            CounterVariable = this.matrixWorld,
            t = r.params.Points.threshold;
          if (
            (null === env.boundingSphere && env.computeBoundingSphere(),
            Am.copy(env.boundingSphere),
            Am.applyMatrix4(CounterVariable),
            (Am.radius += t),
            !1 !== r.ray.intersectsSphere(Am))
          ) {
            Sm.getInverse(CounterVariable), Em.copy(r.ray).applyMatrix4(Sm);
            var i = t / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              RandomGenerator = i * i,
              n = new yu(),
              HelperFunction = new yu();
            if (env.isBufferGeometry) {
              var EnsureFunction = env.index,
                GlobalReference = env.attributes.position.array;
              if (null !== EnsureFunction)
                for (var Property = EnsureFunction.array, MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++) {
                  var ModuleMeta = Property[MathFloorShortcut];
                  n.fromArray(GlobalReference, 3 * ModuleMeta), y(n, ModuleMeta);
                }
              else {
                MathFloorShortcut = 0;
                for (var g = GlobalReference.length / 3; MathFloorShortcut < g; MathFloorShortcut++)
                  n.fromArray(GlobalReference, 3 * MathFloorShortcut), y(n, MathFloorShortcut);
              }
            } else {
              var Value = env.vertices;
              for (MathFloorShortcut = 0, g = Value.length; MathFloorShortcut < g; MathFloorShortcut++) y(Value[MathFloorShortcut], MathFloorShortcut);
            }
          }

          function y(env, t) {
            var i = Em.distanceSqToPoint(env);
            if (i < RandomGenerator) {
              Em.closestPointToPoint(env, HelperFunction), HelperFunction.applyMatrix4(CounterVariable);
              var n = r.ray.origin.distanceTo(HelperFunction);
              if (n < r.near || n > r.far) return;
              a.push({
                distance: n,
                distanceToRay: Math.sqrt(i),
                point: HelperFunction.clone(),
                index: t,
                face: null,
                object: ObjectMethodWrapper,
              });
            }
          }
        }),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      },
    })),
    (sg.prototype = Object.assign(Object.create(Du.prototype), {
      constructor: sg,
      isVideoTexture: !0,
      update: function () {
        var env = this.image;
        env.readyState >= env.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
      },
    })),
    (((lg.prototype = Object.create(Du.prototype)).constructor =
      lg).prototype.isCompressedTexture = !0),
    (((hg.prototype = Object.create(Du.prototype)).constructor =
      hg).prototype.isCanvasTexture = !0),
    (((cg.prototype = Object.create(Du.prototype)).constructor =
      cg).prototype.isDepthTexture = !0),
    ((ug.prototype = Object.create(StateDetector.prototype)).constructor = ug),
    ((pg.prototype = Object.create(Up.prototype)).constructor = pg),
    ((dg.prototype = Object.create(StateDetector.prototype)).constructor = dg),
    ((fg.prototype = Object.create(Up.prototype)).constructor = fg),
    ((mg.prototype = Object.create(StateDetector.prototype)).constructor = mg),
    ((GlobalGetter.prototype = Object.create(Up.prototype)).constructor = GlobalGetter),
    ((vg.prototype = Object.create(mg.prototype)).constructor = vg),
    ((yg.prototype = Object.create(Up.prototype)).constructor = yg),
    ((_g.prototype = Object.create(mg.prototype)).constructor = _g),
    ((xg.prototype = Object.create(Up.prototype)).constructor = xg),
    ((bg.prototype = Object.create(mg.prototype)).constructor = bg),
    ((wg.prototype = Object.create(Up.prototype)).constructor = wg),
    ((Tg.prototype = Object.create(mg.prototype)).constructor = Tg),
    ((Sg.prototype = Object.create(Up.prototype)).constructor = Sg),
    ((Eg.prototype = Object.create(StateDetector.prototype)).constructor = Eg),
    ((Ag.prototype = Object.create(Up.prototype)).constructor = Ag),
    ((Mg.prototype = Object.create(StateDetector.prototype)).constructor = Mg),
    ((Pg.prototype = Object.create(Up.prototype)).constructor = Pg),
    ((Lg.prototype = Object.create(StateDetector.prototype)).constructor = Lg);
  var Cg = function (env, t, i) {
    i = i || 2;
    var n,
      r,
      a,
      ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction = t && t.length,
      GlobalReference = EnsureFunction ? t[0] * i : env.length,
      Property = Ig(env, 0, GlobalReference, i, !0),
      MathFloorShortcut = [];
    if (!Property) return MathFloorShortcut;
    if (
      (EnsureFunction &&
        (Property = (function (env, t, i, n) {
          var r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction = [];
          for (r = 0, a = t.length; r < a; r++)
            (ObjectMethodWrapper = t[r] * n),
              (CounterVariable = r < a - 1 ? t[r + 1] * n : env.length),
              (RandomGenerator = Ig(env, ObjectMethodWrapper, CounterVariable, n, !1)) === RandomGenerator.next && (RandomGenerator.steiner = !0),
              HelperFunction.push(Hg(RandomGenerator));
          for (HelperFunction.sort(Dg), r = 0; r < HelperFunction.length; r++)
            zg(HelperFunction[r], i), (i = Rg(i, i.next));
          return i;
        })(env, t, Property, i)),
      env.length > 80 * i)
    ) {
      (n = a = env[0]), (r = ObjectMethodWrapper = env[1]);
      for (var f = i; f < GlobalReference; f += i)
        (CounterVariable = env[f]) < n && (n = CounterVariable),
          (RandomGenerator = env[f + 1]) < r && (r = RandomGenerator),
          a < CounterVariable && (a = CounterVariable),
          ObjectMethodWrapper < RandomGenerator && (ObjectMethodWrapper = RandomGenerator);
      HelperFunction = 0 !== (HelperFunction = Math.max(a - n, ObjectMethodWrapper - r)) ? 1 / HelperFunction : 0;
    }
    return Og(Property, MathFloorShortcut, i, n, r, HelperFunction), MathFloorShortcut;
  };

  function Ig(env, t, i, n, r) {
    var a, ObjectMethodWrapper;
    if (
      r ===
      0 <
        (function (env, t, i, n) {
          for (var r = 0, a = t, ObjectMethodWrapper = i - n; a < i; a += n)
            (r += (env[ObjectMethodWrapper] - env[a]) * (env[a + 1] + env[ObjectMethodWrapper + 1])), (ObjectMethodWrapper = a);
          return r;
        })(env, t, i, n)
    )
      for (a = t; a < i; a += n) ObjectMethodWrapper = qg(a, env[a], env[a + 1], ObjectMethodWrapper);
    else for (a = i - n; t <= a; a -= n) ObjectMethodWrapper = qg(a, env[a], env[a + 1], ObjectMethodWrapper);
    return ObjectMethodWrapper && Vg(ObjectMethodWrapper, ObjectMethodWrapper.next) && (Qg(ObjectMethodWrapper), (ObjectMethodWrapper = ObjectMethodWrapper.next)), ObjectMethodWrapper;
  }

  function Rg(env, t) {
    if (!env) return env;
    t || (t = env);
    var i,
      n = env;
    do {
      if (
        ((i = !1), n.steiner || (!Vg(n, n.next) && 0 !== jg(n.prev, n, n.next)))
      )
        n = n.next;
      else {
        if ((Qg(n), (n = t = n.prev) === n.next)) break;
        i = !0;
      }
    } while (i || n !== t);
    return t;
  }

  function Og(env, t, i, n, r, a, ObjectMethodWrapper) {
    if (env) {
      !ObjectMethodWrapper &&
        a &&
        (function (env, t, i, n) {
          var r = env;
          for (
            ;
            null === r.z && (r.z = Bg(r.x, r.y, t, i, n)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next),
              r !== env;

          );
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (env) {
              var t,
                i,
                n,
                r,
                a,
                ObjectMethodWrapper,
                CounterVariable,
                RandomGenerator,
                HelperFunction = 1;
              do {
                for (i = env, a = env = null, ObjectMethodWrapper = 0; i; ) {
                  for (
                    ObjectMethodWrapper++, n = i, t = CounterVariable = 0;
                    t < HelperFunction && (CounterVariable++, (n = n.nextZ));
                    t++
                  );
                  for (RandomGenerator = HelperFunction; 0 < CounterVariable || (0 < RandomGenerator && n); )
                    0 !== CounterVariable && (0 === RandomGenerator || !n || i.z <= n.z)
                      ? ((i = (r = i).nextZ), CounterVariable--)
                      : ((n = (r = n).nextZ), RandomGenerator--),
                      a ? (a.nextZ = r) : (env = r),
                      (r.prevZ = a),
                      (a = r);
                  i = n;
                }
                (a.nextZ = null), (HelperFunction *= 2);
              } while (1 < ObjectMethodWrapper);
            })(r);
        })(env, n, r, a);
      for (var CounterVariable, RandomGenerator, HelperFunction = env; env.prev !== env.next; )
        if (((CounterVariable = env.prev), (RandomGenerator = env.next), a ? Ng(env, n, r, a) : Fg(env)))
          t.push(CounterVariable.i / i),
            t.push(env.i / i),
            t.push(RandomGenerator.i / i),
            Qg(env),
            (env = RandomGenerator.next),
            (HelperFunction = RandomGenerator.next);
        else if ((env = RandomGenerator) === HelperFunction) {
          ObjectMethodWrapper
            ? 1 === ObjectMethodWrapper
              ? Og((env = kg(env, t, i)), t, i, n, r, a, 2)
              : 2 === ObjectMethodWrapper && Ug(env, t, i, n, r, a)
            : Og(Rg(env), t, i, n, r, a, 1);
          break;
        }
    }
  }

  function Fg(env) {
    var t = env.prev,
      i = env,
      n = env.next;
    if (0 <= jg(t, i, n)) return !1;
    for (var r = env.next.next; r !== env.prev; ) {
      if (
        Gg(t.x, t.y, i.x, i.y, n.x, n.y, r.x, r.y) &&
        0 <= jg(r.prev, r, r.next)
      )
        return !1;
      r = r.next;
    }
    return !0;
  }

  function Ng(env, t, i, n) {
    var r = env.prev,
      a = env,
      ObjectMethodWrapper = env.next;
    if (0 <= jg(r, a, ObjectMethodWrapper)) return !1;
    for (
      var CounterVariable = r.x < a.x ? (r.x < ObjectMethodWrapper.x ? r.x : ObjectMethodWrapper.x) : a.x < ObjectMethodWrapper.x ? a.x : ObjectMethodWrapper.x,
        RandomGenerator = r.y < a.y ? (r.y < ObjectMethodWrapper.y ? r.y : ObjectMethodWrapper.y) : a.y < ObjectMethodWrapper.y ? a.y : ObjectMethodWrapper.y,
        HelperFunction = r.x > a.x ? (r.x > ObjectMethodWrapper.x ? r.x : ObjectMethodWrapper.x) : a.x > ObjectMethodWrapper.x ? a.x : ObjectMethodWrapper.x,
        EnsureFunction = r.y > a.y ? (r.y > ObjectMethodWrapper.y ? r.y : ObjectMethodWrapper.y) : a.y > ObjectMethodWrapper.y ? a.y : ObjectMethodWrapper.y,
        GlobalReference = Bg(CounterVariable, RandomGenerator, t, i, n),
        Property = Bg(HelperFunction, EnsureFunction, t, i, n),
        MathFloorShortcut = env.nextZ;
      MathFloorShortcut && MathFloorShortcut.z <= Property;

    ) {
      if (
        MathFloorShortcut !== env.prev &&
        MathFloorShortcut !== env.next &&
        Gg(r.x, r.y, a.x, a.y, ObjectMethodWrapper.x, ObjectMethodWrapper.y, MathFloorShortcut.x, MathFloorShortcut.y) &&
        0 <= jg(MathFloorShortcut.prev, MathFloorShortcut, MathFloorShortcut.next)
      )
        return !1;
      MathFloorShortcut = MathFloorShortcut.nextZ;
    }
    for (MathFloorShortcut = env.prevZ; MathFloorShortcut && MathFloorShortcut.z >= GlobalReference; ) {
      if (
        MathFloorShortcut !== env.prev &&
        MathFloorShortcut !== env.next &&
        Gg(r.x, r.y, a.x, a.y, ObjectMethodWrapper.x, ObjectMethodWrapper.y, MathFloorShortcut.x, MathFloorShortcut.y) &&
        0 <= jg(MathFloorShortcut.prev, MathFloorShortcut, MathFloorShortcut.next)
      )
        return !1;
      MathFloorShortcut = MathFloorShortcut.prevZ;
    }
    return !0;
  }

  function kg(env, t, i) {
    var n = env;
    do {
      var r = n.prev,
        a = n.next.next;
      !Vg(r, a) &&
        Xg(r, n, n.next, a) &&
        Wg(r, a) &&
        Wg(a, r) &&
        (t.push(r.i / i),
        t.push(n.i / i),
        t.push(a.i / i),
        Qg(n),
        Qg(n.next),
        (n = env = a)),
        (n = n.next);
    } while (n !== env);
    return n;
  }

  function Ug(env, t, i, n, r, a) {
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator = env;
    do {
      for (var HelperFunction = RandomGenerator.next.next; HelperFunction !== RandomGenerator.prev; ) {
        if (
          RandomGenerator.i !== HelperFunction.i &&
          ((CounterVariable = HelperFunction),
          (ObjectMethodWrapper = RandomGenerator).next.i !== CounterVariable.i &&
            ObjectMethodWrapper.prev.i !== CounterVariable.i &&
            !(function (env, t) {
              var i = env;
              do {
                if (
                  i.i !== env.i &&
                  i.next.i !== env.i &&
                  i.i !== t.i &&
                  i.next.i !== t.i &&
                  Xg(i, i.next, env, t)
                )
                  return !0;
                i = i.next;
              } while (i !== env);
              return !1;
            })(ObjectMethodWrapper, CounterVariable) &&
            Wg(ObjectMethodWrapper, CounterVariable) &&
            Wg(CounterVariable, ObjectMethodWrapper) &&
            (function (env, t) {
              var i = env,
                n = !1,
                r = (env.x + t.x) / 2,
                a = (env.y + t.y) / 2;
              for (
                ;
                i.y > a != i.next.y > a &&
                  i.next.y !== i.y &&
                  r < ((i.next.x - i.x) * (a - i.y)) / (i.next.y - i.y) + i.x &&
                  (n = !n),
                  (i = i.next),
                  i !== env;

              );
              return n;
            })(ObjectMethodWrapper, CounterVariable))
        ) {
          var EnsureFunction = Yg(RandomGenerator, HelperFunction);
          return (
            (RandomGenerator = Rg(RandomGenerator, RandomGenerator.next)),
            (EnsureFunction = Rg(EnsureFunction, EnsureFunction.next)),
            Og(RandomGenerator, t, i, n, r, a),
            void Og(EnsureFunction, t, i, n, r, a)
          );
        }
        HelperFunction = HelperFunction.next;
      }
      RandomGenerator = RandomGenerator.next;
    } while (RandomGenerator !== env);
  }

  function Dg(env, t) {
    return env.x - t.x;
  }

  function zg(env, t) {
    if (
      (t = (function (env, t) {
        var i,
          n = t,
          r = env.x,
          a = env.y,
          ObjectMethodWrapper = -1 / 0;
        do {
          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
            var CounterVariable = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
            if (CounterVariable <= r && ObjectMethodWrapper < CounterVariable) {
              if ((ObjectMethodWrapper = CounterVariable) === r) {
                if (a === n.y) return n;
                if (a === n.next.y) return n.next;
              }
              i = n.x < n.next.x ? n : n.next;
            }
          }
          n = n.next;
        } while (n !== t);
        if (!i) return null;
        if (r === ObjectMethodWrapper) return i.prev;
        var RandomGenerator,
          HelperFunction = i,
          EnsureFunction = i.x,
          GlobalReference = i.y,
          Property = 1 / 0;
        n = i.next;
        for (; n !== HelperFunction; )
          r >= n.x &&
            n.x >= EnsureFunction &&
            r !== n.x &&
            Gg(a < GlobalReference ? r : ObjectMethodWrapper, a, EnsureFunction, GlobalReference, a < GlobalReference ? ObjectMethodWrapper : r, a, n.x, n.y) &&
            ((RandomGenerator = Math.abs(a - n.y) / (r - n.x)) < Property ||
              (RandomGenerator === Property && n.x > i.x)) &&
            Wg(n, env) &&
            ((i = n), (Property = RandomGenerator)),
            (n = n.next);
        return i;
      })(env, t))
    ) {
      var i = Yg(t, env);
      Rg(i, i.next);
    }
  }

  function Bg(env, t, i, n, r) {
    return (
      (env =
        1431655765 &
        ((env =
          858993459 &
          ((env =
            252645135 &
            ((env = 16711935 & ((env = 32767 * (env - i) * r) | (env << 8))) |
              (env << 4))) |
            (env << 2))) |
          (env << 1))) |
      ((t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = 32767 * (t - n) * r) | (t << 8))) |
              (t << 4))) |
            (t << 2))) |
          (t << 1))) <<
        1)
    );
  }

  function Hg(env) {
    for (var t = env, i = env; t.x < i.x && (i = t), (t = t.next) !== env; );
    return i;
  }

  function Gg(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
    return (
      0 <= (r - ObjectMethodWrapper) * (t - CounterVariable) - (env - ObjectMethodWrapper) * (a - CounterVariable) &&
      0 <= (env - ObjectMethodWrapper) * (n - CounterVariable) - (i - ObjectMethodWrapper) * (t - CounterVariable) &&
      0 <= (i - ObjectMethodWrapper) * (a - CounterVariable) - (r - ObjectMethodWrapper) * (n - CounterVariable)
    );
  }

  function jg(env, t, i) {
    return (t.y - env.y) * (i.x - t.x) - (t.x - env.x) * (i.y - t.y);
  }

  function Vg(env, t) {
    return env.x === t.x && env.y === t.y;
  }

  function Xg(env, t, i, n) {
    return (
      !!((Vg(env, t) && Vg(i, n)) || (Vg(env, n) && Vg(i, t))) ||
      (0 < jg(env, t, i) != 0 < jg(env, t, n) && 0 < jg(i, n, env) != 0 < jg(i, n, t))
    );
  }

  function Wg(env, t) {
    return jg(env.prev, env, env.next) < 0
      ? 0 <= jg(env, t, env.next) && 0 <= jg(env, env.prev, t)
      : jg(env, t, env.prev) < 0 || jg(env, env.next, t) < 0;
  }

  function Yg(env, t) {
    var i = new Zg(env.i, env.x, env.y),
      n = new Zg(t.i, t.x, t.y),
      r = env.next,
      a = t.prev;
    return (
      ((env.next = t).prev = env),
      ((i.next = r).prev = i),
      ((n.next = i).prev = n),
      ((a.next = n).prev = a),
      n
    );
  }

  function qg(env, t, i, n) {
    var r = new Zg(env, t, i);
    return (
      n
        ? ((r.next = n.next), ((r.prev = n).next.prev = r), (n.next = r))
        : ((r.prev = r).next = r),
      r
    );
  }

  function Qg(env) {
    (env.next.prev = env.prev),
      (env.prev.next = env.next),
      env.prevZ && (env.prevZ.nextZ = env.nextZ),
      env.nextZ && (env.nextZ.prevZ = env.prevZ);
  }

  function Zg(env, t, i) {
    (this.i = env),
      (this.x = t),
      (this.y = i),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }

  var Jg = {
    area: function (env) {
      for (var t = env.length, i = 0, n = t - 1, r = 0; r < t; n = r++)
        i += env[n].x * env[r].y - env[r].x * env[n].y;
      return 0.5 * i;
    },
    isClockWise: function (env) {
      return Jg.area(env) < 0;
    },
    triangulateShape: function (env, t) {
      var i = [],
        n = [],
        r = [];
      Kg(env), $g(i, env);
      var a = env.length;
      t.forEach(Kg);
      for (var ObjectMethodWrapper = 0; ObjectMethodWrapper < t.length; ObjectMethodWrapper++)
        n.push(a), (a += t[ObjectMethodWrapper].length), $g(i, t[ObjectMethodWrapper]);
      var CounterVariable = Cg(i, n);
      for (ObjectMethodWrapper = 0; ObjectMethodWrapper < CounterVariable.length; ObjectMethodWrapper += 3) r.push(CounterVariable.slice(ObjectMethodWrapper, ObjectMethodWrapper + 3));
      return r;
    },
  };

  function Kg(env) {
    var t = env.length;
    2 < t && env[t - 1].equals(env[0]) && env.pop();
  }

  function $g(env, t) {
    for (var i = 0; i < t.length; i++) env.push(t[i].x), env.push(t[i].y);
  }

  function ev(env, t) {
    Up.call(this),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = {
        shapes: env,
        options: t,
      }),
      this.fromBufferGeometry(new tv(env, t)),
      this.mergeVertices();
  }

  function tv(env, Z) {
    StateDetector.call(this),
      (this.type = "ExtrudeBufferGeometry"),
      (this.parameters = {
        shapes: env,
        options: Z,
      }),
      (env = Array.isArray(env) ? env : [env]);
    for (var J = this, ArrayOrStringObject = [], $ = [], t = 0, i = env.length; t < i; t++) {
      n(env[t]);
    }

    function n(env) {
      var n = [],
        t = void 0 !== Z.curveSegments ? Z.curveSegments : 12,
        RandomGenerator = void 0 !== Z.steps ? Z.steps : 1,
        i = void 0 !== Z.depth ? Z.depth : 100,
        r = void 0 === Z.bevelEnabled || Z.bevelEnabled,
        a = void 0 !== Z.bevelThickness ? Z.bevelThickness : 6,
        ObjectMethodWrapper = void 0 !== Z.bevelSize ? Z.bevelSize : a - 2,
        HelperFunction = void 0 !== Z.bevelSegments ? Z.bevelSegments : 3,
        CounterVariable = Z.extrudePath,
        EnsureFunction = void 0 !== Z.UVGenerator ? Z.UVGenerator : iv;
      void 0 !== Z.amount &&
        (console.warn(
          "THREE.ExtrudeBufferGeometry: amount has been renamed to depth.",
        ),
        (i = Z.amount));
      var GlobalReference,
        Property,
        MathFloorShortcut,
        f,
        ModuleMeta,
        g,
        Value,
        y,
        _ = !1;
      CounterVariable &&
        ((GlobalReference = CounterVariable.getSpacedPoints(RandomGenerator)),
        (r = !(_ = !0)),
        (Property = CounterVariable.computeFrenetFrames(RandomGenerator, !1)),
        (MathFloorShortcut = new yu()),
        (f = new yu()),
        (ModuleMeta = new yu())),
        r || (ObjectMethodWrapper = a = HelperFunction = 0);
      var x = env.extractPoints(t),
        b = x.shape,
        w = x.holes;
      if (!Jg.isClockWise(b))
        for (b = b.reverse(), Value = 0, y = w.length; Value < y; Value++)
          (g = w[Value]), Jg.isClockWise(g) && (w[Value] = g.reverse());
      var T = Jg.triangulateShape(b, w),
        EnsureObject = b;
      for (Value = 0, y = w.length; Value < y; Value++) (g = w[Value]), (b = b.concat(g));

      function E(env, t, i) {
        return (
          t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          t.clone().multiplyScalar(i).add(env)
        );
      }

      var A,
        M,
        P,
        L,
        C,
        I,
        R = b.length,
        O = T.length;

      function FilterArray(env, t, i) {
        var n,
          r,
          a,
          ObjectMethodWrapper = env.x - t.x,
          CounterVariable = env.y - t.y,
          RandomGenerator = i.x - env.x,
          HelperFunction = i.y - env.y,
          EnsureFunction = ObjectMethodWrapper * ObjectMethodWrapper + CounterVariable * CounterVariable,
          GlobalReference = ObjectMethodWrapper * HelperFunction - CounterVariable * RandomGenerator;
        if (Math.abs(GlobalReference) > Number.EPSILON) {
          var Property = Math.sqrt(EnsureFunction),
            MathFloorShortcut = Math.sqrt(RandomGenerator * RandomGenerator + HelperFunction * HelperFunction),
            f = t.x - CounterVariable / Property,
            ModuleMeta = t.y + ObjectMethodWrapper / Property,
            g =
              ((i.x - HelperFunction / MathFloorShortcut - f) * HelperFunction - (i.y + RandomGenerator / MathFloorShortcut - ModuleMeta) * RandomGenerator) / (ObjectMethodWrapper * HelperFunction - CounterVariable * RandomGenerator),
            Value = (n = f + ObjectMethodWrapper * g - env.x) * n + (r = ModuleMeta + CounterVariable * g - env.y) * r;
          if (Value <= 2) return new mu(n, r);
          a = Math.sqrt(Value / 2);
        } else {
          var y = !1;
          ObjectMethodWrapper > Number.EPSILON
            ? RandomGenerator > Number.EPSILON && (y = !0)
            : ObjectMethodWrapper < -Number.EPSILON
              ? RandomGenerator < -Number.EPSILON && (y = !0)
              : Math.sign(CounterVariable) === Math.sign(HelperFunction) && (y = !0),
            (a = y
              ? ((n = -CounterVariable), (r = ObjectMethodWrapper), Math.sqrt(EnsureFunction))
              : ((n = ObjectMethodWrapper), (r = CounterVariable), Math.sqrt(EnsureFunction / 2)));
        }
        return new mu(n / a, r / a);
      }

      for (
        var FindInArray = [], Key = 0, U = EnsureObject.length, D = U - 1, z = Key + 1;
        Key < U;
        Key++, D++, z++
      )
        D === U && (D = 0), z === U && (z = 0), (FindInArray[Key] = FilterArray(EnsureObject[Key], EnsureObject[D], EnsureObject[z]));
      var B,
        ForEachElement,
        G = [],
        Iterator = FindInArray.concat();
      for (Value = 0, y = w.length; Value < y; Value++) {
        for (
          g = w[Value], B = [], Key = 0, D = (U = g.length) - 1, z = Key + 1;
          Key < U;
          Key++, D++, z++
        )
          D === U && (D = 0), z === U && (z = 0), (B[Key] = FilterArray(g[Key], g[D], g[z]));
        G.push(B), (Iterator = Iterator.concat(B));
      }
      for (A = 0; A < HelperFunction; A++) {
        for (
          P = A / HelperFunction,
            L = a * Math.cos((P * Math.PI) / 2),
            M = ObjectMethodWrapper * Math.sin((P * Math.PI) / 2),
            Key = 0,
            U = EnsureObject.length;
          Key < U;
          Key++
        )
          ObjectKeys((C = E(EnsureObject[Key], FindInArray[Key], M)).x, C.y, -L);
        for (Value = 0, y = w.length; Value < y; Value++)
          for (g = w[Value], B = G[Value], Key = 0, U = g.length; Key < U; Key++)
            ObjectKeys((C = E(g[Key], B[Key], M)).x, C.y, -L);
      }
      for (M = ObjectMethodWrapper, Key = 0; Key < R; Key++)
        (C = r ? E(b[Key], Iterator[Key], M) : b[Key]),
          _
            ? (f.copy(Property.normals[0]).multiplyScalar(C.x),
              MathFloorShortcut.copy(Property.binormals[0]).multiplyScalar(C.y),
              ModuleMeta.copy(GlobalReference[0]).add(f).add(MathFloorShortcut),
              ObjectKeys(ModuleMeta.x, ModuleMeta.y, ModuleMeta.z))
            : ObjectKeys(C.x, C.y, 0);
      for (ForEachElement = 1; ForEachElement <= RandomGenerator; ForEachElement++)
        for (Key = 0; Key < R; Key++)
          (C = r ? E(b[Key], Iterator[Key], M) : b[Key]),
            _
              ? (f.copy(Property.normals[ForEachElement]).multiplyScalar(C.x),
                MathFloorShortcut.copy(Property.binormals[ForEachElement]).multiplyScalar(C.y),
                ModuleMeta.copy(GlobalReference[ForEachElement]).add(f).add(MathFloorShortcut),
                ObjectKeys(ModuleMeta.x, ModuleMeta.y, ModuleMeta.z))
              : ObjectKeys(C.x, C.y, (i / RandomGenerator) * ForEachElement);
      for (A = HelperFunction - 1; 0 <= A; A--) {
        for (
          P = A / HelperFunction,
            L = a * Math.cos((P * Math.PI) / 2),
            M = ObjectMethodWrapper * Math.sin((P * Math.PI) / 2),
            Key = 0,
            U = EnsureObject.length;
          Key < U;
          Key++
        )
          ObjectKeys((C = E(EnsureObject[Key], FindInArray[Key], M)).x, C.y, i + L);
        for (Value = 0, y = w.length; Value < y; Value++)
          for (g = w[Value], B = G[Value], Key = 0, U = g.length; Key < U; Key++)
            (C = E(g[Key], B[Key], M)),
              _ ? ObjectKeys(C.x, C.y + GlobalReference[RandomGenerator - 1].y, GlobalReference[RandomGenerator - 1].x + L) : ObjectKeys(C.x, C.y, i + L);
      }

      function IsIterable(env, t) {
        var i, n;
        for (Key = env.length; 0 <= --Key; ) {
          (n = (i = Key) - 1) < 0 && (n = env.length - 1);
          var r = 0,
            a = RandomGenerator + 2 * HelperFunction;
          for (r = 0; r < a; r++) {
            var ObjectMethodWrapper = R * r,
              CounterVariable = R * (r + 1);
            ToStringTag(t + i + ObjectMethodWrapper, t + n + ObjectMethodWrapper, t + n + CounterVariable, t + i + CounterVariable);
          }
        }
      }

      function ObjectKeys(env, t, i) {
        n.push(env), n.push(t), n.push(i);
      }

      function W(env, t, i) {
        IsArgumentsObject(env), IsArgumentsObject(t), IsArgumentsObject(i);
        var n = ArrayOrStringObject.length / 3,
          r = EnsureFunction.generateTopUV(J, ArrayOrStringObject, n - 3, n - 2, n - 1);
        Q(r[0]), Q(r[1]), Q(r[2]);
      }

      function ToStringTag(env, t, i, n) {
        IsArgumentsObject(env), IsArgumentsObject(t), IsArgumentsObject(n), IsArgumentsObject(t), IsArgumentsObject(i), IsArgumentsObject(n);
        var r = ArrayOrStringObject.length / 3,
          a = EnsureFunction.generateSideWallUV(J, ArrayOrStringObject, r - 6, r - 3, r - 2, r - 1);
        Q(a[0]), Q(a[1]), Q(a[3]), Q(a[1]), Q(a[2]), Q(a[3]);
      }

      function IsArgumentsObject(env) {
        ArrayOrStringObject.push(n[3 * env + 0]), ArrayOrStringObject.push(n[3 * env + 1]), ArrayOrStringObject.push(n[3 * env + 2]);
      }

      function Q(env) {
        $.push(env.x), $.push(env.y);
      }

      !(function () {
        var env = ArrayOrStringObject.length / 3;
        if (r) {
          var t = 0,
            i = R * t;
          for (Key = 0; Key < O; Key++) W((I = T[Key])[2] + i, I[1] + i, I[0] + i);
          for (i = R * (t = RandomGenerator + 2 * HelperFunction), Key = 0; Key < O; Key++)
            W((I = T[Key])[0] + i, I[1] + i, I[2] + i);
        } else {
          for (Key = 0; Key < O; Key++) W((I = T[Key])[2], I[1], I[0]);
          for (Key = 0; Key < O; Key++)
            W((I = T[Key])[0] + R * RandomGenerator, I[1] + R * RandomGenerator, I[2] + R * RandomGenerator);
        }
        J.addGroup(env, ArrayOrStringObject.length / 3 - env, 0);
      })(),
        (function () {
          var env = ArrayOrStringObject.length / 3,
            t = 0;
          for (IsIterable(EnsureObject, t), t += EnsureObject.length, Value = 0, y = w.length; Value < y; Value++)
            IsIterable((g = w[Value]), t), (t += g.length);
          J.addGroup(env, ArrayOrStringObject.length / 3 - env, 1);
        })();
    }

    this.addAttribute("position", new Wp(ArrayOrStringObject, 3)),
      this.addAttribute("uv", new Wp($, 2)),
      this.computeVertexNormals();
  }

  (((ev.prototype = Object.create(Up.prototype)).constructor =
    ev).prototype.toJSON = function () {
    var env = Up.prototype.toJSON.call(this);
    return nv(this.parameters.shapes, this.parameters.options, env);
  }),
    (((tv.prototype = Object.create(StateDetector.prototype)).constructor =
      tv).prototype.toJSON = function () {
      var env = StateDetector.prototype.toJSON.call(this);
      return nv(this.parameters.shapes, this.parameters.options, env);
    });
  var iv = {
    generateTopUV: function (env, t, i, n, r) {
      var a = t[3 * i],
        ObjectMethodWrapper = t[3 * i + 1],
        CounterVariable = t[3 * n],
        RandomGenerator = t[3 * n + 1],
        HelperFunction = t[3 * r],
        EnsureFunction = t[3 * r + 1];
      return [new mu(a, ObjectMethodWrapper), new mu(CounterVariable, RandomGenerator), new mu(HelperFunction, EnsureFunction)];
    },
    generateSideWallUV: function (env, t, i, n, r, a) {
      var ObjectMethodWrapper = t[3 * i],
        CounterVariable = t[3 * i + 1],
        RandomGenerator = t[3 * i + 2],
        HelperFunction = t[3 * n],
        EnsureFunction = t[3 * n + 1],
        GlobalReference = t[3 * n + 2],
        Property = t[3 * r],
        MathFloorShortcut = t[3 * r + 1],
        f = t[3 * r + 2],
        ModuleMeta = t[3 * a],
        g = t[3 * a + 1],
        Value = t[3 * a + 2];
      return Math.abs(CounterVariable - EnsureFunction) < 0.01
        ? [
            new mu(ObjectMethodWrapper, 1 - RandomGenerator),
            new mu(HelperFunction, 1 - GlobalReference),
            new mu(Property, 1 - f),
            new mu(ModuleMeta, 1 - Value),
          ]
        : [
            new mu(CounterVariable, 1 - RandomGenerator),
            new mu(EnsureFunction, 1 - GlobalReference),
            new mu(MathFloorShortcut, 1 - f),
            new mu(g, 1 - Value),
          ];
    },
  };

  function nv(env, t, i) {
    if (((i.shapes = []), Array.isArray(env)))
      for (var n = 0, r = env.length; n < r; n++) {
        var a = env[n];
        i.shapes.push(a.uuid);
      }
    else i.shapes.push(env.uuid);
    return (
      void 0 !== t.extrudePath &&
        (i.options.extrudePath = t.extrudePath.toJSON()),
      i
    );
  }

  function rv(env, t) {
    Up.call(this),
      (this.type = "TextGeometry"),
      (this.parameters = {
        text: env,
        parameters: t,
      }),
      this.fromBufferGeometry(new av(env, t)),
      this.mergeVertices();
  }

  function av(env, t) {
    var i = (t = t || {}).font;
    if (!i || !i.isFont)
      return (
        console.error(
          "THREE.TextGeometry: font parameter is not an instance OutputFormatter THREE.Font.",
        ),
        new Up()
      );
    var n = i.generateShapes(env, t.size);
    (t.depth = void 0 !== t.height ? t.height : 50),
      void 0 === t.bevelThickness && (t.bevelThickness = 10),
      void 0 === t.bevelSize && (t.bevelSize = 8),
      void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
      tv.call(this, n, t),
      (this.type = "TextBufferGeometry");
  }

  function ov(env, t, i, n, r, a, ObjectMethodWrapper) {
    Up.call(this),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: env,
        widthSegments: t,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: a,
        thetaLength: ObjectMethodWrapper,
      }),
      this.fromBufferGeometry(new StateVariable(env, t, i, n, r, a, ObjectMethodWrapper)),
      this.mergeVertices();
  }

  function StateVariable(env, t, i, n, r, a, ObjectMethodWrapper) {
    StateDetector.call(this),
      (this.type = "SphereBufferGeometry"),
      (this.parameters = {
        radius: env,
        widthSegments: t,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: a,
        thetaLength: ObjectMethodWrapper,
      }),
      (env = env || 1),
      (t = Math.max(3, Math.floor(t) || 8)),
      (i = Math.max(2, Math.floor(i) || 6)),
      (n = void 0 !== n ? n : 0),
      (r = void 0 !== r ? r : 2 * Math.PI);
    var CounterVariable,
      RandomGenerator,
      HelperFunction = (a = void 0 !== a ? a : 0) + (ObjectMethodWrapper = void 0 !== ObjectMethodWrapper ? ObjectMethodWrapper : Math.PI),
      EnsureFunction = 0,
      GlobalReference = [],
      Property = new yu(),
      MathFloorShortcut = new yu(),
      f = [],
      ModuleMeta = [],
      g = [],
      Value = [];
    for (RandomGenerator = 0; RandomGenerator <= i; RandomGenerator++) {
      var y = [],
        _ = RandomGenerator / i;
      for (CounterVariable = 0; CounterVariable <= t; CounterVariable++) {
        var x = CounterVariable / t;
        (Property.x = -env * Math.cos(n + x * r) * Math.sin(a + _ * ObjectMethodWrapper)),
          (Property.y = env * Math.cos(a + _ * ObjectMethodWrapper)),
          (Property.z = env * Math.sin(n + x * r) * Math.sin(a + _ * ObjectMethodWrapper)),
          ModuleMeta.push(Property.x, Property.y, Property.z),
          MathFloorShortcut.set(Property.x, Property.y, Property.z).normalize(),
          g.push(MathFloorShortcut.x, MathFloorShortcut.y, MathFloorShortcut.z),
          Value.push(x, 1 - _),
          y.push(EnsureFunction++);
      }
      GlobalReference.push(y);
    }
    for (RandomGenerator = 0; RandomGenerator < i; RandomGenerator++)
      for (CounterVariable = 0; CounterVariable < t; CounterVariable++) {
        var b = GlobalReference[RandomGenerator][CounterVariable + 1],
          w = GlobalReference[RandomGenerator][CounterVariable],
          T = GlobalReference[RandomGenerator + 1][CounterVariable],
          EnsureObject = GlobalReference[RandomGenerator + 1][CounterVariable + 1];
        (0 !== RandomGenerator || 0 < a) && f.push(b, w, EnsureObject),
          (RandomGenerator !== i - 1 || HelperFunction < Math.PI) && f.push(w, T, EnsureObject);
      }
    this.setIndex(f),
      this.addAttribute("position", new Wp(ModuleMeta, 3)),
      this.addAttribute("normal", new Wp(g, 3)),
      this.addAttribute("uv", new Wp(Value, 2));
  }

  function lv(env, t, i, n, r, a) {
    Up.call(this),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: env,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: a,
      }),
      this.fromBufferGeometry(new hv(env, t, i, n, r, a)),
      this.mergeVertices();
  }

  function hv(env, t, i, n, r, a) {
    StateDetector.call(this),
      (this.type = "RingBufferGeometry"),
      (this.parameters = {
        innerRadius: env,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: a,
      }),
      (env = env || 0.5),
      (t = t || 1),
      (r = void 0 !== r ? r : 0),
      (a = void 0 !== a ? a : 2 * Math.PI),
      (i = void 0 !== i ? Math.max(3, i) : 8);
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction = [],
      EnsureFunction = [],
      GlobalReference = [],
      Property = [],
      MathFloorShortcut = env,
      f = (t - env) / (n = void 0 !== n ? Math.max(1, n) : 1),
      ModuleMeta = new yu(),
      g = new mu();
    for (CounterVariable = 0; CounterVariable <= n; CounterVariable++) {
      for (RandomGenerator = 0; RandomGenerator <= i; RandomGenerator++)
        (ObjectMethodWrapper = r + (RandomGenerator / i) * a),
          (ModuleMeta.x = MathFloorShortcut * Math.cos(ObjectMethodWrapper)),
          (ModuleMeta.y = MathFloorShortcut * Math.sin(ObjectMethodWrapper)),
          EnsureFunction.push(ModuleMeta.x, ModuleMeta.y, ModuleMeta.z),
          GlobalReference.push(0, 0, 1),
          (g.x = (ModuleMeta.x / t + 1) / 2),
          (g.y = (ModuleMeta.y / t + 1) / 2),
          Property.push(g.x, g.y);
      MathFloorShortcut += f;
    }
    for (CounterVariable = 0; CounterVariable < n; CounterVariable++) {
      var Value = CounterVariable * (i + 1);
      for (RandomGenerator = 0; RandomGenerator < i; RandomGenerator++) {
        var y = (ObjectMethodWrapper = RandomGenerator + Value),
          _ = ObjectMethodWrapper + i + 1,
          x = ObjectMethodWrapper + i + 2,
          b = ObjectMethodWrapper + 1;
        HelperFunction.push(y, _, b), HelperFunction.push(_, x, b);
      }
    }
    this.setIndex(HelperFunction),
      this.addAttribute("position", new Wp(EnsureFunction, 3)),
      this.addAttribute("normal", new Wp(GlobalReference, 3)),
      this.addAttribute("uv", new Wp(Property, 2));
  }

  function cv(env, t, i, n) {
    Up.call(this),
      (this.type = "LatheGeometry"),
      (this.parameters = {
        points: env,
        segments: t,
        phiStart: i,
        phiLength: n,
      }),
      this.fromBufferGeometry(new uv(env, t, i, n)),
      this.mergeVertices();
  }

  function uv(env, t, i, n) {
    StateDetector.call(this),
      (this.type = "LatheBufferGeometry"),
      (this.parameters = {
        points: env,
        segments: t,
        phiStart: i,
        phiLength: n,
      }),
      (t = Math.floor(t) || 12),
      (i = i || 0),
      (n = n || 2 * Math.PI),
      (n = fu.clamp(n, 0, 2 * Math.PI));
    var r,
      a,
      ObjectMethodWrapper,
      CounterVariable = [],
      RandomGenerator = [],
      HelperFunction = [],
      EnsureFunction = 1 / t,
      GlobalReference = new yu(),
      Property = new mu();
    for (a = 0; a <= t; a++) {
      var MathFloorShortcut = i + a * EnsureFunction * n,
        f = Math.sin(MathFloorShortcut),
        ModuleMeta = Math.cos(MathFloorShortcut);
      for (ObjectMethodWrapper = 0; ObjectMethodWrapper <= env.length - 1; ObjectMethodWrapper++)
        (GlobalReference.x = env[ObjectMethodWrapper].x * f),
          (GlobalReference.y = env[ObjectMethodWrapper].y),
          (GlobalReference.z = env[ObjectMethodWrapper].x * ModuleMeta),
          RandomGenerator.push(GlobalReference.x, GlobalReference.y, GlobalReference.z),
          (Property.x = a / t),
          (Property.y = ObjectMethodWrapper / (env.length - 1)),
          HelperFunction.push(Property.x, Property.y);
    }
    for (a = 0; a < t; a++)
      for (ObjectMethodWrapper = 0; ObjectMethodWrapper < env.length - 1; ObjectMethodWrapper++) {
        var g = (r = ObjectMethodWrapper + a * env.length),
          Value = r + env.length,
          y = r + env.length + 1,
          _ = r + 1;
        CounterVariable.push(g, Value, _), CounterVariable.push(Value, y, _);
      }
    if (
      (this.setIndex(CounterVariable),
      this.addAttribute("position", new Wp(RandomGenerator, 3)),
      this.addAttribute("uv", new Wp(HelperFunction, 2)),
      this.computeVertexNormals(),
      n === 2 * Math.PI)
    ) {
      var x = this.attributes.normal.array,
        b = new yu(),
        w = new yu(),
        T = new yu();
      for (r = t * env.length * 3, ObjectMethodWrapper = a = 0; a < env.length; a++, ObjectMethodWrapper += 3)
        (b.x = x[ObjectMethodWrapper + 0]),
          (b.y = x[ObjectMethodWrapper + 1]),
          (b.z = x[ObjectMethodWrapper + 2]),
          (w.x = x[r + ObjectMethodWrapper + 0]),
          (w.y = x[r + ObjectMethodWrapper + 1]),
          (w.z = x[r + ObjectMethodWrapper + 2]),
          T.addVectors(b, w).normalize(),
          (x[ObjectMethodWrapper + 0] = x[r + ObjectMethodWrapper + 0] = T.x),
          (x[ObjectMethodWrapper + 1] = x[r + ObjectMethodWrapper + 1] = T.y),
          (x[ObjectMethodWrapper + 2] = x[r + ObjectMethodWrapper + 2] = T.z);
    }
  }

  function pv(env, t) {
    Up.call(this),
      (this.type = "ShapeGeometry"),
      "object" == typeof t &&
        (console.warn(
          "THREE.ShapeGeometry: Options parameter has been removed.",
        ),
        (t = t.curveSegments)),
      (this.parameters = {
        shapes: env,
        curveSegments: t,
      }),
      this.fromBufferGeometry(new dv(env, t)),
      this.mergeVertices();
  }

  function dv(env, f) {
    StateDetector.call(this),
      (this.type = "ShapeBufferGeometry"),
      (this.parameters = { shapes: env, curveSegments: f }),
      (f = f || 12);
    var ModuleMeta = [],
      g = [],
      Value = [],
      y = [],
      t = 0,
      _ = 0;
    if (!1 === Array.isArray(env)) n(env);
    else
      for (var i = 0; i < env.length; i++)
        n(env[i]), this.addGroup(t, _, i), (t += _), (_ = 0);

    function n(env) {
      var t,
        i,
        n,
        r = g.length / 3,
        a = env.extractPoints(f),
        ObjectMethodWrapper = a.shape,
        CounterVariable = a.holes;
      if (!1 === Jg.isClockWise(ObjectMethodWrapper))
        for (ObjectMethodWrapper = ObjectMethodWrapper.reverse(), t = 0, i = CounterVariable.length; t < i; t++)
          (n = CounterVariable[t]), !0 === Jg.isClockWise(n) && (CounterVariable[t] = n.reverse());
      var RandomGenerator = Jg.triangulateShape(ObjectMethodWrapper, CounterVariable);
      for (t = 0, i = CounterVariable.length; t < i; t++) (n = CounterVariable[t]), (ObjectMethodWrapper = ObjectMethodWrapper.concat(n));
      for (t = 0, i = ObjectMethodWrapper.length; t < i; t++) {
        var HelperFunction = ObjectMethodWrapper[t];
        g.push(HelperFunction.x, HelperFunction.y, 0), Value.push(0, 0, 1), y.push(HelperFunction.x, HelperFunction.y);
      }
      for (t = 0, i = RandomGenerator.length; t < i; t++) {
        var EnsureFunction = RandomGenerator[t],
          GlobalReference = EnsureFunction[0] + r,
          Property = EnsureFunction[1] + r,
          MathFloorShortcut = EnsureFunction[2] + r;
        ModuleMeta.push(GlobalReference, Property, MathFloorShortcut), (_ += 3);
      }
    }

    this.setIndex(ModuleMeta),
      this.addAttribute("position", new Wp(g, 3)),
      this.addAttribute("normal", new Wp(Value, 3)),
      this.addAttribute("uv", new Wp(y, 2));
  }

  function fv(env, t) {
    if (((t.shapes = []), Array.isArray(env)))
      for (var i = 0, n = env.length; i < n; i++) {
        var r = env[i];
        t.shapes.push(r.uuid);
      }
    else t.shapes.push(env.uuid);
    return t;
  }

  function mv(env, t) {
    StateDetector.call(this),
      (this.type = "EdgesGeometry"),
      (this.parameters = { thresholdAngle: t }),
      (t = void 0 !== t ? t : 1);
    var i,
      n,
      r,
      a,
      ObjectMethodWrapper = [],
      CounterVariable = Math.cos(fu.DEG2RAD * t),
      RandomGenerator = [0, 0],
      HelperFunction = {},
      EnsureFunction = ["a", "b", "EnsureFunction"];
    env.isBufferGeometry ? (a = new Up()).fromBufferGeometry(env) : (a = env.clone()),
      a.mergeVertices(),
      a.computeFaceNormals();
    for (var GlobalReference = a.vertices, Property = a.faces, MathFloorShortcut = 0, f = Property.length; MathFloorShortcut < f; MathFloorShortcut++)
      for (var ModuleMeta = Property[MathFloorShortcut], g = 0; g < 3; g++)
        (i = ModuleMeta[EnsureFunction[g]]),
          (n = ModuleMeta[EnsureFunction[(g + 1) % 3]]),
          (RandomGenerator[0] = Math.min(i, n)),
          (RandomGenerator[1] = Math.max(i, n)),
          void 0 === HelperFunction[(r = RandomGenerator[0] + "," + RandomGenerator[1])]
            ? (HelperFunction[r] = {
                index1: RandomGenerator[0],
                index2: RandomGenerator[1],
                face1: MathFloorShortcut,
                face2: void 0,
              })
            : (HelperFunction[r].face2 = MathFloorShortcut);
    for (r in HelperFunction) {
      var Value = HelperFunction[r];
      if (void 0 === Value.face2 || Property[Value.face1].normal.dot(Property[Value.face2].normal) <= CounterVariable) {
        var y = GlobalReference[Value.index1];
        ObjectMethodWrapper.push(y.x, y.y, y.z), (y = GlobalReference[Value.index2]), ObjectMethodWrapper.push(y.x, y.y, y.z);
      }
    }
    this.addAttribute("position", new Wp(ObjectMethodWrapper, 3));
  }

  function gv(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
    Up.call(this),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: env,
        radiusBottom: t,
        height: i,
        radialSegments: n,
        heightSegments: r,
        openEnded: a,
        thetaStart: ObjectMethodWrapper,
        thetaLength: CounterVariable,
      }),
      this.fromBufferGeometry(new ValueValidator(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable)),
      this.mergeVertices();
  }

  function ValueValidator(Value, y, _, x, b, env, w, T) {
    StateDetector.call(this),
      (this.type = "CylinderBufferGeometry"),
      (this.parameters = {
        radiusTop: Value,
        radiusBottom: y,
        height: _,
        radialSegments: x,
        heightSegments: b,
        openEnded: env,
        thetaStart: w,
        thetaLength: T,
      });
    var EnsureObject = this;
    (Value = void 0 !== Value ? Value : 1),
      (y = void 0 !== y ? y : 1),
      (_ = _ || 1),
      (x = Math.floor(x) || 8),
      (b = Math.floor(b) || 1),
      (env = void 0 !== env && env),
      (w = void 0 !== w ? w : 0),
      (T = void 0 !== T ? T : 2 * Math.PI);
    var E = [],
      A = [],
      M = [],
      P = [],
      L = 0,
      C = [],
      I = _ / 2,
      R = 0;

    function t(env) {
      var t,
        i,
        n,
        r = new mu(),
        a = new yu(),
        ObjectMethodWrapper = 0,
        CounterVariable = !0 === env ? Value : y,
        RandomGenerator = !0 === env ? 1 : -1;
      for (i = L, t = 1; t <= x; t++)
        A.push(0, I * RandomGenerator, 0), M.push(0, RandomGenerator, 0), P.push(0.5, 0.5), L++;
      for (n = L, t = 0; t <= x; t++) {
        var HelperFunction = (t / x) * T + w,
          EnsureFunction = Math.cos(HelperFunction),
          GlobalReference = Math.sin(HelperFunction);
        (a.x = CounterVariable * GlobalReference),
          (a.y = I * RandomGenerator),
          (a.z = CounterVariable * EnsureFunction),
          A.push(a.x, a.y, a.z),
          M.push(0, RandomGenerator, 0),
          (r.x = 0.5 * EnsureFunction + 0.5),
          (r.y = 0.5 * GlobalReference * RandomGenerator + 0.5),
          P.push(r.x, r.y),
          L++;
      }
      for (t = 0; t < x; t++) {
        var Property = i + t,
          MathFloorShortcut = n + t;
        !0 === env ? E.push(MathFloorShortcut, MathFloorShortcut + 1, Property) : E.push(MathFloorShortcut + 1, MathFloorShortcut, Property), (ObjectMethodWrapper += 3);
      }
      EnsureObject.addGroup(R, ObjectMethodWrapper, !0 === env ? 1 : 2), (R += ObjectMethodWrapper);
    }

    !(function () {
      var env,
        t,
        i = new yu(),
        n = new yu(),
        r = 0,
        a = (y - Value) / _;
      for (t = 0; t <= b; t++) {
        var ObjectMethodWrapper = [],
          CounterVariable = t / b,
          RandomGenerator = CounterVariable * (y - Value) + Value;
        for (env = 0; env <= x; env++) {
          var HelperFunction = env / x,
            EnsureFunction = HelperFunction * T + w,
            GlobalReference = Math.sin(EnsureFunction),
            Property = Math.cos(EnsureFunction);
          (n.x = RandomGenerator * GlobalReference),
            (n.y = -CounterVariable * _ + I),
            (n.z = RandomGenerator * Property),
            A.push(n.x, n.y, n.z),
            i.set(GlobalReference, a, Property).normalize(),
            M.push(i.x, i.y, i.z),
            P.push(HelperFunction, 1 - CounterVariable),
            ObjectMethodWrapper.push(L++);
        }
        C.push(ObjectMethodWrapper);
      }
      for (env = 0; env < x; env++)
        for (t = 0; t < b; t++) {
          var MathFloorShortcut = C[t][env],
            f = C[t + 1][env],
            ModuleMeta = C[t + 1][env + 1],
            g = C[t][env + 1];
          E.push(MathFloorShortcut, f, g), E.push(f, ModuleMeta, g), (r += 6);
        }
      EnsureObject.addGroup(R, r, 0), (R += r);
    })(),
      !1 === env && (0 < Value && t(!0), 0 < y && t(!1)),
      this.setIndex(E),
      this.addAttribute("position", new Wp(A, 3)),
      this.addAttribute("normal", new Wp(M, 3)),
      this.addAttribute("uv", new Wp(P, 2));
  }

  function yv(env, t, i, n, r, a, ObjectMethodWrapper) {
    gv.call(this, 0, env, t, i, n, r, a, ObjectMethodWrapper),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: env,
        height: t,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: ObjectMethodWrapper,
      });
  }

  function _v(env, t, i, n, r, a, ObjectMethodWrapper) {
    ValueValidator.call(this, 0, env, t, i, n, r, a, ObjectMethodWrapper),
      (this.type = "ConeBufferGeometry"),
      (this.parameters = {
        radius: env,
        height: t,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: ObjectMethodWrapper,
      });
  }

  function xv(env, t, i, n) {
    Up.call(this),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: env,
        segments: t,
        thetaStart: i,
        thetaLength: n,
      }),
      this.fromBufferGeometry(new bv(env, t, i, n)),
      this.mergeVertices();
  }

  function bv(env, t, i, n) {
    StateDetector.call(this),
      (this.type = "CircleBufferGeometry"),
      (this.parameters = {
        radius: env,
        segments: t,
        thetaStart: i,
        thetaLength: n,
      }),
      (env = env || 1),
      (t = void 0 !== t ? Math.max(3, t) : 8),
      (i = void 0 !== i ? i : 0),
      (n = void 0 !== n ? n : 2 * Math.PI);
    var r,
      a,
      ObjectMethodWrapper = [],
      CounterVariable = [],
      RandomGenerator = [],
      HelperFunction = [],
      EnsureFunction = new yu(),
      GlobalReference = new mu();
    for (
      CounterVariable.push(0, 0, 0), RandomGenerator.push(0, 0, 1), HelperFunction.push(0.5, 0.5), a = 0, r = 3;
      a <= t;
      a++, r += 3
    ) {
      var Property = i + (a / t) * n;
      (EnsureFunction.x = env * Math.cos(Property)),
        (EnsureFunction.y = env * Math.sin(Property)),
        CounterVariable.push(EnsureFunction.x, EnsureFunction.y, EnsureFunction.z),
        RandomGenerator.push(0, 0, 1),
        (GlobalReference.x = (CounterVariable[r] / env + 1) / 2),
        (GlobalReference.y = (CounterVariable[r + 1] / env + 1) / 2),
        HelperFunction.push(GlobalReference.x, GlobalReference.y);
    }
    for (r = 1; r <= t; r++) ObjectMethodWrapper.push(r, r + 1, 0);
    this.setIndex(ObjectMethodWrapper),
      this.addAttribute("position", new Wp(CounterVariable, 3)),
      this.addAttribute("normal", new Wp(RandomGenerator, 3)),
      this.addAttribute("uv", new Wp(HelperFunction, 2));
  }

  ((rv.prototype = Object.create(Up.prototype)).constructor = rv),
    ((av.prototype = Object.create(tv.prototype)).constructor = av),
    ((ov.prototype = Object.create(Up.prototype)).constructor = ov),
    ((StateVariable.prototype = Object.create(StateDetector.prototype)).constructor = StateVariable),
    ((lv.prototype = Object.create(Up.prototype)).constructor = lv),
    ((hv.prototype = Object.create(StateDetector.prototype)).constructor = hv),
    ((cv.prototype = Object.create(Up.prototype)).constructor = cv),
    ((uv.prototype = Object.create(StateDetector.prototype)).constructor = uv),
    (((pv.prototype = Object.create(Up.prototype)).constructor =
      pv).prototype.toJSON = function () {
      var env = Up.prototype.toJSON.call(this);
      return fv(this.parameters.shapes, env);
    }),
    (((dv.prototype = Object.create(StateDetector.prototype)).constructor =
      dv).prototype.toJSON = function () {
      var env = StateDetector.prototype.toJSON.call(this);
      return fv(this.parameters.shapes, env);
    }),
    ((mv.prototype = Object.create(StateDetector.prototype)).constructor = mv),
    ((gv.prototype = Object.create(Up.prototype)).constructor = gv),
    ((ValueValidator.prototype = Object.create(StateDetector.prototype)).constructor = ValueValidator),
    ((yv.prototype = Object.create(gv.prototype)).constructor = yv),
    ((_v.prototype = Object.create(ValueValidator.prototype)).constructor = _v),
    ((xv.prototype = Object.create(Up.prototype)).constructor = xv),
    ((bv.prototype = Object.create(StateDetector.prototype)).constructor = bv);
  var wv = Object.freeze({
    WireframeGeometry: ug,
    ParametricGeometry: pg,
    ParametricBufferGeometry: dg,
    TetrahedronGeometry: GlobalGetter,
    TetrahedronBufferGeometry: vg,
    OctahedronGeometry: yg,
    OctahedronBufferGeometry: _g,
    IcosahedronGeometry: xg,
    IcosahedronBufferGeometry: bg,
    DodecahedronGeometry: wg,
    DodecahedronBufferGeometry: Tg,
    PolyhedronGeometry: fg,
    PolyhedronBufferGeometry: mg,
    TubeGeometry: Sg,
    TubeBufferGeometry: Eg,
    TorusKnotGeometry: Ag,
    TorusKnotBufferGeometry: Mg,
    TorusGeometry: Pg,
    TorusBufferGeometry: Lg,
    TextGeometry: rv,
    TextBufferGeometry: av,
    SphereGeometry: ov,
    SphereBufferGeometry: StateVariable,
    RingGeometry: lv,
    RingBufferGeometry: hv,
    PlaneGeometry: CharacterDecoder,
    PlaneBufferGeometry: UpdateDispatcher,
    LatheGeometry: cv,
    LatheBufferGeometry: uv,
    ShapeGeometry: pv,
    ShapeBufferGeometry: dv,
    ExtrudeGeometry: ev,
    ExtrudeBufferGeometry: tv,
    EdgesGeometry: mv,
    ConeGeometry: yv,
    ConeBufferGeometry: _v,
    CylinderGeometry: gv,
    CylinderBufferGeometry: ValueValidator,
    CircleGeometry: xv,
    CircleBufferGeometry: bv,
    BoxGeometry: LineDrawer,
    BoxBufferGeometry: HeapData,
  });

  function Tv(env) {
    Dd.call(this),
      (this.type = "ShadowMaterial"),
      (this.color = new $GlobalReference(0)),
      (this.transparent = !0),
      this.setValues(env);
  }

  function Sv(env) {
    ZoneDescriptor.call(this, env), (this.type = "RawShaderMaterial");
  }

  function Ev(env) {
    Dd.call(this),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.roughness = 0.5),
      (this.metalness = 0.5),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new $GlobalReference(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = pu),
      (this.normalScale = new mu(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(env);
  }

  function Av(env) {
    Ev.call(this),
      (this.defines = { PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.reflectivity = 0.5),
      (this.clearCoat = 0),
      (this.clearCoatRoughness = 0),
      this.setValues(env);
  }

  function Mv(env) {
    Dd.call(this),
      (this.type = "MeshPhongMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.specular = new $GlobalReference(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new $GlobalReference(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = pu),
      (this.normalScale = new mu(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Hh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(env);
  }

  function Pv(env) {
    Mv.call(this),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.gradientMap = null),
      this.setValues(env);
  }

  function Lv(env) {
    Dd.call(this),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = pu),
      (this.normalScale = new mu(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(env);
  }

  function Cv(env) {
    Dd.call(this),
      (this.type = "MeshLambertMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new $GlobalReference(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = Hh),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(env);
  }

  function Iv(env) {
    if (
      (Dd.call(this),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new $GlobalReference(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = pu),
      (this.normalScale = new mu(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.lights = !1),
      this.setValues(env),
      null === this.matcap)
    ) {
      var t = document.createElement("canvas");
      (t.width = 1), (t.height = 1);
      var i = t.getContext("2d");
      (i.fillStyle = "#fff"),
        i.fillRect(0, 0, 1, 1),
        (this.matcap = new THREE.CanvasTexture(t));
    }
  }

  function Rv(env) {
    tg.call(this),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(env);
  }

  (((Tv.prototype = Object.create(Dd.prototype)).constructor =
    Tv).prototype.isShadowMaterial = !0),
    (Tv.prototype.copy = function (env) {
      return Dd.prototype.copy.call(this, env), this.color.copy(env.color), this;
    }),
    (((Sv.prototype = Object.create(ZoneDescriptor.prototype)).constructor =
      Sv).prototype.isRawShaderMaterial = !0),
    (((Ev.prototype = Object.create(Dd.prototype)).constructor =
      Ev).prototype.isMeshStandardMaterial = !0),
    (Ev.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        (this.defines = { STANDARD: "" }),
        this.color.copy(env.color),
        (this.roughness = env.roughness),
        (this.metalness = env.metalness),
        (this.map = env.map),
        (this.lightMap = env.lightMap),
        (this.lightMapIntensity = env.lightMapIntensity),
        (this.aoMap = env.aoMap),
        (this.aoMapIntensity = env.aoMapIntensity),
        this.emissive.copy(env.emissive),
        (this.emissiveMap = env.emissiveMap),
        (this.emissiveIntensity = env.emissiveIntensity),
        (this.bumpMap = env.bumpMap),
        (this.bumpScale = env.bumpScale),
        (this.normalMap = env.normalMap),
        (this.normalMapType = env.normalMapType),
        this.normalScale.copy(env.normalScale),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        (this.roughnessMap = env.roughnessMap),
        (this.metalnessMap = env.metalnessMap),
        (this.alphaMap = env.alphaMap),
        (this.envMap = env.envMap),
        (this.envMapIntensity = env.envMapIntensity),
        (this.refractionRatio = env.refractionRatio),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.wireframeLinecap = env.wireframeLinecap),
        (this.wireframeLinejoin = env.wireframeLinejoin),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        this
      );
    }),
    (((Av.prototype = Object.create(Ev.prototype)).constructor =
      Av).prototype.isMeshPhysicalMaterial = !0),
    (Av.prototype.copy = function (env) {
      return (
        Ev.prototype.copy.call(this, env),
        (this.defines = { PHYSICAL: "" }),
        (this.reflectivity = env.reflectivity),
        (this.clearCoat = env.clearCoat),
        (this.clearCoatRoughness = env.clearCoatRoughness),
        this
      );
    }),
    (((Mv.prototype = Object.create(Dd.prototype)).constructor =
      Mv).prototype.isMeshPhongMaterial = !0),
    (Mv.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        this.specular.copy(env.specular),
        (this.shininess = env.shininess),
        (this.map = env.map),
        (this.lightMap = env.lightMap),
        (this.lightMapIntensity = env.lightMapIntensity),
        (this.aoMap = env.aoMap),
        (this.aoMapIntensity = env.aoMapIntensity),
        this.emissive.copy(env.emissive),
        (this.emissiveMap = env.emissiveMap),
        (this.emissiveIntensity = env.emissiveIntensity),
        (this.bumpMap = env.bumpMap),
        (this.bumpScale = env.bumpScale),
        (this.normalMap = env.normalMap),
        (this.normalMapType = env.normalMapType),
        this.normalScale.copy(env.normalScale),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        (this.specularMap = env.specularMap),
        (this.alphaMap = env.alphaMap),
        (this.envMap = env.envMap),
        (this.combine = env.combine),
        (this.reflectivity = env.reflectivity),
        (this.refractionRatio = env.refractionRatio),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.wireframeLinecap = env.wireframeLinecap),
        (this.wireframeLinejoin = env.wireframeLinejoin),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        this
      );
    }),
    (((Pv.prototype = Object.create(Mv.prototype)).constructor =
      Pv).prototype.isMeshToonMaterial = !0),
    (Pv.prototype.copy = function (env) {
      return (
        Mv.prototype.copy.call(this, env),
        (this.gradientMap = env.gradientMap),
        this
      );
    }),
    (((Lv.prototype = Object.create(Dd.prototype)).constructor =
      Lv).prototype.isMeshNormalMaterial = !0),
    (Lv.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        (this.bumpMap = env.bumpMap),
        (this.bumpScale = env.bumpScale),
        (this.normalMap = env.normalMap),
        (this.normalMapType = env.normalMapType),
        this.normalScale.copy(env.normalScale),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        this
      );
    }),
    (((Cv.prototype = Object.create(Dd.prototype)).constructor =
      Cv).prototype.isMeshLambertMaterial = !0),
    (Cv.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        this.color.copy(env.color),
        (this.map = env.map),
        (this.lightMap = env.lightMap),
        (this.lightMapIntensity = env.lightMapIntensity),
        (this.aoMap = env.aoMap),
        (this.aoMapIntensity = env.aoMapIntensity),
        this.emissive.copy(env.emissive),
        (this.emissiveMap = env.emissiveMap),
        (this.emissiveIntensity = env.emissiveIntensity),
        (this.specularMap = env.specularMap),
        (this.alphaMap = env.alphaMap),
        (this.envMap = env.envMap),
        (this.combine = env.combine),
        (this.reflectivity = env.reflectivity),
        (this.refractionRatio = env.refractionRatio),
        (this.wireframe = env.wireframe),
        (this.wireframeLinewidth = env.wireframeLinewidth),
        (this.wireframeLinecap = env.wireframeLinecap),
        (this.wireframeLinejoin = env.wireframeLinejoin),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        this
      );
    }),
    (((Iv.prototype = Object.create(Dd.prototype)).constructor =
      Iv).prototype.isMeshMatcapMaterial = !0),
    (Iv.prototype.copy = function (env) {
      return (
        Dd.prototype.copy.call(this, env),
        (this.defines = { MATCAP: "" }),
        this.color.copy(env.color),
        (this.matcap = env.matcap),
        (this.map = env.map),
        (this.bumpMap = env.bumpMap),
        (this.bumpScale = env.bumpScale),
        (this.normalMap = env.normalMap),
        (this.normalMapType = env.normalMapType),
        this.normalScale.copy(env.normalScale),
        (this.displacementMap = env.displacementMap),
        (this.displacementScale = env.displacementScale),
        (this.displacementBias = env.displacementBias),
        (this.alphaMap = env.alphaMap),
        (this.skinning = env.skinning),
        (this.morphTargets = env.morphTargets),
        (this.morphNormals = env.morphNormals),
        this
      );
    }),
    (((Rv.prototype = Object.create(tg.prototype)).constructor =
      Rv).prototype.isLineDashedMaterial = !0),
    (Rv.prototype.copy = function (env) {
      return (
        tg.prototype.copy.call(this, env),
        (this.scale = env.scale),
        (this.dashSize = env.dashSize),
        (this.gapSize = env.gapSize),
        this
      );
    });
  var Ov = Object.freeze({
      ShadowMaterial: Tv,
      SpriteMaterial: Qm,
      RawShaderMaterial: Sv,
      ShaderMaterial: ZoneDescriptor,
      PointsMaterial: ag,
      MeshPhysicalMaterial: Av,
      MeshStandardMaterial: Ev,
      MeshPhongMaterial: Mv,
      MeshToonMaterial: Pv,
      MeshNormalMaterial: Lv,
      MeshLambertMaterial: Cv,
      MeshDepthMaterial: Im,
      MeshDistanceMaterial: Rm,
      MeshBasicMaterial: Gd,
      MeshMatcapMaterial: Iv,
      LineDashedMaterial: Rv,
      LineBasicMaterial: tg,
      Material: Dd,
    }),
    Fv = {
      enabled: !1,
      files: {},
      add: function (env, t) {
        !1 !== this.enabled && (this.files[env] = t);
      },
      get: function (env) {
        if (!1 !== this.enabled) return this.files[env];
      },
      remove: function (env) {
        delete this.files[env];
      },
      clear: function () {
        this.files = {};
      },
    };

  function Nv(env, t, i) {
    var n = this,
      r = !1,
      a = 0,
      ObjectMethodWrapper = 0,
      CounterVariable = void 0;
    (this.onStart = void 0),
      (this.onLoad = env),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (env) {
        ObjectMethodWrapper++, !1 === r && void 0 !== n.onStart && n.onStart(env, a, ObjectMethodWrapper), (r = !0);
      }),
      (this.itemEnd = function (env) {
        a++,
          void 0 !== n.onProgress && n.onProgress(env, a, ObjectMethodWrapper),
          a === ObjectMethodWrapper && ((r = !1), void 0 !== n.onLoad && n.onLoad());
      }),
      (this.itemError = function (env) {
        void 0 !== n.onError && n.onError(env);
      }),
      (this.resolveURL = function (env) {
        return CounterVariable ? CounterVariable(env) : env;
      }),
      (this.setURLModifier = function (env) {
        return (CounterVariable = env), this;
      });
  }

  var kv = new Nv(),
    Uv = {};

  function Dv(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  function zv(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  function Bv(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  function Hv(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  function Gv() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }

  function jv(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
    Gv.call(this),
      (this.type = "EllipseCurve"),
      (this.aX = env || 0),
      (this.aY = t || 0),
      (this.xRadius = i || 1),
      (this.yRadius = n || 1),
      (this.aStartAngle = r || 0),
      (this.aEndAngle = a || 2 * Math.PI),
      (this.aClockwise = ObjectMethodWrapper || !1),
      (this.aRotation = CounterVariable || 0);
  }

  function Vv(env, t, i, n, r, a) {
    jv.call(this, env, t, i, i, n, r, a), (this.type = "ArcCurve");
  }

  function Xv() {
    var r = 0,
      a = 0,
      ObjectMethodWrapper = 0,
      CounterVariable = 0;

    function HelperFunction(env, t, i, n) {
      (ObjectMethodWrapper = -3 * (r = env) + 3 * t - 2 * (a = i) - n), (CounterVariable = 2 * env - 2 * t + i + n);
    }

    return {
      initCatmullRom: function (env, t, i, n, r) {
        HelperFunction(t, i, r * (i - env), r * (n - t));
      },
      initNonuniformCatmullRom: function (env, t, i, n, r, a, ObjectMethodWrapper) {
        var CounterVariable = (t - env) / r - (i - env) / (r + a) + (i - t) / a,
          RandomGenerator = (i - t) / a - (n - t) / (a + ObjectMethodWrapper) + (n - i) / ObjectMethodWrapper;
        HelperFunction(t, i, (CounterVariable *= a), (RandomGenerator *= a));
      },
      calc: function (env) {
        var t = env * env;
        return r + a * env + ObjectMethodWrapper * t + CounterVariable * (t * env);
      },
    };
  }

  Object.assign(Dv.prototype, {
    load: function (ObjectMethodWrapper, env, t, i) {
      void 0 === ObjectMethodWrapper && (ObjectMethodWrapper = ""),
        void 0 !== this.path && (ObjectMethodWrapper = this.path + ObjectMethodWrapper),
        (ObjectMethodWrapper = this.manager.resolveURL(ObjectMethodWrapper));
      var CounterVariable = this,
        n = Fv.get(ObjectMethodWrapper);
      if (void 0 !== n)
        return (
          CounterVariable.manager.itemStart(ObjectMethodWrapper),
          setTimeout(function () {
            env && env(n), CounterVariable.manager.itemEnd(ObjectMethodWrapper);
          }, 0),
          n
        );
      if (void 0 === Uv[ObjectMethodWrapper]) {
        var r = ObjectMethodWrapper.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (r) {
          var a = r[1],
            RandomGenerator = !!r[2],
            HelperFunction = r[3];
          (HelperFunction = window.decodeURIComponent(HelperFunction)), RandomGenerator && (HelperFunction = window.atob(HelperFunction));
          try {
            var EnsureFunction,
              GlobalReference = (this.responseType || "").toLowerCase();
            switch (GlobalReference) {
              case "arraybuffer":
              case "blob":
                for (var Property = new Uint8Array(HelperFunction.length), MathFloorShortcut = 0; MathFloorShortcut < HelperFunction.length; MathFloorShortcut++)
                  Property[MathFloorShortcut] = HelperFunction.charCodeAt(MathFloorShortcut);
                EnsureFunction = "blob" === GlobalReference ? new Blob([Property.buffer], { type: a }) : Property.buffer;
                break;
              case "document":
                var f = new DOMParser();
                EnsureFunction = f.parseFromString(HelperFunction, a);
                break;
              case "json":
                EnsureFunction = JSON.parse(HelperFunction);
                break;
              default:
                EnsureFunction = HelperFunction;
            }
            window.setTimeout(function () {
              env && env(EnsureFunction), CounterVariable.manager.itemEnd(ObjectMethodWrapper);
            }, 0);
          } catch (env) {
            window.setTimeout(function () {
              i && i(env), CounterVariable.manager.itemEnd(ObjectMethodWrapper), CounterVariable.manager.itemError(ObjectMethodWrapper);
            }, 0);
          }
        } else {
          (Uv[ObjectMethodWrapper] = []), Uv[ObjectMethodWrapper].push({ onLoad: env, onProgress: t, onError: i });
          var ModuleMeta = new XMLHttpRequest();
          for (var g in (ModuleMeta.open("GET", ObjectMethodWrapper, !0),
          ModuleMeta.addEventListener(
            "load",
            function (env) {
              var t = this.response;
              Fv.add(ObjectMethodWrapper, t);
              var i = Uv[ObjectMethodWrapper];
              if ((delete Uv[ObjectMethodWrapper], 200 === this.status || 0 === this.status)) {
                0 === this.status &&
                  console.warn("THREE.FileLoader: HTTP Status 0 received.");
                for (var n = 0, r = i.length; n < r; n++) {
                  (a = i[n]).onLoad && a.onLoad(t);
                }
                CounterVariable.manager.itemEnd(ObjectMethodWrapper);
              } else {
                for (n = 0, r = i.length; n < r; n++) {
                  var a;
                  (a = i[n]).onError && a.onError(env);
                }
                CounterVariable.manager.itemEnd(ObjectMethodWrapper), CounterVariable.manager.itemError(ObjectMethodWrapper);
              }
            },
            !1,
          ),
          ModuleMeta.addEventListener(
            "progress",
            function (env) {
              for (var t = Uv[ObjectMethodWrapper], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                r.onProgress && r.onProgress(env);
              }
            },
            !1,
          ),
          ModuleMeta.addEventListener(
            "error",
            function (env) {
              var t = Uv[ObjectMethodWrapper];
              delete Uv[ObjectMethodWrapper];
              for (var i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                r.onError && r.onError(env);
              }
              CounterVariable.manager.itemEnd(ObjectMethodWrapper), CounterVariable.manager.itemError(ObjectMethodWrapper);
            },
            !1,
          ),
          ModuleMeta.addEventListener(
            "abort",
            function (env) {
              var t = Uv[ObjectMethodWrapper];
              delete Uv[ObjectMethodWrapper];
              for (var i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                r.onError && r.onError(env);
              }
              CounterVariable.manager.itemEnd(ObjectMethodWrapper), CounterVariable.manager.itemError(ObjectMethodWrapper);
            },
            !1,
          ),
          void 0 !== this.responseType && (ModuleMeta.responseType = this.responseType),
          void 0 !== this.withCredentials &&
            (ModuleMeta.withCredentials = this.withCredentials),
          ModuleMeta.overrideMimeType &&
            ModuleMeta.overrideMimeType(
              void 0 !== this.mimeType ? this.mimeType : "text/plain",
            ),
          this.requestHeader))
            ModuleMeta.setRequestHeader(g, this.requestHeader[g]);
          ModuleMeta.send(null);
        }
        return CounterVariable.manager.itemStart(ObjectMethodWrapper), ModuleMeta;
      }
      Uv[ObjectMethodWrapper].push({ onLoad: env, onProgress: t, onError: i });
    },
    setPath: function (env) {
      return (this.path = env), this;
    },
    setResponseType: function (env) {
      return (this.responseType = env), this;
    },
    setWithCredentials: function (env) {
      return (this.withCredentials = env), this;
    },
    setMimeType: function (env) {
      return (this.mimeType = env), this;
    },
    setRequestHeader: function (env) {
      return (this.requestHeader = env), this;
    },
  }),
    Object.assign(
      function (env) {
        (this.manager = void 0 !== env ? env : kv), (this._parser = null);
      }.prototype,
      {
        load: function (env, a, t, n) {
          var ObjectMethodWrapper = this,
            CounterVariable = [],
            RandomGenerator = new lg();
          RandomGenerator.image = CounterVariable;
          var r = new Dv(this.manager);

          function i(i) {
            r.load(
              env[i],
              function (env) {
                var t = ObjectMethodWrapper._parser(env, !0);
                (CounterVariable[i] = {
                  width: t.width,
                  height: t.height,
                  format: t.format,
                  mipmaps: t.mipmaps,
                }),
                  6 === (HelperFunction += 1) &&
                    (1 === t.mipmapCount && (RandomGenerator.minFilter = LineCounter),
                    (RandomGenerator.format = t.format),
                    (RandomGenerator.needsUpdate = !0),
                    a && a(RandomGenerator));
              },
              t,
              n,
            );
          }

          if (
            (r.setPath(this.path),
            r.setResponseType("arraybuffer"),
            Array.isArray(env))
          )
            for (var HelperFunction = 0, EnsureFunction = 0, GlobalReference = env.length; EnsureFunction < GlobalReference; ++EnsureFunction) i(EnsureFunction);
          else
            r.load(
              env,
              function (env) {
                var t = ObjectMethodWrapper._parser(env, !0);
                if (t.isCubemap)
                  for (
                    var i = t.mipmaps.length / t.mipmapCount, n = 0;
                    n < i;
                    n++
                  ) {
                    CounterVariable[n] = { mipmaps: [] };
                    for (var r = 0; r < t.mipmapCount; r++)
                      CounterVariable[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]),
                        (CounterVariable[n].format = t.format),
                        (CounterVariable[n].width = t.width),
                        (CounterVariable[n].height = t.height);
                  }
                else
                  (RandomGenerator.image.width = t.width),
                    (RandomGenerator.image.height = t.height),
                    (RandomGenerator.mipmaps = t.mipmaps);
                1 === t.mipmapCount && (RandomGenerator.minFilter = LineCounter),
                  (RandomGenerator.format = t.format),
                  (RandomGenerator.needsUpdate = !0),
                  a && a(RandomGenerator);
              },
              t,
              n,
            );
          return RandomGenerator;
        },
        setPath: function (env) {
          return (this.path = env), this;
        },
      },
    ),
    Object.assign(
      function (env) {
        (this.manager = void 0 !== env ? env : kv), (this._parser = null);
      }.prototype,
      {
        load: function (env, i, t, n) {
          var r = this,
            a = new Gu(),
            ObjectMethodWrapper = new Dv(this.manager);
          return (
            ObjectMethodWrapper.setResponseType("arraybuffer"),
            ObjectMethodWrapper.load(
              env,
              function (env) {
                var t = r._parser(env);
                t &&
                  (void 0 !== t.image
                    ? (a.image = t.image)
                    : void 0 !== t.data &&
                      ((a.image.width = t.width),
                      (a.image.height = t.height),
                      (a.image.data = t.data)),
                  (a.wrapS = void 0 !== t.wrapS ? t.wrapS : nc),
                  (a.wrapT = void 0 !== t.wrapT ? t.wrapT : nc),
                  (a.magFilter = void 0 !== t.magFilter ? t.magFilter : LineCounter),
                  (a.minFilter = void 0 !== t.minFilter ? t.minFilter : CharacterCount),
                  (a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1),
                  void 0 !== t.format && (a.format = t.format),
                  void 0 !== t.type && (a.type = t.type),
                  void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps),
                  1 === t.mipmapCount && (a.minFilter = LineCounter),
                  (a.needsUpdate = !0),
                  i && i(a, t));
              },
              t,
              n,
            ),
            a
          );
        },
      },
    ),
    Object.assign(zv.prototype, {
      crossOrigin: "anonymous",
      load: function (t, env, i, n) {
        void 0 === t && (t = ""),
          void 0 !== this.path && (t = this.path + t),
          (t = this.manager.resolveURL(t));
        var r = this,
          a = Fv.get(t);
        if (void 0 !== a)
          return (
            r.manager.itemStart(t),
            setTimeout(function () {
              env && env(a), r.manager.itemEnd(t);
            }, 0),
            a
          );
        var ObjectMethodWrapper = document.createElementNS("http://www.w3.org/1999/xhtml", "img");

        function CounterVariable() {
          ObjectMethodWrapper.removeEventListener("load", CounterVariable, !1),
            ObjectMethodWrapper.removeEventListener("error", RandomGenerator, !1),
            Fv.add(t, this),
            env && env(this),
            r.manager.itemEnd(t);
        }

        function RandomGenerator(env) {
          ObjectMethodWrapper.removeEventListener("load", CounterVariable, !1),
            ObjectMethodWrapper.removeEventListener("error", RandomGenerator, !1),
            n && n(env),
            r.manager.itemEnd(t),
            r.manager.itemError(t);
        }

        return (
          ObjectMethodWrapper.addEventListener("load", CounterVariable, !1),
          ObjectMethodWrapper.addEventListener("error", RandomGenerator, !1),
          "data:" !== t.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (ObjectMethodWrapper.crossOrigin = this.crossOrigin),
          r.manager.itemStart(t),
          (ObjectMethodWrapper.src = t),
          ObjectMethodWrapper
        );
      },
      setCrossOrigin: function (env) {
        return (this.crossOrigin = env), this;
      },
      setPath: function (env) {
        return (this.path = env), this;
      },
    }),
    Object.assign(Bv.prototype, {
      crossOrigin: "anonymous",
      load: function (env, i, t, n) {
        var r = new TransactionFormatter(),
          a = new zv(this.manager);
        a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
        var ObjectMethodWrapper = 0;

        function CounterVariable(t) {
          a.load(
            env[t],
            function (env) {
              (r.images[t] = env), 6 === ++ObjectMethodWrapper && ((r.needsUpdate = !0), i && i(r));
            },
            void 0,
            n,
          );
        }

        for (var RandomGenerator = 0; RandomGenerator < env.length; ++RandomGenerator) CounterVariable(RandomGenerator);
        return r;
      },
      setCrossOrigin: function (env) {
        return (this.crossOrigin = env), this;
      },
      setPath: function (env) {
        return (this.path = env), this;
      },
    }),
    Object.assign(Hv.prototype, {
      crossOrigin: "anonymous",
      load: function (i, n, env, t) {
        var r = new Du(),
          a = new zv(this.manager);
        return (
          a.setCrossOrigin(this.crossOrigin),
          a.setPath(this.path),
          a.load(
            i,
            function (env) {
              r.image = env;
              var t =
                0 < i.search(/\.jpe?g$/i) ||
                0 === i.search(/^data\:image\/jpeg/);
              (r.format = t ? Sc : Ec),
                (r.needsUpdate = !0),
                void 0 !== n && n(r);
            },
            env,
            t,
          ),
          r
        );
      },
      setCrossOrigin: function (env) {
        return (this.crossOrigin = env), this;
      },
      setPath: function (env) {
        return (this.path = env), this;
      },
    }),
    Object.assign(Gv.prototype, {
      getPoint: function () {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null;
      },
      getPointAt: function (env, t) {
        var i = this.getUtoTmapping(env);
        return this.getPoint(i, t);
      },
      getPoints: function (env) {
        void 0 === env && (env = 5);
        for (var t = [], i = 0; i <= env; i++) t.push(this.getPoint(i / env));
        return t;
      },
      getSpacedPoints: function (env) {
        void 0 === env && (env = 5);
        for (var t = [], i = 0; i <= env; i++) t.push(this.getPointAt(i / env));
        return t;
      },
      getLength: function () {
        var env = this.getLengths();
        return env[env.length - 1];
      },
      getLengths: function (env) {
        if (
          (void 0 === env && (env = this.arcLengthDivisions),
          this.cacheArcLengths &&
            this.cacheArcLengths.length === env + 1 &&
            !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        var t,
          i,
          n = [],
          r = this.getPoint(0),
          a = 0;
        for (n.push(0), i = 1; i <= env; i++)
          (a += (t = this.getPoint(i / env)).distanceTo(r)), n.push(a), (r = t);
        return (this.cacheArcLengths = n);
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0), this.getLengths();
      },
      getUtoTmapping: function (env, t) {
        var i,
          n = this.getLengths(),
          r = 0,
          a = n.length;
        i = t || env * n[a - 1];
        for (var ObjectMethodWrapper, CounterVariable = 0, RandomGenerator = a - 1; CounterVariable <= RandomGenerator; )
          if ((ObjectMethodWrapper = n[(r = Math.floor(CounterVariable + (RandomGenerator - CounterVariable) / 2))] - i) < 0) CounterVariable = r + 1;
          else {
            if (!(0 < ObjectMethodWrapper)) {
              RandomGenerator = r;
              break;
            }
            RandomGenerator = r - 1;
          }
        if (n[(r = RandomGenerator)] === i) return r / (a - 1);
        var HelperFunction = n[r];
        return (r + (i - HelperFunction) / (n[r + 1] - HelperFunction)) / (a - 1);
      },
      getTangent: function (env) {
        var t = env - 1e-4,
          i = env + 1e-4;
        t < 0 && (t = 0), 1 < i && (i = 1);
        var n = this.getPoint(t);
        return this.getPoint(i).clone().sub(n).normalize();
      },
      getTangentAt: function (env) {
        var t = this.getUtoTmapping(env);
        return this.getTangent(t);
      },
      computeFrenetFrames: function (env, t) {
        var i,
          n,
          r,
          a = new yu(),
          ObjectMethodWrapper = [],
          CounterVariable = [],
          RandomGenerator = [],
          HelperFunction = new yu(),
          EnsureFunction = new gu();
        for (i = 0; i <= env; i++)
          (n = i / env), (ObjectMethodWrapper[i] = this.getTangentAt(n)), ObjectMethodWrapper[i].normalize();
        (CounterVariable[0] = new yu()), (RandomGenerator[0] = new yu());
        var GlobalReference = Number.MAX_VALUE,
          Property = Math.abs(ObjectMethodWrapper[0].x),
          MathFloorShortcut = Math.abs(ObjectMethodWrapper[0].y),
          f = Math.abs(ObjectMethodWrapper[0].z);
        for (
          Property <= GlobalReference && ((GlobalReference = Property), a.set(1, 0, 0)),
            MathFloorShortcut <= GlobalReference && ((GlobalReference = MathFloorShortcut), a.set(0, 1, 0)),
            f <= GlobalReference && a.set(0, 0, 1),
            HelperFunction.crossVectors(ObjectMethodWrapper[0], a).normalize(),
            CounterVariable[0].crossVectors(ObjectMethodWrapper[0], HelperFunction),
            RandomGenerator[0].crossVectors(ObjectMethodWrapper[0], CounterVariable[0]),
            i = 1;
          i <= env;
          i++
        )
          (CounterVariable[i] = CounterVariable[i - 1].clone()),
            (RandomGenerator[i] = RandomGenerator[i - 1].clone()),
            HelperFunction.crossVectors(ObjectMethodWrapper[i - 1], ObjectMethodWrapper[i]),
            HelperFunction.length() > Number.EPSILON &&
              (HelperFunction.normalize(),
              (r = Math.acos(fu.clamp(ObjectMethodWrapper[i - 1].dot(ObjectMethodWrapper[i]), -1, 1))),
              CounterVariable[i].applyMatrix4(EnsureFunction.makeRotationAxis(HelperFunction, r))),
            RandomGenerator[i].crossVectors(ObjectMethodWrapper[i], CounterVariable[i]);
        if (!0 === t)
          for (
            r = Math.acos(fu.clamp(CounterVariable[0].dot(CounterVariable[env]), -1, 1)),
              r /= env,
              0 < ObjectMethodWrapper[0].dot(HelperFunction.crossVectors(CounterVariable[0], CounterVariable[env])) && (r = -r),
              i = 1;
            i <= env;
            i++
          )
            CounterVariable[i].applyMatrix4(EnsureFunction.makeRotationAxis(ObjectMethodWrapper[i], r * i)),
              RandomGenerator[i].crossVectors(ObjectMethodWrapper[i], CounterVariable[i]);
        return { tangents: ObjectMethodWrapper, normals: CounterVariable, binormals: RandomGenerator };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return (this.arcLengthDivisions = env.arcLengthDivisions), this;
      },
      toJSON: function () {
        var env = {
          metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
        };
        return (
          (env.arcLengthDivisions = this.arcLengthDivisions),
          (env.type = this.type),
          env
        );
      },
      fromJSON: function (env) {
        return (this.arcLengthDivisions = env.arcLengthDivisions), this;
      },
    }),
    (((jv.prototype = Object.create(Gv.prototype)).constructor =
      jv).prototype.isEllipseCurve = !0),
    (jv.prototype.getPoint = function (env, t) {
      for (
        var i = t || new mu(),
          n = 2 * Math.PI,
          r = this.aEndAngle - this.aStartAngle,
          a = Math.abs(r) < Number.EPSILON;
        r < 0;

      )
        r += n;
      for (; n < r; ) r -= n;
      r < Number.EPSILON && (r = a ? 0 : n),
        !0 !== this.aClockwise || a || (r === n ? (r = -n) : (r -= n));
      var ObjectMethodWrapper = this.aStartAngle + env * r,
        CounterVariable = this.aX + this.xRadius * Math.cos(ObjectMethodWrapper),
        RandomGenerator = this.aY + this.yRadius * Math.sin(ObjectMethodWrapper);
      if (0 !== this.aRotation) {
        var HelperFunction = Math.cos(this.aRotation),
          EnsureFunction = Math.sin(this.aRotation),
          GlobalReference = CounterVariable - this.aX,
          Property = RandomGenerator - this.aY;
        (CounterVariable = GlobalReference * HelperFunction - Property * EnsureFunction + this.aX), (RandomGenerator = GlobalReference * EnsureFunction + Property * HelperFunction + this.aY);
      }
      return i.set(CounterVariable, RandomGenerator);
    }),
    (jv.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        (this.aX = env.aX),
        (this.aY = env.aY),
        (this.xRadius = env.xRadius),
        (this.yRadius = env.yRadius),
        (this.aStartAngle = env.aStartAngle),
        (this.aEndAngle = env.aEndAngle),
        (this.aClockwise = env.aClockwise),
        (this.aRotation = env.aRotation),
        this
      );
    }),
    (jv.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (
        (env.aX = this.aX),
        (env.aY = this.aY),
        (env.xRadius = this.xRadius),
        (env.yRadius = this.yRadius),
        (env.aStartAngle = this.aStartAngle),
        (env.aEndAngle = this.aEndAngle),
        (env.aClockwise = this.aClockwise),
        (env.aRotation = this.aRotation),
        env
      );
    }),
    (jv.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        (this.aX = env.aX),
        (this.aY = env.aY),
        (this.xRadius = env.xRadius),
        (this.yRadius = env.yRadius),
        (this.aStartAngle = env.aStartAngle),
        (this.aEndAngle = env.aEndAngle),
        (this.aClockwise = env.aClockwise),
        (this.aRotation = env.aRotation),
        this
      );
    }),
    (((Vv.prototype = Object.create(jv.prototype)).constructor =
      Vv).prototype.isArcCurve = !0);
  var Wv = new yu(),
    Yv = new Xv(),
    qv = new Xv(),
    Qv = new Xv();

  function Zv(env, t, i, n) {
    Gv.call(this),
      (this.type = "CatmullRomCurve3"),
      (this.points = env || []),
      (this.closed = t || !1),
      (this.curveType = i || "centripetal"),
      (this.tension = n || 0.5);
  }

  function Jv(env, t, i, n, r) {
    var a = 0.5 * (n - t),
      ObjectMethodWrapper = 0.5 * (r - i),
      CounterVariable = env * env;
    return (
      (2 * i - 2 * n + a + ObjectMethodWrapper) * (env * CounterVariable) +
      (-3 * i + 3 * n - 2 * a - ObjectMethodWrapper) * CounterVariable +
      a * env +
      i
    );
  }

  function Kv(env, t, i, n) {
    return (ObjectMethodWrapper = 1 - env) * ObjectMethodWrapper * t + 2 * (1 - (a = env)) * a * i + (r = env) * r * n;
    var r, a, ObjectMethodWrapper;
  }

  function $Value(env, t, i, n, r) {
    return (
      (HelperFunction = 1 - env) * HelperFunction * HelperFunction * t +
      3 * (RandomGenerator = 1 - (CounterVariable = env)) * RandomGenerator * CounterVariable * i +
      3 * (1 - (ObjectMethodWrapper = env)) * ObjectMethodWrapper * ObjectMethodWrapper * n +
      (a = env) * a * a * r
    );
    var a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction;
  }

  function ey(env, t, i, n) {
    Gv.call(this),
      (this.type = "CubicBezierCurve"),
      (this.v0 = env || new mu()),
      (this.v1 = t || new mu()),
      (this.v2 = i || new mu()),
      (this.v3 = n || new mu());
  }

  function ty(env, t, i, n) {
    Gv.call(this),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = env || new yu()),
      (this.v1 = t || new yu()),
      (this.v2 = i || new yu()),
      (this.v3 = n || new yu());
  }

  function iy(env, t) {
    Gv.call(this),
      (this.type = "LineCurve"),
      (this.v1 = env || new mu()),
      (this.v2 = t || new mu());
  }

  function ny(env, t) {
    Gv.call(this),
      (this.type = "LineCurve3"),
      (this.v1 = env || new yu()),
      (this.v2 = t || new yu());
  }

  function ry(env, t, i) {
    Gv.call(this),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = env || new mu()),
      (this.v1 = t || new mu()),
      (this.v2 = i || new mu());
  }

  function ay(env, t, i) {
    Gv.call(this),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = env || new yu()),
      (this.v1 = t || new yu()),
      (this.v2 = i || new yu());
  }

  function oy(env) {
    Gv.call(this), (this.type = "SplineCurve"), (this.points = env || []);
  }

  (((Zv.prototype = Object.create(Gv.prototype)).constructor =
    Zv).prototype.isCatmullRomCurve3 = !0),
    (Zv.prototype.getPoint = function (env, t) {
      var i,
        n,
        r,
        a,
        ObjectMethodWrapper = t || new yu(),
        CounterVariable = this.points,
        RandomGenerator = CounterVariable.length,
        HelperFunction = (RandomGenerator - (this.closed ? 0 : 1)) * env,
        EnsureFunction = Math.floor(HelperFunction),
        GlobalReference = HelperFunction - EnsureFunction;
      if (
        (this.closed
          ? (EnsureFunction += 0 < EnsureFunction ? 0 : (Math.floor(Math.abs(EnsureFunction) / RandomGenerator) + 1) * RandomGenerator)
          : 0 === GlobalReference && EnsureFunction === RandomGenerator - 1 && ((EnsureFunction = RandomGenerator - 2), (GlobalReference = 1)),
        (i =
          this.closed || 0 < EnsureFunction
            ? CounterVariable[(EnsureFunction - 1) % RandomGenerator]
            : (Wv.subVectors(CounterVariable[0], CounterVariable[1]).add(CounterVariable[0]), Wv)),
        (n = CounterVariable[EnsureFunction % RandomGenerator]),
        (r = CounterVariable[(EnsureFunction + 1) % RandomGenerator]),
        (a =
          this.closed || EnsureFunction + 2 < RandomGenerator
            ? CounterVariable[(EnsureFunction + 2) % RandomGenerator]
            : (Wv.subVectors(CounterVariable[RandomGenerator - 1], CounterVariable[RandomGenerator - 2]).add(CounterVariable[RandomGenerator - 1]), Wv)),
        "centripetal" === this.curveType || "chordal" === this.curveType)
      ) {
        var Property = "chordal" === this.curveType ? 0.5 : 0.25,
          MathFloorShortcut = Math.pow(i.distanceToSquared(n), Property),
          f = Math.pow(n.distanceToSquared(r), Property),
          ModuleMeta = Math.pow(r.distanceToSquared(a), Property);
        f < 1e-4 && (f = 1),
          MathFloorShortcut < 1e-4 && (MathFloorShortcut = f),
          ModuleMeta < 1e-4 && (ModuleMeta = f),
          Yv.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, MathFloorShortcut, f, ModuleMeta),
          qv.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, MathFloorShortcut, f, ModuleMeta),
          Qv.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, MathFloorShortcut, f, ModuleMeta);
      } else
        "catmullrom" === this.curveType &&
          (Yv.initCatmullRom(i.x, n.x, r.x, a.x, this.tension),
          qv.initCatmullRom(i.y, n.y, r.y, a.y, this.tension),
          Qv.initCatmullRom(i.z, n.z, r.z, a.z, this.tension));
      return ObjectMethodWrapper.set(Yv.calc(GlobalReference), qv.calc(GlobalReference), Qv.calc(GlobalReference)), ObjectMethodWrapper;
    }),
    (Zv.prototype.copy = function (env) {
      Gv.prototype.copy.call(this, env), (this.points = []);
      for (var t = 0, i = env.points.length; t < i; t++) {
        var n = env.points[t];
        this.points.push(n.clone());
      }
      return (
        (this.closed = env.closed),
        (this.curveType = env.curveType),
        (this.tension = env.tension),
        this
      );
    }),
    (Zv.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      env.points = [];
      for (var t = 0, i = this.points.length; t < i; t++) {
        var n = this.points[t];
        env.points.push(n.toArray());
      }
      return (
        (env.closed = this.closed),
        (env.curveType = this.curveType),
        (env.tension = this.tension),
        env
      );
    }),
    (Zv.prototype.fromJSON = function (env) {
      Gv.prototype.fromJSON.call(this, env), (this.points = []);
      for (var t = 0, i = env.points.length; t < i; t++) {
        var n = env.points[t];
        this.points.push(new yu().fromArray(n));
      }
      return (
        (this.closed = env.closed),
        (this.curveType = env.curveType),
        (this.tension = env.tension),
        this
      );
    }),
    (((ey.prototype = Object.create(Gv.prototype)).constructor =
      ey).prototype.isCubicBezierCurve = !0),
    (ey.prototype.getPoint = function (env, t) {
      var i = t || new mu(),
        n = this.v0,
        r = this.v1,
        a = this.v2,
        ObjectMethodWrapper = this.v3;
      return i.set($Value(env, n.x, r.x, a.x, ObjectMethodWrapper.x), $Value(env, n.y, r.y, a.y, ObjectMethodWrapper.y)), i;
    }),
    (ey.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v0.copy(env.v0),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this.v3.copy(env.v3),
        this
      );
    }),
    (ey.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (
        (env.v0 = this.v0.toArray()),
        (env.v1 = this.v1.toArray()),
        (env.v2 = this.v2.toArray()),
        (env.v3 = this.v3.toArray()),
        env
      );
    }),
    (ey.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v0.fromArray(env.v0),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this.v3.fromArray(env.v3),
        this
      );
    }),
    (((ty.prototype = Object.create(Gv.prototype)).constructor =
      ty).prototype.isCubicBezierCurve3 = !0),
    (ty.prototype.getPoint = function (env, t) {
      var i = t || new yu(),
        n = this.v0,
        r = this.v1,
        a = this.v2,
        ObjectMethodWrapper = this.v3;
      return (
        i.set(
          $Value(env, n.x, r.x, a.x, ObjectMethodWrapper.x),
          $Value(env, n.y, r.y, a.y, ObjectMethodWrapper.y),
          $Value(env, n.z, r.z, a.z, ObjectMethodWrapper.z),
        ),
        i
      );
    }),
    (ty.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v0.copy(env.v0),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this.v3.copy(env.v3),
        this
      );
    }),
    (ty.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (
        (env.v0 = this.v0.toArray()),
        (env.v1 = this.v1.toArray()),
        (env.v2 = this.v2.toArray()),
        (env.v3 = this.v3.toArray()),
        env
      );
    }),
    (ty.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v0.fromArray(env.v0),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this.v3.fromArray(env.v3),
        this
      );
    }),
    (((iy.prototype = Object.create(Gv.prototype)).constructor =
      iy).prototype.isLineCurve = !0),
    (iy.prototype.getPoint = function (env, t) {
      var i = t || new mu();
      return (
        1 === env
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(env).add(this.v1)),
        i
      );
    }),
    (iy.prototype.getPointAt = function (env, t) {
      return this.getPoint(env, t);
    }),
    (iy.prototype.getTangent = function () {
      return this.v2.clone().sub(this.v1).normalize();
    }),
    (iy.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this
      );
    }),
    (iy.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (env.v1 = this.v1.toArray()), (env.v2 = this.v2.toArray()), env;
    }),
    (iy.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this
      );
    }),
    (((ny.prototype = Object.create(Gv.prototype)).constructor =
      ny).prototype.isLineCurve3 = !0),
    (ny.prototype.getPoint = function (env, t) {
      var i = t || new yu();
      return (
        1 === env
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(env).add(this.v1)),
        i
      );
    }),
    (ny.prototype.getPointAt = function (env, t) {
      return this.getPoint(env, t);
    }),
    (ny.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this
      );
    }),
    (ny.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (env.v1 = this.v1.toArray()), (env.v2 = this.v2.toArray()), env;
    }),
    (ny.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this
      );
    }),
    (((ry.prototype = Object.create(Gv.prototype)).constructor =
      ry).prototype.isQuadraticBezierCurve = !0),
    (ry.prototype.getPoint = function (env, t) {
      var i = t || new mu(),
        n = this.v0,
        r = this.v1,
        a = this.v2;
      return i.set(Kv(env, n.x, r.x, a.x), Kv(env, n.y, r.y, a.y)), i;
    }),
    (ry.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v0.copy(env.v0),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this
      );
    }),
    (ry.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (
        (env.v0 = this.v0.toArray()),
        (env.v1 = this.v1.toArray()),
        (env.v2 = this.v2.toArray()),
        env
      );
    }),
    (ry.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v0.fromArray(env.v0),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this
      );
    }),
    (((ay.prototype = Object.create(Gv.prototype)).constructor =
      ay).prototype.isQuadraticBezierCurve3 = !0),
    (ay.prototype.getPoint = function (env, t) {
      var i = t || new yu(),
        n = this.v0,
        r = this.v1,
        a = this.v2;
      return (
        i.set(Kv(env, n.x, r.x, a.x), Kv(env, n.y, r.y, a.y), Kv(env, n.z, r.z, a.z)),
        i
      );
    }),
    (ay.prototype.copy = function (env) {
      return (
        Gv.prototype.copy.call(this, env),
        this.v0.copy(env.v0),
        this.v1.copy(env.v1),
        this.v2.copy(env.v2),
        this
      );
    }),
    (ay.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      return (
        (env.v0 = this.v0.toArray()),
        (env.v1 = this.v1.toArray()),
        (env.v2 = this.v2.toArray()),
        env
      );
    }),
    (ay.prototype.fromJSON = function (env) {
      return (
        Gv.prototype.fromJSON.call(this, env),
        this.v0.fromArray(env.v0),
        this.v1.fromArray(env.v1),
        this.v2.fromArray(env.v2),
        this
      );
    }),
    (((oy.prototype = Object.create(Gv.prototype)).constructor =
      oy).prototype.isSplineCurve = !0),
    (oy.prototype.getPoint = function (env, t) {
      var i = t || new mu(),
        n = this.points,
        r = (n.length - 1) * env,
        a = Math.floor(r),
        ObjectMethodWrapper = r - a,
        CounterVariable = n[0 === a ? a : a - 1],
        RandomGenerator = n[a],
        HelperFunction = n[a > n.length - 2 ? n.length - 1 : a + 1],
        EnsureFunction = n[a > n.length - 3 ? n.length - 1 : a + 2];
      return i.set(Jv(ObjectMethodWrapper, CounterVariable.x, RandomGenerator.x, HelperFunction.x, EnsureFunction.x), Jv(ObjectMethodWrapper, CounterVariable.y, RandomGenerator.y, HelperFunction.y, EnsureFunction.y)), i;
    }),
    (oy.prototype.copy = function (env) {
      Gv.prototype.copy.call(this, env), (this.points = []);
      for (var t = 0, i = env.points.length; t < i; t++) {
        var n = env.points[t];
        this.points.push(n.clone());
      }
      return this;
    }),
    (oy.prototype.toJSON = function () {
      var env = Gv.prototype.toJSON.call(this);
      env.points = [];
      for (var t = 0, i = this.points.length; t < i; t++) {
        var n = this.points[t];
        env.points.push(n.toArray());
      }
      return env;
    }),
    (oy.prototype.fromJSON = function (env) {
      Gv.prototype.fromJSON.call(this, env), (this.points = []);
      for (var t = 0, i = env.points.length; t < i; t++) {
        var n = env.points[t];
        this.points.push(new mu().fromArray(n));
      }
      return this;
    });
  var sy = Object.freeze({
    ArcCurve: Vv,
    CatmullRomCurve3: Zv,
    CubicBezierCurve: ey,
    CubicBezierCurve3: ty,
    EllipseCurve: jv,
    LineCurve: iy,
    LineCurve3: ny,
    QuadraticBezierCurve: ry,
    QuadraticBezierCurve3: ay,
    SplineCurve: oy,
  });

  function ly() {
    Gv.call(this),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }

  function hy(env) {
    ly.call(this),
      (this.type = "Path"),
      (this.currentPoint = new mu()),
      env && this.setFromPoints(env);
  }

  function cy(env) {
    hy.call(this, env),
      (this.uuid = fu.generateUUID()),
      (this.type = "Shape"),
      (this.holes = []);
  }

  function uy(env, t) {
    Pp.call(this),
      (this.type = "Light"),
      (this.color = new $GlobalReference(env)),
      (this.intensity = void 0 !== t ? t : 1),
      (this.receiveShadow = void 0);
  }

  function py(env, t, i) {
    uy.call(this, env, i),
      (this.type = "HemisphereLight"),
      (this.castShadow = void 0),
      this.position.copy(Pp.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new $GlobalReference(t));
  }

  function dy(env) {
    (this.camera = env),
      (this.bias = 0),
      (this.radius = 1),
      (this.mapSize = new mu(512, 512)),
      (this.map = null),
      (this.matrix = new gu());
  }

  function fy() {
    dy.call(this, new zm(50, 1, 0.5, 500));
  }

  function my(env, t, i, n, r, a) {
    uy.call(this, env, t),
      (this.type = "SpotLight"),
      this.position.copy(Pp.DefaultUp),
      this.updateMatrix(),
      (this.target = new Pp()),
      Object.defineProperty(this, "power", {
        get: function () {
          return this.intensity * Math.PI;
        },
        set: function (env) {
          this.intensity = env / Math.PI;
        },
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.angle = void 0 !== n ? n : Math.PI / 3),
      (this.penumbra = void 0 !== r ? r : 0),
      (this.decay = void 0 !== a ? a : 1),
      (this.shadow = new fy());
  }

  function gy(env, t, i, n) {
    uy.call(this, env, t),
      (this.type = "PointLight"),
      Object.defineProperty(this, "power", {
        get: function () {
          return 4 * this.intensity * Math.PI;
        },
        set: function (env) {
          this.intensity = env / (4 * Math.PI);
        },
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.decay = void 0 !== n ? n : 1),
      (this.shadow = new dy(new zm(90, 1, 0.5, 500)));
  }

  function vy(env, t, i, n, r, a) {
    Dm.call(this),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = env),
      (this.right = t),
      (this.top = i),
      (this.bottom = n),
      (this.near = void 0 !== r ? r : 0.1),
      (this.far = void 0 !== a ? a : 2e3),
      this.updateProjectionMatrix();
  }

  function YCoordinateArray() {
    dy.call(this, new vy(-5, 5, 5, -5, 0.5, 500));
  }

  function _y(env, t) {
    uy.call(this, env, t),
      (this.type = "DirectionalLight"),
      this.position.copy(Pp.DefaultUp),
      this.updateMatrix(),
      (this.target = new Pp()),
      (this.shadow = new YCoordinateArray());
  }

  function xy(env, t) {
    uy.call(this, env, t),
      (this.type = "AmbientLight"),
      (this.castShadow = void 0);
  }

  function by(env, t, i, n) {
    uy.call(this, env, t),
      (this.type = "RectAreaLight"),
      (this.width = void 0 !== i ? i : 10),
      (this.height = void 0 !== n ? n : 10);
  }

  (ly.prototype = Object.assign(Object.create(Gv.prototype), {
    constructor: ly,
    add: function (env) {
      this.curves.push(env);
    },
    closePath: function () {
      var env = this.curves[0].getPoint(0),
        t = this.curves[this.curves.length - 1].getPoint(1);
      env.equals(t) || this.curves.push(new iy(t, env));
    },
    getPoint: function (env) {
      for (
        var t = env * this.getLength(), i = this.getCurveLengths(), n = 0;
        n < i.length;

      ) {
        if (i[n] >= t) {
          var r = i[n] - t,
            a = this.curves[n],
            ObjectMethodWrapper = a.getLength(),
            CounterVariable = 0 === ObjectMethodWrapper ? 0 : 1 - r / ObjectMethodWrapper;
          return a.getPointAt(CounterVariable);
        }
        n++;
      }
      return null;
    },
    getLength: function () {
      var env = this.getCurveLengths();
      return env[env.length - 1];
    },
    updateArcLengths: function () {
      (this.needsUpdate = !0),
        (this.cacheLengths = null),
        this.getCurveLengths();
    },
    getCurveLengths: function () {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var env = [], t = 0, i = 0, n = this.curves.length; i < n; i++)
        (t += this.curves[i].getLength()), env.push(t);
      return (this.cacheLengths = env);
    },
    getSpacedPoints: function (env) {
      void 0 === env && (env = 40);
      for (var t = [], i = 0; i <= env; i++) t.push(this.getPoint(i / env));
      return this.autoClose && t.push(t[0]), t;
    },
    getPoints: function (env) {
      env = env || 12;
      for (var t, i = [], n = 0, r = this.curves; n < r.length; n++)
        for (
          var a = r[n],
            ObjectMethodWrapper =
              a && a.isEllipseCurve
                ? 2 * env
                : a && (a.isLineCurve || a.isLineCurve3)
                  ? 1
                  : a && a.isSplineCurve
                    ? env * a.points.length
                    : env,
            CounterVariable = a.getPoints(ObjectMethodWrapper),
            RandomGenerator = 0;
          RandomGenerator < CounterVariable.length;
          RandomGenerator++
        ) {
          var HelperFunction = CounterVariable[RandomGenerator];
          (t && t.equals(HelperFunction)) || (i.push(HelperFunction), (t = HelperFunction));
        }
      return (
        this.autoClose &&
          1 < i.length &&
          !i[i.length - 1].equals(i[0]) &&
          i.push(i[0]),
        i
      );
    },
    copy: function (env) {
      Gv.prototype.copy.call(this, env), (this.curves = []);
      for (var t = 0, i = env.curves.length; t < i; t++) {
        var n = env.curves[t];
        this.curves.push(n.clone());
      }
      return (this.autoClose = env.autoClose), this;
    },
    toJSON: function () {
      var env = Gv.prototype.toJSON.call(this);
      (env.autoClose = this.autoClose), (env.curves = []);
      for (var t = 0, i = this.curves.length; t < i; t++) {
        var n = this.curves[t];
        env.curves.push(n.toJSON());
      }
      return env;
    },
    fromJSON: function (env) {
      Gv.prototype.fromJSON.call(this, env),
        (this.autoClose = env.autoClose),
        (this.curves = []);
      for (var t = 0, i = env.curves.length; t < i; t++) {
        var n = env.curves[t];
        this.curves.push(new sy[n.type]().fromJSON(n));
      }
      return this;
    },
  })),
    (hy.prototype = Object.assign(Object.create(ly.prototype), {
      constructor: hy,
      setFromPoints: function (env) {
        this.moveTo(env[0].x, env[0].y);
        for (var t = 1, i = env.length; t < i; t++) this.lineTo(env[t].x, env[t].y);
      },
      moveTo: function (env, t) {
        this.currentPoint.set(env, t);
      },
      lineTo: function (env, t) {
        var i = new iy(this.currentPoint.clone(), new mu(env, t));
        this.curves.push(i), this.currentPoint.set(env, t);
      },
      quadraticCurveTo: function (env, t, i, n) {
        var r = new ry(this.currentPoint.clone(), new mu(env, t), new mu(i, n));
        this.curves.push(r), this.currentPoint.set(i, n);
      },
      bezierCurveTo: function (env, t, i, n, r, a) {
        var ObjectMethodWrapper = new ey(
          this.currentPoint.clone(),
          new mu(env, t),
          new mu(i, n),
          new mu(r, a),
        );
        this.curves.push(ObjectMethodWrapper), this.currentPoint.set(r, a);
      },
      splineThru: function (env) {
        var t = new oy([this.currentPoint.clone()].concat(env));
        this.curves.push(t), this.currentPoint.copy(env[env.length - 1]);
      },
      arc: function (env, t, i, n, r, a) {
        var ObjectMethodWrapper = this.currentPoint.x,
          CounterVariable = this.currentPoint.y;
        this.absarc(env + ObjectMethodWrapper, t + CounterVariable, i, n, r, a);
      },
      absarc: function (env, t, i, n, r, a) {
        this.absellipse(env, t, i, i, n, r, a);
      },
      ellipse: function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
        var RandomGenerator = this.currentPoint.x,
          HelperFunction = this.currentPoint.y;
        this.absellipse(env + RandomGenerator, t + HelperFunction, i, n, r, a, ObjectMethodWrapper, CounterVariable);
      },
      absellipse: function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable) {
        var RandomGenerator = new jv(env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable);
        if (0 < this.curves.length) {
          var HelperFunction = RandomGenerator.getPoint(0);
          HelperFunction.equals(this.currentPoint) || this.lineTo(HelperFunction.x, HelperFunction.y);
        }
        this.curves.push(RandomGenerator);
        var EnsureFunction = RandomGenerator.getPoint(1);
        this.currentPoint.copy(EnsureFunction);
      },
      copy: function (env) {
        return (
          ly.prototype.copy.call(this, env),
          this.currentPoint.copy(env.currentPoint),
          this
        );
      },
      toJSON: function () {
        var env = ly.prototype.toJSON.call(this);
        return (env.currentPoint = this.currentPoint.toArray()), env;
      },
      fromJSON: function (env) {
        return (
          ly.prototype.fromJSON.call(this, env),
          this.currentPoint.fromArray(env.currentPoint),
          this
        );
      },
    })),
    (cy.prototype = Object.assign(Object.create(hy.prototype), {
      constructor: cy,
      getPointsHoles: function (env) {
        for (var t = [], i = 0, n = this.holes.length; i < n; i++)
          t[i] = this.holes[i].getPoints(env);
        return t;
      },
      extractPoints: function (env) {
        return { shape: this.getPoints(env), holes: this.getPointsHoles(env) };
      },
      copy: function (env) {
        hy.prototype.copy.call(this, env), (this.holes = []);
        for (var t = 0, i = env.holes.length; t < i; t++) {
          var n = env.holes[t];
          this.holes.push(n.clone());
        }
        return this;
      },
      toJSON: function () {
        var env = hy.prototype.toJSON.call(this);
        (env.uuid = this.uuid), (env.holes = []);
        for (var t = 0, i = this.holes.length; t < i; t++) {
          var n = this.holes[t];
          env.holes.push(n.toJSON());
        }
        return env;
      },
      fromJSON: function (env) {
        hy.prototype.fromJSON.call(this, env),
          (this.uuid = env.uuid),
          (this.holes = []);
        for (var t = 0, i = env.holes.length; t < i; t++) {
          var n = env.holes[t];
          this.holes.push(new hy().fromJSON(n));
        }
        return this;
      },
    })),
    (uy.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: uy,
      isLight: !0,
      copy: function (env) {
        return (
          Pp.prototype.copy.call(this, env),
          this.color.copy(env.color),
          (this.intensity = env.intensity),
          this
        );
      },
      toJSON: function (env) {
        var t = Pp.prototype.toJSON.call(this, env);
        return (
          (t.object.color = this.color.getHex()),
          (t.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (t.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (t.object.distance = this.distance),
          void 0 !== this.angle && (t.object.angle = this.angle),
          void 0 !== this.decay && (t.object.decay = this.decay),
          void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
          t
        );
      },
    })),
    (py.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: py,
      isHemisphereLight: !0,
      copy: function (env) {
        return (
          uy.prototype.copy.call(this, env),
          this.groundColor.copy(env.groundColor),
          this
        );
      },
    })),
    Object.assign(dy.prototype, {
      copy: function (env) {
        return (
          (this.camera = env.camera.clone()),
          (this.bias = env.bias),
          (this.radius = env.radius),
          this.mapSize.copy(env.mapSize),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        var env = {};
        return (
          0 !== this.bias && (env.bias = this.bias),
          1 !== this.radius && (env.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (env.mapSize = this.mapSize.toArray()),
          (env.camera = this.camera.toJSON(!1).object),
          delete env.camera.matrix,
          env
        );
      },
    }),
    (fy.prototype = Object.assign(Object.create(dy.prototype), {
      constructor: fy,
      isSpotLightShadow: !0,
      update: function (env) {
        var t = this.camera,
          i = 2 * fu.RAD2DEG * env.angle,
          n = this.mapSize.width / this.mapSize.height,
          r = env.distance || t.far;
        (i === t.fov && n === t.aspect && r === t.far) ||
          ((t.fov = i),
          (t.aspect = n),
          (t.far = r),
          t.updateProjectionMatrix());
      },
    })),
    (my.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: my,
      isSpotLight: !0,
      copy: function (env) {
        return (
          uy.prototype.copy.call(this, env),
          (this.distance = env.distance),
          (this.angle = env.angle),
          (this.penumbra = env.penumbra),
          (this.decay = env.decay),
          (this.target = env.target.clone()),
          (this.shadow = env.shadow.clone()),
          this
        );
      },
    })),
    (gy.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: gy,
      isPointLight: !0,
      copy: function (env) {
        return (
          uy.prototype.copy.call(this, env),
          (this.distance = env.distance),
          (this.decay = env.decay),
          (this.shadow = env.shadow.clone()),
          this
        );
      },
    })),
    (vy.prototype = Object.assign(Object.create(Dm.prototype), {
      constructor: vy,
      isOrthographicCamera: !0,
      copy: function (env, t) {
        return (
          Dm.prototype.copy.call(this, env, t),
          (this.left = env.left),
          (this.right = env.right),
          (this.top = env.top),
          (this.bottom = env.bottom),
          (this.near = env.near),
          (this.far = env.far),
          (this.zoom = env.zoom),
          (this.view = null === env.view ? null : Object.assign({}, env.view)),
          this
        );
      },
      setViewOffset: function (env, t, i, n, r, a) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1,
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = env),
          (this.view.fullHeight = t),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = r),
          (this.view.height = a),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1),
          this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var env = (this.right - this.left) / (2 * this.zoom),
          t = (this.top - this.bottom) / (2 * this.zoom),
          i = (this.right + this.left) / 2,
          n = (this.top + this.bottom) / 2,
          r = i - env,
          a = i + env,
          ObjectMethodWrapper = n + t,
          CounterVariable = n - t;
        if (null !== this.view && this.view.enabled) {
          var RandomGenerator = this.zoom / (this.view.width / this.view.fullWidth),
            HelperFunction = this.zoom / (this.view.height / this.view.fullHeight),
            EnsureFunction = (this.right - this.left) / this.view.width,
            GlobalReference = (this.top - this.bottom) / this.view.height;
          (a = (r += EnsureFunction * (this.view.offsetX / RandomGenerator)) + EnsureFunction * (this.view.width / RandomGenerator)),
            (CounterVariable =
              (ObjectMethodWrapper -= GlobalReference * (this.view.offsetY / HelperFunction)) - GlobalReference * (this.view.height / HelperFunction));
        }
        this.projectionMatrix.makeOrthographic(r, a, ObjectMethodWrapper, CounterVariable, this.near, this.far),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (env) {
        var t = Pp.prototype.toJSON.call(this, env);
        return (
          (t.object.zoom = this.zoom),
          (t.object.left = this.left),
          (t.object.right = this.right),
          (t.object.top = this.top),
          (t.object.bottom = this.bottom),
          (t.object.near = this.near),
          (t.object.far = this.far),
          null !== this.view && (t.object.view = Object.assign({}, this.view)),
          t
        );
      },
    })),
    (YCoordinateArray.prototype = Object.assign(Object.create(dy.prototype), {
      constructor: YCoordinateArray,
    })),
    (_y.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: _y,
      isDirectionalLight: !0,
      copy: function (env) {
        return (
          uy.prototype.copy.call(this, env),
          (this.target = env.target.clone()),
          (this.shadow = env.shadow.clone()),
          this
        );
      },
    })),
    (xy.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: xy,
      isAmbientLight: !0,
    })),
    (by.prototype = Object.assign(Object.create(uy.prototype), {
      constructor: by,
      isRectAreaLight: !0,
      copy: function (env) {
        return (
          uy.prototype.copy.call(this, env),
          (this.width = env.width),
          (this.height = env.height),
          this
        );
      },
      toJSON: function (env) {
        var t = uy.prototype.toJSON.call(this, env);
        return (
          (t.object.width = this.width), (t.object.height = this.height), t
        );
      },
    }));
  var wy = {
    arraySlice: function (env, t, i) {
      return wy.isTypedArray(env)
        ? new env.constructor(env.subarray(t, void 0 !== i ? i : env.length))
        : env.slice(t, i);
    },
    convertArray: function (env, t, i) {
      return !env || (!i && env.constructor === t)
        ? env
        : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(env)
          : Array.prototype.slice.call(env);
    },
    isTypedArray: function (env) {
      return ArrayBuffer.isView(env) && !(env instanceof DataView);
    },
    getKeyframeOrder: function (i) {
      for (var env = i.length, t = new Array(env), n = 0; n !== env; ++n) t[n] = n;
      return (
        t.sort(function (env, t) {
          return i[env] - i[t];
        }),
        t
      );
    },
    sortedArray: function (env, t, i) {
      for (
        var n = env.length, r = new env.constructor(n), a = 0, ObjectMethodWrapper = 0;
        ObjectMethodWrapper !== n;
        ++a
      )
        for (var CounterVariable = i[a] * t, RandomGenerator = 0; RandomGenerator !== t; ++RandomGenerator) r[ObjectMethodWrapper++] = env[CounterVariable + RandomGenerator];
      return r;
    },
    flattenJSON: function (env, t, i, n) {
      for (var r = 1, a = env[0]; void 0 !== a && void 0 === a[n]; ) a = env[r++];
      if (void 0 !== a) {
        var ObjectMethodWrapper = a[n];
        if (void 0 !== ObjectMethodWrapper)
          if (Array.isArray(ObjectMethodWrapper))
            for (
              ;
              void 0 !== (ObjectMethodWrapper = a[n]) && (t.push(a.time), i.push.apply(i, ObjectMethodWrapper)),
                void 0 !== (a = env[r++]);

            );
          else if (void 0 !== ObjectMethodWrapper.toArray)
            for (
              ;
              void 0 !== (ObjectMethodWrapper = a[n]) && (t.push(a.time), ObjectMethodWrapper.toArray(i, i.length)),
                void 0 !== (a = env[r++]);

            );
          else
            for (
              ;
              void 0 !== (ObjectMethodWrapper = a[n]) && (t.push(a.time), i.push(ObjectMethodWrapper)),
                void 0 !== (a = env[r++]);

            );
      }
    },
  };

  function Ty(env, t, i, n) {
    (this.parameterPositions = env),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i);
  }

  function Sy(env, t, i, n) {
    Ty.call(this, env, t, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0);
  }

  function Ey(env, t, i, n) {
    Ty.call(this, env, t, i, n);
  }

  function Ay(env, t, i, n) {
    Ty.call(this, env, t, i, n);
  }

  function My(env, t, i, n) {
    if (void 0 === env)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + env);
    (this.name = env),
      (this.times = wy.convertArray(t, this.TimeBufferType)),
      (this.values = wy.convertArray(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }

  function Py(env, t, i) {
    My.call(this, env, t, i);
  }

  function Ly(env, t, i, n) {
    My.call(this, env, t, i, n);
  }

  function Cy(env, t, i, n) {
    My.call(this, env, t, i, n);
  }

  function Iy(env, t, i, n) {
    Ty.call(this, env, t, i, n);
  }

  function Ry(env, t, i, n) {
    My.call(this, env, t, i, n);
  }

  function Oy(env, t, i, n) {
    My.call(this, env, t, i, n);
  }

  function Fy(env, t, i, n) {
    My.call(this, env, t, i, n);
  }

  function Ny(env, t, i) {
    (this.name = env),
      (this.tracks = i),
      (this.duration = void 0 !== t ? t : -1),
      (this.uuid = fu.generateUUID()),
      this.duration < 0 && this.resetDuration();
  }

  function ky(env) {
    if (void 0 === env.type)
      throw new Error(
        "THREE.KeyframeTrack: track type undefined, can not parse",
      );
    var t = (function (env) {
      switch (env.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
          return Cy;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
          return Fy;
        case "color":
          return Ly;
        case "quaternion":
          return Ry;
        case "bool":
        case "boolean":
          return Py;
        case "string":
          return Oy;
      }
      throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + env);
    })(env.type);
    if (void 0 === env.times) {
      var i = [],
        n = [];
      wy.flattenJSON(env.keys, i, n, "value"), (env.times = i), (env.values = n);
    }
    return void 0 !== t.parse
      ? t.parse(env)
      : new t(env.name, env.times, env.values, env.interpolation);
  }

  function Uy(env) {
    (this.manager = void 0 !== env ? env : kv), (this.textures = {});
  }

  function Dy(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  Object.assign(Ty.prototype, {
    evaluate: function (env) {
      var t = this.parameterPositions,
        i = this._cachedIndex,
        n = t[i],
        r = t[i - 1];
      env: {
        t: {
          var a;
          i: {
            n: if (!(env < n)) {
              for (var ObjectMethodWrapper = i + 2; ; ) {
                if (void 0 === n) {
                  if (env < r) break n;
                  return (
                    (i = t.length),
                    (this._cachedIndex = i),
                    this.afterEnd_(i - 1, env, r)
                  );
                }
                if (i === ObjectMethodWrapper) break;
                if (((r = n), env < (n = t[++i]))) break t;
              }
              a = t.length;
              break i;
            }
            if (r <= env) break env;
            var CounterVariable = t[1];
            env < CounterVariable && ((i = 2), (r = CounterVariable));
            for (ObjectMethodWrapper = i - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, env, n);
              if (i === ObjectMethodWrapper) break;
              if (((n = r), (r = t[--i - 1]) <= env)) break t;
            }
            (a = i), (i = 0);
          }
          for (; i < a; ) {
            var RandomGenerator = (i + a) >>> 1;
            env < t[RandomGenerator] ? (a = RandomGenerator) : (i = RandomGenerator + 1);
          }
          if (((n = t[i]), void 0 === (r = t[i - 1])))
            return (this._cachedIndex = 0), this.beforeStart_(0, env, n);
          if (void 0 === n)
            return (
              (i = t.length),
              (this._cachedIndex = i),
              this.afterEnd_(i - 1, r, env)
            );
        }
        (this._cachedIndex = i), this.intervalChanged_(i, r, n);
      }
      return this.interpolate_(i, r, env, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function () {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function (env) {
      for (
        var t = this.resultBuffer,
          i = this.sampleValues,
          n = this.valueSize,
          r = env * n,
          a = 0;
        a !== n;
        ++a
      )
        t[a] = i[r + a];
      return t;
    },
    interpolate_: function () {
      throw new Error("call to abstract method");
    },
    intervalChanged_: function () {},
  }),
    Object.assign(Ty.prototype, {
      beforeStart_: Ty.prototype.copySampleValue_,
      afterEnd_: Ty.prototype.copySampleValue_,
    }),
    (Sy.prototype = Object.assign(Object.create(Ty.prototype), {
      constructor: Sy,
      DefaultSettings_: { endingStart: eu, endingEnd: eu },
      intervalChanged_: function (env, t, i) {
        var n = this.parameterPositions,
          r = env - 2,
          a = env + 1,
          ObjectMethodWrapper = n[r],
          CounterVariable = n[a];
        if (void 0 === ObjectMethodWrapper)
          switch (this.getSettings_().endingStart) {
            case tu:
              (r = env), (ObjectMethodWrapper = 2 * t - i);
              break;
            case 2402:
              ObjectMethodWrapper = t + n[(r = n.length - 2)] - n[r + 1];
              break;
            default:
              (r = env), (ObjectMethodWrapper = i);
          }
        if (void 0 === CounterVariable)
          switch (this.getSettings_().endingEnd) {
            case tu:
              (a = env), (CounterVariable = 2 * i - t);
              break;
            case 2402:
              CounterVariable = i + n[(a = 1)] - n[0];
              break;
            default:
              (a = env - 1), (CounterVariable = t);
          }
        var RandomGenerator = 0.5 * (i - t),
          HelperFunction = this.valueSize;
        (this._weightPrev = RandomGenerator / (t - ObjectMethodWrapper)),
          (this._weightNext = RandomGenerator / (CounterVariable - i)),
          (this._offsetPrev = r * HelperFunction),
          (this._offsetNext = a * HelperFunction);
      },
      interpolate_: function (env, t, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            ObjectMethodWrapper = this.valueSize,
            CounterVariable = env * ObjectMethodWrapper,
            RandomGenerator = CounterVariable - ObjectMethodWrapper,
            HelperFunction = this._offsetPrev,
            EnsureFunction = this._offsetNext,
            GlobalReference = this._weightPrev,
            Property = this._weightNext,
            MathFloorShortcut = (i - t) / (n - t),
            f = MathFloorShortcut * MathFloorShortcut,
            ModuleMeta = f * MathFloorShortcut,
            g = -GlobalReference * ModuleMeta + 2 * GlobalReference * f - GlobalReference * MathFloorShortcut,
            Value = (1 + GlobalReference) * ModuleMeta + (-1.5 - 2 * GlobalReference) * f + (-0.5 + GlobalReference) * MathFloorShortcut + 1,
            y = (-1 - Property) * ModuleMeta + (1.5 + Property) * f + 0.5 * MathFloorShortcut,
            _ = Property * ModuleMeta - Property * f,
            x = 0;
          x !== ObjectMethodWrapper;
          ++x
        )
          r[x] = g * a[HelperFunction + x] + Value * a[RandomGenerator + x] + y * a[CounterVariable + x] + _ * a[EnsureFunction + x];
        return r;
      },
    })),
    (Ey.prototype = Object.assign(Object.create(Ty.prototype), {
      constructor: Ey,
      interpolate_: function (env, t, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            ObjectMethodWrapper = this.valueSize,
            CounterVariable = env * ObjectMethodWrapper,
            RandomGenerator = CounterVariable - ObjectMethodWrapper,
            HelperFunction = (i - t) / (n - t),
            EnsureFunction = 1 - HelperFunction,
            GlobalReference = 0;
          GlobalReference !== ObjectMethodWrapper;
          ++GlobalReference
        )
          r[GlobalReference] = a[RandomGenerator + GlobalReference] * EnsureFunction + a[CounterVariable + GlobalReference] * HelperFunction;
        return r;
      },
    })),
    (Ay.prototype = Object.assign(Object.create(Ty.prototype), {
      constructor: Ay,
      interpolate_: function (env) {
        return this.copySampleValue_(env - 1);
      },
    })),
    Object.assign(My, {
      toJSON: function (env) {
        var t,
          i = env.constructor;
        if (void 0 !== i.toJSON) t = i.toJSON(env);
        else {
          t = {
            name: env.name,
            times: wy.convertArray(env.times, Array),
            values: wy.convertArray(env.values, Array),
          };
          var n = env.getInterpolation();
          n !== env.DefaultInterpolation && (t.interpolation = n);
        }
        return (t.type = env.ValueTypeName), t;
      },
    }),
    Object.assign(My.prototype, {
      constructor: My,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: 2301,
      InterpolantFactoryMethodDiscrete: function (env) {
        return new Ay(this.times, this.values, this.getValueSize(), env);
      },
      InterpolantFactoryMethodLinear: function (env) {
        return new Ey(this.times, this.values, this.getValueSize(), env);
      },
      InterpolantFactoryMethodSmooth: function (env) {
        return new Sy(this.times, this.values, this.getValueSize(), env);
      },
      setInterpolation: function (env) {
        var t;
        switch (env) {
          case 2300:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
          case 2301:
            t = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            t = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 !== t) return (this.createInterpolant = t), this;
        var i =
          "unsupported interpolation for " +
          this.ValueTypeName +
          " keyframe track named " +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (env === this.DefaultInterpolation) throw new Error(i);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn("THREE.KeyframeTrack:", i), this;
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return 2300;
          case this.InterpolantFactoryMethodLinear:
            return 2301;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (env) {
        if (0 !== env)
          for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] += env;
        return this;
      },
      scale: function (env) {
        if (1 !== env)
          for (var t = this.times, i = 0, n = t.length; i !== n; ++i) t[i] *= env;
        return this;
      },
      trim: function (env, t) {
        for (
          var i = this.times, n = i.length, r = 0, a = n - 1;
          r !== n && i[r] < env;

        )
          ++r;
        for (; -1 !== a && i[a] > t; ) --a;
        if ((++a, 0 !== r || a !== n)) {
          a <= r && (r = (a = Math.max(a, 1)) - 1);
          var ObjectMethodWrapper = this.getValueSize();
          (this.times = wy.arraySlice(i, r, a)),
            (this.values = wy.arraySlice(this.values, r * ObjectMethodWrapper, a * ObjectMethodWrapper));
        }
        return this;
      },
      validate: function () {
        var env = !0,
          t = this.getValueSize();
        t - Math.floor(t) != 0 &&
          (console.error(
            "THREE.KeyframeTrack: Invalid value size in track.",
            this,
          ),
          (env = !1));
        var i = this.times,
          n = this.values,
          r = i.length;
        0 === r &&
          (console.error("THREE.KeyframeTrack: Track is empty.", this),
          (env = !1));
        for (var a = null, ObjectMethodWrapper = 0; ObjectMethodWrapper !== r; ObjectMethodWrapper++) {
          var CounterVariable = i[ObjectMethodWrapper];
          if ("number" == typeof CounterVariable && isNaN(CounterVariable)) {
            console.error(
              "THREE.KeyframeTrack: Time is not a valid number.",
              this,
              ObjectMethodWrapper,
              CounterVariable,
            ),
              (env = !1);
            break;
          }
          if (null !== a && CounterVariable < a) {
            console.error(
              "THREE.KeyframeTrack: Out OutputFormatter order keys.",
              this,
              ObjectMethodWrapper,
              CounterVariable,
              a,
            ),
              (env = !1);
            break;
          }
          a = CounterVariable;
        }
        if (void 0 !== n && wy.isTypedArray(n)) {
          ObjectMethodWrapper = 0;
          for (var RandomGenerator = n.length; ObjectMethodWrapper !== RandomGenerator; ++ObjectMethodWrapper) {
            var HelperFunction = n[ObjectMethodWrapper];
            if (isNaN(HelperFunction)) {
              console.error(
                "THREE.KeyframeTrack: Value is not a valid number.",
                this,
                ObjectMethodWrapper,
                HelperFunction,
              ),
                (env = !1);
              break;
            }
          }
        }
        return env;
      },
      optimize: function () {
        for (
          var env = this.times,
            t = this.values,
            i = this.getValueSize(),
            n = 2302 === this.getInterpolation(),
            r = 1,
            a = env.length - 1,
            ObjectMethodWrapper = 1;
          ObjectMethodWrapper < a;
          ++ObjectMethodWrapper
        ) {
          var CounterVariable = !1,
            RandomGenerator = env[ObjectMethodWrapper];
          if (RandomGenerator !== env[ObjectMethodWrapper + 1] && (1 !== ObjectMethodWrapper || RandomGenerator !== RandomGenerator[0]))
            if (n) CounterVariable = !0;
            else
              for (var HelperFunction = ObjectMethodWrapper * i, EnsureFunction = HelperFunction - i, GlobalReference = HelperFunction + i, Property = 0; Property !== i; ++Property) {
                var MathFloorShortcut = t[HelperFunction + Property];
                if (MathFloorShortcut !== t[EnsureFunction + Property] || MathFloorShortcut !== t[GlobalReference + Property]) {
                  CounterVariable = !0;
                  break;
                }
              }
          if (CounterVariable) {
            if (ObjectMethodWrapper !== r) {
              env[r] = env[ObjectMethodWrapper];
              var f = ObjectMethodWrapper * i,
                ModuleMeta = r * i;
              for (Property = 0; Property !== i; ++Property) t[ModuleMeta + Property] = t[f + Property];
            }
            ++r;
          }
        }
        if (0 < a) {
          env[r] = env[a];
          for (f = a * i, ModuleMeta = r * i, Property = 0; Property !== i; ++Property) t[ModuleMeta + Property] = t[f + Property];
          ++r;
        }
        return (
          r !== env.length &&
            ((this.times = wy.arraySlice(env, 0, r)),
            (this.values = wy.arraySlice(t, 0, r * i))),
          this
        );
      },
    }),
    (Py.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Py,
      ValueTypeName: "bool",
      ValueBufferType: Array,
      DefaultInterpolation: 2300,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (Ly.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Ly,
      ValueTypeName: "color",
    })),
    (Cy.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Cy,
      ValueTypeName: "number",
    })),
    (Iy.prototype = Object.assign(Object.create(Ty.prototype), {
      constructor: Iy,
      interpolate_: function (env, t, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            ObjectMethodWrapper = this.valueSize,
            CounterVariable = env * ObjectMethodWrapper,
            RandomGenerator = (i - t) / (n - t),
            HelperFunction = CounterVariable + ObjectMethodWrapper;
          CounterVariable !== HelperFunction;
          CounterVariable += 4
        )
          vu.slerpFlat(r, 0, a, CounterVariable - ObjectMethodWrapper, a, CounterVariable, RandomGenerator);
        return r;
      },
    })),
    (Ry.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Ry,
      ValueTypeName: "quaternion",
      DefaultInterpolation: 2301,
      InterpolantFactoryMethodLinear: function (env) {
        return new Iy(this.times, this.values, this.getValueSize(), env);
      },
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (Oy.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Oy,
      ValueTypeName: "string",
      ValueBufferType: Array,
      DefaultInterpolation: 2300,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0,
    })),
    (Fy.prototype = Object.assign(Object.create(My.prototype), {
      constructor: Fy,
      ValueTypeName: "vector",
    })),
    Object.assign(Ny, {
      parse: function (env) {
        for (
          var t = [], i = env.tracks, n = 1 / (env.fps || 1), r = 0, a = i.length;
          r !== a;
          ++r
        )
          t.push(ky(i[r]).scale(n));
        return new Ny(env.name, env.duration, t);
      },
      toJSON: function (env) {
        for (
          var t = [],
            i = env.tracks,
            n = {
              name: env.name,
              duration: env.duration,
              tracks: t,
              uuid: env.uuid,
            },
            r = 0,
            a = i.length;
          r !== a;
          ++r
        )
          t.push(My.toJSON(i[r]));
        return n;
      },
      CreateFromMorphTargetSequence: function (env, t, i, n) {
        for (var r = t.length, a = [], ObjectMethodWrapper = 0; ObjectMethodWrapper < r; ObjectMethodWrapper++) {
          var CounterVariable = [],
            RandomGenerator = [];
          CounterVariable.push((ObjectMethodWrapper + r - 1) % r, ObjectMethodWrapper, (ObjectMethodWrapper + 1) % r), RandomGenerator.push(0, 1, 0);
          var HelperFunction = wy.getKeyframeOrder(CounterVariable);
          (CounterVariable = wy.sortedArray(CounterVariable, 1, HelperFunction)),
            (RandomGenerator = wy.sortedArray(RandomGenerator, 1, HelperFunction)),
            n || 0 !== CounterVariable[0] || (CounterVariable.push(r), RandomGenerator.push(RandomGenerator[0])),
            a.push(
              new Cy(".morphTargetInfluences[" + t[ObjectMethodWrapper].name + "]", CounterVariable, RandomGenerator).scale(
                1 / i,
              ),
            );
        }
        return new Ny(env, -1, a);
      },
      findByName: function (env, t) {
        var i = env;
        if (!Array.isArray(env)) {
          var n = env;
          i = (n.geometry && n.geometry.animations) || n.animations;
        }
        for (var r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
        return null;
      },
      CreateClipsFromMorphTargetSequences: function (env, t, i) {
        for (
          var n = {}, r = /^([\w-]*?)([\MathFloorShortcut]+)$/, a = 0, ObjectMethodWrapper = env.length;
          a < ObjectMethodWrapper;
          a++
        ) {
          var CounterVariable = env[a],
            RandomGenerator = CounterVariable.name.match(r);
          if (RandomGenerator && 1 < RandomGenerator.length) {
            var HelperFunction = n[(GlobalReference = RandomGenerator[1])];
            HelperFunction || (n[GlobalReference] = HelperFunction = []), HelperFunction.push(CounterVariable);
          }
        }
        var EnsureFunction = [];
        for (var GlobalReference in n)
          EnsureFunction.push(Ny.CreateFromMorphTargetSequence(GlobalReference, n[GlobalReference], t, i));
        return EnsureFunction;
      },
      parseAnimation: function (env, t) {
        if (!env)
          return (
            console.error(
              "THREE.AnimationClip: No animation in JSONLoader data.",
            ),
            null
          );
        for (
          var i = function (env, t, i, n, r) {
              if (0 !== i.length) {
                var a = [],
                  ObjectMethodWrapper = [];
                wy.flattenJSON(i, a, ObjectMethodWrapper, n),
                  0 !== a.length && r.push(new env(t, a, ObjectMethodWrapper));
              }
            },
            n = [],
            r = env.name || "default",
            a = env.length || -1,
            ObjectMethodWrapper = env.fps || 30,
            CounterVariable = env.hierarchy || [],
            RandomGenerator = 0;
          RandomGenerator < CounterVariable.length;
          RandomGenerator++
        ) {
          var HelperFunction = CounterVariable[RandomGenerator].keys;
          if (HelperFunction && 0 !== HelperFunction.length)
            if (HelperFunction[0].morphTargets) {
              for (var EnsureFunction = {}, GlobalReference = 0; GlobalReference < HelperFunction.length; GlobalReference++)
                if (HelperFunction[GlobalReference].morphTargets)
                  for (var Property = 0; Property < HelperFunction[GlobalReference].morphTargets.length; Property++)
                    EnsureFunction[HelperFunction[GlobalReference].morphTargets[Property]] = -1;
              for (var MathFloorShortcut in EnsureFunction) {
                var f = [],
                  ModuleMeta = [];
                for (Property = 0; Property !== HelperFunction[GlobalReference].morphTargets.length; ++Property) {
                  var g = HelperFunction[GlobalReference];
                  f.push(g.time), ModuleMeta.push(g.morphTarget === MathFloorShortcut ? 1 : 0);
                }
                n.push(new Cy(".morphTargetInfluence[" + MathFloorShortcut + "]", f, ModuleMeta));
              }
              a = EnsureFunction.length * (ObjectMethodWrapper || 1);
            } else {
              var Value = ".bones[" + t[RandomGenerator].name + "]";
              i(Fy, Value + ".position", HelperFunction, "pos", n),
                i(Ry, Value + ".quaternion", HelperFunction, "rot", n),
                i(Fy, Value + ".scale", HelperFunction, "scl", n);
            }
        }
        return 0 === n.length ? null : new Ny(r, a, n);
      },
    }),
    Object.assign(Ny.prototype, {
      resetDuration: function () {
        for (var env = 0, t = 0, i = this.tracks.length; t !== i; ++t) {
          var n = this.tracks[t];
          env = Math.max(env, n.times[n.times.length - 1]);
        }
        return (this.duration = env), this;
      },
      trim: function () {
        for (var env = 0; env < this.tracks.length; env++)
          this.tracks[env].trim(0, this.duration);
        return this;
      },
      validate: function () {
        for (var env = !0, t = 0; t < this.tracks.length; t++)
          env = env && this.tracks[t].validate();
        return env;
      },
      optimize: function () {
        for (var env = 0; env < this.tracks.length; env++) this.tracks[env].optimize();
        return this;
      },
    }),
    Object.assign(Uy.prototype, {
      load: function (env, t, i, n) {
        var r = this;
        new Dv(r.manager).load(
          env,
          function (env) {
            t(r.parse(JSON.parse(env)));
          },
          i,
          n,
        );
      },
      setTextures: function (env) {
        this.textures = env;
      },
      parse: function (env) {
        var t = this.textures;

        function i(env) {
          return (
            void 0 === t[env] &&
              console.warn("THREE.MaterialLoader: Undefined texture", env),
            t[env]
          );
        }

        var n = new Ov[env.type]();
        if (
          (void 0 !== env.uuid && (n.uuid = env.uuid),
          void 0 !== env.name && (n.name = env.name),
          void 0 !== env.color && n.color.setHex(env.color),
          void 0 !== env.roughness && (n.roughness = env.roughness),
          void 0 !== env.metalness && (n.metalness = env.metalness),
          void 0 !== env.emissive && n.emissive.setHex(env.emissive),
          void 0 !== env.specular && n.specular.setHex(env.specular),
          void 0 !== env.shininess && (n.shininess = env.shininess),
          void 0 !== env.clearCoat && (n.clearCoat = env.clearCoat),
          void 0 !== env.clearCoatRoughness &&
            (n.clearCoatRoughness = env.clearCoatRoughness),
          void 0 !== env.vertexColors && (n.vertexColors = env.vertexColors),
          void 0 !== env.fog && (n.fog = env.fog),
          void 0 !== env.flatShading && (n.flatShading = env.flatShading),
          void 0 !== env.blending && (n.blending = env.blending),
          void 0 !== env.combine && (n.combine = env.combine),
          void 0 !== env.side && (n.side = env.side),
          void 0 !== env.opacity && (n.opacity = env.opacity),
          void 0 !== env.transparent && (n.transparent = env.transparent),
          void 0 !== env.alphaTest && (n.alphaTest = env.alphaTest),
          void 0 !== env.depthTest && (n.depthTest = env.depthTest),
          void 0 !== env.depthWrite && (n.depthWrite = env.depthWrite),
          void 0 !== env.colorWrite && (n.colorWrite = env.colorWrite),
          void 0 !== env.wireframe && (n.wireframe = env.wireframe),
          void 0 !== env.wireframeLinewidth &&
            (n.wireframeLinewidth = env.wireframeLinewidth),
          void 0 !== env.wireframeLinecap &&
            (n.wireframeLinecap = env.wireframeLinecap),
          void 0 !== env.wireframeLinejoin &&
            (n.wireframeLinejoin = env.wireframeLinejoin),
          void 0 !== env.rotation && (n.rotation = env.rotation),
          1 !== env.linewidth && (n.linewidth = env.linewidth),
          void 0 !== env.dashSize && (n.dashSize = env.dashSize),
          void 0 !== env.gapSize && (n.gapSize = env.gapSize),
          void 0 !== env.scale && (n.scale = env.scale),
          void 0 !== env.polygonOffset && (n.polygonOffset = env.polygonOffset),
          void 0 !== env.polygonOffsetFactor &&
            (n.polygonOffsetFactor = env.polygonOffsetFactor),
          void 0 !== env.polygonOffsetUnits &&
            (n.polygonOffsetUnits = env.polygonOffsetUnits),
          void 0 !== env.skinning && (n.skinning = env.skinning),
          void 0 !== env.morphTargets && (n.morphTargets = env.morphTargets),
          void 0 !== env.dithering && (n.dithering = env.dithering),
          void 0 !== env.visible && (n.visible = env.visible),
          void 0 !== env.userData && (n.userData = env.userData),
          void 0 !== env.uniforms)
        )
          for (var r in env.uniforms) {
            var a = env.uniforms[r];
            switch (((n.uniforms[r] = {}), a.type)) {
              case "t":
                n.uniforms[r].value = i(a.value);
                break;
              case "EnsureFunction":
                n.uniforms[r].value = new $GlobalReference().setHex(a.value);
                break;
              case "v2":
                n.uniforms[r].value = new mu().fromArray(a.value);
                break;
              case "v3":
                n.uniforms[r].value = new yu().fromArray(a.value);
                break;
              case "v4":
                n.uniforms[r].value = new zu().fromArray(a.value);
                break;
              case "m4":
                n.uniforms[r].value = new gu().fromArray(a.value);
                break;
              default:
                n.uniforms[r].value = a.value;
            }
          }
        if (
          (void 0 !== env.defines && (n.defines = env.defines),
          void 0 !== env.vertexShader && (n.vertexShader = env.vertexShader),
          void 0 !== env.fragmentShader && (n.fragmentShader = env.fragmentShader),
          void 0 !== env.shading && (n.flatShading = 1 === env.shading),
          void 0 !== env.size && (n.size = env.size),
          void 0 !== env.sizeAttenuation &&
            (n.sizeAttenuation = env.sizeAttenuation),
          void 0 !== env.map && (n.map = i(env.map)),
          void 0 !== env.alphaMap &&
            ((n.alphaMap = i(env.alphaMap)), (n.transparent = !0)),
          void 0 !== env.bumpMap && (n.bumpMap = i(env.bumpMap)),
          void 0 !== env.bumpScale && (n.bumpScale = env.bumpScale),
          void 0 !== env.normalMap && (n.normalMap = i(env.normalMap)),
          void 0 !== env.normalMapType && (n.normalMapType = env.normalMapType),
          void 0 !== env.normalScale)
        ) {
          var ObjectMethodWrapper = env.normalScale;
          !1 === Array.isArray(ObjectMethodWrapper) && (ObjectMethodWrapper = [ObjectMethodWrapper, ObjectMethodWrapper]),
            (n.normalScale = new mu().fromArray(ObjectMethodWrapper));
        }
        return (
          void 0 !== env.displacementMap &&
            (n.displacementMap = i(env.displacementMap)),
          void 0 !== env.displacementScale &&
            (n.displacementScale = env.displacementScale),
          void 0 !== env.displacementBias &&
            (n.displacementBias = env.displacementBias),
          void 0 !== env.roughnessMap && (n.roughnessMap = i(env.roughnessMap)),
          void 0 !== env.metalnessMap && (n.metalnessMap = i(env.metalnessMap)),
          void 0 !== env.emissiveMap && (n.emissiveMap = i(env.emissiveMap)),
          void 0 !== env.emissiveIntensity &&
            (n.emissiveIntensity = env.emissiveIntensity),
          void 0 !== env.specularMap && (n.specularMap = i(env.specularMap)),
          void 0 !== env.envMap && (n.envMap = i(env.envMap)),
          void 0 !== env.envMapIntensity &&
            (n.envMapIntensity = env.envMapIntensity),
          void 0 !== env.reflectivity && (n.reflectivity = env.reflectivity),
          void 0 !== env.lightMap && (n.lightMap = i(env.lightMap)),
          void 0 !== env.lightMapIntensity &&
            (n.lightMapIntensity = env.lightMapIntensity),
          void 0 !== env.aoMap && (n.aoMap = i(env.aoMap)),
          void 0 !== env.aoMapIntensity && (n.aoMapIntensity = env.aoMapIntensity),
          void 0 !== env.gradientMap && (n.gradientMap = i(env.gradientMap)),
          n
        );
      },
    }),
    Object.assign(Dy.prototype, {
      load: function (env, t, i, n) {
        var r = this;
        new Dv(r.manager).load(
          env,
          function (env) {
            t(r.parse(JSON.parse(env)));
          },
          i,
          n,
        );
      },
      parse: function (env) {
        var t = new StateDetector(),
          i = env.data.index;
        if (void 0 !== i) {
          var n = new jy[i.type](i.array);
          t.setIndex(new Dp(n, 1));
        }
        var r = env.data.attributes;
        for (var a in r) {
          var ObjectMethodWrapper = r[a];
          n = new jy[ObjectMethodWrapper.type](ObjectMethodWrapper.array);
          t.addAttribute(a, new Dp(n, ObjectMethodWrapper.itemSize, ObjectMethodWrapper.normalized));
        }
        var CounterVariable = env.data.groups || env.data.drawcalls || env.data.offsets;
        if (void 0 !== CounterVariable)
          for (var RandomGenerator = 0, HelperFunction = CounterVariable.length; RandomGenerator !== HelperFunction; ++RandomGenerator) {
            var EnsureFunction = CounterVariable[RandomGenerator];
            t.addGroup(EnsureFunction.start, EnsureFunction.count, EnsureFunction.materialIndex);
          }
        var GlobalReference = env.data.boundingSphere;
        if (void 0 !== GlobalReference) {
          var Property = new yu();
          void 0 !== GlobalReference.center && Property.fromArray(GlobalReference.center),
            (t.boundingSphere = new Vu(Property, GlobalReference.radius));
        }
        return t;
      },
    });
  var zy,
    By,
    Hy,
    Gy,
    jy = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        "undefined" != typeof Uint8ClampedArray
          ? Uint8ClampedArray
          : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array,
    };

  function Vy() {}

  (Vy.Handlers = {
    handlers: [],
    add: function (env, t) {
      this.handlers.push(env, t);
    },
    get: function (env) {
      for (var t = this.handlers, i = 0, n = t.length; i < n; i += 2) {
        var r = t[i],
          a = t[i + 1];
        if (r.test(env)) return a;
      }
      return null;
    },
  }),
    Object.assign(Vy.prototype, {
      crossOrigin: "anonymous",
      onLoadStart: function () {},
      onLoadProgress: function () {},
      onLoadComplete: function () {},
      initMaterials: function (env, t, i) {
        for (var n = [], r = 0; r < env.length; ++r)
          n[r] = this.createMaterial(env[r], t, i);
        return n;
      },
      createMaterial:
        ((zy = {
          NoBlending: uh,
          NormalBlending: ph,
          AdditiveBlending: dh,
          SubtractiveBlending: fh,
          MultiplyBlending: mh,
          CustomBlending: GraphHandler,
        }),
        (By = new $GlobalReference()),
        (Hy = new Hv()),
        (Gy = new Uy()),
        function (env, HelperFunction, EnsureFunction) {
          var GlobalReference = {};

          function t(env, t, i, n, r) {
            var a,
              ObjectMethodWrapper = HelperFunction + env,
              CounterVariable = Vy.Handlers.get(ObjectMethodWrapper);
            (a = null !== CounterVariable ? CounterVariable.load(ObjectMethodWrapper) : (Hy.setCrossOrigin(EnsureFunction), Hy.load(ObjectMethodWrapper))),
              void 0 !== t &&
                (a.repeat.fromArray(t),
                1 !== t[0] && (a.wrapS = IndexCounter),
                1 !== t[1] && (a.wrapT = IndexCounter)),
              void 0 !== i && a.offset.fromArray(i),
              void 0 !== n &&
                ("repeat" === n[0] && (a.wrapS = IndexCounter),
                "mirror" === n[0] && (a.wrapS = RequestCache),
                "repeat" === n[1] && (a.wrapT = IndexCounter),
                "mirror" === n[1] && (a.wrapT = RequestCache)),
              void 0 !== r && (a.anisotropy = r);
            var RandomGenerator = fu.generateUUID();
            return (GlobalReference[RandomGenerator] = a), RandomGenerator;
          }

          var i = { uuid: fu.generateUUID(), type: "MeshLambertMaterial" };
          for (var n in env) {
            var r = env[n];
            switch (n) {
              case "DbgColor":
              case "DbgIndex":
              case "opticalDensity":
              case "illumination":
                break;
              case "DbgName":
                i.name = r;
                break;
              case "blending":
                i.blending = zy[r];
                break;
              case "colorAmbient":
              case "mapAmbient":
                console.warn(
                  "THREE.Loader.createMaterial:",
                  n,
                  "is no longer supported.",
                );
                break;
              case "colorDiffuse":
                i.color = By.fromArray(r).getHex();
                break;
              case "colorSpecular":
                i.specular = By.fromArray(r).getHex();
                break;
              case "colorEmissive":
                i.emissive = By.fromArray(r).getHex();
                break;
              case "specularCoef":
                i.shininess = r;
                break;
              case "shading":
                "basic" === r.toLowerCase() && (i.type = "MeshBasicMaterial"),
                  "phong" === r.toLowerCase() && (i.type = "MeshPhongMaterial"),
                  "standard" === r.toLowerCase() &&
                    (i.type = "MeshStandardMaterial");
                break;
              case "mapDiffuse":
                i.map = t(
                  r,
                  env.mapDiffuseRepeat,
                  env.mapDiffuseOffset,
                  env.mapDiffuseWrap,
                  env.mapDiffuseAnisotropy,
                );
                break;
              case "mapDiffuseRepeat":
              case "mapDiffuseOffset":
              case "mapDiffuseWrap":
              case "mapDiffuseAnisotropy":
                break;
              case "mapEmissive":
                i.emissiveMap = t(
                  r,
                  env.mapEmissiveRepeat,
                  env.mapEmissiveOffset,
                  env.mapEmissiveWrap,
                  env.mapEmissiveAnisotropy,
                );
                break;
              case "mapEmissiveRepeat":
              case "mapEmissiveOffset":
              case "mapEmissiveWrap":
              case "mapEmissiveAnisotropy":
                break;
              case "mapLight":
                i.lightMap = t(
                  r,
                  env.mapLightRepeat,
                  env.mapLightOffset,
                  env.mapLightWrap,
                  env.mapLightAnisotropy,
                );
                break;
              case "mapLightRepeat":
              case "mapLightOffset":
              case "mapLightWrap":
              case "mapLightAnisotropy":
                break;
              case "mapAO":
                i.aoMap = t(
                  r,
                  env.mapAORepeat,
                  env.mapAOOffset,
                  env.mapAOWrap,
                  env.mapAOAnisotropy,
                );
                break;
              case "mapAORepeat":
              case "mapAOOffset":
              case "mapAOWrap":
              case "mapAOAnisotropy":
                break;
              case "mapBump":
                i.bumpMap = t(
                  r,
                  env.mapBumpRepeat,
                  env.mapBumpOffset,
                  env.mapBumpWrap,
                  env.mapBumpAnisotropy,
                );
                break;
              case "mapBumpScale":
                i.bumpScale = r;
                break;
              case "mapBumpRepeat":
              case "mapBumpOffset":
              case "mapBumpWrap":
              case "mapBumpAnisotropy":
                break;
              case "mapNormal":
                i.normalMap = t(
                  r,
                  env.mapNormalRepeat,
                  env.mapNormalOffset,
                  env.mapNormalWrap,
                  env.mapNormalAnisotropy,
                );
                break;
              case "mapNormalFactor":
                i.normalScale = r;
                break;
              case "mapNormalRepeat":
              case "mapNormalOffset":
              case "mapNormalWrap":
              case "mapNormalAnisotropy":
                break;
              case "mapSpecular":
                i.specularMap = t(
                  r,
                  env.mapSpecularRepeat,
                  env.mapSpecularOffset,
                  env.mapSpecularWrap,
                  env.mapSpecularAnisotropy,
                );
                break;
              case "mapSpecularRepeat":
              case "mapSpecularOffset":
              case "mapSpecularWrap":
              case "mapSpecularAnisotropy":
                break;
              case "mapMetalness":
                i.metalnessMap = t(
                  r,
                  env.mapMetalnessRepeat,
                  env.mapMetalnessOffset,
                  env.mapMetalnessWrap,
                  env.mapMetalnessAnisotropy,
                );
                break;
              case "mapMetalnessRepeat":
              case "mapMetalnessOffset":
              case "mapMetalnessWrap":
              case "mapMetalnessAnisotropy":
                break;
              case "mapRoughness":
                i.roughnessMap = t(
                  r,
                  env.mapRoughnessRepeat,
                  env.mapRoughnessOffset,
                  env.mapRoughnessWrap,
                  env.mapRoughnessAnisotropy,
                );
                break;
              case "mapRoughnessRepeat":
              case "mapRoughnessOffset":
              case "mapRoughnessWrap":
              case "mapRoughnessAnisotropy":
                break;
              case "mapAlpha":
                i.alphaMap = t(
                  r,
                  env.mapAlphaRepeat,
                  env.mapAlphaOffset,
                  env.mapAlphaWrap,
                  env.mapAlphaAnisotropy,
                );
                break;
              case "mapAlphaRepeat":
              case "mapAlphaOffset":
              case "mapAlphaWrap":
              case "mapAlphaAnisotropy":
                break;
              case "flipSided":
                i.side = lh;
                break;
              case "doubleSided":
                i.side = hh;
                break;
              case "transparency":
                console.warn(
                  "THREE.Loader.createMaterial: transparency has been renamed to opacity",
                ),
                  (i.opacity = r);
                break;
              case "depthTest":
              case "depthWrite":
              case "colorWrite":
              case "opacity":
              case "reflectivity":
              case "transparent":
              case "visible":
              case "wireframe":
                i[n] = r;
                break;
              case "vertexColors":
                !0 === r && (i.vertexColors = 2),
                  "face" === r && (i.vertexColors = 1);
                break;
              default:
                console.error("THREE.Loader.createMaterial: Unsupported", n, r);
            }
          }
          return (
            "MeshBasicMaterial" === i.type && delete i.emissive,
            "MeshPhongMaterial" !== i.type && delete i.specular,
            i.opacity < 1 && (i.transparent = !0),
            Gy.setTextures(GlobalReference),
            Gy.parse(i)
          );
        }),
    });
  var Xy = function (env) {
    var t = env.lastIndexOf("/");
    return -1 === t ? "./" : env.substr(0, t + 1);
  };

  function Wy(env) {
    "boolean" == typeof env &&
      (console.warn(
        "THREE.JSONLoader: showStatus parameter has been removed from constructor.",
      ),
      (env = void 0)),
      (this.manager = void 0 !== env ? env : kv),
      (this.withCredentials = !1);
  }

  Object.assign(Wy.prototype, {
    crossOrigin: "anonymous",
    load: function (a, ObjectMethodWrapper, env, t) {
      var CounterVariable = this,
        RandomGenerator = void 0 === this.path ? Xy(a) : this.path,
        i = new Dv(this.manager);
      i.setPath(this.path),
        i.setWithCredentials(this.withCredentials),
        i.load(
          a,
          function (env) {
            var t = JSON.parse(env),
              i = t.metadata;
            if (void 0 !== i) {
              var n = i.type;
              if (void 0 !== n && "object" === n.toLowerCase())
                return void console.error(
                  "THREE.JSONLoader: " +
                    a +
                    " should be loaded with THREE.ObjectLoader instead.",
                );
            }
            var r = CounterVariable.parse(t, RandomGenerator);
            ObjectMethodWrapper(r.geometry, r.materials);
          },
          env,
          t,
        );
    },
    setPath: function (env) {
      return (this.path = env), this;
    },
    setResourcePath: function (env) {
      return (this.resourcePath = env), this;
    },
    setCrossOrigin: function (env) {
      return (this.crossOrigin = env), this;
    },
    parse: function (env, t) {
      void 0 !== env.data && (env = env.data),
        void 0 !== env.scale ? (env.scale = 1 / env.scale) : (env.scale = 1);
      var i = new Up();
      return (
        (function (env, t) {
          function i(env, t) {
            return env & (1 << t);
          }

          var n,
            r,
            a,
            ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction,
            GlobalReference,
            Property,
            MathFloorShortcut,
            f,
            ModuleMeta,
            g,
            Value,
            y,
            _,
            x,
            b,
            w,
            T,
            EnsureObject,
            E,
            A,
            M,
            P = env.faces,
            L = env.vertices,
            C = env.normals,
            I = env.colors,
            R = env.scale,
            O = 0;
          if (void 0 !== env.uvs) {
            for (n = 0; n < env.uvs.length; n++) env.uvs[n].length && O++;
            for (n = 0; n < O; n++) t.faceVertexUvs[n] = [];
          }
          for (ObjectMethodWrapper = 0, CounterVariable = L.length; ObjectMethodWrapper < CounterVariable; )
            ((x = new yu()).x = L[ObjectMethodWrapper++] * R),
              (x.y = L[ObjectMethodWrapper++] * R),
              (x.z = L[ObjectMethodWrapper++] * R),
              t.vertices.push(x);
          for (ObjectMethodWrapper = 0, CounterVariable = P.length; ObjectMethodWrapper < CounterVariable; )
            if (
              ((MathFloorShortcut = i((Property = P[ObjectMethodWrapper++]), 0)),
              (f = i(Property, 1)),
              (ModuleMeta = i(Property, 3)),
              (g = i(Property, 4)),
              (Value = i(Property, 5)),
              (y = i(Property, 6)),
              (_ = i(Property, 7)),
              MathFloorShortcut)
            ) {
              if (
                (((w = new OperationParameter()).a = P[ObjectMethodWrapper]),
                (w.b = P[ObjectMethodWrapper + 1]),
                (w.EnsureFunction = P[ObjectMethodWrapper + 3]),
                ((T = new OperationParameter()).a = P[ObjectMethodWrapper + 1]),
                (T.b = P[ObjectMethodWrapper + 2]),
                (T.EnsureFunction = P[ObjectMethodWrapper + 3]),
                (ObjectMethodWrapper += 4),
                f &&
                  ((GlobalReference = P[ObjectMethodWrapper++]), (w.materialIndex = GlobalReference), (T.materialIndex = GlobalReference)),
                (a = t.faces.length),
                ModuleMeta)
              )
                for (n = 0; n < O; n++)
                  for (
                    A = env.uvs[n],
                      t.faceVertexUvs[n][a] = [],
                      t.faceVertexUvs[n][a + 1] = [],
                      r = 0;
                    r < 4;
                    r++
                  )
                    (M = new mu(A[2 * (EnsureFunction = P[ObjectMethodWrapper++])], A[2 * EnsureFunction + 1])),
                      2 !== r && t.faceVertexUvs[n][a].push(M),
                      0 !== r && t.faceVertexUvs[n][a + 1].push(M);
              if (
                (g &&
                  ((HelperFunction = 3 * P[ObjectMethodWrapper++]),
                  w.normal.set(C[HelperFunction++], C[HelperFunction++], C[HelperFunction]),
                  T.normal.copy(w.normal)),
                Value)
              )
                for (n = 0; n < 4; n++)
                  (HelperFunction = 3 * P[ObjectMethodWrapper++]),
                    (E = new yu(C[HelperFunction++], C[HelperFunction++], C[HelperFunction])),
                    2 !== n && w.vertexNormals.push(E),
                    0 !== n && T.vertexNormals.push(E);
              if (
                (y &&
                  ((EnsureObject = I[(RandomGenerator = P[ObjectMethodWrapper++])]), w.color.setHex(EnsureObject), T.color.setHex(EnsureObject)),
                _)
              )
                for (n = 0; n < 4; n++)
                  (EnsureObject = I[(RandomGenerator = P[ObjectMethodWrapper++])]),
                    2 !== n && w.vertexColors.push(new $GlobalReference(EnsureObject)),
                    0 !== n && T.vertexColors.push(new $GlobalReference(EnsureObject));
              t.faces.push(w), t.faces.push(T);
            } else {
              if (
                (((b = new OperationParameter()).a = P[ObjectMethodWrapper++]),
                (b.b = P[ObjectMethodWrapper++]),
                (b.EnsureFunction = P[ObjectMethodWrapper++]),
                f && ((GlobalReference = P[ObjectMethodWrapper++]), (b.materialIndex = GlobalReference)),
                (a = t.faces.length),
                ModuleMeta)
              )
                for (n = 0; n < O; n++)
                  for (
                    A = env.uvs[n], t.faceVertexUvs[n][a] = [], r = 0;
                    r < 3;
                    r++
                  )
                    (M = new mu(A[2 * (EnsureFunction = P[ObjectMethodWrapper++])], A[2 * EnsureFunction + 1])),
                      t.faceVertexUvs[n][a].push(M);
              if (
                (g && ((HelperFunction = 3 * P[ObjectMethodWrapper++]), b.normal.set(C[HelperFunction++], C[HelperFunction++], C[HelperFunction])), Value)
              )
                for (n = 0; n < 3; n++)
                  (HelperFunction = 3 * P[ObjectMethodWrapper++]),
                    (E = new yu(C[HelperFunction++], C[HelperFunction++], C[HelperFunction])),
                    b.vertexNormals.push(E);
              if ((y && ((RandomGenerator = P[ObjectMethodWrapper++]), b.color.setHex(I[RandomGenerator])), _))
                for (n = 0; n < 3; n++)
                  (RandomGenerator = P[ObjectMethodWrapper++]), b.vertexColors.push(new $GlobalReference(I[RandomGenerator]));
              t.faces.push(b);
            }
        })(env, i),
        (function (env, t) {
          var i = void 0 !== env.influencesPerVertex ? env.influencesPerVertex : 2;
          if (env.skinWeights)
            for (var n = 0, r = env.skinWeights.length; n < r; n += i) {
              var a = env.skinWeights[n],
                ObjectMethodWrapper = 1 < i ? env.skinWeights[n + 1] : 0,
                CounterVariable = 2 < i ? env.skinWeights[n + 2] : 0,
                RandomGenerator = 3 < i ? env.skinWeights[n + 3] : 0;
              t.skinWeights.push(new zu(a, ObjectMethodWrapper, CounterVariable, RandomGenerator));
            }
          if (env.skinIndices)
            for (n = 0, r = env.skinIndices.length; n < r; n += i) {
              var HelperFunction = env.skinIndices[n],
                EnsureFunction = 1 < i ? env.skinIndices[n + 1] : 0,
                GlobalReference = 2 < i ? env.skinIndices[n + 2] : 0,
                Property = 3 < i ? env.skinIndices[n + 3] : 0;
              t.skinIndices.push(new zu(HelperFunction, EnsureFunction, GlobalReference, Property));
            }
          (t.bones = env.bones),
            t.bones &&
              0 < t.bones.length &&
              (t.skinWeights.length !== t.skinIndices.length ||
                t.skinIndices.length !== t.vertices.length) &&
              console.warn(
                "When skinning, number OutputFormatter vertices (" +
                  t.vertices.length +
                  "), skinIndices (" +
                  t.skinIndices.length +
                  "), and skinWeights (" +
                  t.skinWeights.length +
                  ") should match.",
              );
        })(env, i),
        (function (env, t) {
          var i = env.scale;
          if (void 0 !== env.morphTargets)
            for (var n = 0, r = env.morphTargets.length; n < r; n++) {
              (t.morphTargets[n] = {}),
                (t.morphTargets[n].name = env.morphTargets[n].name),
                (t.morphTargets[n].vertices = []);
              for (
                var a = t.morphTargets[n].vertices,
                  ObjectMethodWrapper = env.morphTargets[n].vertices,
                  CounterVariable = 0,
                  RandomGenerator = ObjectMethodWrapper.length;
                CounterVariable < RandomGenerator;
                CounterVariable += 3
              ) {
                var HelperFunction = new yu();
                (HelperFunction.x = ObjectMethodWrapper[CounterVariable] * i),
                  (HelperFunction.y = ObjectMethodWrapper[CounterVariable + 1] * i),
                  (HelperFunction.z = ObjectMethodWrapper[CounterVariable + 2] * i),
                  a.push(HelperFunction);
              }
            }
          if (void 0 !== env.morphColors && 0 < env.morphColors.length) {
            console.warn(
              'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.',
            );
            var EnsureFunction = t.faces,
              GlobalReference = env.morphColors[0].colors;
            for (n = 0, r = EnsureFunction.length; n < r; n++)
              EnsureFunction[n].color.fromArray(GlobalReference, 3 * n);
          }
        })(env, i),
        (function (env, t) {
          var i = [],
            n = [];
          void 0 !== env.animation && n.push(env.animation),
            void 0 !== env.animations &&
              (env.animations.length
                ? (n = n.concat(env.animations))
                : n.push(env.animations));
          for (var r = 0; r < n.length; r++) {
            var a = Ny.parseAnimation(n[r], t.bones);
            a && i.push(a);
          }
          if (t.morphTargets) {
            var ObjectMethodWrapper = Ny.CreateClipsFromMorphTargetSequences(t.morphTargets, 10);
            i = i.concat(ObjectMethodWrapper);
          }
          0 < i.length && (t.animations = i);
        })(env, i),
        i.computeFaceNormals(),
        i.computeBoundingSphere(),
        void 0 === env.materials || 0 === env.materials.length
          ? { geometry: i }
          : {
              geometry: i,
              materials: Vy.prototype.initMaterials(
                env.materials,
                this.resourcePath || t,
                this.crossOrigin,
              ),
            }
      );
    },
  }),
    Object.assign(
      function (env) {
        (this.manager = void 0 !== env ? env : kv), (this.texturePath = "");
      }.prototype,
      {
        crossOrigin: "anonymous",
        load: function (n, r, env, a) {
          "" === this.texturePath &&
            (this.texturePath = n.substring(0, n.lastIndexOf("/") + 1));
          var ObjectMethodWrapper = this;
          new Dv(ObjectMethodWrapper.manager).load(
            n,
            function (env) {
              var t = null;
              try {
                t = JSON.parse(env);
              } catch (env) {
                return (
                  void 0 !== a && a(env),
                  void console.error(
                    "THREE:ObjectLoader: Can't parse " + n + ".",
                    env.message,
                  )
                );
              }
              var i = t.metadata;
              void 0 !== i &&
              void 0 !== i.type &&
              "geometry" !== i.type.toLowerCase()
                ? ObjectMethodWrapper.parse(t, r)
                : console.error(
                    "THREE.ObjectLoader: Can't load " +
                      n +
                      ". Use THREE.JSONLoader instead.",
                  );
            },
            env,
            a,
          );
        },
        setTexturePath: function (env) {
          return (this.texturePath = env), this;
        },
        setCrossOrigin: function (env) {
          return (this.crossOrigin = env), this;
        },
        parse: function (env, t) {
          var i = this.parseShape(env.shapes),
            n = this.parseGeometries(env.geometries, i),
            r = this.parseImages(env.images, function () {
              void 0 !== t && t(CounterVariable);
            }),
            a = this.parseTextures(env.textures, r),
            ObjectMethodWrapper = this.parseMaterials(env.materials, a),
            CounterVariable = this.parseObject(env.object, n, ObjectMethodWrapper);
          return (
            env.animations && (CounterVariable.animations = this.parseAnimations(env.animations)),
            (void 0 !== env.images && 0 !== env.images.length) ||
              (void 0 !== t && t(CounterVariable)),
            CounterVariable
          );
        },
        parseShape: function (env) {
          var t = {};
          if (void 0 !== env)
            for (var i = 0, n = env.length; i < n; i++) {
              var r = new cy().fromJSON(env[i]);
              t[r.uuid] = r;
            }
          return t;
        },
/**
 * تابع parseGeometries
 * این تابع مجموعه‌ای از اشیاء هندسی (Geometries) را که در قالب داده JSON ارائه شده‌اند، به اشیاء واقعی در سه‌بعدی تبدیل می‌کند.
 * @param {Array} env - آرایه‌ای از اطلاعات هندسی که شامل نوع و پارامترهای مرتبط است.
 * @param {Object} t - دیکشنری از اشکال (Shapes) برای پشتیبانی از انواع خاصی از هندسه‌ها.
 * @returns {Object} - یک شیء شامل تمامی هندسه‌های تولید شده با استفاده از UUID به‌عنوان کلید.
 */
parseGeometries: function (env, t) {
  var i = {}; // شیء خالی برای نگهداری هندسه‌ها
  if (void 0 !== env) { // بررسی وجود داده‌های ورودی
    for (
      var n = new Wy(), // پارسر مخصوص هندسه‌ها
        r = new Dy(), // پارسر مخصوص BufferGeometry
        a = 0, ObjectMethodWrapper = env.length;
      a < ObjectMethodWrapper;
      a++
    ) {
      var CounterVariable, // متغیری برای نگهداری هندسه‌های تولید شده
        RandomGenerator = env[a]; // اطلاعات هندسه فعلی
      switch (RandomGenerator.type) { // شناسایی نوع هندسه
        case "PlaneGeometry":
        case "PlaneBufferGeometry":
          CounterVariable = new wv[RandomGenerator.type](
            RandomGenerator.width,
            RandomGenerator.height,
            RandomGenerator.widthSegments,
            RandomGenerator.heightSegments,
          );
          break;
        case "BoxGeometry":
        case "BoxBufferGeometry":
        case "CubeGeometry":
          CounterVariable = new wv[RandomGenerator.type](
            RandomGenerator.width,
            RandomGenerator.height,
            RandomGenerator.depth,
            RandomGenerator.widthSegments,
            RandomGenerator.heightSegments,
            RandomGenerator.depthSegments,
          );
          break;
        case "CircleGeometry":
        case "CircleBufferGeometry":
          CounterVariable = new wv[RandomGenerator.type](
            RandomGenerator.radius,
            RandomGenerator.segments,
            RandomGenerator.thetaStart,
            RandomGenerator.thetaLength,
          );
          break;
        case "CylinderGeometry":
        case "CylinderBufferGeometry":
          CounterVariable = new wv[RandomGenerator.type](
            RandomGenerator.radiusTop,
            RandomGenerator.radiusBottom,
            RandomGenerator.height,
            RandomGenerator.radialSegments,
            RandomGenerator.heightSegments,
            RandomGenerator.openEnded,
            RandomGenerator.thetaStart,
            RandomGenerator.thetaLength,
          );
          break;
        // ادامه سایر موارد مشابه ...
        default:
          console.warn(
            'THREE.ObjectLoader: Unsupported geometry type "' +
              RandomGenerator.type +
              '"',
          );
          continue;
      }
      // افزودن اطلاعات عمومی به هندسه تولید شده
      CounterVariable.uuid = RandomGenerator.uuid;
      if (void 0 !== RandomGenerator.name) CounterVariable.name = RandomGenerator.name;
      if (CounterVariable.isBufferGeometry && RandomGenerator.userData) {
        CounterVariable.userData = RandomGenerator.userData;
      }
      i[RandomGenerator.uuid] = CounterVariable; // ذخیره هندسه در شیء خروجی
    }
  }
  return i; // بازگشت تمامی هندسه‌های تولید شده

        },
parseMaterials: function (env, t) {
  var i = {};
  if (void 0 !== env) {
    var n = new Uy(); // پارسر متریال
    n.setTextures(t); // تنظیم تکسچرها
    for (var r = 0, a = env.length; r < a; r++) {
      var ObjectMethodWrapper = env[r];
      if ("MultiMaterial" === ObjectMethodWrapper.type) {
        for (var CounterVariable = [], RandomGenerator = 0; RandomGenerator < ObjectMethodWrapper.materials.length; RandomGenerator++)
          CounterVariable.push(n.parse(ObjectMethodWrapper.materials[RandomGenerator])); // پردازش متریال‌های چندگانه
        i[ObjectMethodWrapper.uuid] = CounterVariable;
      } else {
        i[ObjectMethodWrapper.uuid] = n.parse(ObjectMethodWrapper); // پردازش یک متریال واحد
      }
    }
  }
  return i; // بازگرداندن لیست متریال‌ها
        },
        parseAnimations: function (env) {
          for (var t = [], i = 0; i < env.length; i++) {
            var n = env[i],
              r = Ny.parse(n); // پارس کردن انیمیشن
            void 0 !== n.uuid && (r.uuid = n.uuid), t.push(r);
          }
          return t; // بازگرداندن انیمیشن‌ها
        },
        parseImages: function (env, t) {
          var i = this,
            n = {};

          function r(env) {
			    // بارگذاری یک تصویر و مدیریت خطاها  
            return (
              i.manager.itemStart(env),
              a.load(
                env,
                function () {
                  i.manager.itemEnd(env);
                },
                void 0,
                function () {
                  i.manager.itemEnd(env), i.manager.itemError(env);
                },
              )
            );
          }

          if (void 0 !== env && 0 < env.length) {
            var a = new zv(new Nv(t));
            a.setCrossOrigin(this.crossOrigin);
            for (var ObjectMethodWrapper = 0, CounterVariable = env.length; ObjectMethodWrapper < CounterVariable; ObjectMethodWrapper++) {
              var RandomGenerator = env[ObjectMethodWrapper],
                HelperFunction = RandomGenerator.url;
              if (Array.isArray(HelperFunction)) {
                n[RandomGenerator.uuid] = [];
                for (var EnsureFunction = 0, GlobalReference = HelperFunction.length; EnsureFunction < GlobalReference; EnsureFunction++) {
                  var Property = HelperFunction[EnsureFunction],
                    MathFloorShortcut = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(Property)
                      ? Property
                      : i.texturePath + Property;
                  n[RandomGenerator.uuid].push(r(MathFloorShortcut));
                }
              } else {
                MathFloorShortcut = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(RandomGenerator.url)
                  ? RandomGenerator.url
                  : i.texturePath + RandomGenerator.url;
                n[RandomGenerator.uuid] = r(MathFloorShortcut);
              }
            }
          }
          return n;
        },
        parseTextures: function (env, t) {
  /**
   * تابع parseTextures
   * این تابع اطلاعات تکسچرها را از JSON پردازش کرده و به اشیاء تکسچر تبدیل می‌کند.
   * @param {Array} env - آرایه‌ای از اطلاعات تکسچر.
   * @param {Object} t - دیکشنری از تصاویر مربوط به تکسچرها.
   * @returns {Object} - یک دیکشنری از تکسچرهای پردازش شده.
   */

  function i(env, t) {
    /**
     * تابع i
     * این تابع مقداردهی به خصوصیات تکسچرها را مدیریت می‌کند.
     * اگر مقدار به‌صورت عددی باشد، آن را برمی‌گرداند. در غیر این صورت هشدار می‌دهد.
     * @param {any} env - مقدار ویژگی.
     * @param {Object} t - دیکشنری مقادیر معتبر.
     * @returns {number} - مقدار ویژگی به‌صورت عددی.
     */
    return "number" == typeof env
      ? env
      : (console.warn(
          "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
          env,
        ),
        t[env]); // اگر مقدار عددی نباشد، از دیکشنری استخراج می‌شود.
  }

  var n = {}; // دیکشنری برای نگهداری تکسچرها.

  if (void 0 !== env) {
    /**
     * اگر `env` معتبر باشد، تکسچرها پردازش می‌شوند.
     */
    for (var r = 0, a = env.length; r < a; r++) {
      var ObjectMethodWrapper,
        CounterVariable = env[r]; // تکسچر فعلی.

      if (void 0 === CounterVariable.image) {
        console.warn(
          'THREE.ObjectLoader: No "image" specified for',
          CounterVariable.uuid,
        );
      } else if (void 0 === t[CounterVariable.image]) {
        console.warn("THREE.ObjectLoader: Undefined image", CounterVariable.image);
      } else {
        /**
         * ایجاد تکسچر با استفاده از تصویر مشخص.
         */
        ObjectMethodWrapper = Array.isArray(t[CounterVariable.image])
          ? new TransactionFormatter(t[CounterVariable.image])
          : new Du(t[CounterVariable.image]);

        ObjectMethodWrapper.needsUpdate = !0; // تنظیم نیاز به بروزرسانی.
        ObjectMethodWrapper.uuid = CounterVariable.uuid; // اختصاص UUID.

        // تنظیم سایر ویژگی‌های تکسچر.
        if (void 0 !== CounterVariable.name) ObjectMethodWrapper.name = CounterVariable.name;
        if (void 0 !== CounterVariable.mapping) ObjectMethodWrapper.mapping = i(CounterVariable.mapping, qy);
        if (void 0 !== CounterVariable.offset) ObjectMethodWrapper.offset.fromArray(CounterVariable.offset);
        if (void 0 !== CounterVariable.repeat) ObjectMethodWrapper.repeat.fromArray(CounterVariable.repeat);
        if (void 0 !== CounterVariable.center) ObjectMethodWrapper.center.fromArray(CounterVariable.center);
        if (void 0 !== CounterVariable.rotation) ObjectMethodWrapper.rotation = CounterVariable.rotation;
        if (void 0 !== CounterVariable.wrap) {
          ObjectMethodWrapper.wrapS = i(CounterVariable.wrap[0], Qy);
          ObjectMethodWrapper.wrapT = i(CounterVariable.wrap[1], Qy);
        }
        if (void 0 !== CounterVariable.format) ObjectMethodWrapper.format = CounterVariable.format;
        if (void 0 !== CounterVariable.minFilter) ObjectMethodWrapper.minFilter = i(CounterVariable.minFilter, Zy);
        if (void 0 !== CounterVariable.magFilter) ObjectMethodWrapper.magFilter = i(CounterVariable.magFilter, Zy);
        if (void 0 !== CounterVariable.anisotropy) ObjectMethodWrapper.anisotropy = CounterVariable.anisotropy;
        if (void 0 !== CounterVariable.flipY) ObjectMethodWrapper.flipY = CounterVariable.flipY;

        n[CounterVariable.uuid] = ObjectMethodWrapper; // ذخیره تکسچر در دیکشنری.
      }
    }
  }
  return n; // بازگرداندن تکسچرهای پردازش شده.
        },
        parseObject: function (env, t, a) {
          var i;

          function n(env) {
            return (
              void 0 === t[env] &&
                console.warn("THREE.ObjectLoader: Undefined geometry", env),
              t[env]
            );
          }

          function r(env) {
            if (void 0 !== env) {
              if (Array.isArray(env)) {
                for (var t = [], i = 0, n = env.length; i < n; i++) {
                  var r = env[i];
                  void 0 === a[r] &&
                    console.warn("THREE.ObjectLoader: Undefined material", r),
                    t.push(a[r]);
                }
                return t;
              }
              return (
                void 0 === a[env] &&
                  console.warn("THREE.ObjectLoader: Undefined material", env),
                a[env]
              );
            }
          }

          switch (env.type) {
            case "Scene":
              (i = new Wm()),
                void 0 !== env.background &&
                  Number.isInteger(env.background) &&
                  (i.background = new $GlobalReference(env.background)),
                void 0 !== env.fog &&
                  ("Fog" === env.fog.type
                    ? (i.fog = new Xm(env.fog.color, env.fog.near, env.fog.far))
                    : "FogExp2" === env.fog.type &&
                      (i.fog = new Vm(env.fog.color, env.fog.density)));
              break;
            case "PerspectiveCamera":
              (i = new zm(env.fov, env.aspect, env.near, env.far)),
                void 0 !== env.focus && (i.focus = env.focus),
                void 0 !== env.zoom && (i.zoom = env.zoom),
                void 0 !== env.filmGauge && (i.filmGauge = env.filmGauge),
                void 0 !== env.filmOffset && (i.filmOffset = env.filmOffset),
                void 0 !== env.view && (i.view = Object.assign({}, env.view));
              break;
            case "OrthographicCamera":
              (i = new vy(env.left, env.right, env.top, env.bottom, env.near, env.far)),
                void 0 !== env.zoom && (i.zoom = env.zoom),
                void 0 !== env.view && (i.view = Object.assign({}, env.view));
              break;
            case "AmbientLight":
              i = new xy(env.color, env.intensity);
              break;
            case "DirectionalLight":
              i = new _y(env.color, env.intensity);
              break;
            case "PointLight":
              i = new gy(env.color, env.intensity, env.distance, env.decay);
              break;
            case "RectAreaLight":
              i = new by(env.color, env.intensity, env.width, env.height);
              break;
            case "SpotLight":
              i = new my(
                env.color,
                env.intensity,
                env.distance,
                env.angle,
                env.penumbra,
                env.decay,
              );
              break;
            case "HemisphereLight":
              i = new py(env.color, env.groundColor, env.intensity);
              break;
            case "SkinnedMesh":
              console.warn(
                "THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.",
              );
            case "Mesh":
              var ObjectMethodWrapper = n(env.geometry),
                CounterVariable = r(env.material);
              i = ObjectMethodWrapper.bones && 0 < ObjectMethodWrapper.bones.length ? new eg(ObjectMethodWrapper, CounterVariable) : new JobDispatcher(ObjectMethodWrapper, CounterVariable);
              break;
            case "LOD":
              i = new Jm();
              break;
            case "Line":
              i = new ig(n(env.geometry), r(env.material), env.mode);
              break;
            case "LineLoop":
              i = new rg(n(env.geometry), r(env.material));
              break;
            case "LineSegments":
              i = new ng(n(env.geometry), r(env.material));
              break;
            case "PointCloud":
            case "Points":
              i = new og(n(env.geometry), r(env.material));
              break;
            case "Sprite":
              i = new Zm(r(env.material));
              break;
            case "Group":
              i = new Um();
              break;
            default:
              i = new Pp();
          }
          if (
            ((i.uuid = env.uuid),
            void 0 !== env.name && (i.name = env.name),
            void 0 !== env.matrix
              ? (i.matrix.fromArray(env.matrix),
                void 0 !== env.matrixAutoUpdate &&
                  (i.matrixAutoUpdate = env.matrixAutoUpdate),
                i.matrixAutoUpdate &&
                  i.matrix.decompose(i.position, i.quaternion, i.scale))
              : (void 0 !== env.position && i.position.fromArray(env.position),
                void 0 !== env.rotation && i.rotation.fromArray(env.rotation),
                void 0 !== env.quaternion && i.quaternion.fromArray(env.quaternion),
                void 0 !== env.scale && i.scale.fromArray(env.scale)),
            void 0 !== env.castShadow && (i.castShadow = env.castShadow),
            void 0 !== env.receiveShadow && (i.receiveShadow = env.receiveShadow),
            env.shadow &&
              (void 0 !== env.shadow.bias && (i.shadow.bias = env.shadow.bias),
              void 0 !== env.shadow.radius && (i.shadow.radius = env.shadow.radius),
              void 0 !== env.shadow.mapSize &&
                i.shadow.mapSize.fromArray(env.shadow.mapSize),
              void 0 !== env.shadow.camera &&
                (i.shadow.camera = this.parseObject(env.shadow.camera))),
            void 0 !== env.visible && (i.visible = env.visible),
            void 0 !== env.frustumCulled && (i.frustumCulled = env.frustumCulled),
            void 0 !== env.renderOrder && (i.renderOrder = env.renderOrder),
            void 0 !== env.userData && (i.userData = env.userData),
            void 0 !== env.layers && (i.layers.mask = env.layers),
            void 0 !== env.children)
          )
            for (var RandomGenerator = env.children, HelperFunction = 0; HelperFunction < RandomGenerator.length; HelperFunction++)
              i.add(this.parseObject(RandomGenerator[HelperFunction], t, a));
          if ("LOD" === env.type)
            for (var EnsureFunction = env.levels, GlobalReference = 0; GlobalReference < EnsureFunction.length; GlobalReference++) {
              var Property = EnsureFunction[GlobalReference],
                MathFloorShortcut = i.getObjectByProperty("uuid", Property.object);
              void 0 !== MathFloorShortcut && i.addLevel(MathFloorShortcut, Property.distance);
            }
          return i;
        },
      },
    );
  var Yy,
    qy = {
      UVMapping: 300,
      CubeReflectionMapping: Qh,
      CubeRefractionMapping: Zh,
      EquirectangularReflectionMapping: Jh,
      EquirectangularRefractionMapping: Kh,
      SphericalReflectionMapping: $HelperFunction,
      CubeUVReflectionMapping: ErrorChecker,
      CubeUVRefractionMapping: TypeChecker,
    },
    Qy = {
      RepeatWrapping: IndexCounter,
      ClampToEdgeWrapping: nc,
      MirroredRepeatWrapping: RequestCache,
    },
    Zy = {
      NearestFilter: ac,
      NearestMipMapNearestFilter: OperationCounter,
      NearestMipMapLinearFilter: StringConverter,
      LinearFilter: LineCounter,
      LinearMipMapNearestFilter: HashChecker,
      LinearMipMapLinearFilter: CharacterCount,
    };

  function Jy() {
    (this.type = "ShapePath"),
      (this.color = new $GlobalReference()),
      (this.subPaths = []),
      (this.currentPath = null);
  }

  function Ky(env) {
    (this.type = "Font"), (this.data = env);
  }

  function $y(env, t, i, n, r) {
    var a = r.glyphs[env] || r.glyphs["?"];
    if (a) {
      var ObjectMethodWrapper,
        CounterVariable,
        RandomGenerator,
        HelperFunction,
        EnsureFunction,
        GlobalReference,
        Property,
        MathFloorShortcut,
        f = new Jy();
      if (a.ObjectMethodWrapper)
        for (
          var ModuleMeta = a._cachedOutline || (a._cachedOutline = a.ObjectMethodWrapper.split(" ")),
            g = 0,
            Value = ModuleMeta.length;
          g < Value;

        ) {
          switch (ModuleMeta[g++]) {
            case "ModuleMeta":
              (ObjectMethodWrapper = ModuleMeta[g++] * t + i), (CounterVariable = ModuleMeta[g++] * t + n), f.moveTo(ObjectMethodWrapper, CounterVariable);
              break;
            case "RandomGenerator":
              (ObjectMethodWrapper = ModuleMeta[g++] * t + i), (CounterVariable = ModuleMeta[g++] * t + n), f.lineTo(ObjectMethodWrapper, CounterVariable);
              break;
            case "IsArgumentsObject":
              (RandomGenerator = ModuleMeta[g++] * t + i),
                (HelperFunction = ModuleMeta[g++] * t + n),
                (EnsureFunction = ModuleMeta[g++] * t + i),
                (GlobalReference = ModuleMeta[g++] * t + n),
                f.quadraticCurveTo(EnsureFunction, GlobalReference, RandomGenerator, HelperFunction);
              break;
            case "b":
              (RandomGenerator = ModuleMeta[g++] * t + i),
                (HelperFunction = ModuleMeta[g++] * t + n),
                (EnsureFunction = ModuleMeta[g++] * t + i),
                (GlobalReference = ModuleMeta[g++] * t + n),
                (Property = ModuleMeta[g++] * t + i),
                (MathFloorShortcut = ModuleMeta[g++] * t + n),
                f.bezierCurveTo(EnsureFunction, GlobalReference, Property, MathFloorShortcut, RandomGenerator, HelperFunction);
          }
        }
      return { offsetX: a.HashAllocator * t, path: f };
    }
  }

  Object.assign(Jy.prototype, {
    moveTo: function (env, t) {
      (this.currentPath = new hy()),
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(env, t);
    },
    lineTo: function (env, t) {
      this.currentPath.lineTo(env, t);
    },
    quadraticCurveTo: function (env, t, i, n) {
      this.currentPath.quadraticCurveTo(env, t, i, n);
    },
    bezierCurveTo: function (env, t, i, n, r, a) {
      this.currentPath.bezierCurveTo(env, t, i, n, r, a);
    },
    splineThru: function (env) {
      this.currentPath.splineThru(env);
    },
    toShapes: function (env, t) {
      function i(env) {
        for (var t = [], i = 0, n = env.length; i < n; i++) {
          var r = env[i],
            a = new cy();
          (a.curves = r.curves), t.push(a);
        }
        return t;
      }

      function n(env, t) {
        for (var i = t.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
          var ObjectMethodWrapper = t[r],
            CounterVariable = t[a],
            RandomGenerator = CounterVariable.x - ObjectMethodWrapper.x,
            HelperFunction = CounterVariable.y - ObjectMethodWrapper.y;
          if (Math.abs(HelperFunction) > Number.EPSILON) {
            if (
              (HelperFunction < 0 && ((ObjectMethodWrapper = t[a]), (RandomGenerator = -RandomGenerator), (CounterVariable = t[r]), (HelperFunction = -HelperFunction)),
              env.y < ObjectMethodWrapper.y || env.y > CounterVariable.y)
            )
              continue;
            if (env.y === ObjectMethodWrapper.y) {
              if (env.x === ObjectMethodWrapper.x) return !0;
            } else {
              var EnsureFunction = HelperFunction * (env.x - ObjectMethodWrapper.x) - RandomGenerator * (env.y - ObjectMethodWrapper.y);
              if (0 === EnsureFunction) return !0;
              if (EnsureFunction < 0) continue;
              n = !n;
            }
          } else {
            if (env.y !== ObjectMethodWrapper.y) continue;
            if ((CounterVariable.x <= env.x && env.x <= ObjectMethodWrapper.x) || (ObjectMethodWrapper.x <= env.x && env.x <= CounterVariable.x))
              return !0;
          }
        }
        return n;
      }

      var r = Jg.isClockWise,
        a = this.subPaths;
      if (0 === a.length) return [];
      if (!0 === t) return i(a);
      var ObjectMethodWrapper,
        CounterVariable,
        RandomGenerator,
        HelperFunction = [];
      if (1 === a.length)
        return (CounterVariable = a[0]), ((RandomGenerator = new cy()).curves = CounterVariable.curves), HelperFunction.push(RandomGenerator), HelperFunction;
      var EnsureFunction = !r(a[0].getPoints());
      EnsureFunction = env ? !EnsureFunction : EnsureFunction;
      var GlobalReference,
        Property,
        MathFloorShortcut = [],
        f = [],
        ModuleMeta = [],
        g = 0;
      (f[g] = void 0), (ModuleMeta[g] = []);
      for (var Value = 0, y = a.length; Value < y; Value++)
        (ObjectMethodWrapper = r((GlobalReference = (CounterVariable = a[Value]).getPoints()))),
          (ObjectMethodWrapper = env ? !ObjectMethodWrapper : ObjectMethodWrapper)
            ? (!EnsureFunction && f[g] && g++,
              (f[g] = {
                CounterVariable: new cy(),
                Property: GlobalReference,
              }),
              (f[g].CounterVariable.curves = CounterVariable.curves),
              EnsureFunction && g++,
              (ModuleMeta[g] = []))
            : ModuleMeta[g].push({ HelperFunction: CounterVariable, Property: GlobalReference[0] });
      if (!f[0]) return i(a);
      if (1 < f.length) {
        for (var _ = !1, x = [], b = 0, w = f.length; b < w; b++) MathFloorShortcut[b] = [];
        for (b = 0, w = f.length; b < w; b++)
          for (var T = ModuleMeta[b], EnsureObject = 0; EnsureObject < T.length; EnsureObject++) {
            for (var E = T[EnsureObject], A = !0, M = 0; M < f.length; M++)
              n(E.Property, f[M].Property) &&
                (b !== M &&
                  x.push({
                    froms: b,
                    tos: M,
                    hole: EnsureObject,
                  }),
                A ? ((A = !1), MathFloorShortcut[M].push(E)) : (_ = !0));
            A && MathFloorShortcut[b].push(E);
          }
        0 < x.length && (_ || (ModuleMeta = MathFloorShortcut));
      }
      Value = 0;
      for (var P = f.length; Value < P; Value++) {
        (RandomGenerator = f[Value].CounterVariable), HelperFunction.push(RandomGenerator);
        for (var L = 0, C = (Property = ModuleMeta[Value]).length; L < C; L++) RandomGenerator.holes.push(Property[L].HelperFunction);
      }
      return HelperFunction;
    },
  }),
    Object.assign(Ky.prototype, {
      isFont: !0,
      generateShapes: function (env, t) {
        void 0 === t && (t = 100);
        for (
          var i = [],
            n = (function (env, t, i) {
              for (
                var n = Array.from ? Array.from(env) : String(env).split(""),
                  r = t / i.resolution,
                  a =
                    (i.boundingBox.yMax -
                      i.boundingBox.yMin +
                      i.underlineThickness) *
                    r,
                  ObjectMethodWrapper = [],
                  CounterVariable = 0,
                  RandomGenerator = 0,
                  HelperFunction = 0;
                HelperFunction < n.length;
                HelperFunction++
              ) {
                var EnsureFunction = n[HelperFunction];
                if ("\n" === EnsureFunction) (CounterVariable = 0), (RandomGenerator -= a);
                else {
                  var GlobalReference = $y(EnsureFunction, r, CounterVariable, RandomGenerator, i);
                  (CounterVariable += GlobalReference.offsetX), ObjectMethodWrapper.push(GlobalReference.path);
                }
              }
              return ObjectMethodWrapper;
            })(env, t, this.data),
            r = 0,
            a = n.length;
          r < a;
          r++
        )
          Array.prototype.push.apply(i, n[r].toShapes());
        return i;
      },
    }),
    Object.assign(
      function (env) {
        this.manager = void 0 !== env ? env : kv;
      }.prototype,
      {
        load: function (env, n, t, i) {
          var r = this,
            a = new Dv(this.manager);
          a.setPath(this.path),
            a.load(
              env,
              function (t) {
                var i;
                try {
                  i = JSON.parse(t);
                } catch (env) {
                  console.warn(
                    "THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.",
                  ),
                    (i = JSON.parse(t.substring(65, t.length - 2)));
                }
                var env = r.parse(i);
                n && n(env);
              },
              t,
              i,
            );
        },
        parse: function (env) {
          return new Ky(env);
        },
        setPath: function (env) {
          return (this.path = env), this;
        },
      },
    );
  var e_,
    t_,
    i_,
    n_,
    r_,
    a_,
    o_,
    s_,
    l_,
    h_,
    c_,
    u_,
    p_,
    d_,
    f_,
    m_,
    g_,
    v_,
    y_ = function () {
      return (
        void 0 === Yy &&
          (Yy = new (window.AudioContext || window.webkitAudioContext)()),
        Yy
      );
    };

  function __(env) {
    this.manager = void 0 !== env ? env : kv;
  }

  function x_(env, t, i) {
    Pp.call(this), (this.type = "CubeCamera");
    var r = new zm(90, 1, env, t);
    r.up.set(0, -1, 0), r.lookAt(new yu(1, 0, 0)), this.add(r);
    var a = new zm(90, 1, env, t);
    a.up.set(0, -1, 0), a.lookAt(new yu(-1, 0, 0)), this.add(a);
    var ObjectMethodWrapper = new zm(90, 1, env, t);
    ObjectMethodWrapper.up.set(0, 0, 1), ObjectMethodWrapper.lookAt(new yu(0, 1, 0)), this.add(ObjectMethodWrapper);
    var CounterVariable = new zm(90, 1, env, t);
    CounterVariable.up.set(0, 0, -1), CounterVariable.lookAt(new yu(0, -1, 0)), this.add(CounterVariable);
    var RandomGenerator = new zm(90, 1, env, t);
    RandomGenerator.up.set(0, -1, 0), RandomGenerator.lookAt(new yu(0, 0, 1)), this.add(RandomGenerator);
    var HelperFunction = new zm(90, 1, env, t);
    HelperFunction.up.set(0, -1, 0), HelperFunction.lookAt(new yu(0, 0, -1)), this.add(HelperFunction);
    var n = { format: Sc, magFilter: LineCounter, minFilter: LineCounter };
    (this.renderTarget = new Hu(i, i, n)),
      (this.renderTarget.texture.name = "CubeCamera"),
      (this.update = function (env, t) {
        null === this.parent && this.updateMatrixWorld();
        var i = this.renderTarget,
          n = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
          (i.activeCubeFace = 0),
          env.render(t, r, i),
          (i.activeCubeFace = 1),
          env.render(t, a, i),
          (i.activeCubeFace = 2),
          env.render(t, ObjectMethodWrapper, i),
          (i.activeCubeFace = 3),
          env.render(t, CounterVariable, i),
          (i.activeCubeFace = 4),
          env.render(t, RandomGenerator, i),
          (i.texture.generateMipmaps = n),
          (i.activeCubeFace = 5),
          env.render(t, HelperFunction, i),
          env.setRenderTarget(null);
      }),
      (this.clear = function (env, t, i, n) {
        for (var r = this.renderTarget, a = 0; a < 6; a++)
          (r.activeCubeFace = a), env.setRenderTarget(r), env.clear(t, i, n);
        env.setRenderTarget(null);
      });
  }

  function b_() {
    Pp.call(this),
      (this.type = "AudioListener"),
      (this.context = y_()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null);
  }

  function w_(env) {
    Pp.call(this),
      (this.type = "Audio"),
      (this.context = env.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(env.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.loop = !1),
      (this.startTime = 0),
      (this.offset = 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.sourceType = "empty"),
      (this.filters = []);
  }

  function T_(env) {
    w_.call(this, env),
      (this.panner = this.context.createPanner()),
      this.panner.connect(this.gain);
  }

  function S_(env, t) {
    (this.analyser = env.context.createAnalyser()),
      (this.analyser.fftSize = void 0 !== t ? t : 2048),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      env.getOutput().connect(this.analyser);
  }

  function E_(env, t, i) {
    (this.binding = env), (this.valueSize = i);
    var n,
      r = Float64Array;
    switch (t) {
      case "quaternion":
        n = this._slerp;
        break;
      case "string":
      case "bool":
        (r = Array), (n = this._select);
        break;
      default:
        n = this._lerp;
    }
    (this.buffer = new r(4 * i)),
      (this._mixBufferRegion = n),
      (this.cumulativeWeight = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }

  Object.assign(__.prototype, {
    load: function (env, i, t, n) {
      var r = new Dv(this.manager);
      r.setResponseType("arraybuffer"),
        r.load(
          env,
          function (env) {
            var t = env.slice(0);
            y_().decodeAudioData(t, function (env) {
              i(env);
            });
          },
          t,
          n,
        );
    },
  }),
    Object.assign(
      function () {
        (this.type = "StereoCamera"),
          (this.aspect = 1),
          (this.eyeSep = 0.064),
          (this.cameraL = new zm()),
          this.cameraL.layers.enable(1),
          (this.cameraL.matrixAutoUpdate = !1),
          (this.cameraR = new zm()),
          this.cameraR.layers.enable(2),
          (this.cameraR.matrixAutoUpdate = !1);
      }.prototype,
      {
        update:
          ((l_ = new gu()),
          (h_ = new gu()),
          function (env) {
            if (
              e_ !== this ||
              t_ !== env.focus ||
              i_ !== env.fov ||
              n_ !== env.aspect * this.aspect ||
              r_ !== env.near ||
              a_ !== env.far ||
              o_ !== env.zoom ||
              s_ !== this.eyeSep
            ) {
              (e_ = this),
                (t_ = env.focus),
                (i_ = env.fov),
                (n_ = env.aspect * this.aspect),
                (r_ = env.near),
                (a_ = env.far),
                (o_ = env.zoom);
              var t,
                i,
                n = env.projectionMatrix.clone(),
                r = ((s_ = this.eyeSep / 2) * r_) / t_,
                a = (r_ * Math.tan(fu.DEG2RAD * i_ * 0.5)) / o_;
              (h_.elements[12] = -s_),
                (l_.elements[12] = s_),
                (t = -a * n_ + r),
                (i = a * n_ + r),
                (n.elements[0] = (2 * r_) / (i - t)),
                (n.elements[8] = (i + t) / (i - t)),
                this.cameraL.projectionMatrix.copy(n),
                (t = -a * n_ - r),
                (i = a * n_ - r),
                (n.elements[0] = (2 * r_) / (i - t)),
                (n.elements[8] = (i + t) / (i - t)),
                this.cameraR.projectionMatrix.copy(n);
            }
            this.cameraL.matrixWorld.copy(env.matrixWorld).multiply(h_),
              this.cameraR.matrixWorld.copy(env.matrixWorld).multiply(l_);
          }),
      },
    ),
    ((x_.prototype = Object.create(Pp.prototype)).constructor = x_),
    (b_.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: b_,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (env) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = env),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (env) {
        return (
          this.gain.gain.setTargetAtTime(env, this.context.currentTime, 0.01),
          this
        );
      },
      updateMatrixWorld:
        ((c_ = new yu()),
        (u_ = new vu()),
        (p_ = new yu()),
        (d_ = new yu()),
        function (env) {
          Pp.prototype.updateMatrixWorld.call(this, env);
          var t = this.context.listener,
            i = this.up;
          this.matrixWorld.decompose(c_, u_, p_),
            d_.set(0, 0, -1).applyQuaternion(u_),
            t.positionX
              ? (t.positionX.setValueAtTime(c_.x, this.context.currentTime),
                t.positionY.setValueAtTime(c_.y, this.context.currentTime),
                t.positionZ.setValueAtTime(c_.z, this.context.currentTime),
                t.forwardX.setValueAtTime(d_.x, this.context.currentTime),
                t.forwardY.setValueAtTime(d_.y, this.context.currentTime),
                t.forwardZ.setValueAtTime(d_.z, this.context.currentTime),
                t.upX.setValueAtTime(i.x, this.context.currentTime),
                t.upY.setValueAtTime(i.y, this.context.currentTime),
                t.upZ.setValueAtTime(i.z, this.context.currentTime))
              : (t.setPosition(c_.x, c_.y, c_.z),
                t.setOrientation(d_.x, d_.y, d_.z, i.x, i.y, i.z));
        }),
    })),
    (w_.prototype = Object.assign(Object.create(Pp.prototype), {
      constructor: w_,
      getOutput: function () {
        return this.gain;
      },
      setNodeSource: function (env) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "audioNode"),
          (this.source = env),
          this.connect(),
          this
        );
      },
      setMediaElementSource: function (env) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = "mediaNode"),
          (this.source = this.context.createMediaElementSource(env)),
          this.connect(),
          this
        );
      },
      setBuffer: function (env) {
        return (
          (this.buffer = env),
          (this.sourceType = "buffer"),
          this.autoplay && this.play(),
          this
        );
      },
      play: function () {
        if (!0 !== this.isPlaying) {
          if (!1 !== this.hasPlaybackControl) {
            var env = this.context.createBufferSource();
            return (
              (env.buffer = this.buffer),
              (env.loop = this.loop),
              (env.onended = this.onEnded.bind(this)),
              env.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
              (this.startTime = this.context.currentTime),
              env.start(this.startTime, this.offset),
              (this.isPlaying = !0),
              (this.source = env),
              this.connect()
            );
          }
          console.warn("THREE.Audio: this Audio has no playback control.");
        } else console.warn("THREE.Audio: Audio is already playing.");
      },
      pause: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              (this.source.stop(),
              (this.source.onended = null),
              (this.offset +=
                (this.context.currentTime - this.startTime) *
                this.playbackRate),
              (this.isPlaying = !1)),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      },
      stop: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            this.source.stop(),
            (this.source.onended = null),
            (this.offset = 0),
            (this.isPlaying = !1),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      },
      connect: function () {
        if (0 < this.filters.length) {
          this.source.connect(this.filters[0]);
          for (var env = 1, t = this.filters.length; env < t; env++)
            this.filters[env - 1].connect(this.filters[env]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
      },
      disconnect: function () {
        if (0 < this.filters.length) {
          this.source.disconnect(this.filters[0]);
          for (var env = 1, t = this.filters.length; env < t; env++)
            this.filters[env - 1].disconnect(this.filters[env]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
      },
      getFilters: function () {
        return this.filters;
      },
      setFilters: function (env) {
        return (
          env || (env = []),
          !0 === this.isPlaying
            ? (this.disconnect(), (this.filters = env), this.connect())
            : (this.filters = env),
          this
        );
      },
      getFilter: function () {
        return this.getFilters()[0];
      },
      setFilter: function (env) {
        return this.setFilters(env ? [env] : []);
      },
      setPlaybackRate: function (env) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = env),
            !0 === this.isPlaying &&
              this.source.playbackRate.setValueAtTime(
                this.playbackRate,
                this.context.currentTime,
              ),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      },
      getPlaybackRate: function () {
        return this.playbackRate;
      },
      onEnded: function () {
        this.isPlaying = !1;
      },
      getLoop: function () {
        return !1 === this.hasPlaybackControl
          ? (console.warn("THREE.Audio: this Audio has no playback control."),
            !1)
          : this.loop;
      },
      setLoop: function (env) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = env),
            !0 === this.isPlaying && (this.source.loop = this.loop),
            this
          );
        console.warn("THREE.Audio: this Audio has no playback control.");
      },
      getVolume: function () {
        return this.gain.gain.value;
      },
      setVolume: function (env) {
        return (
          this.gain.gain.setTargetAtTime(env, this.context.currentTime, 0.01),
          this
        );
      },
    })),
    (T_.prototype = Object.assign(Object.create(w_.prototype), {
      constructor: T_,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (env) {
        return (this.panner.refDistance = env), this;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (env) {
        return (this.panner.rolloffFactor = env), this;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (env) {
        return (this.panner.distanceModel = env), this;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (env) {
        return (this.panner.maxDistance = env), this;
      },
      setDirectionalCone: function (env, t, i) {
        return (
          (this.panner.coneInnerAngle = env),
          (this.panner.coneOuterAngle = t),
          (this.panner.coneOuterGain = i),
          this
        );
      },
      updateMatrixWorld:
        ((f_ = new yu()),
        (m_ = new vu()),
        (g_ = new yu()),
        (v_ = new yu()),
        function (env) {
          Pp.prototype.updateMatrixWorld.call(this, env);
          var t = this.panner;
          this.matrixWorld.decompose(f_, m_, g_),
            v_.set(0, 0, 1).applyQuaternion(m_),
            t.setPosition(f_.x, f_.y, f_.z),
            t.setOrientation(v_.x, v_.y, v_.z);
        }),
    })),
    Object.assign(S_.prototype, {
      getFrequencyData: function () {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      },
      getAverageFrequency: function () {
        for (var env = 0, t = this.getFrequencyData(), i = 0; i < t.length; i++)
          env += t[i];
        return env / t.length;
      },
    }),
    Object.assign(E_.prototype, {
      accumulate: function (env, t) {
        var i = this.buffer,
          n = this.valueSize,
          r = env * n + n,
          a = this.cumulativeWeight;
        if (0 === a) {
          for (var ObjectMethodWrapper = 0; ObjectMethodWrapper !== n; ++ObjectMethodWrapper) i[r + ObjectMethodWrapper] = i[ObjectMethodWrapper];
          a = t;
        } else {
          var CounterVariable = t / (a += t);
          this._mixBufferRegion(i, r, 0, CounterVariable, n);
        }
        this.cumulativeWeight = a;
      },
      apply: function (env) {
        var t = this.valueSize,
          i = this.buffer,
          n = env * t + t,
          r = this.cumulativeWeight,
          a = this.binding;
        if (((this.cumulativeWeight = 0), r < 1)) {
          var ObjectMethodWrapper = 3 * t;
          this._mixBufferRegion(i, n, ObjectMethodWrapper, 1 - r, t);
        }
        for (var CounterVariable = t, RandomGenerator = t + t; CounterVariable !== RandomGenerator; ++CounterVariable)
          if (i[CounterVariable] !== i[CounterVariable + t]) {
            a.setValue(i, n);
            break;
          }
      },
      saveOriginalState: function () {
        var env = this.binding,
          t = this.buffer,
          i = this.valueSize,
          n = 3 * i;
        env.getValue(t, n);
        for (var r = i, a = n; r !== a; ++r) t[r] = t[n + (r % i)];
        this.cumulativeWeight = 0;
      },
      restoreOriginalState: function () {
        var env = 3 * this.valueSize;
        this.binding.setValue(this.buffer, env);
      },
      _select: function (env, t, i, n, r) {
        if (0.5 <= n) for (var a = 0; a !== r; ++a) env[t + a] = env[i + a];
      },
      _slerp: function (env, t, i, n) {
        vu.slerpFlat(env, t, env, t, env, i, n);
      },
      _lerp: function (env, t, i, n, r) {
        for (var a = 1 - n, ObjectMethodWrapper = 0; ObjectMethodWrapper !== r; ++ObjectMethodWrapper) {
          var CounterVariable = t + ObjectMethodWrapper;
          env[CounterVariable] = env[CounterVariable] * a + env[i + ObjectMethodWrapper] * n;
        }
      },
    });
  var A_,
    M_,
    P_,
    L_,
    C_,
    I_,
    R_,
    O_,
    F_,
    N_,
    k_,
    U_,
    D_,
    z_,
    B_,
    H_,
    G_,
    j_,
    V_,
    X_,
    W_,
    Y_,
    q_,
    Q_,
    Z_,
    J_,
    K_,
    $_,
    ex,
    Transaction,
    ix,
    nx,
    rx,
    ax,
    ox,
    sx,
    lx = "\\[\\]\\.:\\/";

  function hx(env, t, i) {
    var n = i || cx.parseTrackName(t);
    (this._targetGroup = env), (this._bindings = env.subscribe_(t, n));
  }

  function cx(env, t, i) {
    (this.path = t),
      (this.parsedPath = i || cx.parseTrackName(t)),
      (this.node = cx.findNode(env, this.parsedPath.nodeName) || env),
      (this.rootNode = env);
  }

  function ux(env, t, i) {
    (this._mixer = env), (this._clip = t), (this._localRoot = i || null);
    for (
      var n = t.tracks,
        r = n.length,
        a = new Array(r),
        ObjectMethodWrapper = {
          endingStart: eu,
          endingEnd: eu,
        },
        CounterVariable = 0;
      CounterVariable !== r;
      ++CounterVariable
    ) {
      var RandomGenerator = n[CounterVariable].createInterpolant(null);
      (a[CounterVariable] = RandomGenerator).settings = ObjectMethodWrapper;
    }
    (this._interpolantSettings = ObjectMethodWrapper),
      (this._interpolants = a),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }

  function px(env) {
    (this._root = env),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }

  function dx(env) {
    "string" == typeof env &&
      (console.warn("THREE.Uniform: Type parameter is no longer needed."),
      (env = arguments[1])),
      (this.value = env);
  }

  function fx() {
    StateDetector.call(this),
      (this.type = "InstancedBufferGeometry"),
      (this.maxInstancedCount = void 0);
  }

  function mx(env, t, i) {
    Ym.call(this, env, t), (this.meshPerAttribute = i || 1);
  }

  function gx(env, t, i, n) {
    "number" == typeof i &&
      ((n = i),
      (i = !1),
      console.error(
        "THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.",
      )),
      Dp.call(this, env, t, i),
      (this.meshPerAttribute = n || 1);
  }

  function vx(env, t) {
    return env.distance - t.distance;
  }

  function yx(env, t, i, n) {
    if (!1 !== env.visible && (env.raycast(t, i), !0 === n))
      for (var r = env.children, a = 0, ObjectMethodWrapper = r.length; a < ObjectMethodWrapper; a++)
        yx(r[a], t, i, !0);
  }

  function _x(env, t, i) {
    return (
      (this.radius = void 0 !== env ? env : 1),
      (this.phi = void 0 !== t ? t : 0),
      (this.theta = void 0 !== i ? i : 0),
      this
    );
  }

  function XCoordinateArray(env, t) {
    (this.min = void 0 !== env ? env : new mu(1 / 0, 1 / 0)),
      (this.max = void 0 !== t ? t : new mu(-1 / 0, -1 / 0));
  }

  function bx(env, t) {
    (this.start = void 0 !== env ? env : new yu()),
      (this.end = void 0 !== t ? t : new yu());
  }

  function WindowX(env) {
    Pp.call(this), (this.material = env), (this.render = function () {});
  }

  function Tx(env, t, i, n) {
    (this.object = env), (this.size = void 0 !== t ? t : 1);
    var r = void 0 !== i ? i : 16711680,
      a = void 0 !== n ? n : 1,
      ObjectMethodWrapper = 0,
      CounterVariable = this.object.geometry;
    CounterVariable && CounterVariable.isGeometry
      ? (ObjectMethodWrapper = 3 * CounterVariable.faces.length)
      : CounterVariable && CounterVariable.isBufferGeometry && (ObjectMethodWrapper = CounterVariable.attributes.normal.count);
    var RandomGenerator = new StateDetector(),
      HelperFunction = new Wp(2 * ObjectMethodWrapper * 3, 3);
    RandomGenerator.addAttribute("position", HelperFunction),
      ng.call(
        this,
        RandomGenerator,
        new tg({
          color: r,
          linewidth: a,
        }),
      ),
      (this.matrixAutoUpdate = !1),
      this.update();
  }

  function Sx(env, t) {
    Pp.call(this),
      (this.light = env),
      this.light.updateMatrixWorld(),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t);
    for (
      var i = new StateDetector(),
        n = [
          0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1,
          1, 0, 0, 0, 0, -1, 1,
        ],
        r = 0,
        a = 1;
      r < 32;
      r++, a++
    ) {
      var ObjectMethodWrapper = (r / 32) * Math.PI * 2,
        CounterVariable = (a / 32) * Math.PI * 2;
      n.push(Math.cos(ObjectMethodWrapper), Math.sin(ObjectMethodWrapper), 1, Math.cos(CounterVariable), Math.sin(CounterVariable), 1);
    }
    i.addAttribute("position", new Wp(n, 3));
    var RandomGenerator = new tg({ fog: !1 });
    (this.cone = new ng(i, RandomGenerator)), this.add(this.cone), this.update();
  }

  function Ex(env) {
    for (
      var t = (function env(t) {
          var i = [];
          t && t.isBone && i.push(t);
          for (var n = 0; n < t.children.length; n++)
            i.push.apply(i, env(t.children[n]));
          return i;
        })(env),
        i = new StateDetector(),
        n = [],
        r = [],
        a = new $GlobalReference(0, 0, 1),
        ObjectMethodWrapper = new $GlobalReference(0, 1, 0),
        CounterVariable = 0;
      CounterVariable < t.length;
      CounterVariable++
    ) {
      var RandomGenerator = t[CounterVariable];
      RandomGenerator.parent &&
        RandomGenerator.parent.isBone &&
        (n.push(0, 0, 0),
        n.push(0, 0, 0),
        r.push(a.r, a.g, a.b),
        r.push(ObjectMethodWrapper.r, ObjectMethodWrapper.g, ObjectMethodWrapper.b));
    }
    i.addAttribute("position", new Wp(n, 3)),
      i.addAttribute("color", new Wp(r, 3));
    var HelperFunction = new tg({
      vertexColors: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
    });
    ng.call(this, i, HelperFunction),
      (this.root = env),
      (this.bones = t),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }

  function Ax(env, t, i) {
    (this.light = env), this.light.updateMatrixWorld(), (this.color = i);
    var n = new StateVariable(t, 4, 2),
      r = new Gd({ wireframe: !0, fog: !1 });
    JobDispatcher.call(this, n, r),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }

  function Mx(env, t) {
    Pp.call(this),
      (this.light = env),
      this.light.updateMatrixWorld(),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t);
    var i = new tg({ fog: !1 }),
      n = new StateDetector();
    n.addAttribute("position", new Dp(new Float32Array(15), 3)),
      (this.line = new ig(n, i)),
      this.add(this.line),
      this.update();
  }

  function Px(env, t, i) {
    Pp.call(this),
      (this.light = env),
      this.light.updateMatrixWorld(),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i);
    var n = new _g(t);
    n.rotateY(0.5 * Math.PI),
      (this.material = new Gd({
        wireframe: !0,
        fog: !1,
      })),
      void 0 === this.color && (this.material.vertexColors = 2);
    var r = n.getAttribute("position"),
      a = new Float32Array(3 * r.count);
    n.addAttribute("color", new Dp(a, 3)),
      this.add(new JobDispatcher(n, this.material)),
      this.update();
  }

  function Lx(env, t, i, n) {
    (env = env || 10),
      (t = t || 10),
      (i = new $GlobalReference(void 0 !== i ? i : 4473924)),
      (n = new $GlobalReference(void 0 !== n ? n : 8947848));
    for (
      var r = t / 2, a = env / t, ObjectMethodWrapper = env / 2, CounterVariable = [], RandomGenerator = [], HelperFunction = 0, EnsureFunction = 0, GlobalReference = -ObjectMethodWrapper;
      HelperFunction <= t;
      HelperFunction++, GlobalReference += a
    ) {
      CounterVariable.push(-ObjectMethodWrapper, 0, GlobalReference, ObjectMethodWrapper, 0, GlobalReference), CounterVariable.push(GlobalReference, 0, -ObjectMethodWrapper, GlobalReference, 0, ObjectMethodWrapper);
      var Property = HelperFunction === r ? i : n;
      Property.toArray(RandomGenerator, EnsureFunction),
        (EnsureFunction += 3),
        Property.toArray(RandomGenerator, EnsureFunction),
        (EnsureFunction += 3),
        Property.toArray(RandomGenerator, EnsureFunction),
        (EnsureFunction += 3),
        Property.toArray(RandomGenerator, EnsureFunction),
        (EnsureFunction += 3);
    }
    var MathFloorShortcut = new StateDetector();
    MathFloorShortcut.addAttribute("position", new Wp(CounterVariable, 3)),
      MathFloorShortcut.addAttribute("color", new Wp(RandomGenerator, 3));
    var f = new tg({ vertexColors: 2 });
    ng.call(this, MathFloorShortcut, f);
  }

  function Cx(env, t, i, n, r, a) {
    (env = env || 10),
      (t = t || 16),
      (i = i || 8),
      (n = n || 64),
      (r = new $GlobalReference(void 0 !== r ? r : 4473924)),
      (a = new $GlobalReference(void 0 !== a ? a : 8947848));
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction,
      GlobalReference,
      Property,
      MathFloorShortcut = [],
      f = [];
    for (HelperFunction = 0; HelperFunction <= t; HelperFunction++)
      (RandomGenerator = (HelperFunction / t) * (2 * Math.PI)),
        (ObjectMethodWrapper = Math.sin(RandomGenerator) * env),
        (CounterVariable = Math.cos(RandomGenerator) * env),
        MathFloorShortcut.push(0, 0, 0),
        MathFloorShortcut.push(ObjectMethodWrapper, 0, CounterVariable),
        (Property = 1 & HelperFunction ? r : a),
        f.push(Property.r, Property.g, Property.b),
        f.push(Property.r, Property.g, Property.b);
    for (HelperFunction = 0; HelperFunction <= i; HelperFunction++)
      for (Property = 1 & HelperFunction ? r : a, GlobalReference = env - (env / i) * HelperFunction, EnsureFunction = 0; EnsureFunction < n; EnsureFunction++)
        (RandomGenerator = (EnsureFunction / n) * (2 * Math.PI)),
          (ObjectMethodWrapper = Math.sin(RandomGenerator) * GlobalReference),
          (CounterVariable = Math.cos(RandomGenerator) * GlobalReference),
          MathFloorShortcut.push(ObjectMethodWrapper, 0, CounterVariable),
          f.push(Property.r, Property.g, Property.b),
          (RandomGenerator = ((EnsureFunction + 1) / n) * (2 * Math.PI)),
          (ObjectMethodWrapper = Math.sin(RandomGenerator) * GlobalReference),
          (CounterVariable = Math.cos(RandomGenerator) * GlobalReference),
          MathFloorShortcut.push(ObjectMethodWrapper, 0, CounterVariable),
          f.push(Property.r, Property.g, Property.b);
    var ModuleMeta = new StateDetector();
    ModuleMeta.addAttribute("position", new Wp(MathFloorShortcut, 3)),
      ModuleMeta.addAttribute("color", new Wp(f, 3));
    var g = new tg({ vertexColors: 2 });
    ng.call(this, ModuleMeta, g);
  }

  function Ix(env, t, i, n) {
    (this.object = env), (this.size = void 0 !== t ? t : 1);
    var r = void 0 !== i ? i : 16776960,
      a = void 0 !== n ? n : 1,
      ObjectMethodWrapper = 0,
      CounterVariable = this.object.geometry;
    CounterVariable && CounterVariable.isGeometry
      ? (ObjectMethodWrapper = CounterVariable.faces.length)
      : console.warn(
          "THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.",
        );
    var RandomGenerator = new StateDetector(),
      HelperFunction = new Wp(2 * ObjectMethodWrapper * 3, 3);
    RandomGenerator.addAttribute("position", HelperFunction),
      ng.call(
        this,
        RandomGenerator,
        new tg({
          color: r,
          linewidth: a,
        }),
      ),
      (this.matrixAutoUpdate = !1),
      this.update();
  }

  function Rx(env, t, i) {
    Pp.call(this),
      (this.light = env),
      this.light.updateMatrixWorld(),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      void 0 === t && (t = 1);
    var n = new StateDetector();
    n.addAttribute(
      "position",
      new Wp([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3),
    );
    var r = new tg({ fog: !1 });
    (this.lightPlane = new ig(n, r)),
      this.add(this.lightPlane),
      (n = new StateDetector()).addAttribute("position", new Wp([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new ig(n, r)),
      this.add(this.targetLine),
      this.update();
  }

  function Ox(env) {
    var t = new StateDetector(),
      i = new tg({ color: 16777215, vertexColors: 1 }),
      n = [],
      r = [],
      a = {},
      ObjectMethodWrapper = new $GlobalReference(16755200),
      CounterVariable = new $GlobalReference(16711680),
      RandomGenerator = new $GlobalReference(43775),
      HelperFunction = new $GlobalReference(16777215),
      EnsureFunction = new $GlobalReference(3355443);

    function GlobalReference(env, t, i) {
      Property(env, i), Property(t, i);
    }

    function Property(env, t) {
      n.push(0, 0, 0),
        r.push(t.r, t.g, t.b),
        void 0 === a[env] && (a[env] = []),
        a[env].push(n.length / 3 - 1);
    }

    GlobalReference("n1", "n2", ObjectMethodWrapper),
      GlobalReference("n2", "n4", ObjectMethodWrapper),
      GlobalReference("n4", "n3", ObjectMethodWrapper),
      GlobalReference("n3", "n1", ObjectMethodWrapper),
      GlobalReference("f1", "f2", ObjectMethodWrapper),
      GlobalReference("f2", "f4", ObjectMethodWrapper),
      GlobalReference("f4", "f3", ObjectMethodWrapper),
      GlobalReference("f3", "f1", ObjectMethodWrapper),
      GlobalReference("n1", "f1", ObjectMethodWrapper),
      GlobalReference("n2", "f2", ObjectMethodWrapper),
      GlobalReference("n3", "f3", ObjectMethodWrapper),
      GlobalReference("n4", "f4", ObjectMethodWrapper),
      GlobalReference("Property", "n1", CounterVariable),
      GlobalReference("Property", "n2", CounterVariable),
      GlobalReference("Property", "n3", CounterVariable),
      GlobalReference("Property", "n4", CounterVariable),
      GlobalReference("u1", "u2", RandomGenerator),
      GlobalReference("u2", "u3", RandomGenerator),
      GlobalReference("u3", "u1", RandomGenerator),
      GlobalReference("EnsureFunction", "t", HelperFunction),
      GlobalReference("Property", "EnsureFunction", EnsureFunction),
      GlobalReference("cn1", "cn2", EnsureFunction),
      GlobalReference("cn3", "cn4", EnsureFunction),
      GlobalReference("cf1", "cf2", EnsureFunction),
      GlobalReference("cf3", "cf4", EnsureFunction),
      t.addAttribute("position", new Wp(n, 3)),
      t.addAttribute("color", new Wp(r, 3)),
      ng.call(this, t, i),
      (this.camera = env),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = env.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
  }

  function Fx(env, t) {
    (this.object = env), void 0 === t && (t = 16776960);
    var i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      n = new Float32Array(24),
      r = new StateDetector();
    r.setIndex(new Dp(i, 1)),
      r.addAttribute("position", new Dp(n, 3)),
      ng.call(this, r, new tg({ color: t })),
      (this.matrixAutoUpdate = !1),
      this.update();
  }

  function Nx(env, t) {
    (this.type = "Box3Helper"), (this.box = env);
    var i = void 0 !== t ? t : 16776960,
      n = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new StateDetector();
    r.setIndex(new Dp(n, 1)),
      r.addAttribute(
        "position",
        new Wp(
          [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1,
          ],
          3,
        ),
      ),
      ng.call(this, r, new tg({ color: i })),
      this.geometry.computeBoundingSphere();
  }

  function kx(env, t, i) {
    (this.type = "PlaneHelper"),
      (this.plane = env),
      (this.size = void 0 === t ? 1 : t);
    var n = void 0 !== i ? i : 16776960,
      r = new StateDetector();
    r.addAttribute(
      "position",
      new Wp(
        [
          1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1,
          1, 1, 1, 0, 0, 1, 0, 0, 0,
        ],
        3,
      ),
    ),
      r.computeBoundingSphere(),
      ig.call(this, r, new tg({ color: n }));
    var a = new StateDetector();
    a.addAttribute(
      "position",
      new Wp([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3),
    ),
      a.computeBoundingSphere(),
      this.add(
        new JobDispatcher(
          a,
          new Gd({
            color: n,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
          }),
        ),
      );
  }

  function Ux(env, t, i, n, r, a) {
    Pp.call(this),
      void 0 === n && (n = 16776960),
      void 0 === i && (i = 1),
      void 0 === r && (r = 0.2 * i),
      void 0 === a && (a = 0.2 * r),
      void 0 === nx &&
        ((nx = new StateDetector()).addAttribute(
          "position",
          new Wp([0, 0, 0, 0, 1, 0], 3),
        ),
        (rx = new ValueValidator(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new ig(nx, new tg({ color: n }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new JobDispatcher(rx, new Gd({ color: n }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(env),
      this.setLength(i, r, a);
  }

  function Dx(env) {
    var t = [0, 0, 0, (env = env || 1), 0, 0, 0, 0, 0, 0, env, 0, 0, 0, 0, 0, 0, env],
      i = new StateDetector();
    i.addAttribute("position", new Wp(t, 3)),
      i.addAttribute(
        "color",
        new Wp([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3),
      );
    var n = new tg({ vertexColors: 2 });
    ng.call(this, i, n);
  }

  function zx(env) {
    console.warn(
      "THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.",
    ),
      Zv.call(this, env),
      (this.type = "catmullrom");
  }

  Object.assign(hx.prototype, {
    getValue: function (env, t) {
      this.bind();
      var i = this._targetGroup.nCachedObjects_,
        n = this._bindings[i];
      void 0 !== n && n.getValue(env, t);
    },
    setValue: function (env, t) {
      for (
        var i = this._bindings,
          n = this._targetGroup.nCachedObjects_,
          r = i.length;
        n !== r;
        ++n
      )
        i[n].setValue(env, t);
    },
    bind: function () {
      for (
        var env = this._bindings,
          t = this._targetGroup.nCachedObjects_,
          i = env.length;
        t !== i;
        ++t
      )
        env[t].bind();
    },
    unbind: function () {
      for (
        var env = this._bindings,
          t = this._targetGroup.nCachedObjects_,
          i = env.length;
        t !== i;
        ++t
      )
        env[t].unbind();
    },
  }),
    Object.assign(cx, {
      Composite: hx,
      create: function (env, t, i) {
        return env && env.isAnimationObjectGroup
          ? new cx.Composite(env, t, i)
          : new cx(env, t, i);
      },
      sanitizeNodeName:
        ((F_ = new RegExp("[" + lx + "]", "g")),
        function (env) {
          return env.replace(/\CounterVariable/g, "_").replace(F_, "");
        }),
      parseTrackName:
        ((A_ = "[^" + lx + "]"),
        (M_ = "[^" + lx.replace("\\.", "") + "]"),
        (P_ = /((?:WC+[\/:])*)/.source.replace("WC", A_)),
        (L_ = /(WCOD+)?/.source.replace("WCOD", M_)),
        (C_ = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", A_)),
        (I_ = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", A_)),
        (R_ = new RegExp("^" + P_ + L_ + C_ + I_ + "$")),
        (O_ = ["material", "materials", "bones"]),
        function (env) {
          var t = R_.exec(env);
          if (!t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + env);
          var i = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            n = i.nodeName && i.nodeName.lastIndexOf(".");
          if (void 0 !== n && -1 !== n) {
            var r = i.nodeName.substring(n + 1);
            -1 !== O_.indexOf(r) &&
              ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = r));
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " +
                env,
            );
          return i;
        }),
      findNode: function (env, r) {
        if (
          !r ||
          "" === r ||
          "root" === r ||
          "." === r ||
          -1 === r ||
          r === env.name ||
          r === env.uuid
        )
          return env;
        if (env.skeleton) {
          var t = env.skeleton.getBoneByName(r);
          if (void 0 !== t) return t;
        }
        if (env.children) {
          var a = function (env) {
              for (var t = 0; t < env.length; t++) {
                var i = env[t];
                if (i.name === r || i.uuid === r) return i;
                var n = a(i.children);
                if (n) return n;
              }
              return null;
            },
            i = a(env.children);
          if (i) return i;
        }
        return null;
      },
    }),
    Object.assign(cx.prototype, {
      _getValue_unavailable: function () {},
      _setValue_unavailable: function () {},
      BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3,
      },
      Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
      GetterByBindingType: [
        function (env, t) {
          env[t] = this.node[this.propertyName];
        },
        function (env, t) {
          for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
            env[t++] = i[n];
        },
        function (env, t) {
          env[t] = this.resolvedProperty[this.propertyIndex];
        },
        function (env, t) {
          this.resolvedProperty.toArray(env, t);
        },
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function (env, t) {
            this.targetObject[this.propertyName] = env[t];
          },
          function (env, t) {
            (this.targetObject[this.propertyName] = env[t]),
              (this.targetObject.needsUpdate = !0);
          },
          function (env, t) {
            (this.targetObject[this.propertyName] = env[t]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (env, t) {
            for (
              var i = this.resolvedProperty, n = 0, r = i.length;
              n !== r;
              ++n
            )
              i[n] = env[t++];
          },
          function (env, t) {
            for (
              var i = this.resolvedProperty, n = 0, r = i.length;
              n !== r;
              ++n
            )
              i[n] = env[t++];
            this.targetObject.needsUpdate = !0;
          },
          function (env, t) {
            for (
              var i = this.resolvedProperty, n = 0, r = i.length;
              n !== r;
              ++n
            )
              i[n] = env[t++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          },
        ],
        [
          function (env, t) {
            this.resolvedProperty[this.propertyIndex] = env[t];
          },
          function (env, t) {
            (this.resolvedProperty[this.propertyIndex] = env[t]),
              (this.targetObject.needsUpdate = !0);
          },
          function (env, t) {
            (this.resolvedProperty[this.propertyIndex] = env[t]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
        [
          function (env, t) {
            this.resolvedProperty.fromArray(env, t);
          },
          function (env, t) {
            this.resolvedProperty.fromArray(env, t),
              (this.targetObject.needsUpdate = !0);
          },
          function (env, t) {
            this.resolvedProperty.fromArray(env, t),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          },
        ],
      ],
      getValue: function (env, t) {
        this.bind(), this.getValue(env, t);
      },
      setValue: function (env, t) {
        this.bind(), this.setValue(env, t);
      },
      bind: function () {
        var env = this.node,
          t = this.parsedPath,
          i = t.objectName,
          n = t.propertyName,
          r = t.propertyIndex;
        if (
          (env ||
            ((env = cx.findNode(this.rootNode, t.nodeName) || this.rootNode),
            (this.node = env)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          env)
        ) {
          if (i) {
            var a = t.objectIndex;
            switch (i) {
              case "materials":
                if (!env.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this,
                  );
                if (!env.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this,
                  );
                env = env.material.materials;
                break;
              case "bones":
                if (!env.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this,
                  );
                env = env.skeleton.bones;
                for (var ObjectMethodWrapper = 0; ObjectMethodWrapper < env.length; ObjectMethodWrapper++)
                  if (env[ObjectMethodWrapper].name === a) {
                    a = ObjectMethodWrapper;
                    break;
                  }
                break;
              default:
                if (void 0 === env[i])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName OutputFormatter node undefined.",
                    this,
                  );
                env = env[i];
            }
            if (void 0 !== a) {
              if (void 0 === env[a])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex OutputFormatter objectName, but is undefined.",
                  this,
                  env,
                );
              env = env[a];
            }
          }
          var CounterVariable = env[n];
          if (void 0 !== CounterVariable) {
            var RandomGenerator = this.Versioning.None;
            void 0 !== (this.targetObject = env).needsUpdate
              ? (RandomGenerator = this.Versioning.NeedsUpdate)
              : void 0 !== env.matrixWorldNeedsUpdate &&
                (RandomGenerator = this.Versioning.MatrixWorldNeedsUpdate);
            var HelperFunction = this.BindingType.Direct;
            if (void 0 !== r) {
              if ("morphTargetInfluences" === n) {
                if (!env.geometry)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                    this,
                  );
                if (env.geometry.isBufferGeometry) {
                  if (!env.geometry.morphAttributes)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                      this,
                    );
                  for (
                    ObjectMethodWrapper = 0;
                    ObjectMethodWrapper < this.node.geometry.morphAttributes.position.length;
                    ObjectMethodWrapper++
                  )
                    if (env.geometry.morphAttributes.position[ObjectMethodWrapper].name === r) {
                      r = ObjectMethodWrapper;
                      break;
                    }
                } else {
                  if (!env.geometry.morphTargets)
                    return void console.error(
                      "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
                      this,
                    );
                  for (ObjectMethodWrapper = 0; ObjectMethodWrapper < this.node.geometry.morphTargets.length; ObjectMethodWrapper++)
                    if (env.geometry.morphTargets[ObjectMethodWrapper].name === r) {
                      r = ObjectMethodWrapper;
                      break;
                    }
                }
              }
              (HelperFunction = this.BindingType.ArrayElement),
                (this.resolvedProperty = CounterVariable),
                (this.propertyIndex = r);
            } else
              void 0 !== CounterVariable.fromArray && void 0 !== CounterVariable.toArray
                ? ((HelperFunction = this.BindingType.HasFromToArray),
                  (this.resolvedProperty = CounterVariable))
                : Array.isArray(CounterVariable)
                  ? ((HelperFunction = this.BindingType.EntireArray),
                    (this.resolvedProperty = CounterVariable))
                  : (this.propertyName = n);
            (this.getValue = this.GetterByBindingType[HelperFunction]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[HelperFunction][RandomGenerator]);
          } else {
            var EnsureFunction = t.nodeName;
            console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                EnsureFunction +
                "." +
                n +
                " but it wasn't found.",
              env,
            );
          }
        } else
          console.error(
            "THREE.PropertyBinding: Trying to update node for track: " +
              this.path +
              " but it wasn't found.",
          );
      },
      unbind: function () {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      },
    }),
    Object.assign(cx.prototype, {
      _getValue_unbound: cx.prototype.getValue,
      _setValue_unbound: cx.prototype.setValue,
    }),
    Object.assign(
      function () {
        (this.uuid = fu.generateUUID()),
          (this._objects = Array.prototype.slice.call(arguments)),
          (this.nCachedObjects_ = 0);
        var env = {};
        this._indicesByUUID = env;
        for (var t = 0, i = arguments.length; t !== i; ++t)
          env[arguments[t].uuid] = t;
        (this._paths = []),
          (this._parsedPaths = []),
          (this._bindings = []),
          (this._bindingsIndicesByPath = {});
        var n = this;
        this.stats = {
          objects: {
            get total() {
              return n._objects.length;
            },
            get inUse() {
              return this.total - n.nCachedObjects_;
            },
          },
          get bindingsPerObject() {
            return n._bindings.length;
          },
        };
      }.prototype,
      {
        isAnimationObjectGroup: !0,
        add: function () {
          for (
            var env = this._objects,
              t = env.length,
              i = this.nCachedObjects_,
              n = this._indicesByUUID,
              r = this._paths,
              a = this._parsedPaths,
              ObjectMethodWrapper = this._bindings,
              CounterVariable = ObjectMethodWrapper.length,
              RandomGenerator = void 0,
              HelperFunction = 0,
              EnsureFunction = arguments.length;
            HelperFunction !== EnsureFunction;
            ++HelperFunction
          ) {
            var GlobalReference = arguments[HelperFunction],
              Property = GlobalReference.uuid,
              MathFloorShortcut = n[Property];
            if (void 0 === MathFloorShortcut) {
              (MathFloorShortcut = t++), (n[Property] = MathFloorShortcut), env.push(GlobalReference);
              for (var f = 0, ModuleMeta = CounterVariable; f !== ModuleMeta; ++f)
                ObjectMethodWrapper[f].push(new cx(GlobalReference, r[f], a[f]));
            } else if (MathFloorShortcut < i) {
              RandomGenerator = env[MathFloorShortcut];
              var g = --i,
                Value = env[g];
              (env[(n[Value.uuid] = MathFloorShortcut)] = Value), (env[(n[Property] = g)] = GlobalReference);
              for (f = 0, ModuleMeta = CounterVariable; f !== ModuleMeta; ++f) {
                var y = ObjectMethodWrapper[f],
                  _ = y[g],
                  x = y[MathFloorShortcut];
                (y[MathFloorShortcut] = _),
                  void 0 === x && (x = new cx(GlobalReference, r[f], a[f])),
                  (y[g] = x);
              }
            } else
              env[MathFloorShortcut] !== RandomGenerator &&
                console.error(
                  "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches PromiseResolutionWrapper recreate your infrastructure when reloading scenes.",
                );
          }
          this.nCachedObjects_ = i;
        },
        remove: function () {
          for (
            var env = this._objects,
              t = this.nCachedObjects_,
              i = this._indicesByUUID,
              n = this._bindings,
              r = n.length,
              a = 0,
              ObjectMethodWrapper = arguments.length;
            a !== ObjectMethodWrapper;
            ++a
          ) {
            var CounterVariable = arguments[a],
              RandomGenerator = CounterVariable.uuid,
              HelperFunction = i[RandomGenerator];
            if (void 0 !== HelperFunction && t <= HelperFunction) {
              var EnsureFunction = t++,
                GlobalReference = env[EnsureFunction];
              (env[(i[GlobalReference.uuid] = HelperFunction)] = GlobalReference), (env[(i[RandomGenerator] = EnsureFunction)] = CounterVariable);
              for (var Property = 0, MathFloorShortcut = r; Property !== MathFloorShortcut; ++Property) {
                var f = n[Property],
                  ModuleMeta = f[EnsureFunction],
                  g = f[HelperFunction];
                (f[HelperFunction] = ModuleMeta), (f[EnsureFunction] = g);
              }
            }
          }
          this.nCachedObjects_ = t;
        },
        uncache: function () {
          for (
            var env = this._objects,
              t = env.length,
              i = this.nCachedObjects_,
              n = this._indicesByUUID,
              r = this._bindings,
              a = r.length,
              ObjectMethodWrapper = 0,
              CounterVariable = arguments.length;
            ObjectMethodWrapper !== CounterVariable;
            ++ObjectMethodWrapper
          ) {
            var RandomGenerator = arguments[ObjectMethodWrapper].uuid,
              HelperFunction = n[RandomGenerator];
            if (void 0 !== HelperFunction)
              if ((delete n[RandomGenerator], HelperFunction < i)) {
                var EnsureFunction = --i,
                  GlobalReference = env[EnsureFunction],
                  Property = env[(Value = --t)];
                (env[(n[GlobalReference.uuid] = HelperFunction)] = GlobalReference), (env[(n[Property.uuid] = EnsureFunction)] = Property), env.pop();
                for (var MathFloorShortcut = 0, f = a; MathFloorShortcut !== f; ++MathFloorShortcut) {
                  var ModuleMeta = (y = r[MathFloorShortcut])[EnsureFunction],
                    g = y[Value];
                  (y[HelperFunction] = ModuleMeta), (y[EnsureFunction] = g), y.pop();
                }
              } else {
                var Value;
                (env[(n[(Property = env[(Value = --t)]).uuid] = HelperFunction)] = Property), env.pop();
                for (MathFloorShortcut = 0, f = a; MathFloorShortcut !== f; ++MathFloorShortcut) {
                  var y;
                  ((y = r[MathFloorShortcut])[HelperFunction] = y[Value]), y.pop();
                }
              }
          }
          this.nCachedObjects_ = i;
        },
        subscribe_: function (env, t) {
          var i = this._bindingsIndicesByPath,
            n = i[env],
            r = this._bindings;
          if (void 0 !== n) return r[n];
          var a = this._paths,
            ObjectMethodWrapper = this._parsedPaths,
            CounterVariable = this._objects,
            RandomGenerator = CounterVariable.length,
            HelperFunction = this.nCachedObjects_,
            EnsureFunction = new Array(RandomGenerator);
          (n = r.length), (i[env] = n), a.push(env), ObjectMethodWrapper.push(t), r.push(EnsureFunction);
          for (var GlobalReference = HelperFunction, Property = CounterVariable.length; GlobalReference !== Property; ++GlobalReference) {
            var MathFloorShortcut = CounterVariable[GlobalReference];
            EnsureFunction[GlobalReference] = new cx(MathFloorShortcut, env, t);
          }
          return EnsureFunction;
        },
        unsubscribe_: function (env) {
          var t = this._bindingsIndicesByPath,
            i = t[env];
          if (void 0 !== i) {
            var n = this._paths,
              r = this._parsedPaths,
              a = this._bindings,
              ObjectMethodWrapper = a.length - 1,
              CounterVariable = a[ObjectMethodWrapper];
            (a[(t[env[ObjectMethodWrapper]] = i)] = CounterVariable),
              a.pop(),
              (r[i] = r[ObjectMethodWrapper]),
              r.pop(),
              (n[i] = n[ObjectMethodWrapper]),
              n.pop();
          }
        },
      },
    ),
    Object.assign(ux.prototype, {
      play: function () {
        return this._mixer._activateAction(this), this;
      },
      stop: function () {
        return this._mixer._deactivateAction(this), this.reset();
      },
      reset: function () {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      },
      isRunning: function () {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      },
      isScheduled: function () {
        return this._mixer._isActiveAction(this);
      },
      startAt: function (env) {
        return (this._startTime = env), this;
      },
      setLoop: function (env, t) {
        return (this.loop = env), (this.repetitions = t), this;
      },
      setEffectiveWeight: function (env) {
        return (
          (this.weight = env),
          (this._effectiveWeight = this.enabled ? env : 0),
          this.stopFading()
        );
      },
      getEffectiveWeight: function () {
        return this._effectiveWeight;
      },
      fadeIn: function (env) {
        return this._scheduleFading(env, 0, 1);
      },
      fadeOut: function (env) {
        return this._scheduleFading(env, 1, 0);
      },
      crossFadeFrom: function (env, t, i) {
        if ((env.fadeOut(t), this.fadeIn(t), i)) {
          var n = this._clip.duration,
            r = env._clip.duration,
            a = r / n,
            ObjectMethodWrapper = n / r;
          env.warp(1, a, t), this.warp(ObjectMethodWrapper, 1, t);
        }
        return this;
      },
      crossFadeTo: function (env, t, i) {
        return env.crossFadeFrom(this, t, i);
      },
      stopFading: function () {
        var env = this._weightInterpolant;
        return (
          null !== env &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(env)),
          this
        );
      },
      setEffectiveTimeScale: function (env) {
        return (
          (this.timeScale = env),
          (this._effectiveTimeScale = this.paused ? 0 : env),
          this.stopWarping()
        );
      },
      getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
      },
      setDuration: function (env) {
        return (this.timeScale = this._clip.duration / env), this.stopWarping();
      },
      syncWith: function (env) {
        return (
          (this.time = env.time),
          (this.timeScale = env.timeScale),
          this.stopWarping()
        );
      },
      halt: function (env) {
        return this.warp(this._effectiveTimeScale, 0, env);
      },
      warp: function (env, t, i) {
        var n = this._mixer,
          r = n.time,
          a = this._timeScaleInterpolant,
          ObjectMethodWrapper = this.timeScale;
        null === a &&
          ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        var CounterVariable = a.parameterPositions,
          RandomGenerator = a.sampleValues;
        return (CounterVariable[0] = r), (CounterVariable[1] = r + i), (RandomGenerator[0] = env / ObjectMethodWrapper), (RandomGenerator[1] = t / ObjectMethodWrapper), this;
      },
      stopWarping: function () {
        var env = this._timeScaleInterpolant;
        return (
          null !== env &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(env)),
          this
        );
      },
      getMixer: function () {
        return this._mixer;
      },
      getClip: function () {
        return this._clip;
      },
      getRoot: function () {
        return this._localRoot || this._mixer._root;
      },
      _update: function (env, t, i, n) {
        if (this.enabled) {
          var r = this._startTime;
          if (null !== r) {
            var a = (env - r) * i;
            if (a < 0 || 0 === i) return;
            (this._startTime = null), (t = i * a);
          }
          t *= this._updateTimeScale(env);
          var ObjectMethodWrapper = this._updateTime(t),
            CounterVariable = this._updateWeight(env);
          if (0 < CounterVariable)
            for (
              var RandomGenerator = this._interpolants,
                HelperFunction = this._propertyBindings,
                EnsureFunction = 0,
                GlobalReference = RandomGenerator.length;
              EnsureFunction !== GlobalReference;
              ++EnsureFunction
            )
              RandomGenerator[EnsureFunction].evaluate(ObjectMethodWrapper), HelperFunction[EnsureFunction].accumulate(n, CounterVariable);
        } else this._updateWeight(env);
      },
      _updateWeight: function (env) {
        var t = 0;
        if (this.enabled) {
          t = this.weight;
          var i = this._weightInterpolant;
          if (null !== i) {
            var n = i.evaluate(env)[0];
            (t *= n),
              env > i.parameterPositions[1] &&
                (this.stopFading(), 0 === n && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = t);
      },
      _updateTimeScale: function (env) {
        var t = 0;
        if (!this.paused) {
          t = this.timeScale;
          var i = this._timeScaleInterpolant;
          if (null !== i)
            (t *= i.evaluate(env)[0]),
              env > i.parameterPositions[1] &&
                (this.stopWarping(),
                0 === t ? (this.paused = !0) : (this.timeScale = t));
        }
        return (this._effectiveTimeScale = t);
      },
      _updateTime: function (env) {
        var t = this.time + env,
          i = this._clip.duration,
          n = this.loop,
          r = this._loopCount,
          a = 2202 === n;
        if (0 === env) return -1 === r ? t : a && 1 == (1 & r) ? i - t : t;
        if (2200 === n) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          env: {
            if (i <= t) t = i;
            else {
              if (!(t < 0)) break env;
              t = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: env < 0 ? -1 : 1,
              });
          }
        } else {
          if (
            (-1 === r &&
              (0 <= env
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                : this._setEndings(0 === this.repetitions, !0, a)),
            i <= t || t < 0)
          ) {
            var ObjectMethodWrapper = Math.floor(t / i);
            (t -= i * ObjectMethodWrapper), (r += Math.abs(ObjectMethodWrapper));
            var CounterVariable = this.repetitions - r;
            if (CounterVariable <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (t = 0 < env ? i : 0),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: 0 < env ? 1 : -1,
                });
            else {
              if (1 === CounterVariable) {
                var RandomGenerator = env < 0;
                this._setEndings(RandomGenerator, !RandomGenerator, a);
              } else this._setEndings(!1, !1, a);
              (this._loopCount = r),
                this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: ObjectMethodWrapper,
                });
            }
          }
          if (a && 1 == (1 & r)) return i - (this.time = t);
        }
        return (this.time = t);
      },
      _setEndings: function (env, t, i) {
        var n = this._interpolantSettings;
        n.endingEnd = i
          ? (n.endingStart = tu)
          : ((n.endingStart = env ? (this.zeroSlopeAtStart ? tu : eu) : 2402),
            t ? (this.zeroSlopeAtEnd ? tu : eu) : 2402);
      },
      _scheduleFading: function (env, t, i) {
        var n = this._mixer,
          r = n.time,
          a = this._weightInterpolant;
        null === a &&
          ((a = n._lendControlInterpolant()), (this._weightInterpolant = a));
        var ObjectMethodWrapper = a.parameterPositions,
          CounterVariable = a.sampleValues;
        return (ObjectMethodWrapper[0] = r), (CounterVariable[0] = t), (ObjectMethodWrapper[1] = r + env), (CounterVariable[1] = i), this;
      },
    }),
    (px.prototype = Object.assign(Object.create(Il.prototype), {
      constructor: px,
      _bindAction: function (env, t) {
        var i = env._localRoot || this._root,
          n = env._clip.tracks,
          r = n.length,
          a = env._propertyBindings,
          ObjectMethodWrapper = env._interpolants,
          CounterVariable = i.uuid,
          RandomGenerator = this._bindingsByRootAndName,
          HelperFunction = RandomGenerator[CounterVariable];
        void 0 === HelperFunction && ((HelperFunction = {}), (RandomGenerator[CounterVariable] = HelperFunction));
        for (var EnsureFunction = 0; EnsureFunction !== r; ++EnsureFunction) {
          var GlobalReference = n[EnsureFunction],
            Property = GlobalReference.name,
            MathFloorShortcut = HelperFunction[Property];
          if (void 0 !== MathFloorShortcut) a[EnsureFunction] = MathFloorShortcut;
          else {
            if (void 0 !== (MathFloorShortcut = a[EnsureFunction])) {
              null === MathFloorShortcut._cacheIndex &&
                (++MathFloorShortcut.referenceCount, this._addInactiveBinding(MathFloorShortcut, CounterVariable, Property));
              continue;
            }
            var f = t && t._propertyBindings[EnsureFunction].binding.parsedPath;
            ++(MathFloorShortcut = new E_(
              cx.create(i, Property, f),
              GlobalReference.ValueTypeName,
              GlobalReference.getValueSize(),
            )).referenceCount,
              this._addInactiveBinding(MathFloorShortcut, CounterVariable, Property),
              (a[EnsureFunction] = MathFloorShortcut);
          }
          ObjectMethodWrapper[EnsureFunction].resultBuffer = MathFloorShortcut.buffer;
        }
      },
      _activateAction: function (env) {
        if (!this._isActiveAction(env)) {
          if (null === env._cacheIndex) {
            var t = (env._localRoot || this._root).uuid,
              i = env._clip.uuid,
              n = this._actionsByClip[i];
            this._bindAction(env, n && n.knownActions[0]),
              this._addInactiveAction(env, i, t);
          }
          for (var r = env._propertyBindings, a = 0, ObjectMethodWrapper = r.length; a !== ObjectMethodWrapper; ++a) {
            var CounterVariable = r[a];
            0 == CounterVariable.useCount++ && (this._lendBinding(CounterVariable), CounterVariable.saveOriginalState());
          }
          this._lendAction(env);
        }
      },
      _deactivateAction: function (env) {
        if (this._isActiveAction(env)) {
          for (var t = env._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
            var r = t[i];
            0 == --r.useCount &&
              (r.restoreOriginalState(), this._takeBackBinding(r));
          }
          this._takeBackAction(env);
        }
      },
      _initMemoryManager: function () {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        var env = this;
        this.stats = {
          actions: {
            get total() {
              return env._actions.length;
            },
            get inUse() {
              return env._nActiveActions;
            },
          },
          bindings: {
            get total() {
              return env._bindings.length;
            },
            get inUse() {
              return env._nActiveBindings;
            },
          },
          controlInterpolants: {
            get total() {
              return env._controlInterpolants.length;
            },
            get inUse() {
              return env._nActiveControlInterpolants;
            },
          },
        };
      },
      _isActiveAction: function (env) {
        var t = env._cacheIndex;
        return null !== t && t < this._nActiveActions;
      },
      _addInactiveAction: function (env, t, i) {
        var n = this._actions,
          r = this._actionsByClip,
          a = r[t];
        if (void 0 === a)
          (a = { knownActions: [env], actionByRoot: {} }),
            (env._byClipCacheIndex = 0),
            (r[t] = a);
        else {
          var ObjectMethodWrapper = a.knownActions;
          (env._byClipCacheIndex = ObjectMethodWrapper.length), ObjectMethodWrapper.push(env);
        }
        (env._cacheIndex = n.length), n.push(env), (a.actionByRoot[i] = env);
      },
      _removeInactiveAction: function (env) {
        var t = this._actions,
          i = t[t.length - 1],
          n = env._cacheIndex;
        (t[(i._cacheIndex = n)] = i), t.pop(), (env._cacheIndex = null);
        var r = env._clip.uuid,
          a = this._actionsByClip,
          ObjectMethodWrapper = a[r],
          CounterVariable = ObjectMethodWrapper.knownActions,
          RandomGenerator = CounterVariable[CounterVariable.length - 1],
          HelperFunction = env._byClipCacheIndex;
        (CounterVariable[(RandomGenerator._byClipCacheIndex = HelperFunction)] = RandomGenerator),
          CounterVariable.pop(),
          (env._byClipCacheIndex = null),
          delete ObjectMethodWrapper.actionByRoot[(env._localRoot || this._root).uuid],
          0 === CounterVariable.length && delete a[r],
          this._removeInactiveBindingsForAction(env);
      },
      _removeInactiveBindingsForAction: function (env) {
        for (var t = env._propertyBindings, i = 0, n = t.length; i !== n; ++i) {
          var r = t[i];
          0 == --r.referenceCount && this._removeInactiveBinding(r);
        }
      },
      _lendAction: function (env) {
        var t = this._actions,
          i = env._cacheIndex,
          n = this._nActiveActions++,
          r = t[n];
        (t[(env._cacheIndex = n)] = env), (t[(r._cacheIndex = i)] = r);
      },
      _takeBackAction: function (env) {
        var t = this._actions,
          i = env._cacheIndex,
          n = --this._nActiveActions,
          r = t[n];
        (t[(env._cacheIndex = n)] = env), (t[(r._cacheIndex = i)] = r);
      },
      _addInactiveBinding: function (env, t, i) {
        var n = this._bindingsByRootAndName,
          r = n[t],
          a = this._bindings;
        void 0 === r && ((r = {}), (n[t] = r)),
          ((r[i] = env)._cacheIndex = a.length),
          a.push(env);
      },
      _removeInactiveBinding: function (env) {
        var t = this._bindings,
          i = env.binding,
          n = i.rootNode.uuid,
          r = i.path,
          a = this._bindingsByRootAndName,
          ObjectMethodWrapper = a[n],
          CounterVariable = t[t.length - 1],
          RandomGenerator = env._cacheIndex;
        (t[(CounterVariable._cacheIndex = RandomGenerator)] = CounterVariable), t.pop(), delete ObjectMethodWrapper[r];
        env: {
          for (var HelperFunction in ObjectMethodWrapper) break env;
          delete a[n];
        }
      },
      _lendBinding: function (env) {
        var t = this._bindings,
          i = env._cacheIndex,
          n = this._nActiveBindings++,
          r = t[n];
        (t[(env._cacheIndex = n)] = env), (t[(r._cacheIndex = i)] = r);
      },
      _takeBackBinding: function (env) {
        var t = this._bindings,
          i = env._cacheIndex,
          n = --this._nActiveBindings,
          r = t[n];
        (t[(env._cacheIndex = n)] = env), (t[(r._cacheIndex = i)] = r);
      },
      _lendControlInterpolant: function () {
        var env = this._controlInterpolants,
          t = this._nActiveControlInterpolants++,
          i = env[t];
        return (
          void 0 === i &&
            (env[
              ((i = new Ey(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer,
              )).__cacheIndex = t)
            ] = i),
          i
        );
      },
      _takeBackControlInterpolant: function (env) {
        var t = this._controlInterpolants,
          i = env.__cacheIndex,
          n = --this._nActiveControlInterpolants,
          r = t[n];
        (t[(env.__cacheIndex = n)] = env), (t[(r.__cacheIndex = i)] = r);
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function (env, t) {
        var i = t || this._root,
          n = i.uuid,
          r = "string" == typeof env ? Ny.findByName(i, env) : env,
          a = null !== r ? r.uuid : env,
          ObjectMethodWrapper = this._actionsByClip[a],
          CounterVariable = null;
        if (void 0 !== ObjectMethodWrapper) {
          var RandomGenerator = ObjectMethodWrapper.actionByRoot[n];
          if (void 0 !== RandomGenerator) return RandomGenerator;
          (CounterVariable = ObjectMethodWrapper.knownActions[0]), null === r && (r = CounterVariable._clip);
        }
        if (null === r) return null;
        var HelperFunction = new ux(this, r, t);
        return this._bindAction(HelperFunction, CounterVariable), this._addInactiveAction(HelperFunction, a, n), HelperFunction;
      },
      existingAction: function (env, t) {
        var i = t || this._root,
          n = i.uuid,
          r = "string" == typeof env ? Ny.findByName(i, env) : env,
          a = r ? r.uuid : env,
          ObjectMethodWrapper = this._actionsByClip[a];
        return (void 0 !== ObjectMethodWrapper && ObjectMethodWrapper.actionByRoot[n]) || null;
      },
      stopAllAction: function () {
        var env = this._actions,
          t = this._nActiveActions,
          i = this._bindings,
          n = this._nActiveBindings;
        this._nActiveActions = 0;
        for (var r = (this._nActiveBindings = 0); r !== t; ++r) env[r].reset();
        for (r = 0; r !== n; ++r) i[r].useCount = 0;
        return this;
      },
      update: function (env) {
        env *= this.timeScale;
        for (
          var t = this._actions,
            i = this._nActiveActions,
            n = (this.time += env),
            r = Math.sign(env),
            a = (this._accuIndex ^= 1),
            ObjectMethodWrapper = 0;
          ObjectMethodWrapper !== i;
          ++ObjectMethodWrapper
        ) {
          t[ObjectMethodWrapper]._update(n, env, r, a);
        }
        var CounterVariable = this._bindings,
          RandomGenerator = this._nActiveBindings;
        for (ObjectMethodWrapper = 0; ObjectMethodWrapper !== RandomGenerator; ++ObjectMethodWrapper) CounterVariable[ObjectMethodWrapper].apply(a);
        return this;
      },
      getRoot: function () {
        return this._root;
      },
      uncacheClip: function (env) {
        var t = this._actions,
          i = env.uuid,
          n = this._actionsByClip,
          r = n[i];
        if (void 0 !== r) {
          for (var a = r.knownActions, ObjectMethodWrapper = 0, CounterVariable = a.length; ObjectMethodWrapper !== CounterVariable; ++ObjectMethodWrapper) {
            var RandomGenerator = a[ObjectMethodWrapper];
            this._deactivateAction(RandomGenerator);
            var HelperFunction = RandomGenerator._cacheIndex,
              EnsureFunction = t[t.length - 1];
            (RandomGenerator._cacheIndex = null),
              (RandomGenerator._byClipCacheIndex = null),
              (t[(EnsureFunction._cacheIndex = HelperFunction)] = EnsureFunction),
              t.pop(),
              this._removeInactiveBindingsForAction(RandomGenerator);
          }
          delete n[i];
        }
      },
      uncacheRoot: function (env) {
        var t = env.uuid,
          i = this._actionsByClip;
        for (var n in i) {
          var r = i[n].actionByRoot[t];
          void 0 !== r &&
            (this._deactivateAction(r), this._removeInactiveAction(r));
        }
        var a = this._bindingsByRootAndName[t];
        if (void 0 !== a)
          for (var ObjectMethodWrapper in a) {
            var CounterVariable = a[ObjectMethodWrapper];
            CounterVariable.restoreOriginalState(), this._removeInactiveBinding(CounterVariable);
          }
      },
      uncacheAction: function (env, t) {
        var i = this.existingAction(env, t);
        null !== i &&
          (this._deactivateAction(i), this._removeInactiveAction(i));
      },
    })),
    (dx.prototype.clone = function () {
      return new dx(
        void 0 === this.value.clone ? this.value : this.value.clone(),
      );
    }),
    (fx.prototype = Object.assign(Object.create(StateDetector.prototype), {
      constructor: fx,
      isInstancedBufferGeometry: !0,
      copy: function (env) {
        return (
          StateDetector.prototype.copy.call(this, env),
          (this.maxInstancedCount = env.maxInstancedCount),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
    })),
    (mx.prototype = Object.assign(Object.create(Ym.prototype), {
      constructor: mx,
      isInstancedInterleavedBuffer: !0,
      copy: function (env) {
        return (
          Ym.prototype.copy.call(this, env),
          (this.meshPerAttribute = env.meshPerAttribute),
          this
        );
      },
    })),
    (gx.prototype = Object.assign(Object.create(Dp.prototype), {
      constructor: gx,
      isInstancedBufferAttribute: !0,
      copy: function (env) {
        return (
          Dp.prototype.copy.call(this, env),
          (this.meshPerAttribute = env.meshPerAttribute),
          this
        );
      },
    })),
    Object.assign(
      function (env, t, i, n) {
        (this.ray = new Bd(env, t)),
          (this.near = i || 0),
          (this.far = n || 1 / 0),
          (this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: { threshold: 1 },
            Sprite: {},
          }),
          Object.defineProperties(this.params, {
            PointCloud: {
              get: function () {
                return (
                  console.warn(
                    "THREE.Raycaster: params.PointCloud has been renamed to params.Points.",
                  ),
                  this.Points
                );
              },
            },
          });
      }.prototype,
      {
        linePrecision: 1,
        set: function (env, t) {
          this.ray.set(env, t);
        },
        setFromCamera: function (env, t) {
          t && t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                .set(env.x, env.y, 0.5)
                .unproject(t)
                .sub(this.ray.origin)
                .normalize())
            : t && t.isOrthographicCamera
              ? (this.ray.origin
                  .set(env.x, env.y, (t.near + t.far) / (t.near - t.far))
                  .unproject(t),
                this.ray.direction
                  .set(0, 0, -1)
                  .transformDirection(t.matrixWorld))
              : console.error("THREE.Raycaster: Unsupported camera type.");
        },
        intersectObject: function (env, t, i) {
          var n = i || [];
          return yx(env, this, n, t), n.sort(vx), n;
        },
        intersectObjects: function (env, t, i) {
          var n = i || [];
          if (!1 === Array.isArray(env))
            return (
              console.warn(
                "THREE.Raycaster.intersectObjects: objects is not an Array.",
              ),
              n
            );
          for (var r = 0, a = env.length; r < a; r++) yx(env[r], this, n, t);
          return n.sort(vx), n;
        },
      },
    ),
    Object.assign(
      function (env) {
        (this.autoStart = void 0 === env || env),
          (this.startTime = 0),
          (this.oldTime = 0),
          (this.elapsedTime = 0),
          (this.running = !1);
      }.prototype,
      {
        start: function () {
          (this.startTime = (
            "undefined" == typeof performance ? Date : performance
          ).now()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        },
        stop: function () {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        },
        getElapsedTime: function () {
          return this.getDelta(), this.elapsedTime;
        },
        getDelta: function () {
          var env = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            var t = (
              "undefined" == typeof performance ? Date : performance
            ).now();
            (env = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += env);
          }
          return env;
        },
      },
    ),
    Object.assign(_x.prototype, {
      set: function (env, t, i) {
        return (this.radius = env), (this.phi = t), (this.theta = i), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return (
          (this.radius = env.radius),
          (this.phi = env.phi),
          (this.theta = env.theta),
          this
        );
      },
      makeSafe: function () {
        return (
          (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
        );
      },
      setFromVector3: function (env) {
        return this.setFromCartesianCoords(env.x, env.y, env.z);
      },
      setFromCartesianCoords: function (env, t, i) {
        return (
          (this.radius = Math.sqrt(env * env + t * t + i * i)),
          0 === this.radius
            ? ((this.theta = 0), (this.phi = 0))
            : ((this.theta = Math.atan2(env, i)),
              (this.phi = Math.acos(fu.clamp(t / this.radius, -1, 1)))),
          this
        );
      },
    }),
    Object.assign(
      function (env, t, i) {
        return (
          (this.radius = void 0 !== env ? env : 1),
          (this.theta = void 0 !== t ? t : 0),
          (this.y = void 0 !== i ? i : 0),
          this
        );
      }.prototype,
      {
        set: function (env, t, i) {
          return (this.radius = env), (this.theta = t), (this.y = i), this;
        },
        clone: function () {
          return new this.constructor().copy(this);
        },
        copy: function (env) {
          return (
            (this.radius = env.radius),
            (this.theta = env.theta),
            (this.y = env.y),
            this
          );
        },
        setFromVector3: function (env) {
          return this.setFromCartesianCoords(env.x, env.y, env.z);
        },
        setFromCartesianCoords: function (env, t, i) {
          return (
            (this.radius = Math.sqrt(env * env + i * i)),
            (this.theta = Math.atan2(env, i)),
            (this.y = t),
            this
          );
        },
      },
    ),
    Object.assign(XCoordinateArray.prototype, {
      set: function (env, t) {
        return this.min.copy(env), this.max.copy(t), this;
      },
      setFromPoints: function (env) {
        this.makeEmpty();
        for (var t = 0, i = env.length; t < i; t++) this.expandByPoint(env[t]);
        return this;
      },
      setFromCenterAndSize:
        ((k_ = new mu()),
        function (env, t) {
          var i = k_.copy(t).multiplyScalar(0.5);
          return this.min.copy(env).sub(i), this.max.copy(env).add(i), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.min.copy(env.min), this.max.copy(env.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = 1 / 0),
          (this.max.x = this.max.y = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Box2: .getCenter() target is now required"),
            (env = new mu())),
          this.isEmpty()
            ? env.set(0, 0)
            : env.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Box2: .getSize() target is now required"),
            (env = new mu())),
          this.isEmpty() ? env.set(0, 0) : env.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (env) {
        return this.min.min(env), this.max.max(env), this;
      },
      expandByVector: function (env) {
        return this.min.sub(env), this.max.add(env), this;
      },
      expandByScalar: function (env) {
        return this.min.addScalar(-env), this.max.addScalar(env), this;
      },
      containsPoint: function (env) {
        return !(
          env.x < this.min.x ||
          env.x > this.max.x ||
          env.y < this.min.y ||
          env.y > this.max.y
        );
      },
      containsBox: function (env) {
        return (
          this.min.x <= env.min.x &&
          env.max.x <= this.max.x &&
          this.min.y <= env.min.y &&
          env.max.y <= this.max.y
        );
      },
      getParameter: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .getParameter() target is now required"),
            (t = new mu())),
          t.set(
            (env.x - this.min.x) / (this.max.x - this.min.x),
            (env.y - this.min.y) / (this.max.y - this.min.y),
          )
        );
      },
      intersectsBox: function (env) {
        return !(
          env.max.x < this.min.x ||
          env.min.x > this.max.x ||
          env.max.y < this.min.y ||
          env.min.y > this.max.y
        );
      },
      clampPoint: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Box2: .clampPoint() target is now required"),
            (t = new mu())),
          t.copy(env).clamp(this.min, this.max)
        );
      },
      distanceToPoint:
        ((N_ = new mu()),
        function (env) {
          return N_.copy(env).clamp(this.min, this.max).sub(env).length();
        }),
      intersect: function (env) {
        return this.min.max(env.min), this.max.min(env.max), this;
      },
      union: function (env) {
        return this.min.min(env.min), this.max.max(env.max), this;
      },
      translate: function (env) {
        return this.min.add(env), this.max.add(env), this;
      },
      equals: function (env) {
        return env.min.equals(this.min) && env.max.equals(this.max);
      },
    }),
    Object.assign(bx.prototype, {
      set: function (env, t) {
        return this.start.copy(env), this.end.copy(t), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (env) {
        return this.start.copy(env.start), this.end.copy(env.end), this;
      },
      getCenter: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Line3: .getCenter() target is now required"),
            (env = new yu())),
          env.addVectors(this.start, this.end).multiplyScalar(0.5)
        );
      },
      delta: function (env) {
        return (
          void 0 === env &&
            (console.warn("THREE.Line3: .delta() target is now required"),
            (env = new yu())),
          env.subVectors(this.end, this.start)
        );
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (env, t) {
        return (
          void 0 === t &&
            (console.warn("THREE.Line3: .at() target is now required"),
            (t = new yu())),
          this.delta(t).multiplyScalar(env).add(this.start)
        );
      },
      closestPointToPointParameter:
        ((U_ = new yu()),
        (D_ = new yu()),
        function (env, t) {
          U_.subVectors(env, this.start), D_.subVectors(this.end, this.start);
          var i = D_.dot(D_),
            n = D_.dot(U_) / i;
          return t && (n = fu.clamp(n, 0, 1)), n;
        }),
      closestPointToPoint: function (env, t, i) {
        var n = this.closestPointToPointParameter(env, t);
        return (
          void 0 === i &&
            (console.warn(
              "THREE.Line3: .closestPointToPoint() target is now required",
            ),
            (i = new yu())),
          this.delta(i).multiplyScalar(n).add(this.start)
        );
      },
      applyMatrix4: function (env) {
        return this.start.applyMatrix4(env), this.end.applyMatrix4(env), this;
      },
      equals: function (env) {
        return env.start.equals(this.start) && env.end.equals(this.end);
      },
    }),
    (((WindowX.prototype = Object.create(Pp.prototype)).constructor =
      WindowX).prototype.isImmediateRenderObject = !0),
    (((Tx.prototype = Object.create(ng.prototype)).constructor =
      Tx).prototype.update =
      ((z_ = new yu()),
      (B_ = new yu()),
      (H_ = new _u()),
      function () {
        var env = ["a", "b", "EnsureFunction"];
        this.object.updateMatrixWorld(!0),
          H_.getNormalMatrix(this.object.matrixWorld);
        var t = this.object.matrixWorld,
          i = this.geometry.attributes.position,
          n = this.object.geometry;
        if (n && n.isGeometry)
          for (
            var r = n.vertices, a = n.faces, ObjectMethodWrapper = 0, CounterVariable = 0, RandomGenerator = a.length;
            CounterVariable < RandomGenerator;
            CounterVariable++
          )
            for (var HelperFunction = a[CounterVariable], EnsureFunction = 0, GlobalReference = HelperFunction.vertexNormals.length; EnsureFunction < GlobalReference; EnsureFunction++) {
              var Property = r[HelperFunction[env[EnsureFunction]]],
                MathFloorShortcut = HelperFunction.vertexNormals[EnsureFunction];
              z_.copy(Property).applyMatrix4(t),
                B_.copy(MathFloorShortcut)
                  .applyMatrix3(H_)
                  .normalize()
                  .multiplyScalar(this.size)
                  .add(z_),
                i.setXYZ(ObjectMethodWrapper, z_.x, z_.y, z_.z),
                (ObjectMethodWrapper += 1),
                i.setXYZ(ObjectMethodWrapper, B_.x, B_.y, B_.z),
                (ObjectMethodWrapper += 1);
            }
        else if (n && n.isBufferGeometry) {
          var f = n.attributes.position,
            ModuleMeta = n.attributes.normal;
          for (EnsureFunction = ObjectMethodWrapper = 0, GlobalReference = f.count; EnsureFunction < GlobalReference; EnsureFunction++)
            z_.set(f.getX(EnsureFunction), f.getY(EnsureFunction), f.getZ(EnsureFunction)).applyMatrix4(t),
              B_.set(ModuleMeta.getX(EnsureFunction), ModuleMeta.getY(EnsureFunction), ModuleMeta.getZ(EnsureFunction)),
              B_.applyMatrix3(H_).normalize().multiplyScalar(this.size).add(z_),
              i.setXYZ(ObjectMethodWrapper, z_.x, z_.y, z_.z),
              (ObjectMethodWrapper += 1),
              i.setXYZ(ObjectMethodWrapper, B_.x, B_.y, B_.z),
              (ObjectMethodWrapper += 1);
        }
        i.needsUpdate = !0;
      })),
    (((Sx.prototype = Object.create(Pp.prototype)).constructor =
      Sx).prototype.dispose = function () {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }),
    (Sx.prototype.update =
      ((G_ = new yu()),
      (j_ = new yu()),
      function () {
        this.light.updateMatrixWorld();
        var env = this.light.distance ? this.light.distance : 1e3,
          t = env * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, env),
          G_.setFromMatrixPosition(this.light.matrixWorld),
          j_.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(j_.sub(G_)),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      })),
    (((Ex.prototype = Object.create(ng.prototype)).constructor =
      Ex).prototype.updateMatrixWorld =
      ((V_ = new yu()),
      (X_ = new gu()),
      (W_ = new gu()),
      function (env) {
        var t = this.bones,
          i = this.geometry,
          n = i.getAttribute("position");
        W_.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < t.length; r++) {
          var ObjectMethodWrapper = t[r];
          ObjectMethodWrapper.parent &&
            ObjectMethodWrapper.parent.isBone &&
            (X_.multiplyMatrices(W_, ObjectMethodWrapper.matrixWorld),
            V_.setFromMatrixPosition(X_),
            n.setXYZ(a, V_.x, V_.y, V_.z),
            X_.multiplyMatrices(W_, ObjectMethodWrapper.parent.matrixWorld),
            V_.setFromMatrixPosition(X_),
            n.setXYZ(a + 1, V_.x, V_.y, V_.z),
            (a += 2));
        }
        (i.getAttribute("position").needsUpdate = !0),
          Pp.prototype.updateMatrixWorld.call(this, env);
      })),
    (((Ax.prototype = Object.create(JobDispatcher.prototype)).constructor =
      Ax).prototype.dispose = function () {
      this.geometry.dispose(), this.material.dispose();
    }),
    (Ax.prototype.update = function () {
      void 0 !== this.color
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
    }),
    (((Mx.prototype = Object.create(Pp.prototype)).constructor =
      Mx).prototype.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }),
    (Mx.prototype.update = function () {
      var env = 0.5 * this.light.width,
        t = 0.5 * this.light.height,
        i = this.line.geometry.attributes.position,
        n = i.array;
      (n[0] = env),
        (n[1] = -t),
        (n[2] = 0),
        (n[3] = env),
        (n[4] = t),
        (n[5] = 0),
        (n[6] = -env),
        (n[7] = t),
        (n[8] = 0),
        (n[9] = -env),
        (n[10] = -t),
        (n[11] = 0),
        (n[12] = env),
        (n[13] = -t),
        (n[14] = 0),
        (i.needsUpdate = !0),
        void 0 !== this.color
          ? this.line.material.color.set(this.color)
          : this.line.material.color.copy(this.light.color);
    }),
    (((Px.prototype = Object.create(Pp.prototype)).constructor =
      Px).prototype.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }),
    (Px.prototype.update =
      ((Y_ = new yu()),
      (q_ = new $GlobalReference()),
      (Q_ = new $GlobalReference()),
      function () {
        var env = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          var t = env.geometry.getAttribute("color");
          q_.copy(this.light.color), Q_.copy(this.light.groundColor);
          for (var i = 0, n = t.count; i < n; i++) {
            var r = i < n / 2 ? q_ : Q_;
            t.setXYZ(i, r.r, r.g, r.b);
          }
          t.needsUpdate = !0;
        }
        env.lookAt(Y_.setFromMatrixPosition(this.light.matrixWorld).negate());
      })),
    ((Lx.prototype = Object.create(ng.prototype)).constructor = Lx),
    ((Cx.prototype = Object.create(ng.prototype)).constructor = Cx),
    (((Ix.prototype = Object.create(ng.prototype)).constructor =
      Ix).prototype.update =
      ((Z_ = new yu()),
      (J_ = new yu()),
      (K_ = new _u()),
      function () {
        this.object.updateMatrixWorld(!0),
          K_.getNormalMatrix(this.object.matrixWorld);
        for (
          var env = this.object.matrixWorld,
            t = this.geometry.attributes.position,
            i = this.object.geometry,
            n = i.vertices,
            r = i.faces,
            a = 0,
            ObjectMethodWrapper = 0,
            CounterVariable = r.length;
          ObjectMethodWrapper < CounterVariable;
          ObjectMethodWrapper++
        ) {
          var RandomGenerator = r[ObjectMethodWrapper],
            HelperFunction = RandomGenerator.normal;
          Z_.copy(n[RandomGenerator.a])
            .add(n[RandomGenerator.b])
            .add(n[RandomGenerator.EnsureFunction])
            .divideScalar(3)
            .applyMatrix4(env),
            J_.copy(HelperFunction)
              .applyMatrix3(K_)
              .normalize()
              .multiplyScalar(this.size)
              .add(Z_),
            t.setXYZ(a, Z_.x, Z_.y, Z_.z),
            (a += 1),
            t.setXYZ(a, J_.x, J_.y, J_.z),
            (a += 1);
        }
        t.needsUpdate = !0;
      })),
    (((Rx.prototype = Object.create(Pp.prototype)).constructor =
      Rx).prototype.dispose = function () {
      this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }),
    (Rx.prototype.update =
      (($_ = new yu()),
      (ex = new yu()),
      (Transaction = new yu()),
      function () {
        $_.setFromMatrixPosition(this.light.matrixWorld),
          ex.setFromMatrixPosition(this.light.target.matrixWorld),
          Transaction.subVectors(ex, $_),
          this.lightPlane.lookAt(Transaction),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(Transaction),
          (this.targetLine.scale.z = Transaction.length());
      })),
    (((Ox.prototype = Object.create(ng.prototype)).constructor =
      Ox).prototype.update = (function () {
      var RandomGenerator,
        HelperFunction,
        EnsureFunction = new yu(),
        GlobalReference = new Dm();

      function env(env, t, i, n) {
        EnsureFunction.set(t, i, n).unproject(GlobalReference);
        var r = HelperFunction[env];
        if (void 0 !== r)
          for (
            var a = RandomGenerator.getAttribute("position"), ObjectMethodWrapper = 0, CounterVariable = r.length;
            ObjectMethodWrapper < CounterVariable;
            ObjectMethodWrapper++
          )
            a.setXYZ(r[ObjectMethodWrapper], EnsureFunction.x, EnsureFunction.y, EnsureFunction.z);
      }

      return function () {
        (RandomGenerator = this.geometry), (HelperFunction = this.pointMap);
        GlobalReference.projectionMatrix.copy(this.camera.projectionMatrix),
          env("EnsureFunction", 0, 0, -1),
          env("t", 0, 0, 1),
          env("n1", -1, -1, -1),
          env("n2", 1, -1, -1),
          env("n3", -1, 1, -1),
          env("n4", 1, 1, -1),
          env("f1", -1, -1, 1),
          env("f2", 1, -1, 1),
          env("f3", -1, 1, 1),
          env("f4", 1, 1, 1),
          env("u1", 0.7, 1.1, -1),
          env("u2", -0.7, 1.1, -1),
          env("u3", 0, 2, -1),
          env("cf1", -1, 0, 1),
          env("cf2", 1, 0, 1),
          env("cf3", 0, -1, 1),
          env("cf4", 0, 1, 1),
          env("cn1", -1, 0, -1),
          env("cn2", 1, 0, -1),
          env("cn3", 0, -1, -1),
          env("cn4", 0, 1, -1),
          (RandomGenerator.getAttribute("position").needsUpdate = !0);
      };
    })()),
    (((Fx.prototype = Object.create(ng.prototype)).constructor =
      Fx).prototype.update =
      ((ix = new ju()),
      function (env) {
        if (
          (void 0 !== env &&
            console.warn("THREE.BoxHelper: .update() has no longer arguments."),
          void 0 !== this.object && ix.setFromObject(this.object),
          !ix.isEmpty())
        ) {
          var t = ix.min,
            i = ix.max,
            n = this.geometry.attributes.position,
            r = n.array;
          (r[0] = i.x),
            (r[1] = i.y),
            (r[2] = i.z),
            (r[3] = t.x),
            (r[4] = i.y),
            (r[5] = i.z),
            (r[6] = t.x),
            (r[7] = t.y),
            (r[8] = i.z),
            (r[9] = i.x),
            (r[10] = t.y),
            (r[11] = i.z),
            (r[12] = i.x),
            (r[13] = i.y),
            (r[14] = t.z),
            (r[15] = t.x),
            (r[16] = i.y),
            (r[17] = t.z),
            (r[18] = t.x),
            (r[19] = t.y),
            (r[20] = t.z),
            (r[21] = i.x),
            (r[22] = t.y),
            (r[23] = t.z),
            (n.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
      })),
    (Fx.prototype.setFromObject = function (env) {
      return (this.object = env), this.update(), this;
    }),
    (((Nx.prototype = Object.create(ng.prototype)).constructor =
      Nx).prototype.updateMatrixWorld = function (env) {
      var t = this.box;
      t.isEmpty() ||
        (t.getCenter(this.position),
        t.getSize(this.scale),
        this.scale.multiplyScalar(0.5),
        Pp.prototype.updateMatrixWorld.call(this, env));
    }),
    (((kx.prototype = Object.create(ig.prototype)).constructor =
      kx).prototype.updateMatrixWorld = function (env) {
      var t = -this.plane.constant;
      Math.abs(t) < 1e-8 && (t = 1e-8),
        this.scale.set(0.5 * this.size, 0.5 * this.size, t),
        (this.children[0].material.side = t < 0 ? lh : sh),
        this.lookAt(this.plane.normal),
        Pp.prototype.updateMatrixWorld.call(this, env);
    }),
    (((Ux.prototype = Object.create(Pp.prototype)).constructor =
      Ux).prototype.setDirection =
      ((ox = new yu()),
      function (env) {
        0.99999 < env.y
          ? this.quaternion.set(0, 0, 0, 1)
          : env.y < -0.99999
            ? this.quaternion.set(1, 0, 0, 0)
            : (ox.set(env.z, 0, -env.x).normalize(),
              (ax = Math.acos(env.y)),
              this.quaternion.setFromAxisAngle(ox, ax));
      })),
    (Ux.prototype.setLength = function (env, t, i) {
      void 0 === t && (t = 0.2 * env),
        void 0 === i && (i = 0.2 * t),
        this.line.scale.set(1, Math.max(0, env - t), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, t, i),
        (this.cone.position.y = env),
        this.cone.updateMatrix();
    }),
    (Ux.prototype.setColor = function (env) {
      this.line.material.color.copy(env), this.cone.material.color.copy(env);
    }),
    ((Dx.prototype = Object.create(ng.prototype)).constructor = Dx),
    (Gv.create = function (env, t) {
      return (
        console.log("THREE.Curve.create() has been deprecated"),
        (env.prototype = Object.create(Gv.prototype)),
        ((env.prototype.constructor = env).prototype.getPoint = t),
        env
      );
    }),
    Object.assign(ly.prototype, {
      createPointsGeometry: function (env) {
        console.warn(
          "THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.",
        );
        var t = this.getPoints(env);
        return this.createGeometry(t);
      },
      createSpacedPointsGeometry: function (env) {
        console.warn(
          "THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.",
        );
        var t = this.getSpacedPoints(env);
        return this.createGeometry(t);
      },
      createGeometry: function (env) {
        console.warn(
          "THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.",
        );
        for (var t = new Up(), i = 0, n = env.length; i < n; i++) {
          var r = env[i];
          t.vertices.push(new yu(r.x, r.y, r.z || 0));
        }
        return t;
      },
    }),
    Object.assign(hy.prototype, {
      fromPoints: function (env) {
        console.warn(
          "THREE.Path: .fromPoints() has been renamed to .setFromPoints().",
        ),
          this.setFromPoints(env);
      },
    }),
    (zx.prototype = Object.create(Zv.prototype)),
    Object.assign(zx.prototype, {
      initFromArray: function () {
        console.error("THREE.Spline: .initFromArray() has been removed.");
      },
      getControlPointsArray: function () {
        console.error(
          "THREE.Spline: .getControlPointsArray() has been removed.",
        );
      },
      reparametrizeByArcLength: function () {
        console.error(
          "THREE.Spline: .reparametrizeByArcLength() has been removed.",
        );
      },
    }),
    (Lx.prototype.setColors = function () {
      console.error(
        "THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.",
      );
    }),
    (Ex.prototype.update = function () {
      console.error(
        "THREE.SkeletonHelper: update() no longer needs to be called.",
      );
    }),
    Object.assign(Vy.prototype, {
      extractUrlBase: function (env) {
        return (
          console.warn(
            "THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.",
          ),
          Xy(env)
        );
      },
    }),
    Object.assign(Wy.prototype, {
      setTexturePath: function (env) {
        return (
          console.warn(
            "THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath().",
          ),
          this.setResourcePath(env)
        );
      },
    }),
    Object.assign(XCoordinateArray.prototype, {
      center: function (env) {
        return (
          console.warn(
            "THREE.Box2: .center() has been renamed to .getCenter().",
          ),
          this.getCenter(env)
        );
      },
      empty: function () {
        return (
          console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (env) {
        return (
          console.warn(
            "THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().",
          ),
          this.intersectsBox(env)
        );
      },
      size: function (env) {
        return (
          console.warn("THREE.Box2: .size() has been renamed to .getSize()."),
          this.getSize(env)
        );
      },
    }),
    Object.assign(ju.prototype, {
      center: function (env) {
        return (
          console.warn(
            "THREE.Box3: .center() has been renamed to .getCenter().",
          ),
          this.getCenter(env)
        );
      },
      empty: function () {
        return (
          console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (env) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().",
          ),
          this.intersectsBox(env)
        );
      },
      isIntersectionSphere: function (env) {
        return (
          console.warn(
            "THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().",
          ),
          this.intersectsSphere(env)
        );
      },
      size: function (env) {
        return (
          console.warn("THREE.Box3: .size() has been renamed to .getSize()."),
          this.getSize(env)
        );
      },
    }),
    (bx.prototype.center = function (env) {
      return (
        console.warn(
          "THREE.Line3: .center() has been renamed to .getCenter().",
        ),
        this.getCenter(env)
      );
    }),
    Object.assign(fu, {
      random16: function () {
        return (
          console.warn(
            "THREE.Math: .random16() has been deprecated. Use Math.random() instead.",
          ),
          Math.random()
        );
      },
      nearestPowerOfTwo: function (env) {
        return (
          console.warn(
            "THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().",
          ),
          fu.floorPowerOfTwo(env)
        );
      },
      nextPowerOfTwo: function (env) {
        return (
          console.warn(
            "THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().",
          ),
          fu.ceilPowerOfTwo(env)
        );
      },
    }),
    Object.assign(_u.prototype, {
      flattenToArrayOffset: function (env, t) {
        return (
          console.warn(
            "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.",
          ),
          this.toArray(env, t)
        );
      },
      multiplyVector3: function (env) {
        return (
          console.warn(
            "THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.",
          ),
          env.applyMatrix3(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          "THREE.Matrix3: .multiplyVector3Array() has been removed.",
        );
      },
      applyToBuffer: function (env) {
        return (
          console.warn(
            "THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.",
          ),
          this.applyToBufferAttribute(env)
        );
      },
      applyToVector3Array: function () {
        console.error(
          "THREE.Matrix3: .applyToVector3Array() has been removed.",
        );
      },
    }),
    Object.assign(gu.prototype, {
      extractPosition: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().",
          ),
          this.copyPosition(env)
        );
      },
      flattenToArrayOffset: function (env, t) {
        return (
          console.warn(
            "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.",
          ),
          this.toArray(env, t)
        );
      },
      getPosition: function () {
        return (
          void 0 === sx && (sx = new yu()),
          console.warn(
            "THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.",
          ),
          sx.setFromMatrixColumn(this, 3)
        );
      },
      setRotationFromQuaternion: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().",
          ),
          this.makeRotationFromQuaternion(env)
        );
      },
      multiplyToArray: function () {
        console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
      },
      multiplyVector3: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.",
          ),
          env.applyMatrix4(this)
        );
      },
      multiplyVector4: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.",
          ),
          env.applyMatrix4(this)
        );
      },
      multiplyVector3Array: function () {
        console.error(
          "THREE.Matrix4: .multiplyVector3Array() has been removed.",
        );
      },
      rotateAxis: function (env) {
        console.warn(
          "THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.",
        ),
          env.transformDirection(this);
      },
      crossVector: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.",
          ),
          env.applyMatrix4(this)
        );
      },
      translate: function () {
        console.error("THREE.Matrix4: .translate() has been removed.");
      },
      rotateX: function () {
        console.error("THREE.Matrix4: .rotateX() has been removed.");
      },
      rotateY: function () {
        console.error("THREE.Matrix4: .rotateY() has been removed.");
      },
      rotateZ: function () {
        console.error("THREE.Matrix4: .rotateZ() has been removed.");
      },
      rotateByAxis: function () {
        console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
      },
      applyToBuffer: function (env) {
        return (
          console.warn(
            "THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.",
          ),
          this.applyToBufferAttribute(env)
        );
      },
      applyToVector3Array: function () {
        console.error(
          "THREE.Matrix4: .applyToVector3Array() has been removed.",
        );
      },
      makeFrustum: function (env, t, i, n, r, a) {
        return (
          console.warn(
            "THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.",
          ),
          this.makePerspective(env, t, n, i, r, a)
        );
      },
    }),
    (Xu.prototype.isIntersectionLine = function (env) {
      return (
        console.warn(
          "THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().",
        ),
        this.intersectsLine(env)
      );
    }),
    (vu.prototype.multiplyVector3 = function (env) {
      return (
        console.warn(
          "THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.",
        ),
        env.applyQuaternion(this)
      );
    }),
    Object.assign(Bd.prototype, {
      isIntersectionBox: function (env) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().",
          ),
          this.intersectsBox(env)
        );
      },
      isIntersectionPlane: function (env) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().",
          ),
          this.intersectsPlane(env)
        );
      },
      isIntersectionSphere: function (env) {
        return (
          console.warn(
            "THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().",
          ),
          this.intersectsSphere(env)
        );
      },
    }),
    Object.assign(Hd.prototype, {
      area: function () {
        return (
          console.warn(
            "THREE.Triangle: .area() has been renamed to .getArea().",
          ),
          this.getArea()
        );
      },
      barycoordFromPoint: function (env, t) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().",
          ),
          this.getBarycoord(env, t)
        );
      },
      midpoint: function (env) {
        return (
          console.warn(
            "THREE.Triangle: .midpoint() has been renamed to .getMidpoint().",
          ),
          this.getMidpoint(env)
        );
      },
      normal: function (env) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal().",
          ),
          this.getNormal(env)
        );
      },
      plane: function (env) {
        return (
          console.warn(
            "THREE.Triangle: .plane() has been renamed to .getPlane().",
          ),
          this.getPlane(env)
        );
      },
    }),
    Object.assign(Hd, {
      barycoordFromPoint: function (env, t, i, n, r) {
        return (
          console.warn(
            "THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().",
          ),
          Hd.getBarycoord(env, t, i, n, r)
        );
      },
      normal: function (env, t, i, n) {
        return (
          console.warn(
            "THREE.Triangle: .normal() has been renamed to .getNormal().",
          ),
          Hd.getNormal(env, t, i, n)
        );
      },
    }),
    Object.assign(cy.prototype, {
      extractAllPoints: function (env) {
        return (
          console.warn(
            "THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.",
          ),
          this.extractPoints(env)
        );
      },
      extrude: function (env) {
        return (
          console.warn(
            "THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.",
          ),
          new ev(this, env)
        );
      },
      makeGeometry: function (env) {
        return (
          console.warn(
            "THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.",
          ),
          new pv(this, env)
        );
      },
    }),
    Object.assign(mu.prototype, {
      fromAttribute: function (env, t, i) {
        return (
          console.warn(
            "THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().",
          ),
          this.fromBufferAttribute(env, t, i)
        );
      },
      distanceToManhattan: function (env) {
        return (
          console.warn(
            "THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().",
          ),
          this.manhattanDistanceTo(env)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().",
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(yu.prototype, {
      setEulerFromRotationMatrix: function () {
        console.error(
          "THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.",
        );
      },
      setEulerFromQuaternion: function () {
        console.error(
          "THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.",
        );
      },
      getPositionFromMatrix: function (env) {
        return (
          console.warn(
            "THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().",
          ),
          this.setFromMatrixPosition(env)
        );
      },
      getScaleFromMatrix: function (env) {
        return (
          console.warn(
            "THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().",
          ),
          this.setFromMatrixScale(env)
        );
      },
      getColumnFromMatrix: function (env, t) {
        return (
          console.warn(
            "THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().",
          ),
          this.setFromMatrixColumn(t, env)
        );
      },
      applyProjection: function (env) {
        return (
          console.warn(
            "THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( ModuleMeta ) instead.",
          ),
          this.applyMatrix4(env)
        );
      },
      fromAttribute: function (env, t, i) {
        return (
          console.warn(
            "THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().",
          ),
          this.fromBufferAttribute(env, t, i)
        );
      },
      distanceToManhattan: function (env) {
        return (
          console.warn(
            "THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().",
          ),
          this.manhattanDistanceTo(env)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().",
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(zu.prototype, {
      fromAttribute: function (env, t, i) {
        return (
          console.warn(
            "THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().",
          ),
          this.fromBufferAttribute(env, t, i)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            "THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().",
          ),
          this.manhattanLength()
        );
      },
    }),
    Object.assign(Up.prototype, {
      computeTangents: function () {
        console.error("THREE.Geometry: .computeTangents() has been removed.");
      },
      computeLineDistances: function () {
        console.error(
          "THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.",
        );
      },
    }),
    Object.assign(Pp.prototype, {
      getChildByName: function (env) {
        return (
          console.warn(
            "THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().",
          ),
          this.getObjectByName(env)
        );
      },
      renderDepth: function () {
        console.warn(
          "THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.",
        );
      },
      translate: function (env, t) {
        return (
          console.warn(
            "THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.",
          ),
          this.translateOnAxis(t, env)
        );
      },
      getWorldRotation: function () {
        console.error(
          "THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.",
        );
      },
    }),
    Object.defineProperties(Pp.prototype, {
      eulerOrder: {
        get: function () {
          return (
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
          );
        },
        set: function (env) {
          console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            (this.rotation.order = env);
        },
      },
      useQuaternion: {
        get: function () {
          console.warn(
            "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.",
          );
        },
        set: function () {
          console.warn(
            "THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.",
          );
        },
      },
    }),
    Object.defineProperties(Jm.prototype, {
      objects: {
        get: function () {
          return (
            console.warn("THREE.LOD: .objects has been renamed to .levels."),
            this.levels
          );
        },
      },
    }),
    Object.defineProperty(Km.prototype, "useVertexTexture", {
      get: function () {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
      set: function () {
        console.warn("THREE.Skeleton: useVertexTexture has been removed.");
      },
    }),
    Object.defineProperty(Gv.prototype, "__arcLengthDivisions", {
      get: function () {
        return (
          console.warn(
            "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.",
          ),
          this.arcLengthDivisions
        );
      },
      set: function (env) {
        console.warn(
          "THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.",
        ),
          (this.arcLengthDivisions = env);
      },
    }),
    (zm.prototype.setLens = function (env, t) {
      console.warn(
        "THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.",
      ),
        void 0 !== t && (this.filmGauge = t),
        this.setFocalLength(env);
    }),
    Object.defineProperties(uy.prototype, {
      onlyShadow: {
        set: function () {
          console.warn("THREE.Light: .onlyShadow has been removed.");
        },
      },
      shadowCameraFov: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraFov is now .shadow.camera.fov.",
          ),
            (this.shadow.camera.fov = env);
        },
      },
      shadowCameraLeft: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraLeft is now .shadow.camera.left.",
          ),
            (this.shadow.camera.left = env);
        },
      },
      shadowCameraRight: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraRight is now .shadow.camera.right.",
          ),
            (this.shadow.camera.right = env);
        },
      },
      shadowCameraTop: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraTop is now .shadow.camera.top.",
          ),
            (this.shadow.camera.top = env);
        },
      },
      shadowCameraBottom: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.",
          ),
            (this.shadow.camera.bottom = env);
        },
      },
      shadowCameraNear: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraNear is now .shadow.camera.near.",
          ),
            (this.shadow.camera.near = env);
        },
      },
      shadowCameraFar: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowCameraFar is now .shadow.camera.far.",
          ),
            (this.shadow.camera.far = env);
        },
      },
      shadowCameraVisible: {
        set: function () {
          console.warn(
            "THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.",
          );
        },
      },
      shadowBias: {
        set: function (env) {
          console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            (this.shadow.bias = env);
        },
      },
      shadowDarkness: {
        set: function () {
          console.warn("THREE.Light: .shadowDarkness has been removed.");
        },
      },
      shadowMapWidth: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.",
          ),
            (this.shadow.mapSize.width = env);
        },
      },
      shadowMapHeight: {
        set: function (env) {
          console.warn(
            "THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.",
          ),
            (this.shadow.mapSize.height = env);
        },
      },
    }),
    Object.defineProperties(Dp.prototype, {
      length: {
        get: function () {
          return (
            console.warn(
              "THREE.BufferAttribute: .length has been deprecated. Use .count instead.",
            ),
            this.array.length
          );
        },
      },
      copyIndicesArray: function () {
        console.error(
          "THREE.BufferAttribute: .copyIndicesArray() has been removed.",
        );
      },
    }),
    Object.assign(StateDetector.prototype, {
      addIndex: function (env) {
        console.warn(
          "THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().",
        ),
          this.setIndex(env);
      },
      addDrawCall: function (env, t, i) {
        void 0 !== i &&
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.",
          ),
          console.warn(
            "THREE.BufferGeometry: .addDrawCall() is now .addGroup().",
          ),
          this.addGroup(env, t);
      },
      clearDrawCalls: function () {
        console.warn(
          "THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().",
        ),
          this.clearGroups();
      },
      computeTangents: function () {
        console.warn(
          "THREE.BufferGeometry: .computeTangents() has been removed.",
        );
      },
      computeOffsets: function () {
        console.warn(
          "THREE.BufferGeometry: .computeOffsets() has been removed.",
        );
      },
    }),
    Object.defineProperties(StateDetector.prototype, {
      drawcalls: {
        get: function () {
          return (
            console.error(
              "THREE.BufferGeometry: .drawcalls has been renamed to .groups.",
            ),
            this.groups
          );
        },
      },
      offsets: {
        get: function () {
          return (
            console.warn(
              "THREE.BufferGeometry: .offsets has been renamed to .groups.",
            ),
            this.groups
          );
        },
      },
    }),
    Object.assign(tv.prototype, {
      getArrays: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .getArrays() has been removed.",
        );
      },
      addShapeList: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.",
        );
      },
      addShape: function () {
        console.error(
          "THREE.ExtrudeBufferGeometry: .addShape() has been removed.",
        );
      },
    }),
    Object.defineProperties(dx.prototype, {
      dynamic: {
        set: function () {
          console.warn(
            "THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.",
          );
        },
      },
      onUpdate: {
        value: function () {
          return (
            console.warn(
              "THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.",
            ),
            this
          );
        },
      },
    }),
    Object.defineProperties(Dd.prototype, {
      wrapAround: {
        get: function () {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
        set: function () {
          console.warn("THREE.Material: .wrapAround has been removed.");
        },
      },
      wrapRGB: {
        get: function () {
          return (
            console.warn("THREE.Material: .wrapRGB has been removed."), new $GlobalReference()
          );
        },
      },
      shading: {
        get: function () {
          console.error(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead.",
          );
        },
        set: function (env) {
          console.warn(
            "THREE." +
              this.type +
              ": .shading has been removed. Use the boolean .flatShading instead.",
          ),
            (this.flatShading = 1 === env);
        },
      },
    }),
    Object.defineProperties(Mv.prototype, {
      metal: {
        get: function () {
          return (
            console.warn(
              "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.",
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            "THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead",
          );
        },
      },
    }),
    Object.defineProperties(ZoneDescriptor.prototype, {
      derivatives: {
        get: function () {
          return (
            console.warn(
              "THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.",
            ),
            this.extensions.derivatives
          );
        },
        set: function (env) {
          console.warn(
            "THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.",
          ),
            (this.extensions.derivatives = env);
        },
      },
    }),
Object.assign(jm.prototype, {
  // متد .clearTarget منسوخ شده است. حالا باید از .setRenderTarget() و .clear() استفاده کنید.
  clearTarget: function (env, t, i, n) {
    console.warn(
      "THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."
    );
    this.setRenderTarget(env); // تنظیم هدف رندر
    this.clear(t, i, n); // پاکسازی
  },

  // متد .animate تغییر کرده و اکنون باید از .setAnimationLoop() استفاده کنید.
  animate: function (env) {
    console.warn(
      "THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."
    );
    this.setAnimationLoop(env); // تنظیم حلقه انیمیشن
  },

  // متد .getCurrentRenderTarget تغییر کرده و اکنون باید از .getRenderTarget() استفاده کنید.
  getCurrentRenderTarget: function () {
    console.warn(
      "THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."
    );
    return this.getRenderTarget(); // دریافت هدف رندر
  },

  // متد .getMaxAnisotropy تغییر کرده و اکنون باید از .capabilities.getMaxAnisotropy() استفاده کنید.
  getMaxAnisotropy: function () {
    console.warn(
      "THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."
    );
    return this.capabilities.getMaxAnisotropy(); // دریافت بیشترین آنیزوتروپی
  },

  // متد .getPrecision تغییر کرده و اکنون باید از .capabilities.precision استفاده کنید.
  getPrecision: function () {
    console.warn(
      "THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."
    );
    return this.capabilities.precision; // دریافت دقت
  },

  // متد .resetGLState تغییر کرده و اکنون باید از .state.reset() استفاده کنید.
  resetGLState: function () {
    console.warn(
      "THREE.WebGLRenderer: .resetGLState() is now .state.reset()."
    );
    this.state.reset(); // ریست کردن وضعیت
  },

  // متد .supportsFloatTextures تغییر کرده و اکنون باید از .extensions.get( 'OES_texture_float' ) استفاده کنید.
  supportsFloatTextures: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
    );
    return this.extensions.get("OES_texture_float"); // پشتیبانی از تکسچرهای شناور
  },

  // متد .supportsHalfFloatTextures تغییر کرده و اکنون باید از .extensions.get( 'OES_texture_half_float' ) استفاده کنید.
  supportsHalfFloatTextures: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
    );
    return this.extensions.get("OES_texture_half_float"); // پشتیبانی از تکسچرهای نصف شناور
  },

  // متد .supportsStandardDerivatives تغییر کرده و اکنون باید از .extensions.get( 'OES_standard_derivatives' ) استفاده کنید.
  supportsStandardDerivatives: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
    );
    return this.extensions.get("OES_standard_derivatives"); // پشتیبانی از مشتقات استاندارد
  },

  // متد .supportsCompressedTextureS3TC تغییر کرده و اکنون باید از .extensions.get( 'WEBGL_compressed_texture_s3tc' ) استفاده کنید.
  supportsCompressedTextureS3TC: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
    );
    return this.extensions.get("WEBGL_compressed_texture_s3tc"); // پشتیبانی از تکسچرهای فشرده S3TC
  },

  // متد .supportsCompressedTexturePVRTC تغییر کرده و اکنون باید از .extensions.get( 'WEBGL_compressed_texture_pvrtc' ) استفاده کنید.
  supportsCompressedTexturePVRTC: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
    );
    return this.extensions.get("WEBGL_compressed_texture_pvrtc"); // پشتیبانی از تکسچرهای فشرده PVRTC
  },

  // متد .supportsBlendMinMax تغییر کرده و اکنون باید از .extensions.get( 'EXT_blend_minmax' ) استفاده کنید.
  supportsBlendMinMax: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
    );
    return this.extensions.get("EXT_blend_minmax"); // پشتیبانی از ترکیب MinMax
  },

  // متد .supportsVertexTextures تغییر کرده و اکنون باید از .capabilities.vertexTextures استفاده کنید.
  supportsVertexTextures: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."
    );
    return this.capabilities.vertexTextures; // پشتیبانی از تکسچرهای ورتکس
  },

  // متد .supportsInstancedArrays تغییر کرده و اکنون باید از .extensions.get( 'ANGLE_instanced_arrays' ) استفاده کنید.
  supportsInstancedArrays: function () {
    console.warn(
      "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
    );
    return this.extensions.get("ANGLE_instanced_arrays"); // پشتیبانی از آرایه‌های نمونه‌برداری
  },

  // متد .enableScissorTest تغییر کرده و اکنون باید از .setScissorTest() استفاده کنید.
  enableScissorTest: function (env) {
    console.warn(
      "THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."
    );
    this.setScissorTest(env); // فعال‌سازی تست قیچی
  },

  // متد .initMaterial حذف شده است.
  initMaterial: function () {
    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
  },

  // متد .addPrePlugin حذف شده است.
  addPrePlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
  },

  // متد .addPostPlugin حذف شده است.
  addPostPlugin: function () {
    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
  },

  // متد .updateShadowMap حذف شده است.
  updateShadowMap: function () {
    console.warn(
      "THREE.WebGLRenderer: .updateShadowMap() has been removed."
    );
  },

  // متد .setFaceCulling حذف شده است.
  setFaceCulling: function () {
    console.warn(
      "THREE.WebGLRenderer: .setFaceCulling() has been removed."
    );
  },
}),

// تعریف ویژگی‌های جدید برای shadowMap
Object.defineProperties(jm.prototype, {
  shadowMapEnabled: {
    get: function () {
      return this.shadowMap.enabled;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."
      );
      this.shadowMap.enabled = env; // فعال‌سازی نقشه سایه
    },
  },

  shadowMapType: {
    get: function () {
      return this.shadowMap.type;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."
      );
      this.shadowMap.type = env; // نوع نقشه سایه
    },
  },

  // ویژگی .shadowMapCullFace حذف شده است و اکنون باید Material.shadowSide را تنظیم کنید.
  shadowMapCullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },
}),

// ویژگی‌های shadowMap برای Om (کلاس دیگر) نیز تغییر کرده است.
Object.defineProperties(Om.prototype, {
  cullFace: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead."
      );
    },
  },

  renderReverseSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead."
      );
    },
  },

  renderSingleSided: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
    set: function () {
      console.warn(
        "THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead."
      );
    },
  },
}),

Object.defineProperties(Bu.prototype, {
  // ویژگی wrapS به texture.wrapS تغییر یافته است
  wrapS: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
      );
      return this.texture.wrapS;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."
      );
      this.texture.wrapS = env;
    },
  },
  // ویژگی wrapT به texture.wrapT تغییر یافته است
  wrapT: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
      );
      return this.texture.wrapT;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."
      );
      this.texture.wrapT = env;
    },
  },
  // ویژگی magFilter به texture.magFilter تغییر یافته است
  magFilter: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      );
      return this.texture.magFilter;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."
      );
      this.texture.magFilter = env;
    },
  },
  // ویژگی minFilter به texture.minFilter تغییر یافته است
  minFilter: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      );
      return this.texture.minFilter;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."
      );
      this.texture.minFilter = env;
    },
  },
  // ویژگی anisotropy به texture.anisotropy تغییر یافته است
  anisotropy: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      );
      return this.texture.anisotropy;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."
      );
      this.texture.anisotropy = env;
    },
  },
  // ویژگی offset به texture.offset تغییر یافته است
  offset: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .offset is now .texture.offset."
      );
      return this.texture.offset;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .offset is now .texture.offset."
      );
      this.texture.offset = env;
    },
  },
  // ویژگی repeat به texture.repeat تغییر یافته است
  repeat: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
      );
      return this.texture.repeat;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .repeat is now .texture.repeat."
      );
      this.texture.repeat = env;
    },
  },
  // ویژگی format به texture.format تغییر یافته است
  format: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .format is now .texture.format."
      );
      return this.texture.format;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .format is now .texture.format."
      );
      this.texture.format = env;
    },
  },
  // ویژگی type به texture.type تغییر یافته است
  type: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .type is now .texture.type."
      );
      return this.texture.type;
    },
    set: function (env) {
      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
      this.texture.type = env;
    },
  },
  // ویژگی generateMipmaps به texture.generateMipmaps تغییر یافته است
  generateMipmaps: {
    get: function () {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      );
      return this.texture.generateMipmaps;
    },
    set: function (env) {
      console.warn(
        "THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."
      );
      this.texture.generateMipmaps = env;
    },
  },
}),
Object.defineProperties(Hm.prototype, {
  // هشدار برای ویژگی standing که حذف شده است
  standing: {
    set: function () {
      console.warn("THREE.WebVRManager: .standing has been removed.");
    },
  },
  // هشدار برای ویژگی userHeight که حذف شده است
  userHeight: {
    set: function () {
      console.warn("THREE.WebVRManager: .userHeight has been removed.");
    },
  },
}),
(w_.prototype.load = function (env) {
  console.warn(
    "THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."
  );
  var t = this;
  return (
    new __().load(env, function (env) {
      t.setBuffer(env);
    }),
    this
  );
}),
(S_.prototype.getData = function () {
  return (
    console.warn(
      "THREE.AudioAnalyser: .getData() is now .getFrequencyData()."
    ),
    this.getFrequencyData()
  );
}),
(x_.prototype.updateCubeMap = function (env, t) {
  return (
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),
    this.update(env, t)
  );
}),
(ku.crossOrigin = void 0),
(ku.loadTexture = function (env, t, i, n) {
  console.warn(
    "THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."
  );
  var r = new Hv();
  r.setCrossOrigin(this.crossOrigin);
  var a = r.load(env, i, void 0, n);
  return t && (a.mapping = t), a;
}),
(ku.loadTextureCube = function (env, t, i, n) {
  console.warn(
    "THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."
  );
  var r = new Bv();
  r.setCrossOrigin(this.crossOrigin);
  var a = r.load(env, i, void 0, n);
  return t && (a.mapping = t), a;
}),
(ku.loadCompressedTexture = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead."
  );
}),
(ku.loadCompressedTextureCube = function () {
  console.error(
    "THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead."
  );
});

// تعریف یک شیء جدید با شیدر ساده برای نمایش تصویر
var Bx = {
  uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
  vertexShader: [
    "varying vec2 vUv;",
    "void main() {",
    "vUv = uv;",
    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
    "}",
  ].join("\n"),
  fragmentShader: [
    "uniform float opacity;",
    "uniform sampler2D tDiffuse;",
    "varying vec2 vUv;",
    "void main() {",
    "vec4 texel = texture2D( tDiffuse, vUv );",
    "gl_FragColor = opacity * texel;",
    "}",
  ].join("\n"),
};


  function Hx() {
    (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }

  function Gx(env, t) {
    Hx.call(this),
      (this.textureID = void 0 !== t ? t : "tDiffuse"),
      env instanceof ZoneDescriptor
        ? ((this.uniforms = env.uniforms), (this.material = env))
        : env &&
          ((this.uniforms = Ju.clone(env.uniforms)),
          (this.material = new ZoneDescriptor({
            defines: Object.assign({}, env.defines),
            uniforms: this.uniforms,
            vertexShader: env.vertexShader,
            fragmentShader: env.fragmentShader,
          }))),
      (this.camera = new vy(-1, 1, 1, -1, 0, 1)),
      (this.scene = new Wm()),
      (this.quad = new JobDispatcher(new UpdateDispatcher(2, 2), null)),
      (this.quad.frustumCulled = !1),
      this.scene.add(this.quad);
  }

  function jx(env, t) {
    Hx.call(this),
      (this.scene = env),
      (this.camera = t),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }

  function Vx() {
    Hx.call(this), (this.needsSwap = !1);
  }

  function Xx(env, t) {
    if (((this.renderer = env), void 0 === t)) {
      var i = { minFilter: LineCounter, magFilter: LineCounter, format: Ec, stencilBuffer: !1 },
        n = env.getDrawingBufferSize();
      (t = new Bu(n.width, n.height, i)).texture.name = "EffectComposer.rt1";
    }
    (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.passes = []),
      void 0 === Bx &&
        console.error("THREE.EffectComposer relies on THREE.CopyShader"),
      void 0 === Gx &&
        console.error("THREE.EffectComposer relies on THREE.ShaderPass"),
      (this.copyPass = new Gx(Bx));
  }

  function Wx(env, t, i, n, r) {
    Hx.call(this),
      (this.scene = env),
      (this.camera = t),
      (this.overrideMaterial = i),
      (this.clearColor = n),
      (this.clearAlpha = void 0 !== r ? r : 0),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1);
  }

  Object.assign(Hx.prototype, {
    setSize: function (env, t) {},
    render: function (env, t, i, n, r) {
      console.error(
        "THREE.Pass: .render() must be implemented in derived pass.",
      );
    },
  }),
    (Gx.prototype = Object.assign(Object.create(Hx.prototype), {
      constructor: Gx,
      render: function (env, t, i, n, r) {
        this.uniforms[this.textureID] &&
          (this.uniforms[this.textureID].value = i.texture),
          (this.quad.material = this.material),
          this.renderToScreen
            ? env.render(this.scene, this.camera)
            : env.render(this.scene, this.camera, t, this.clear);
      },
    })),
    (jx.prototype = Object.assign(Object.create(Hx.prototype), {
      constructor: jx,
      render: function (env, t, i, n, r) {
        var a,
ObjectMethodWrapper,
CounterVariable = env.context, // دسترسی به کانتکست محیط گرافیکی
RandomGenerator = env.state;  // دسترسی به وضعیت محیط

// غیرفعال کردن ماسک برای بافر رنگ و عمق
RandomGenerator.buffers.color.setMask(!1),
RandomGenerator.buffers.depth.setMask(!1),

// قفل کردن بافرهای رنگ و عمق به منظور جلوگیری از تغییرات غیرمجاز
RandomGenerator.buffers.color.setLocked(!0),
RandomGenerator.buffers.depth.setLocked(!0),

// تنظیم مقدار متغیر برای استفاده در حالت معکوس (inverse)
(ObjectMethodWrapper = this.inverse ? ((a = 0), 1) : ((a = 1), 0)),

// تنظیم تست استنسیل و عملیات روی آن
RandomGenerator.buffers.stencil.setTest(!0),
RandomGenerator.buffers.stencil.setOp(CounterVariable.REPLACE, CounterVariable.REPLACE, CounterVariable.REPLACE),

// تنظیم تابع برای استنسیل (در اینجا همیشه معتبر است)
RandomGenerator.buffers.stencil.setFunc(CounterVariable.ALWAYS, a, 4294967295),

// پاکسازی بافر استنسیل با استفاده از مقدار تنظیم‌شده
RandomGenerator.buffers.stencil.setClear(ObjectMethodWrapper),

// رندر کردن صحنه با دوربین و اعمال تنظیمات مربوطه
env.render(this.scene, this.camera, i, this.clear),
env.render(this.scene, this.camera, t, this.clear),

// آزادسازی قفل‌ها از بافرهای رنگ و عمق
RandomGenerator.buffers.color.setLocked(!1),
RandomGenerator.buffers.depth.setLocked(!1),

// تنظیم مجدد عملکرد استنسیل به حالت مقایسه با مقدار 1
RandomGenerator.buffers.stencil.setFunc(CounterVariable.EQUAL, 1, 4294967295),

// حفظ عملیات استنسیل
RandomGenerator.buffers.stencil.setOp(CounterVariable.KEEP, CounterVariable.KEEP, CounterVariable.KEEP);

      },
    })),
    (Vx.prototype = Object.create(Hx.prototype)),
    Object.assign(Vx.prototype, {
      render: function (env, t, i, n, r) {
        env.state.buffers.stencil.setTest(!1);
      },
    }),
    Object.assign(Xx.prototype, {
      swapBuffers: function () {
        var env = this.readBuffer;
        (this.readBuffer = this.writeBuffer), (this.writeBuffer = env);
      },
      addPass: function (env) {
        this.passes.push(env);
        var t = this.renderer.getDrawingBufferSize();
        env.setSize(t.width, t.height);
      },
      insertPass: function (env, t) {
        this.passes.splice(t, 0, env);
      },
      render: function (env) {
        var t,
          i,
          n = !1,
          r = this.passes.length;
        for (i = 0; i < r; i++)
          if (!1 !== (t = this.passes[i]).enabled) {
            if (
              (t.render(this.renderer, this.writeBuffer, this.readBuffer, env, n),
              t.needsSwap)
            ) {
              if (n) {
                var a = this.renderer.context;
                a.stencilFunc(a.NOTEQUAL, 1, 4294967295),
                  this.copyPass.render(
                    this.renderer,
                    this.writeBuffer,
                    this.readBuffer,
                    env,
                  ),
                  a.stencilFunc(a.EQUAL, 1, 4294967295);
              }
              this.swapBuffers();
            }
            void 0 !== jx &&
              (t instanceof jx ? (n = !0) : t instanceof Vx && (n = !1));
          }
      },
      reset: function (env) {
        if (void 0 === env) {
          var t = this.renderer.getDrawingBufferSize();
          (env = this.renderTarget1.clone()).setSize(t.width, t.height);
        }
        this.renderTarget1.dispose(),
          this.renderTarget2.dispose(),
          (this.renderTarget1 = env),
          (this.renderTarget2 = env.clone()),
          (this.writeBuffer = this.renderTarget1),
          (this.readBuffer = this.renderTarget2);
      },
      setSize: function (env, t) {
        this.renderTarget1.setSize(env, t), this.renderTarget2.setSize(env, t);
        for (var i = 0; i < this.passes.length; i++)
          this.passes[i].setSize(env, t);
      },
    }),
    (Wx.prototype = Object.assign(Object.create(Hx.prototype), {
      constructor: Wx,
      render: function (env, t, i, n, r) {
        var a,
ObjectMethodWrapper,
CounterVariable = env.autoClear; // ذخیره وضعیت اولیه autoClear

// غیرفعال کردن autoClear برای جلوگیری از پاکسازی خودکار محیط گرافیکی
(env.autoClear = !1),

// تنظیم متریال جایگزین برای صحنه
(this.scene.overrideMaterial = this.overrideMaterial),

// بررسی و اعمال رنگ پس‌زمینه (clearColor) در صورت تنظیم بودن
this.clearColor &&
  ((a = env.getClearColor().getHex()), // ذخیره رنگ قبلی
  (ObjectMethodWrapper = env.getClearAlpha()), // ذخیره مقدار آلفا قبلی
  env.setClearColor(this.clearColor, this.clearAlpha)), // اعمال رنگ جدید برای پس‌زمینه

// پاک کردن عمق (در صورتی که لازم باشد)
this.clearDepth && env.clearDepth(),

// رندر کردن صحنه با استفاده از دوربین و شرایط مختلف
env.render(
  this.scene,
  this.camera,
  this.renderToScreen ? null : i, // در صورت لزوم نمایش به صورت مستقیم یا در بافر
  this.clear, // استفاده از تنظیمات مربوط به پاکسازی
),

// بازگشت به رنگ قبلی پس‌زمینه
this.clearColor && env.setClearColor(a, ObjectMethodWrapper),

// غیرفعال کردن متریال جایگزین
(this.scene.overrideMaterial = null),

// بازگرداندن وضعیت اولیه autoClear
(env.autoClear = CounterVariable);

      },
    }));
  var Yx = {
    uniforms: {
      tDiffuse: { value: null },
      resolution: { value: new mu(1 / 1024, 1 / 512) },
    },
    vertexShader: [
      "varying vec2 vUv;",
      "void main() {",
      "vUv = uv;",
      "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
      "}",
    ].join("\n"),
    fragmentShader: [
      "precision highp float;",
      "",
      "uniform sampler2D tDiffuse;",
      "",
      "uniform vec2 resolution;",
      "",
      "varying vec2 vUv;",
      "",
      "// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)",
      "",
      "//----------------------------------------------------------------------------------",
      "// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag",
      "// SDK Version: v3.00",
      "// Email:       gameworks@nvidia.com",
      "// Site:        http://developer.nvidia.com/",
      "//",
      "// Copyright (EnsureFunction) 2014-2015, NVIDIA CORPORATION. All rights reserved.",
      "//",
      "// Redistribution and use in source and binary forms, with PromiseResolutionWrapper without",
      "// modification, are permitted provided that the following conditions",
      "// are met:",
      "//  * Redistributions OutputFormatter source code must retain the above copyright",
      "//    notice, this list OutputFormatter conditions and the following disclaimer.",
      "//  * Redistributions in binary form must reproduce the above copyright",
      "//    notice, this list OutputFormatter conditions and the following disclaimer in the",
      "//    documentation and/PromiseResolutionWrapper other materials provided with the distribution.",
      "//  * Neither the name OutputFormatter NVIDIA CORPORATION nor the names OutputFormatter its",
      "//    contributors may be used to endorse PromiseResolutionWrapper promote products derived",
      "//    from this software without specific prior written permission.",
      "//",
      "// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY",
      "// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE",
      "// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR",
      "// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR",
      "// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,",
      "// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,",
      "// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR",
      "// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY",
      "// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT",
      "// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE",
      "// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.",
      "//",
      "//----------------------------------------------------------------------------------",
      "",
      "#define FXAA_PC 1",
      "#define FXAA_GLSL_100 1",
      "#define FXAA_QUALITY_PRESET 12",
      "",
      "#define FXAA_GREEN_AS_LUMA 1",
      "",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_PC_CONSOLE",
      "    //",
      "    // The console algorithm for PC is included",
      "    // for developers targeting really low spec machines.",
      "    // Likely better to just run FXAA_PC, and use a really low preset.",
      "    //",
      "    #define FXAA_PC_CONSOLE 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GLSL_120",
      "    #define FXAA_GLSL_120 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GLSL_130",
      "    #define FXAA_GLSL_130 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_3",
      "    #define FXAA_HLSL_3 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_4",
      "    #define FXAA_HLSL_4 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_HLSL_5",
      "    #define FXAA_HLSL_5 0",
      "#endif",
      "/*==========================================================================*/",
      "#ifndef FXAA_GREEN_AS_LUMA",
      "    //",
      "    // For those using non-linear color,",
      "    // and either not able to get luma in alpha, PromiseResolutionWrapper not wanting to,",
      "    // this enables FXAA to run using green as a proxy for luma.",
      "    // So with this enabled, no need to pack luma in alpha.",
      "    //",
      "    // This will turn off AA on anything which lacks some amount OutputFormatter green.",
      "    // Pure red and blue PromiseResolutionWrapper combination OutputFormatter only R and B, will get no AA.",
      "    //",
      "    // Might want to lower the settings for both,",
      "    //    fxaaConsoleEdgeThresholdMin",
      "    //    fxaaQualityEdgeThresholdMin",
      "    // In order to insure AA does not get turned off on colors",
      "    // which contain a minor amount OutputFormatter green.",
      "    //",
      "    // 1 = MessageHandler.",
      "    // 0 = Off.",
      "    //",
      "    #define FXAA_GREEN_AS_LUMA 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_EARLY_EXIT",
      "    //",
      "    // Controls algorithm'CounterVariable early exit path.",
      "    // MessageHandler PS3 turning this ON adds 2 cycles to the shader.",
      "    // MessageHandler 360 turning this OFF adds 10ths OutputFormatter a millisecond to the shader.",
      "    // Turning this off on console will result in a more blurry image.",
      "    // So this defaults to on.",
      "    //",
      "    // 1 = MessageHandler.",
      "    // 0 = Off.",
      "    //",
      "    #define FXAA_EARLY_EXIT 1",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_DISCARD",
      "    //",
      "    // Only valid for PC OpenGL currently.",
      "    // Probably will not work when FXAA_GREEN_AS_LUMA = 1.",
      "    //",
      "    // 1 = Use discard on pixels which don't need AA.",
      "    //     For APIs which enable concurrent TEX+ROP from same surface.",
      "    // 0 = Return unchanged color on pixels which don't need AA.",
      "    //",
      "    #define FXAA_DISCARD 0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_FAST_PIXEL_OFFSET",
      "    //",
      "    // Used for GLSL 120 only.",
      "    //",
      "    // 1 = GL API supports fast pixel offsets",
      "    // 0 = do not use fast pixel offsets",
      "    //",
      "    #ifdef GL_EXT_gpu_shader4",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifdef GL_NV_gpu_shader5",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifdef GL_ARB_gpu_shader5",
      "        #define FXAA_FAST_PIXEL_OFFSET 1",
      "    #endif",
      "    #ifndef FXAA_FAST_PIXEL_OFFSET",
      "        #define FXAA_FAST_PIXEL_OFFSET 0",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#ifndef FXAA_GATHER4_ALPHA",
      "    //",
      "    // 1 = API supports gather4 on alpha channel.",
      "    // 0 = API does not support gather4 on alpha channel.",
      "    //",
      "    #if (FXAA_HLSL_5 == 1)",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifdef GL_ARB_gpu_shader5",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifdef GL_NV_gpu_shader5",
      "        #define FXAA_GATHER4_ALPHA 1",
      "    #endif",
      "    #ifndef FXAA_GATHER4_ALPHA",
      "        #define FXAA_GATHER4_ALPHA 0",
      "    #endif",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "                        FXAA QUALITY - TUNING KNOBS",
      "------------------------------------------------------------------------------",
      "NOTE the other tuning knobs are now in the shader function inputs!",
      "============================================================================*/",
      "#ifndef FXAA_QUALITY_PRESET",
      "    //",
      "    // Choose the quality preset.",
      "    // This needs to be compiled into the shader as it effects code.",
      "    // Best option to include multiple presets is to",
      "    // in each shader define the preset, then include this file.",
      "    //",
      "    // OPTIONS",
      "    // -----------------------------------------------------------------------",
      "    // 10 to 15 - default medium dither (10=fastest, 15=highest quality)",
      "    // 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)",
      "    // 39       - no dither, very expensive",
      "    //",
      "    // NOTES",
      "    // -----------------------------------------------------------------------",
      "    // 12 = slightly faster then FXAA 3.9 and higher edge quality (default)",
      "    // 13 = about same speed as FXAA 3.9 and better than 12",
      "    // 23 = closest to FXAA 3.9 visually and performance wise",
      "    //  _ = the lowest digit is directly related to performance",
      "    // _  = the highest digit is directly related to style",
      "    //",
      "    #define FXAA_QUALITY_PRESET 12",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "",
      "                           FXAA QUALITY - PRESETS",
      "",
      "============================================================================*/",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - MEDIUM DITHER PRESETS",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 10)",
      "    #define FXAA_QUALITY_PS 3",
      "    #define FXAA_QUALITY_P0 1.5",
      "    #define FXAA_QUALITY_P1 3.0",
      "    #define FXAA_QUALITY_P2 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 11)",
      "    #define FXAA_QUALITY_PS 4",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 3.0",
      "    #define FXAA_QUALITY_P3 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 12)",
      "    #define FXAA_QUALITY_PS 5",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 4.0",
      "    #define FXAA_QUALITY_P4 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 13)",
      "    #define FXAA_QUALITY_PS 6",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 4.0",
      "    #define FXAA_QUALITY_P5 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 14)",
      "    #define FXAA_QUALITY_PS 7",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 4.0",
      "    #define FXAA_QUALITY_P6 12.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 15)",
      "    #define FXAA_QUALITY_PS 8",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 4.0",
      "    #define FXAA_QUALITY_P7 12.0",
      "#endif",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - LOW DITHER PRESETS",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 20)",
      "    #define FXAA_QUALITY_PS 3",
      "    #define FXAA_QUALITY_P0 1.5",
      "    #define FXAA_QUALITY_P1 2.0",
      "    #define FXAA_QUALITY_P2 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 21)",
      "    #define FXAA_QUALITY_PS 4",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 22)",
      "    #define FXAA_QUALITY_PS 5",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 23)",
      "    #define FXAA_QUALITY_PS 6",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 24)",
      "    #define FXAA_QUALITY_PS 7",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 3.0",
      "    #define FXAA_QUALITY_P6 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 25)",
      "    #define FXAA_QUALITY_PS 8",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 4.0",
      "    #define FXAA_QUALITY_P7 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 26)",
      "    #define FXAA_QUALITY_PS 9",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 4.0",
      "    #define FXAA_QUALITY_P8 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 27)",
      "    #define FXAA_QUALITY_PS 10",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 4.0",
      "    #define FXAA_QUALITY_P9 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 28)",
      "    #define FXAA_QUALITY_PS 11",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 4.0",
      "    #define FXAA_QUALITY_P10 8.0",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_QUALITY_PRESET == 29)",
      "    #define FXAA_QUALITY_PS 12",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.5",
      "    #define FXAA_QUALITY_P2 2.0",
      "    #define FXAA_QUALITY_P3 2.0",
      "    #define FXAA_QUALITY_P4 2.0",
      "    #define FXAA_QUALITY_P5 2.0",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 2.0",
      "    #define FXAA_QUALITY_P10 4.0",
      "    #define FXAA_QUALITY_P11 8.0",
      "#endif",
      "",
      "/*============================================================================",
      "                     FXAA QUALITY - EXTREME QUALITY",
      "============================================================================*/",
      "#if (FXAA_QUALITY_PRESET == 39)",
      "    #define FXAA_QUALITY_PS 12",
      "    #define FXAA_QUALITY_P0 1.0",
      "    #define FXAA_QUALITY_P1 1.0",
      "    #define FXAA_QUALITY_P2 1.0",
      "    #define FXAA_QUALITY_P3 1.0",
      "    #define FXAA_QUALITY_P4 1.0",
      "    #define FXAA_QUALITY_P5 1.5",
      "    #define FXAA_QUALITY_P6 2.0",
      "    #define FXAA_QUALITY_P7 2.0",
      "    #define FXAA_QUALITY_P8 2.0",
      "    #define FXAA_QUALITY_P9 2.0",
      "    #define FXAA_QUALITY_P10 4.0",
      "    #define FXAA_QUALITY_P11 8.0",
      "#endif",
      "",
      "",
      "",
      "/*============================================================================",
      "",
      "                                API PORTING",
      "",
      "============================================================================*/",
      "#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)",
      "    #define FxaaBool bool",
      "    #define FxaaDiscard discard",
      "    #define FxaaFloat float",
      "    #define FxaaFloat2 vec2",
      "    #define FxaaFloat3 vec3",
      "    #define FxaaFloat4 vec4",
      "    #define FxaaHalf float",
      "    #define FxaaHalf2 vec2",
      "    #define FxaaHalf3 vec3",
      "    #define FxaaHalf4 vec4",
      "    #define FxaaInt2 ivec2",
      "    #define FxaaSat(x) clamp(x, 0.0, 1.0)",
      "    #define FxaaTex sampler2D",
      "#else",
      "    #define FxaaBool bool",
      "    #define FxaaDiscard clip(-1)",
      "    #define FxaaFloat float",
      "    #define FxaaFloat2 float2",
      "    #define FxaaFloat3 float3",
      "    #define FxaaFloat4 float4",
      "    #define FxaaHalf half",
      "    #define FxaaHalf2 half2",
      "    #define FxaaHalf3 half3",
      "    #define FxaaHalf4 half4",
      "    #define FxaaSat(x) saturate(x)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_100 == 1)",
      "  #define FxaaTexTop(t, Property) texture2D(t, Property, 0.0)",
      "  #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) texture2D(t, Property + (ObjectMethodWrapper * r), 0.0)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_120 == 1)",
      "    // Requires,",
      "    //  #version 120",
      "    // And at least,",
      "    //  #extension GL_EXT_gpu_shader4 : enable",
      "    //  (PromiseResolutionWrapper set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)",
      "    #define FxaaTexTop(t, Property) texture2DLod(t, Property, 0.0)",
      "    #if (FXAA_FAST_PIXEL_OFFSET == 1)",
      "        #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) texture2DLodOffset(t, Property, 0.0, ObjectMethodWrapper)",
      "    #else",
      "        #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) texture2DLod(t, Property + (ObjectMethodWrapper * r), 0.0)",
      "    #endif",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        // use #extension GL_ARB_gpu_shader5 : enable",
      "        #define FxaaTexAlpha4(t, Property) textureGather(t, Property, 3)",
      "        #define FxaaTexOffAlpha4(t, Property, ObjectMethodWrapper) textureGatherOffset(t, Property, ObjectMethodWrapper, 3)",
      "        #define FxaaTexGreen4(t, Property) textureGather(t, Property, 1)",
      "        #define FxaaTexOffGreen4(t, Property, ObjectMethodWrapper) textureGatherOffset(t, Property, ObjectMethodWrapper, 1)",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_GLSL_130 == 1)",
      '    // Requires "#version 130" PromiseResolutionWrapper better',
      "    #define FxaaTexTop(t, Property) textureLod(t, Property, 0.0)",
      "    #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) textureLodOffset(t, Property, 0.0, ObjectMethodWrapper)",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        // use #extension GL_ARB_gpu_shader5 : enable",
      "        #define FxaaTexAlpha4(t, Property) textureGather(t, Property, 3)",
      "        #define FxaaTexOffAlpha4(t, Property, ObjectMethodWrapper) textureGatherOffset(t, Property, ObjectMethodWrapper, 3)",
      "        #define FxaaTexGreen4(t, Property) textureGather(t, Property, 1)",
      "        #define FxaaTexOffGreen4(t, Property, ObjectMethodWrapper) textureGatherOffset(t, Property, ObjectMethodWrapper, 1)",
      "    #endif",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_3 == 1)",
      "    #define FxaaInt2 float2",
      "    #define FxaaTex sampler2D",
      "    #define FxaaTexTop(t, Property) tex2Dlod(t, float4(Property, 0.0, 0.0))",
      "    #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) tex2Dlod(t, float4(Property + (ObjectMethodWrapper * r), 0, 0))",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_4 == 1)",
      "    #define FxaaInt2 int2",
      "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
      "    #define FxaaTexTop(t, Property) t.tex.SampleLevel(t.smpl, Property, 0.0)",
      "    #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) t.tex.SampleLevel(t.smpl, Property, 0.0, ObjectMethodWrapper)",
      "#endif",
      "/*--------------------------------------------------------------------------*/",
      "#if (FXAA_HLSL_5 == 1)",
      "    #define FxaaInt2 int2",
      "    struct FxaaTex { SamplerState smpl; Texture2D tex; };",
      "    #define FxaaTexTop(t, Property) t.tex.SampleLevel(t.smpl, Property, 0.0)",
      "    #define FxaaTexOff(t, Property, ObjectMethodWrapper, r) t.tex.SampleLevel(t.smpl, Property, 0.0, ObjectMethodWrapper)",
      "    #define FxaaTexAlpha4(t, Property) t.tex.GatherAlpha(t.smpl, Property)",
      "    #define FxaaTexOffAlpha4(t, Property, ObjectMethodWrapper) t.tex.GatherAlpha(t.smpl, Property, ObjectMethodWrapper)",
      "    #define FxaaTexGreen4(t, Property) t.tex.GatherGreen(t.smpl, Property)",
      "    #define FxaaTexOffGreen4(t, Property, ObjectMethodWrapper) t.tex.GatherGreen(t.smpl, Property, ObjectMethodWrapper)",
      "#endif",
      "",
      "",
      "/*============================================================================",
      "                   GREEN AS LUMA OPTION SUPPORT FUNCTION",
      "============================================================================*/",
      "#if (FXAA_GREEN_AS_LUMA == 0)",
      "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }",
      "#else",
      "    FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }",
      "#endif",
      "",
      "",
      "",
      "",
      "/*============================================================================",
      "",
      "                             FXAA3 QUALITY - PC",
      "",
      "============================================================================*/",
      "#if (FXAA_PC == 1)",
      "/*--------------------------------------------------------------------------*/",
      "FxaaFloat4 FxaaPixelShader(",
      "    //",
      "    // Use noperspective interpolation here (turn off perspective interpolation).",
      "    // {xy} = center OutputFormatter pixel",
      "    FxaaFloat2 pos,",
      "    //",
      "    // Used only for FXAA Console, and not used on the 360 version.",
      "    // Use noperspective interpolation here (turn off perspective interpolation).",
      "    // {xy_} = upper left OutputFormatter pixel",
      "    // {_zw} = lower right OutputFormatter pixel",
      "    FxaaFloat4 fxaaConsolePosPos,",
      "    //",
      "    // Input color texture.",
      "    // {rgb_} = color in linear PromiseResolutionWrapper perceptual color space",
      "    // if (FXAA_GREEN_AS_LUMA == 0)",
      "    //     {__a} = luma in perceptual color space (not linear)",
      "    FxaaTex tex,",
      "    //",
      "    // Only used on the optimized 360 version OutputFormatter FXAA Console.",
      '    // For everything but 360, just use the same input here as for "tex".',
      "    // For 360, same texture, just alias with a 2nd sampler.",
      "    // This sampler needs to have an exponent bias OutputFormatter -1.",
      "    FxaaTex fxaaConsole360TexExpBiasNegOne,",
      "    //",
      "    // Only used on the optimized 360 version OutputFormatter FXAA Console.",
      '    // For everything but 360, just use the same input here as for "tex".',
      "    // For 360, same texture, just alias with a 3nd sampler.",
      "    // This sampler needs to have an exponent bias OutputFormatter -2.",
      "    FxaaTex fxaaConsole360TexExpBiasNegTwo,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This must be from a constant/uniform.",
      "    // {x_} = 1.0/screenWidthInPixels",
      "    // {_y} = 1.0/screenHeightInPixels",
      "    FxaaFloat2 fxaaQualityRcpFrame,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This must be from a constant/uniform.",
      "    // This effects sub-pixel AA quality and inversely sharpness.",
      "    //   Where FindInArray ranges between,",
      "    //     FindInArray = 0.50 (default)",
      "    //     FindInArray = 0.33 (sharper)",
      "    // {x__} = -FindInArray/screenWidthInPixels",
      "    // {_y_} = -FindInArray/screenHeightInPixels",
      "    // {_z_} =  FindInArray/screenWidthInPixels",
      "    // {__w} =  FindInArray/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsoleRcpFrameOpt,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // Not used on 360, but used on PS3 and PC.",
      "    // This must be from a constant/uniform.",
      "    // {x__} = -2.0/screenWidthInPixels",
      "    // {_y_} = -2.0/screenHeightInPixels",
      "    // {_z_} =  2.0/screenWidthInPixels",
      "    // {__w} =  2.0/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsoleRcpFrameOpt2,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // Only used on 360 in place OutputFormatter fxaaConsoleRcpFrameOpt2.",
      "    // This must be from a constant/uniform.",
      "    // {x__} =  8.0/screenWidthInPixels",
      "    // {_y_} =  8.0/screenHeightInPixels",
      "    // {_z_} = -4.0/screenWidthInPixels",
      "    // {__w} = -4.0/screenHeightInPixels",
      "    FxaaFloat4 fxaaConsole360RcpFrameOpt2,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_SUBPIX define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // Choose the amount OutputFormatter sub-pixel aliasing removal.",
      "    // This can effect sharpness.",
      "    //   1.00 - upper limit (softer)",
      "    //   0.75 - default amount OutputFormatter filtering",
      "    //   0.50 - lower limit (sharper, less sub-pixel aliasing removal)",
      "    //   0.25 - almost off",
      "    //   0.00 - completely off",
      "    FxaaFloat fxaaQualitySubpix,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // The minimum amount OutputFormatter local contrast required to apply algorithm.",
      "    //   0.333 - too little (faster)",
      "    //   0.250 - low quality",
      "    //   0.166 - default",
      "    //   0.125 - high quality",
      "    //   0.063 - overkill (slower)",
      "    FxaaFloat fxaaQualityEdgeThreshold,",
      "    //",
      "    // Only used on FXAA Quality.",
      "    // This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // Trims the algorithm from processing darks.",
      "    //   0.0833 - upper limit (default, the start OutputFormatter visible unfiltered edges)",
      "    //   0.0625 - high quality (faster)",
      "    //   0.0312 - visible limit (slower)",
      "    // Special notes when using FXAA_GREEN_AS_LUMA,",
      "    //   Likely want to set this to zero.",
      "    //   As colors that are mostly not-green",
      "    //   will appear very dark in the green channel!",
      "    //   Tune by looking at mostly non-green content,",
      "    //   then start at zero and increase until aliasing is a problem.",
      "    FxaaFloat fxaaQualityEdgeThresholdMin,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // This does not effect PS3, as this needs to be compiled in.",
      "    //   Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.",
      "    //   Due to the PS3 being ALU bound,",
      "    //   there are only three safe values here: 2 and 4 and 8.",
      "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
      "    // For all other platforms can be a non-power OutputFormatter two.",
      "    //   8.0 is sharper (default!!!)",
      "    //   4.0 is softer",
      "    //   2.0 is really soft (good only for vector graphics inputs)",
      "    FxaaFloat fxaaConsoleEdgeSharpness,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // This does not effect PS3, as this needs to be compiled in.",
      "    //   Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.",
      "    //   Due to the PS3 being ALU bound,",
      "    //   there are only two safe values here: 1/4 and 1/8.",
      "    //   These options use the shaders ability to a free *|/ by 2|4|8.",
      "    // The console setting has a different mapping than the quality setting.",
      "    // Other platforms can use other values.",
      "    //   0.125 leaves less aliasing, but is softer (default!!!)",
      "    //   0.25 leaves more aliasing, and is sharper",
      "    FxaaFloat fxaaConsoleEdgeThreshold,",
      "    //",
      "    // Only used on FXAA Console.",
      "    // This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.",
      "    // PrototypeValidator is here now to allow easier tuning.",
      "    // Trims the algorithm from processing darks.",
      "    // The console setting has a different mapping than the quality setting.",
      "    // This only applies when FXAA_EARLY_EXIT is 1.",
      "    // This does not apply to PS3,",
      "    // PS3 was simplified to avoid more shader instructions.",
      "    //   0.06 - faster but more aliasing in darks",
      "    //   0.05 - default",
      "    //   0.04 - slower and less aliasing in darks",
      "    // Special notes when using FXAA_GREEN_AS_LUMA,",
      "    //   Likely want to set this to zero.",
      "    //   As colors that are mostly not-green",
      "    //   will appear very dark in the green channel!",
      "    //   Tune by looking at mostly non-green content,",
      "    //   then start at zero and increase until aliasing is a problem.",
      "    FxaaFloat fxaaConsoleEdgeThresholdMin,",
      "    //",
      "    // Extra constants for 360 FXAA Console only.",
      "    // Use zeros PromiseResolutionWrapper anything else for other platforms.",
      "    // These must be in physical constant registers and NOT immedates.",
      "    // Immedates will result in compiler un-optimizing.",
      "    // {xyzw} = float4(1.0, -1.0, 0.25, -0.25)",
      "    FxaaFloat4 fxaaConsole360ConstDir",
      ") {",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posM;",
      "    posM.x = pos.x;",
      "    posM.y = pos.y;",
      "    #if (FXAA_GATHER4_ALPHA == 1)",
      "        #if (FXAA_DISCARD == 0)",
      "            FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
      "            #if (FXAA_GREEN_AS_LUMA == 0)",
      "                #define lumaM rgbyM.w",
      "            #else",
      "                #define lumaM rgbyM.y",
      "            #endif",
      "        #endif",
      "        #if (FXAA_GREEN_AS_LUMA == 0)",
      "            FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);",
      "            FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));",
      "        #else",
      "            FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);",
      "            FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));",
      "        #endif",
      "        #if (FXAA_DISCARD == 1)",
      "            #define lumaM luma4A.w",
      "        #endif",
      "        #define lumaE luma4A.z",
      "        #define lumaS luma4A.x",
      "        #define lumaSE luma4A.y",
      "        #define lumaNW luma4B.w",
      "        #define lumaN luma4B.z",
      "        #define lumaW luma4B.x",
      "    #else",
      "        FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);",
      "        #if (FXAA_GREEN_AS_LUMA == 0)",
      "            #define lumaM rgbyM.w",
      "        #else",
      "            #define lumaM rgbyM.y",
      "        #endif",
      "        #if (FXAA_GLSL_100 == 1)",
      "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));",
      "        #else",
      "          FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));",
      "        #endif",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat maxSM = max(lumaS, lumaM);",
      "    FxaaFloat minSM = min(lumaS, lumaM);",
      "    FxaaFloat maxESM = max(lumaE, maxSM);",
      "    FxaaFloat minESM = min(lumaE, minSM);",
      "    FxaaFloat maxWN = max(lumaN, lumaW);",
      "    FxaaFloat minWN = min(lumaN, lumaW);",
      "    FxaaFloat rangeMax = max(maxWN, maxESM);",
      "    FxaaFloat rangeMin = min(minWN, minESM);",
      "    FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;",
      "    FxaaFloat range = rangeMax - rangeMin;",
      "    FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);",
      "    FxaaBool earlyExit = range < rangeMaxClamped;",
      "/*--------------------------------------------------------------------------*/",
      "    if(earlyExit)",
      "        #if (FXAA_DISCARD == 1)",
      "            FxaaDiscard;",
      "        #else",
      "            return rgbyM;",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    #if (FXAA_GATHER4_ALPHA == 0)",
      "        #if (FXAA_GLSL_100 == 1)",
      "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));",
      "        #else",
      "          FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));",
      "          FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
      "        #endif",
      "    #else",
      "        FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));",
      "        FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNS = lumaN + lumaS;",
      "    FxaaFloat lumaWE = lumaW + lumaE;",
      "    FxaaFloat subpixRcpRange = 1.0/range;",
      "    FxaaFloat subpixNSWE = lumaNS + lumaWE;",
      "    FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;",
      "    FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNESE = lumaNE + lumaSE;",
      "    FxaaFloat lumaNWNE = lumaNW + lumaNE;",
      "    FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;",
      "    FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat lumaNWSW = lumaNW + lumaSW;",
      "    FxaaFloat lumaSWSE = lumaSW + lumaSE;",
      "    FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);",
      "    FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);",
      "    FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;",
      "    FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;",
      "    FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;",
      "    FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;",
      "    FxaaFloat lengthSign = fxaaQualityRcpFrame.x;",
      "    FxaaBool horzSpan = edgeHorz >= edgeVert;",
      "    FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;",
      "/*--------------------------------------------------------------------------*/",
      "    if(!horzSpan) lumaN = lumaW;",
      "    if(!horzSpan) lumaS = lumaE;",
      "    if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;",
      "    FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat gradientN = lumaN - lumaM;",
      "    FxaaFloat gradientS = lumaS - lumaM;",
      "    FxaaFloat lumaNN = lumaN + lumaM;",
      "    FxaaFloat lumaSS = lumaS + lumaM;",
      "    FxaaBool pairN = abs(gradientN) >= abs(gradientS);",
      "    FxaaFloat gradient = max(abs(gradientN), abs(gradientS));",
      "    if(pairN) lengthSign = -lengthSign;",
      "    FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posB;",
      "    posB.x = posM.x;",
      "    posB.y = posM.y;",
      "    FxaaFloat2 offNP;",
      "    offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;",
      "    offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;",
      "    if(!horzSpan) posB.x += lengthSign * 0.5;",
      "    if( horzSpan) posB.y += lengthSign * 0.5;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat2 posN;",
      "    posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;",
      "    posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;",
      "    FxaaFloat2 posP;",
      "    posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;",
      "    posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;",
      "    FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;",
      "    FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));",
      "    FxaaFloat subpixE = subpixC * subpixC;",
      "    FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));",
      "/*--------------------------------------------------------------------------*/",
      "    if(!pairN) lumaNN = lumaSS;",
      "    FxaaFloat gradientScaled = gradient * 1.0/4.0;",
      "    FxaaFloat lumaMM = lumaM - lumaNN * 0.5;",
      "    FxaaFloat subpixF = subpixD * subpixE;",
      "    FxaaBool lumaMLTZero = lumaMM < 0.0;",
      "/*--------------------------------------------------------------------------*/",
      "    lumaEndN -= lumaNN * 0.5;",
      "    lumaEndP -= lumaNN * 0.5;",
      "    FxaaBool doneN = abs(lumaEndN) >= gradientScaled;",
      "    FxaaBool doneP = abs(lumaEndP) >= gradientScaled;",
      "    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;",
      "    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;",
      "    FxaaBool doneNP = (!doneN) || (!doneP);",
      "    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;",
      "    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;",
      "/*--------------------------------------------------------------------------*/",
      "    if(doneNP) {",
      "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "        doneN = abs(lumaEndN) >= gradientScaled;",
      "        doneP = abs(lumaEndP) >= gradientScaled;",
      "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;",
      "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;",
      "        doneNP = (!doneN) || (!doneP);",
      "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;",
      "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;",
      "/*--------------------------------------------------------------------------*/",
      "        #if (FXAA_QUALITY_PS > 3)",
      "        if(doneNP) {",
      "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "            doneN = abs(lumaEndN) >= gradientScaled;",
      "            doneP = abs(lumaEndP) >= gradientScaled;",
      "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;",
      "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;",
      "            doneNP = (!doneN) || (!doneP);",
      "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;",
      "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;",
      "/*--------------------------------------------------------------------------*/",
      "            #if (FXAA_QUALITY_PS > 4)",
      "            if(doneNP) {",
      "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                doneN = abs(lumaEndN) >= gradientScaled;",
      "                doneP = abs(lumaEndP) >= gradientScaled;",
      "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;",
      "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;",
      "                doneNP = (!doneN) || (!doneP);",
      "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;",
      "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;",
      "/*--------------------------------------------------------------------------*/",
      "                #if (FXAA_QUALITY_PS > 5)",
      "                if(doneNP) {",
      "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                    doneN = abs(lumaEndN) >= gradientScaled;",
      "                    doneP = abs(lumaEndP) >= gradientScaled;",
      "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;",
      "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;",
      "                    doneNP = (!doneN) || (!doneP);",
      "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;",
      "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;",
      "/*--------------------------------------------------------------------------*/",
      "                    #if (FXAA_QUALITY_PS > 6)",
      "                    if(doneNP) {",
      "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                        doneN = abs(lumaEndN) >= gradientScaled;",
      "                        doneP = abs(lumaEndP) >= gradientScaled;",
      "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;",
      "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;",
      "                        doneNP = (!doneN) || (!doneP);",
      "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;",
      "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;",
      "/*--------------------------------------------------------------------------*/",
      "                        #if (FXAA_QUALITY_PS > 7)",
      "                        if(doneNP) {",
      "                            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                            doneN = abs(lumaEndN) >= gradientScaled;",
      "                            doneP = abs(lumaEndP) >= gradientScaled;",
      "                            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;",
      "                            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;",
      "                            doneNP = (!doneN) || (!doneP);",
      "                            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;",
      "                            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;",
      "/*--------------------------------------------------------------------------*/",
      "    #if (FXAA_QUALITY_PS > 8)",
      "    if(doneNP) {",
      "        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "        doneN = abs(lumaEndN) >= gradientScaled;",
      "        doneP = abs(lumaEndP) >= gradientScaled;",
      "        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;",
      "        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;",
      "        doneNP = (!doneN) || (!doneP);",
      "        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;",
      "        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;",
      "/*--------------------------------------------------------------------------*/",
      "        #if (FXAA_QUALITY_PS > 9)",
      "        if(doneNP) {",
      "            if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "            if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "            if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "            if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "            doneN = abs(lumaEndN) >= gradientScaled;",
      "            doneP = abs(lumaEndP) >= gradientScaled;",
      "            if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;",
      "            if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;",
      "            doneNP = (!doneN) || (!doneP);",
      "            if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;",
      "            if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;",
      "/*--------------------------------------------------------------------------*/",
      "            #if (FXAA_QUALITY_PS > 10)",
      "            if(doneNP) {",
      "                if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                doneN = abs(lumaEndN) >= gradientScaled;",
      "                doneP = abs(lumaEndP) >= gradientScaled;",
      "                if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;",
      "                if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;",
      "                doneNP = (!doneN) || (!doneP);",
      "                if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;",
      "                if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;",
      "/*--------------------------------------------------------------------------*/",
      "                #if (FXAA_QUALITY_PS > 11)",
      "                if(doneNP) {",
      "                    if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                    if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                    if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                    if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                    doneN = abs(lumaEndN) >= gradientScaled;",
      "                    doneP = abs(lumaEndP) >= gradientScaled;",
      "                    if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;",
      "                    if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;",
      "                    doneNP = (!doneN) || (!doneP);",
      "                    if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;",
      "                    if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;",
      "/*--------------------------------------------------------------------------*/",
      "                    #if (FXAA_QUALITY_PS > 12)",
      "                    if(doneNP) {",
      "                        if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));",
      "                        if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));",
      "                        if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;",
      "                        if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;",
      "                        doneN = abs(lumaEndN) >= gradientScaled;",
      "                        doneP = abs(lumaEndP) >= gradientScaled;",
      "                        if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;",
      "                        if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;",
      "                        doneNP = (!doneN) || (!doneP);",
      "                        if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;",
      "                        if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;",
      "/*--------------------------------------------------------------------------*/",
      "                    }",
      "                    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                }",
      "                #endif",
      "/*--------------------------------------------------------------------------*/",
      "            }",
      "            #endif",
      "/*--------------------------------------------------------------------------*/",
      "        }",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    }",
      "    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                        }",
      "                        #endif",
      "/*--------------------------------------------------------------------------*/",
      "                    }",
      "                    #endif",
      "/*--------------------------------------------------------------------------*/",
      "                }",
      "                #endif",
      "/*--------------------------------------------------------------------------*/",
      "            }",
      "            #endif",
      "/*--------------------------------------------------------------------------*/",
      "        }",
      "        #endif",
      "/*--------------------------------------------------------------------------*/",
      "    }",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat dstN = posM.x - posN.x;",
      "    FxaaFloat dstP = posP.x - posM.x;",
      "    if(!horzSpan) dstN = posM.y - posN.y;",
      "    if(!horzSpan) dstP = posP.y - posM.y;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;",
      "    FxaaFloat spanLength = (dstP + dstN);",
      "    FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;",
      "    FxaaFloat spanLengthRcp = 1.0/spanLength;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaBool directionN = dstN < dstP;",
      "    FxaaFloat dst = min(dstN, dstP);",
      "    FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;",
      "    FxaaFloat subpixG = subpixF * subpixF;",
      "    FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;",
      "    FxaaFloat subpixH = subpixG * fxaaQualitySubpix;",
      "/*--------------------------------------------------------------------------*/",
      "    FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;",
      "    FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);",
      "    if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;",
      "    if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;",
      "    #if (FXAA_DISCARD == 1)",
      "        return FxaaTexTop(tex, posM);",
      "    #else",
      "        return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);",
      "    #endif",
      "}",
      "/*==========================================================================*/",
      "#endif",
      "",
      "void main() {",
      "  gl_FragColor = FxaaPixelShader(",
      "    vUv,",
      "    vec4(0.0),",
      "    tDiffuse,",
      "    tDiffuse,",
      "    tDiffuse,",
      "    resolution,",
      "    vec4(0.0),",
      "    vec4(0.0),",
      "    vec4(0.0),",
      "    0.75,",
      "    0.166,",
      "    0.0833,",
      "    0.0,",
      "    0.0,",
      "    0.0,",
      "    vec4(0.0)",
      "  );",
      "",
      "  // TODO avoid querying texture twice for same texel",
      "  gl_FragColor.a = texture2D(tDiffuse, vUv).a;",
      "}",
    ].join("\n"),
  };
  var qx = 100,
    Qx = 1,
    Zx = 0.75 * Qx,
    Jx = qx - 2 * Zx,
    Kx = null,
    $x = null,
    eb = null,
    tb = null,
    ib = null,
    nb = null;
  var rb = {
    SIZE: qx,
    HEIGHT: Qx,
    create: function () {
      var env =
        0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : pl;
      Kx ||
        (function () {
          var env = new cy();
          env.moveTo(Zx, Zx),
            env.lineTo(Zx + Jx, Zx),
            env.lineTo(Zx + Jx, Zx + Jx),
            env.lineTo(Zx, Zx + Jx),
            env.lineTo(Zx, Zx);
          var t = new cy();
          t.moveTo(0, 0),
            t.lineTo(0, qx),
            t.lineTo(qx, qx),
            t.lineTo(qx, 0),
            t.lineTo(0, 0),
            t.holes.push(env),
            (Kx = new tv(t, {
              steps: 1,
              depth: Qx,
              bevelEnabled: !1,
            }));
        })(),
        env !== pl ||
          $x ||
          (($x = new Mv({ color: 11451595 })).emissive = new $GlobalReference(67084)),
        env !== ul ||
          eb ||
          ((eb = new Mv({ color: 16777215 })).emissive = new $GlobalReference(15461098)),
        tb || (tb = new LineDrawer(Jx, Jx, Qx)),
        env !== pl || ib || (ib = new Gd({ color: new $GlobalReference(67084) })),
        env !== ul || nb || (nb = new Gd({ color: new $GlobalReference(16777215) }));
      var t = env === pl ? $x : eb,
        i = env === pl ? ib : nb,
        n = new Pp();
      (n.position.x = 0.5 * -qx), (n.position.z = 0.5 * -qx);
      var r = new JobDispatcher(Kx, t);
      n.add(r);
      var a = new JobDispatcher(tb, i);
      return (
        (a.position.x = 0.5 * Jx + Zx),
        (a.position.y = 0.5 * Jx + Zx),
        (a.position.z = 0.5 * Qx),
        n.add(a),
        n
      );
    },
    dispose: function () {
      $x && ($x.dispose(), ($x = null)),
        eb && (eb.dispose(), (eb = null)),
        Kx && (Kx.dispose(), (Kx = null)),
        ib && (ib.dispose(), (ib = null)),
        nb && (nb.dispose(), (nb = null)),
        tb && (tb.dispose(), (tb = null));
    },
  };

  function ArgumentBuffer(env, t) {
    var i, n, r, a, ObjectMethodWrapper;
    (this.object = env),
// تنظیمات اولیه کلاس برای مدیریت کنترل دوربین یا نمای سه‌بعدی

(this.domElement = void 0 !== t ? t : document), // عنصر DOM مورد استفاده (پیش‌فرض: document)
  (this.enabled = !0), // فعال یا غیرفعال کردن کنترل
  (this.target = new yu()), // هدف (مکان) برای کنترل دوربین
  (this.minDistance = 0), // حداقل فاصله دوربین
  (this.maxDistance = 1 / 0), // حداکثر فاصله دوربین (بینهایت)
  (this.minZoom = 0), // حداقل مقدار بزرگنمایی
  (this.maxZoom = 1 / 0), // حداکثر مقدار بزرگنمایی (بینهایت)
  (this.minPolarAngle = 0), // حداقل زاویه قطبی (رادیان)
  (this.maxPolarAngle = Math.PI), // حداکثر زاویه قطبی (رادیان)
  (this.minAzimuthAngle = -1 / 0), // حداقل زاویه سمت‌الزاویه (رادیان)
  (this.maxAzimuthAngle = 1 / 0), // حداکثر زاویه سمت‌الزاویه (رادیان)
  (this.enableDamping = !1), // فعال یا غیرفعال کردن دمپینگ (حرکت نرم‌تر)
  (this.dampingFactor = 0.25), // مقدار دمپینگ (در صورت فعال بودن)
  (this.enableZoom = !0), // فعال یا غیرفعال کردن بزرگنمایی
  (this.zoomSpeed = 1), // سرعت بزرگنمایی
  (this.enableRotate = !0), // فعال یا غیرفعال کردن چرخش
  (this.rotateSpeed = 1), // سرعت چرخش
  (this.enablePan = !0), // فعال یا غیرفعال کردن حرکت
  (this.panSpeed = 1), // سرعت حرکت
  (this.screenSpacePanning = !1), // فعال یا غیرفعال کردن حرکت در فضای صفحه
  (this.keyPanSpeed = 7), // سرعت حرکت در هنگام استفاده از کلیدها
  (this.autoRotate = !1), // فعال یا غیرفعال کردن چرخش خودکار
  (this.autoRotateSpeed = 2), // سرعت چرخش خودکار
  (this.enableKeys = !0), // فعال یا غیرفعال کردن کنترل از طریق کلیدها
  (this.keys = { // تعریف کلیدهای کنترل
    LEFT: 37, // کلید سمت چپ
    UP: 38, // کلید بالا
    RIGHT: 39, // کلید سمت راست
    BOTTOM: 40, // کلید پایین
  }),
  (this.mouseButtons = { // تنظیم دکمه‌های ماوس برای کنترل
    LEFT: $RandomGenerator, // دکمه چپ ماوس
    MIDDLE: eh, // دکمه میانی ماوس
    RIGHT: th, // دکمه راست ماوس
  }),
  (this.target0 = this.target.clone()), // ذخیره هدف اولیه
  (this.position0 = this.object.position.clone()), // ذخیره موقعیت اولیه دوربین
  (this.zoom0 = this.object.zoom), // ذخیره بزرگنمایی اولیه
  (this.getPolarAngle = function () { // تابع برای دریافت زاویه قطبی
    return f.phi;
  }),
  (this.getAzimuthalAngle = function () { // تابع برای دریافت زاویه سمت‌الزاویه
    return f.theta;
  }),
  (this.saveState = function () { // تابع برای ذخیره وضعیت فعلی
    CounterVariable.target0.copy(CounterVariable.target),
      CounterVariable.position0.copy(CounterVariable.object.position),
      (CounterVariable.zoom0 = CounterVariable.object.zoom);
  }),
  (this.reset = function () { // تابع برای بازنشانی وضعیت به حالت اولیه
    CounterVariable.target.copy(CounterVariable.target0),
      CounterVariable.object.position.copy(CounterVariable.position0),
      (CounterVariable.object.zoom = CounterVariable.zoom0),
      CounterVariable.object.updateProjectionMatrix(), // به‌روزرسانی ماتریس پروجکشن
      CounterVariable.dispatchEvent(RandomGenerator), // انتشار رویداد بازنشانی
      CounterVariable.update(), // به‌روزرسانی وضعیت
      (Property = GlobalReference.NONE); // بازنشانی خاصیت‌ها
      }),
      (this.update =
        ((i = new yu()),
        (n = new vu().setFromUnitVectors(env.up, new yu(0, 1, 0))),
        (r = n.clone().inverse()),
        (a = new yu()),
        (ObjectMethodWrapper = new vu()),
        function () {
          var env = CounterVariable.object.position;
          return (
            i.copy(env).sub(CounterVariable.target),
            i.applyQuaternion(n),
            f.setFromVector3(i),
            CounterVariable.autoRotate &&
              Property === GlobalReference.NONE &&
              L(((2 * Math.PI) / 60 / 60) * CounterVariable.autoRotateSpeed),
            (f.theta += ModuleMeta.theta),
            (f.phi += ModuleMeta.phi),
            (f.theta = Math.max(
              CounterVariable.minAzimuthAngle,
              Math.min(CounterVariable.maxAzimuthAngle, f.theta),
            )),
            (f.phi = Math.max(
              CounterVariable.minPolarAngle,
              Math.min(CounterVariable.maxPolarAngle, f.phi),
            )),
            f.makeSafe(),
            (f.radius *= g),
            (f.radius = Math.max(
              CounterVariable.minDistance,
              Math.min(CounterVariable.maxDistance, f.radius),
            )),
            CounterVariable.target.add(Value),
            i.setFromSpherical(f),
            i.applyQuaternion(r),
            env.copy(CounterVariable.target).add(i),
            CounterVariable.object.lookAt(CounterVariable.target),
            !0 === CounterVariable.enableDamping
              ? ((ModuleMeta.theta *= 1 - CounterVariable.dampingFactor),
                (ModuleMeta.phi *= 1 - CounterVariable.dampingFactor),
                Value.multiplyScalar(1 - CounterVariable.dampingFactor))
              : (ModuleMeta.set(0, 0, 0), Value.set(0, 0, 0)),
            (g = 1),
            !(
              !(
                y ||
                a.distanceToSquared(CounterVariable.object.position) > MathFloorShortcut ||
                8 * (1 - ObjectMethodWrapper.dot(CounterVariable.object.quaternion)) > MathFloorShortcut
              ) ||
              (CounterVariable.dispatchEvent(RandomGenerator),
              a.copy(CounterVariable.object.position),
              ObjectMethodWrapper.copy(CounterVariable.object.quaternion),
              (y = !1))
            )
          );
        })),
      (this.dispose = function () {
  CounterVariable.domElement.removeEventListener("contextmenu", IsArgumentsObject, !1); // حذف رویداد راست‌کلیک
  CounterVariable.domElement.removeEventListener("mousedown", B, !1); // حذف رویداد کلیک موس
  CounterVariable.domElement.removeEventListener("wheel", Iterator, !1); // حذف رویداد چرخ اسکرول
  CounterVariable.domElement.removeEventListener("touchstart", ObjectKeys, !1); // حذف رویداد شروع لمس
  CounterVariable.domElement.removeEventListener("touchend", ToStringTag, !1); // حذف رویداد پایان لمس
  CounterVariable.domElement.removeEventListener("touchmove", W, !1); // حذف رویداد حرکت لمس
  document.removeEventListener("mousemove", ForEachElement, !1); // حذف رویداد حرکت موس در سند
  document.removeEventListener("mouseup", G, !1); // حذف رویداد رهاسازی کلیک موس
  window.removeEventListener("keydown", IsIterable, !1); // حذف رویداد فشردن کلید
});

// تعریف متغیرها و ثابت‌های مورد استفاده در کد
var CounterVariable = this, // ارجاع به شیء جاری
  RandomGenerator = { type: "change" }, // رویداد تغییر
  HelperFunction = { type: "start" }, // رویداد شروع
  EnsureFunction = { type: "end" }, // رویداد پایان
  GlobalReference = {
    NONE: -1, // هیچ عملی انجام نشده
    ROTATE: 0, // چرخش
    DOLLY: 1, // زوم
    PAN: 2, // حرکت
    TOUCH_ROTATE: 3, // چرخش با لمس
    TOUCH_DOLLY_PAN: 4, // زوم و حرکت با لمس
  },
  Property = GlobalReference.NONE, // حالت پیش‌فرض
  MathFloorShortcut = 1e-6, // ثابت کوچک برای محاسبات
  f = new _x(), // متغیر برای ذخیره وضعیت
  ModuleMeta = new _x(), // وضعیت زاویه‌های چرخش
  g = 1, // مقیاس بزرگنمایی
  Value = new yu(), // موقعیت دوربین
  y = !1, // وضعیت پیش‌فرض چرخش
  _ = new mu(), // بردار خالی
  x = new mu(), // بردار خالی
  b = new mu(), // بردار خالی
  w = new mu(), // بردار خالی
  T = new mu(), // بردار خالی
  EnsureObject = new mu(), // بردار خالی
  E = new mu(), // بردار خالی
  A = new mu(), // بردار خالی
  M = new mu(); // بردار خالی

/**
 * تابع P
 * محاسبه مقیاس بزرگنمایی برای اعمال زوم نرم.
 * @returns {number} - مقدار مقیاس بزرگنمایی.
 */
function P() {
  return Math.pow(0.95, CounterVariable.zoomSpeed); // زوم با سرعت مشخص
}

/**
 * تابع L
 * تغییر مقدار زاویه theta برای چرخش.
 * @param {number} env - مقدار تغییر زاویه.
 */
function L(env) {
  ModuleMeta.theta -= env; // کاهش زاویه theta
}

/**
 * تابع C
 * تغییر مقدار زاویه phi برای چرخش.
 * @param {number} env - مقدار تغییر زاویه.
 */
function C(env) {
  ModuleMeta.phi -= env; // کاهش زاویه phi
}

// تعریف توابع برای حرکات مختلف
var I,
  R,
  O,
  FilterArray =
    ((I = new yu()),
    function (env, t) {
      /**
       * حرکت در محور x.
       * @param {number} env - مقدار حرکت.
       * @param {Object} t - ماتریس برای اعمال حرکت.
       */
      I.setFromMatrixColumn(t, 0); // تنظیم بردار محور x
      I.multiplyScalar(-env); // تغییر مقیاس بردار
      Value.add(I); // افزودن به موقعیت
    }),
  FindInArray =
    ((R = new yu()),
    function (env, t) {
      /**
       * حرکت در محور y.
       * @param {number} env - مقدار حرکت.
       * @param {Object} t - ماتریس برای اعمال حرکت.
       */
      if (CounterVariable.screenSpacePanning) {
        R.setFromMatrixColumn(t, 1); // حرکت در صفحه
      } else {
        R.setFromMatrixColumn(t, 0); // حرکت در محور x
        R.crossVectors(CounterVariable.object.up, R); // محاسبه بردار عمود
      }
      R.multiplyScalar(env); // تغییر مقیاس بردار
      Value.add(R); // افزودن به موقعیت
    }),
  Key =
    ((O = new yu()),
    function (env, t) {
      /**
       * حرکت دوربین در راستای محورهای صفحه نمایش.
       * @param {number} env - مقدار حرکت در محور x.
       * @param {number} t - مقدار حرکت در محور y.
       */
      var i = CounterVariable.domElement === document ? CounterVariable.domElement.body : CounterVariable.domElement;

      if (CounterVariable.object.isPerspectiveCamera) {
        // محاسبات برای دوربین پرسپکتیو
        var n = CounterVariable.object.position;
        O.copy(n).sub(CounterVariable.target); // فاصله دوربین از هدف
        var r = O.length(); // محاسبه طول بردار
        r *= Math.tan(((CounterVariable.object.fov / 2) * Math.PI) / 180); // تبدیل زاویه دید به شعاع
        FilterArray((2 * env * r) / i.clientHeight, CounterVariable.object.matrix); // اعمال حرکت در محور x
        FindInArray((2 * t * r) / i.clientHeight, CounterVariable.object.matrix); // اعمال حرکت در محور y
      } else if (CounterVariable.object.isOrthographicCamera) {
        // محاسبات برای دوربین ارتوگرافیک
        FilterArray(
          (env * (CounterVariable.object.right - CounterVariable.object.left)) /
            CounterVariable.object.zoom /
            i.clientWidth,
          CounterVariable.object.matrix,
        );
        FindInArray(
          (t * (CounterVariable.object.top - CounterVariable.object.bottom)) /
            CounterVariable.object.zoom /
            i.clientHeight,
          CounterVariable.object.matrix,
        );
      } else {
        console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.",
        );
        CounterVariable.enablePan = !1; // غیرفعال کردن حرکت
      }
    });

    function U(env) {
  CounterVariable.object.isPerspectiveCamera
    ? (g /= env) // برای دوربین پرسپکتیو، مقدار زوم معکوس می‌شود.
    : CounterVariable.object.isOrthographicCamera
      ? ((CounterVariable.object.zoom = Math.max(
          CounterVariable.minZoom,
          Math.min(CounterVariable.maxZoom, CounterVariable.object.zoom * env),
        )),
        CounterVariable.object.updateProjectionMatrix(), // به‌روزرسانی ماتریس پروجکشن.
        (y = !0)) // تنظیم وضعیت برای تغییر.
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
        ),
        (CounterVariable.enableZoom = !1)); // غیرفعال کردن زوم در صورت نوع دوربین ناشناخته.
}

/**
 * تابع D
 * معکوس تغییر زوم یا دالی (Dolly).
 * @param {number} env - مقدار تغییر زوم.
 */
function D(env) {
  CounterVariable.object.isPerspectiveCamera
    ? (g *= env)
    : CounterVariable.object.isOrthographicCamera
      ? ((CounterVariable.object.zoom = Math.max(
          CounterVariable.minZoom,
          Math.min(CounterVariable.maxZoom, CounterVariable.object.zoom / env),
        )),
        CounterVariable.object.updateProjectionMatrix(),
        (y = !0))
      : (console.warn(
          "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.",
        ),
        (CounterVariable.enableZoom = !1));
}

/**
 * تابع z
 * ثبت مختصات x و y کلیک یا لمس.
 * @param {Object} env - رویداد کلیک یا لمس.
 */
function z(env) {
  w.set(env.clientX, env.clientY);
}

/**
 * تابع B
 * مدیریت شروع رویدادهای موس.
 * @param {Object} env - رویداد موس.
 */
function B(env) {
  if (!1 !== CounterVariable.enabled) {
    switch ((env.preventDefault(), env.button)) {
      case CounterVariable.mouseButtons.LEFT: // کلیک چپ
        if (env.ctrlKey || env.metaKey) {
          if (!1 === CounterVariable.enablePan) return;
          z(env), (Property = GlobalReference.PAN);
        } else {
          if (!1 === CounterVariable.enableRotate) return;
          (i = env), _.set(i.clientX, i.clientY), (Property = GlobalReference.ROTATE);
        }
        break;
      case CounterVariable.mouseButtons.MIDDLE: // کلیک وسط
        if (!1 === CounterVariable.enableZoom) return;
        (t = env), E.set(t.clientX, t.clientY), (Property = GlobalReference.DOLLY);
        break;
      case CounterVariable.mouseButtons.RIGHT: // کلیک راست
        if (!1 === CounterVariable.enablePan) return;
        z(env), (Property = GlobalReference.PAN);
    }
    var t, i;
    Property !== GlobalReference.NONE &&
      (document.addEventListener("mousemove", ForEachElement, !1),
      document.addEventListener("mouseup", G, !1),
      CounterVariable.dispatchEvent(HelperFunction));
  }
}

/**
 * تابع ForEachElement
 * مدیریت حرکت موس پس از شروع رویداد.
 * @param {Object} env - رویداد حرکت موس.
 */
function ForEachElement(env) {
  var t, i;
  if (!1 !== CounterVariable.enabled) // بررسی فعال بودن کنترل‌ها.
    switch (
      (env.preventDefault(), // جلوگیری از رفتار پیش‌فرض رویداد.
      Property) // بررسی حالت فعلی (چرخش، زوم، حرکت).
    ) {
      case GlobalReference.ROTATE: // حالت چرخش
        if (!1 === CounterVariable.enableRotate) return; // اگر چرخش غیرفعال باشد، عملیات متوقف شود.
        !(function (env) {
          x.set(env.clientX, env.clientY), // ذخیره موقعیت مکان‌نما.
            b.subVectors(x, _).multiplyScalar(CounterVariable.rotateSpeed); // محاسبه تغییرات مکان‌نما و مقیاس‌بندی با سرعت چرخش.
          var t =
            CounterVariable.domElement === document
              ? CounterVariable.domElement.body
              : CounterVariable.domElement; // تعیین المان DOM مرتبط.
          L((2 * Math.PI * b.x) / t.clientHeight), // اعمال چرخش حول محور x.
            C((2 * Math.PI * b.y) / t.clientHeight), // اعمال چرخش حول محور y.
            _.copy(x), // ذخیره موقعیت جدید برای چرخش بعدی.
            CounterVariable.update(); // به‌روزرسانی وضعیت کنترل.
        })(env);
        break;

      case GlobalReference.DOLLY: // حالت زوم
        if (!1 === CounterVariable.enableZoom) return; // اگر زوم غیرفعال باشد، عملیات متوقف شود.
        (i = env), // ذخیره رویداد.
          A.set(i.clientX, i.clientY), // ثبت موقعیت مکان‌نما.
          M.subVectors(A, E), // محاسبه تغییرات موقعیت.
          0 < M.y ? U(P()) : M.y < 0 && D(P()), // بزرگ‌نمایی یا کوچک‌نمایی بر اساس تغییر y.
          E.copy(A), // ذخیره موقعیت جدید برای زوم بعدی.
          CounterVariable.update(); // به‌روزرسانی وضعیت کنترل.
        break;

      case GlobalReference.PAN: // حالت حرکت
        if (!1 === CounterVariable.enablePan) return; // اگر حرکت غیرفعال باشد، عملیات متوقف شود.
        (t = env), // ذخیره رویداد.
          T.set(t.clientX, t.clientY), // ثبت موقعیت مکان‌نما.
          EnsureObject.subVectors(T, w).multiplyScalar(CounterVariable.panSpeed), // محاسبه تغییرات و مقیاس‌بندی با سرعت حرکت.
          Key(EnsureObject.x, EnsureObject.y), // اعمال تغییرات.
          w.copy(T), // ذخیره موقعیت جدید برای حرکت بعدی.
          CounterVariable.update(); // به‌روزرسانی وضعیت کنترل.
    }
}


/**
 * تابع G
 * مدیریت پایان رویداد موس.
 * @param {Object} env - رویداد پایان موس.
 */
function G(env) {
  !1 !== CounterVariable.enabled &&
    (document.removeEventListener("mousemove", ForEachElement, !1),
    document.removeEventListener("mouseup", G, !1),
    CounterVariable.dispatchEvent(EnsureFunction),
    (Property = GlobalReference.NONE));
    }

    /**
 * تابع Iterator
 * مدیریت رویداد چرخ اسکرول برای زوم یا دالی.
 * @param {Object} env - رویداد اسکرول.
 */
function Iterator(env) {
  var t;
  !1 === CounterVariable.enabled || // اگر کنترل غیرفعال باشد.
    !1 === CounterVariable.enableZoom || // اگر زوم غیرفعال باشد.
    (Property !== GlobalReference.NONE && Property !== GlobalReference.ROTATE) || // بررسی حالت‌های غیرمجاز.
    (env.preventDefault(), // جلوگیری از رفتار پیش‌فرض مرورگر.
    env.stopPropagation(), // جلوگیری از انتقال رویداد به والدها.
    CounterVariable.dispatchEvent(HelperFunction), // ارسال رویداد شروع.
    (t = env).deltaY < 0 ? D(P()) : 0 < t.deltaY && U(P()), // تعیین جهت زوم و اجرای تابع مناسب.
    CounterVariable.update(), // به‌روزرسانی دوربین.
    CounterVariable.dispatchEvent(EnsureFunction)); // ارسال رویداد پایان.
}

/**
 * تابع IsIterable
 * مدیریت کلیدهای جهت‌دار برای حرکت دوربین.
 * @param {Object} env - رویداد کلید.
 */
function IsIterable(env) {
  !1 !== CounterVariable.enabled && // بررسی فعال بودن کنترل.
    !1 !== CounterVariable.enableKeys && // بررسی فعال بودن کلیدها.
    !1 !== CounterVariable.enablePan && // بررسی فعال بودن حرکت.
    (function (env) {
      switch (env.keyCode) {
        case CounterVariable.keys.UP: // کلید بالا
          Key(0, CounterVariable.keyPanSpeed), CounterVariable.update();
          break;
        case CounterVariable.keys.BOTTOM: // کلید پایین
          Key(0, -CounterVariable.keyPanSpeed), CounterVariable.update();
          break;
        case CounterVariable.keys.LEFT: // کلید چپ
          Key(CounterVariable.keyPanSpeed, 0), CounterVariable.update();
          break;
        case CounterVariable.keys.RIGHT: // کلید راست
          Key(-CounterVariable.keyPanSpeed, 0), CounterVariable.update();
      }
    })(env);
}

/**
 * تابع ObjectKeys
 * مدیریت رویداد شروع لمس.
 * @param {Object} env - رویداد لمس.
 */
function ObjectKeys(env) {
  if (!1 !== CounterVariable.enabled) { // بررسی فعال بودن کنترل.
    switch ((env.preventDefault(), env.touches.length)) {
      case 1: // لمس با یک انگشت
        if (!1 === CounterVariable.enableRotate) return; // اگر چرخش غیرفعال باشد.
        (t = env),
          _.set(t.touches[0].pageX, t.touches[0].pageY),
          (Property = GlobalReference.TOUCH_ROTATE);
        break;
      case 2: // لمس با دو انگشت
        if (!1 === CounterVariable.enableZoom && !1 === CounterVariable.enablePan) return;
        !(function (env) {
          if (CounterVariable.enableZoom) { // اگر زوم فعال باشد.
            var t = env.touches[0].pageX - env.touches[1].pageX,
              i = env.touches[0].pageY - env.touches[1].pageY,
              n = Math.sqrt(t * t + i * i);
            E.set(0, n);
          }
          if (CounterVariable.enablePan) { // اگر حرکت فعال باشد.
            var r = 0.5 * (env.touches[0].pageX + env.touches[1].pageX),
              a = 0.5 * (env.touches[0].pageY + env.touches[1].pageY);
            w.set(r, a);
          }
        })(env),
          (Property = GlobalReference.TOUCH_DOLLY_PAN);
        break;
      default:
        Property = GlobalReference.NONE; // حالت پیش‌فرض.
    }
    var t;
    Property !== GlobalReference.NONE && CounterVariable.dispatchEvent(HelperFunction); // ارسال رویداد شروع.
  }
}

/**
 * تابع W
 * مدیریت رویداد حرکت لمس.
 * @param {Object} env - رویداد لمس.
 */
function W(env) {
  if (!1 !== CounterVariable.enabled) { // بررسی فعال بودن کنترل.
    switch (
      (env.preventDefault(), // جلوگیری از رفتار پیش‌فرض رویداد.
      env.stopPropagation(), // جلوگیری از انتشار رویداد.
      env.touches.length) // بررسی تعداد انگشتان لمس.
    ) {
      case 1: // حرکت با یک انگشت.
        if (!1 === CounterVariable.enableRotate) return; // اگر چرخش غیرفعال باشد، عملیات را متوقف کن.
        if (Property !== GlobalReference.TOUCH_ROTATE) return; // اگر حالت چرخش لمس فعال نباشد، عملیات را متوقف کن.
        !(function (env) {
          x.set(env.touches[0].pageX, env.touches[0].pageY), // ثبت موقعیت انگشت.
            b.subVectors(x, _).multiplyScalar(CounterVariable.rotateSpeed); // محاسبه تغییرات موقعیت و مقیاس‌بندی با سرعت چرخش.
          var t =
            CounterVariable.domElement === document
              ? CounterVariable.domElement.body
              : CounterVariable.domElement; // تعیین المان DOM مربوط به کنترل.
          L((2 * Math.PI * b.x) / t.clientHeight), // چرخش حول محور x.
            C((2 * Math.PI * b.y) / t.clientHeight), // چرخش حول محور y.
            _.copy(x), // به‌روزرسانی موقعیت اولیه.
            CounterVariable.update(); // به‌روزرسانی وضعیت کنترل.
        })(env);
        break;
      case 2: // حرکت با دو انگشت.
        if (!1 === CounterVariable.enableZoom && !1 === CounterVariable.enablePan) return; // اگر بزرگ‌نمایی و حرکت غیرفعال باشد، عملیات را متوقف کن.
        if (Property !== GlobalReference.TOUCH_DOLLY_PAN) return; // اگر حالت حرکت یا بزرگ‌نمایی فعال نباشد، عملیات را متوقف کن.
        !(function (env) {
          if (CounterVariable.enableZoom) { // اگر بزرگ‌نمایی فعال باشد.
            var t = env.touches[0].pageX - env.touches[1].pageX, // فاصله افقی بین دو انگشت.
              i = env.touches[0].pageY - env.touches[1].pageY, // فاصله عمودی بین دو انگشت.
              n = Math.sqrt(t * t + i * i); // فاصله کلی بین دو انگشت.
            A.set(0, n), // مقداردهی فاصله فعلی.
              M.set(0, Math.pow(A.y / E.y, CounterVariable.zoomSpeed)), // محاسبه مقدار بزرگ‌نمایی.
              U(M.y), // اعمال بزرگ‌نمایی.
              E.copy(A); // به‌روزرسانی فاصله قبلی.
          }
          if (CounterVariable.enablePan) { // اگر حرکت فعال باشد.
            var r = 0.5 * (env.touches[0].pageX + env.touches[1].pageX), // محاسبه موقعیت افقی میانگین دو انگشت.
              a = 0.5 * (env.touches[0].pageY + env.touches[1].pageY); // محاسبه موقعیت عمودی میانگین دو انگشت.
            T.set(r, a), // تنظیم موقعیت جدید.
              EnsureObject.subVectors(T, w).multiplyScalar(CounterVariable.panSpeed), // محاسبه تغییر موقعیت و مقیاس‌بندی با سرعت حرکت.
              Key(EnsureObject.x, EnsureObject.y), // اعمال حرکت.
              w.copy(T); // به‌روزرسانی موقعیت اولیه.
          }
          CounterVariable.update(); // به‌روزرسانی وضعیت کنترل.
        })(env);
        break;
      default:
        Property = GlobalReference.NONE; // تنظیم حالت پیش‌فرض.
    }
  }
}


/**
 * تابع ToStringTag
 * مدیریت پایان لمس.
 * @param {Object} env - رویداد لمس.
 */
function ToStringTag(env) {
  !1 !== CounterVariable.enabled && (CounterVariable.dispatchEvent(EnsureFunction), (Property = GlobalReference.NONE));
}

/**
 * تابع IsArgumentsObject
 * مدیریت رویداد راست‌کلیک.
 * @param {Object} env - رویداد راست‌کلیک.
 */
function IsArgumentsObject(env) {
  !1 !== CounterVariable.enabled && env.preventDefault(); // جلوگیری از رفتار پیش‌فرض.
     }


    // افزودن EventListener برای تعامل با عنصر DOM و پنجره مرورگر

// جلوگیری از باز شدن منوی راست‌کلیک در عنصر
CounterVariable.domElement.addEventListener("contextmenu", IsArgumentsObject, !1); 

// مدیریت رویداد کلیک موس بر روی عنصر
CounterVariable.domElement.addEventListener("mousedown", B, !1); 

// مدیریت رویداد چرخش چرخ موس برای زوم یا دالی
CounterVariable.domElement.addEventListener("wheel", Iterator, !1); 

// مدیریت رویداد شروع لمس (مثلاً اولین تماس انگشت روی صفحه)
CounterVariable.domElement.addEventListener("touchstart", ObjectKeys, !1); 

// مدیریت رویداد پایان لمس (مثلاً زمانی که انگشت از صفحه جدا می‌شود)
CounterVariable.domElement.addEventListener("touchend", ToStringTag, !1); 

// مدیریت رویداد حرکت انگشت روی صفحه (مثلاً کشیدن انگشت)
CounterVariable.domElement.addEventListener("touchmove", W, !1); 

// مدیریت رویداد فشردن کلیدهای صفحه‌کلید در پنجره
window.addEventListener("keydown", IsIterable, !1); 

// به‌روزرسانی وضعیت و موقعیت کنترل‌ها
this.update();;
  }

/**
 * تنظیم prototype برای کلاس ArgumentBuffer
 * این کلاس از کلاس Il ارث‌بری می‌کند و constructor آن به ArgumentBuffer اشاره دارد.
 */
((ArgumentBuffer.prototype = Object.create(Il.prototype)).constructor = ArgumentBuffer);

// تعریف ویژگی‌ها و متدهای اضافی برای کلاس ArgumentBuffer
Object.defineProperties(ArgumentBuffer.prototype, {
  /**
   * ویژگی center (Deprecated)
   * این ویژگی به .target تغییر نام داده است. هنگام استفاده، هشدار نمایش داده می‌شود.
   * @returns {Object} - مقدار هدف دوربین.
   */
  center: {
    get: function () {
      console.warn("THREE.OrbitControls: .center has been renamed to .target");
      return this.target;
    },
  },
  /**
   * ویژگی noZoom (Deprecated)
   * این ویژگی نشان‌دهنده غیرفعال بودن قابلیت زوم است. به جای آن باید از .enableZoom استفاده شود.
   */
  noZoom: {
    get: function () {
      console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
      return !this.enableZoom; // برگرداندن مقدار معکوس .enableZoom
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.");
      this.enableZoom = !env; // تنظیم مقدار معکوس به .enableZoom
    },
  },
  /**
   * ویژگی noRotate (Deprecated)
   * این ویژگی نشان‌دهنده غیرفعال بودن قابلیت چرخش است. به جای آن باید از .enableRotate استفاده شود.
   */
  noRotate: {
    get: function () {
      console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
      return !this.enableRotate; // برگرداندن مقدار معکوس .enableRotate
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.");
      this.enableRotate = !env; // تنظیم مقدار معکوس به .enableRotate
    },
  },
  /**
   * ویژگی noPan (Deprecated)
   * این ویژگی نشان‌دهنده غیرفعال بودن قابلیت حرکت است. به جای آن باید از .enablePan استفاده شود.
   */
  noPan: {
    get: function () {
      console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
      return !this.enablePan; // برگرداندن مقدار معکوس .enablePan
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.");
      this.enablePan = !env; // تنظیم مقدار معکوس به .enablePan
    },
  },
  /**
   * ویژگی noKeys (Deprecated)
   * این ویژگی نشان‌دهنده غیرفعال بودن کلیدهای کنترلی است. به جای آن باید از .enableKeys استفاده شود.
   */
  noKeys: {
    get: function () {
      console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
      return !this.enableKeys; // برگرداندن مقدار معکوس .enableKeys
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.");
      this.enableKeys = !env; // تنظیم مقدار معکوس به .enableKeys
    },
  },
  /**
   * ویژگی staticMoving (Deprecated)
   * این ویژگی نشان‌دهنده غیرفعال بودن حرکت ایستا است. به جای آن باید از .enableDamping استفاده شود.
   */
  staticMoving: {
    get: function () {
      console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
      return !this.enableDamping; // برگرداندن مقدار معکوس .enableDamping
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.");
      this.enableDamping = !env; // تنظیم مقدار معکوس به .enableDamping
    },
  },
  /**
   * ویژگی dynamicDampingFactor (Deprecated)
   * این ویژگی به .dampingFactor تغییر نام داده است. هنگام استفاده، هشدار نمایش داده می‌شود.
   * @returns {number} - مقدار .dampingFactor.
   */
  dynamicDampingFactor: {
    get: function () {
      console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
      return this.dampingFactor; // برگرداندن مقدار .dampingFactor
    },
    set: function (env) {
      console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.");
      this.dampingFactor = env; // تنظیم مقدار .dampingFactor
        },
      },
    });
  /**
 * کلاس ob
 * این کلاس برای ایجاد یک مش (Mesh) با استفاده از شیدرهای (Shaders) سفارشی استفاده می‌شود.
 */
var ob = (function () {
  /**
   * سازنده کلاس ob
   * @param {Object} env - تنظیمات اولیه شامل رنگ و مواد.
   */
  function a(env) {
    es(this, a); // فراخوانی سازنده پایه

    // تعریف ویژگی‌های مواد و شیدرهای مورد استفاده
    var t = {
      uniforms: {
        uColor: { type: "v3", value: env.color }, // رنگ یکنواخت
        uOpacity: { type: "f", value: 1 }, // شفافیت
      },
      vertexShader:
        "#define GLSLIFY 1\nvoid main(){\n  gl_Position = vec4(position, 1.0);\n}", // تعریف شیدر ورتکس
      fragmentShader:
        "#define GLSLIFY 1\nuniform vec3 uColor;\nuniform float uOpacity;\n\nvoid main(){\n  gl_FragColor = vec4(uColor, uOpacity);\n}", // تعریف شیدر فرگمنت
      depthWrite: !1, // غیرفعال کردن نوشتن به بافر عمق
      fog: !1, // غیرفعال کردن مه
    };

    // اگر `env` حاوی ویژگی `material` باشد، آن را به تنظیمات مواد اضافه می‌کنیم.
    if (env.hasOwnProperty("material"))
      for (var i in env.material) t[i] = env.material[i];

    // ایجاد یک ZoneDescriptor و UpdateDispatcher
    var n = new ZoneDescriptor(t), // تعریف منطقه مواد
      r = new UpdateDispatcher(2, 2, 1, 1); // تنظیم به‌روزرسانی‌های مورد نیاز

    // ایجاد مش و تنظیم ویژگی‌های آن
    (this.mesh = new JobDispatcher(r, n)),
      (this.mesh.frustumCulled = !1), // غیرفعال کردن برش با frustum
      (this.mesh.renderOrder = -1); // تنظیم ترتیب رندر
  }

  return (
    is(a, [
      /**
       * متد dispose
       * آزاد کردن منابع اختصاص داده شده.
       */
      {
        key: "dispose",
        value: function () {},
      },
      /**
       * ویژگی opacity
       * شفافیت مش را تنظیم یا برمی‌گرداند.
       */
      {
        key: "opacity",
        get: function () {
          return this.mesh.material.uniforms.uOpacity.value; // گرفتن مقدار شفافیت
        },
        set: function (env) {
          this.mesh.material.uniforms.uOpacity.value = env; // تنظیم مقدار شفافیت
        },
      },
    ]),
    a
      );
    })(),
    sb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this, env))).index = env.index), // مقداردهی شماره شاخص
      (t.color = env.color), // مقداردهی رنگ
      (t.owner = env.owner), // مقداردهی مالک
      (t.mouseX = 0), // مقدار اولیه موقعیت X موس
      (t.mouseY = 0), // مقدار اولیه موقعیت Y موس
      (t.mousePosition = new yu(t.mouseX, t.mouseY, 0.5)), // مقداردهی موقعیت موس
      (t.mouseEnabled = !1), // غیرفعال کردن تعامل موس
      (t.onMouseMoveCallback = t.onMouseMove.bind(StringStorage(StringStorage(t)))), // ایجاد callback برای رویداد حرکت موس
      (t.timeline = null), // مقداردهی اولیه تایم‌لاین
      (t.scene = new Wm()), // ایجاد صحنه
      (t.background = null), // مقدار اولیه پس‌زمینه
      (t.mouseControlPosition = new mu(t.mouseX, t.mouseY)), // موقعیت کنترل موس
      (t.cameraPositionInit = new yu()), // مقدار اولیه موقعیت دوربین
      (t.cameraTargetPositionInit = new yu()), // مقدار اولیه موقعیت هدف دوربین
      (t.mouseControlDirection = new mu(1, 1)), // جهت کنترل موس
      (t.slowMovementIsRunning = !1), // وضعیت حرکت آهسته
      (t.slowMovementStartTime = 0), // زمان شروع حرکت آهسته
      (t.slowMovementDuration = 40), // مدت زمان حرکت آهسته
      (t.slowMovementProgress = 0), // پیشرفت حرکت آهسته
      (t.slowMovementDirection = 1), // جهت حرکت آهسته

      // مقداردهی اولیه اجزای مختلف
      t.initCamera(), // مقداردهی دوربین
      t.initLights(), // مقداردهی نورها
      t.initMeshes(), // مقداردهی مش‌ها
          t
        );
      }

      return (
        ns(i, bs),
        is(i, [
          {
            key: "initCamera",
            value: function () {
              (this.cameraPivot = new Pp()),
                this.cameraPivot.position.set(-5, 10, 5),
                this.scene.add(this.cameraPivot),
                (this.camera = new zm(
                  37,
                  window.innerWidth / window.innerHeight,
                  0.1,
                  1e3,
                )),
                (this.camera.zoom = 1.5625),
                this.camera.updateProjectionMatrix(),
                this.cameraPivot.add(this.camera),
                (this.cameraTarget = new Pp()),
                this.cameraPivot.add(this.cameraTarget),
                (this.cameraTargetPosition = new yu()),
                (this.cameraWorldPosition = new yu());
            },
          },
          {
            key: "initLights",
            value: function () {
              this.cameraPivot.updateMatrixWorld(),
                this.camera.getWorldPosition(this.cameraWorldPosition);
              var env = this.color === ul ? 0.4 : 2;
              (this.mouseLight = new my(3423042, env, 70, fu.degToRad(12), 1, 2)),
                this.mouseLight.position.copy(this.cameraWorldPosition),
                this.scene.add(this.mouseLight),
                this.scene.add(this.mouseLight.target);
            },
          },
          {
            key: "initMeshes",
            value: function () {
              (this.boxes = []),
                this.color === ul &&
                  ((this.background = new ob({ color: new $GlobalReference(16777215) })),
                  this.scene.add(this.background.mesh));
              for (var env = 0; env < 13; env++) {
                var t = rb.create(this.color);
                (t.position.y = env * (6 + rb.HEIGHT) * -1 - 17),
                  (t.rotation.x = fu.degToRad(90)),
                  this.scene.add(t),
                  this.boxes.push(t);
              }
            },
          },
          {
            key: "dispose",
            value: function () {
              this.disableMouse(), this.disposeLights(), this.disposeMeshes();
            },
          },
          {
            key: "disposeLights",
            value: function () {},
          },
          {
            key: "disposeMeshes",
            value: function () {
              for (
                this.background &&
                (this.background.dispose(),
                this.scene.remove(this.background),
                (this.background = null));
                this.boxes.length;

              ) {
                var env = this.boxes.shift();
                this.scene.remove(env);
              }
            },
          },
          {
            key: "enableMouse",
            value: function () {
              this.mouseEnabled ||
                ((this.mouseEnabled = !0),
                window.addEventListener("mousemove", this.onMouseMoveCallback));
            },
          },
          {
            key: "disableMouse",
            value: function () {
              this.mouseEnabled &&
                ((this.mouseEnabled = !1),
                window.removeEventListener(
                  "mousemove",
                  this.onMouseMoveCallback,
                ));
            },
          },
          {
            key: "createAnimIn",
            value: function (env) {
              (this.timeline = new TimelineLite({ onComplete: env })),
                this.enableMouse();
            },
          },
          {
            key: "createAnimOut",
            value: function (env) {
              (this.timeline = new TimelineLite({ onComplete: env })),
                this.disableMouse(),
                this.pauseSlowMovement();
            },
          },
          {
            key: "updateMouseLight",
            value: function () {
              this.camera.getWorldPosition(this.cameraWorldPosition),
                this.mouseLight.position.copy(this.cameraWorldPosition),
                (this.mousePosition.x = this.mouseX),
                (this.mousePosition.y = this.mouseY),
                this.mousePosition.unproject(this.camera);
              var env = this.mousePosition
                  .sub(this.cameraWorldPosition)
                  .normalize(),
                t = -this.cameraWorldPosition.z / env.z,
                i = this.cameraWorldPosition.clone().add(env.multiplyScalar(t));
              (this.mouseLight.target.position.x +=
                0.08 * (i.x - this.mouseLight.target.position.x)),
                (this.mouseLight.target.position.y +=
                  0.08 * (i.y - this.mouseLight.target.position.y));
            },
          },
          {
            key: "updateMouseControl",
            value: function () {
              var env = this.mouseX,
                t = this.mouseY;
              (this.mouseControlPosition.x +=
                0.08 * (env - this.mouseControlPosition.x)),
                (this.mouseControlPosition.y +=
                  0.08 * (t - this.mouseControlPosition.y)),
                (this.camera.position.x +=
                  this.mouseControlPosition.x * this.mouseControlDirection.x),
                (this.camera.position.y +=
                  this.mouseControlPosition.y * this.mouseControlDirection.y);
            },
          },
          {
            key: "getCameraFov",
            value: function () {
              return (
                (env = window.innerWidth),
                (t = window.innerHeight),
                void 0 === (i = 1920) && (i = 36),
                void 0 === (n = 1080) && (n = 24),
                (n * (env / (i / 28))) / t
              );
              var env, t, i, n;
            },
          },
          {
            key: "render",
            value: function () {
              this.cameraTarget.getWorldPosition(this.cameraTargetPosition),
                this.renderCamera(),
                this.slowMovementIsRunning && this.updateSlowMovement(),
                this.mouseEnabled &&
                  (this.updateMouseLight(),
                  this.timeline || this.updateMouseControl());
            },
          },
          {
            key: "renderCamera",
            value: function () {
              this.camera.lookAt(this.cameraTargetPosition);
            },
          },
          {
            key: "resize",
            value: function () {
              (this.camera.aspect = window.innerWidth / window.innerHeight),
                this.camera.updateProjectionMatrix();
            },
          },
          {
            key: "startSlowMovement",
            value: function () {
              (this.slowMovementIsRunning = !0),
                (this.slowMovementStartTime = Date.now()),
                this.cameraPositionInit.copy(this.camera.position),
                this.cameraTargetPositionInit.copy(this.cameraTarget.position);
            },
          },
          {
            key: "pauseSlowMovement",
            value: function () {
              this.slowMovementIsRunning = !1;
            },
          },
          {
            key: "updateSlowMovement",
            value: function () {
              var env =
                (Date.now() - this.slowMovementStartTime) /
                (1e3 * this.slowMovementDuration);
              (this.slowMovementProgress =
                1 === this.slowMovementDirection ? env : 1 - env),
                1 < env &&
                  ((this.slowMovementDirection *= -1),
                  (this.slowMovementStartTime = Date.now()));
            },
          },
          {
            key: "onMouseMove",
            value: function (env) {
              (this.mouseX = (env.clientX / window.innerWidth) * 2 - 1),
                (this.mouseY = (env.clientY / window.innerHeight) * -2 + 1);
            },
          },
          {
            key: "onAnimateInComplete",
            value: function (env) {
              hs(rs(i.prototype), "onAnimateInComplete", this).call(this, env),
                (this.timeline = null),
                this.startSlowMovement();
            },
          },
          {
            key: "onAnimateOutComplete",
            value: function (env) {
              hs(rs(i.prototype), "onAnimateOutComplete", this).call(this, env),
                this.disableMouse();
            },
          },
        ]),
        i
      );
    })(),
    lb = (function (env) {
function n(env) {
  var t;
  return (
    es(this, n), // فراخوانی سازنده والد برای تنظیم ارث‌بری.
    (t = ls(this, rs(n).call(this, env))), // ساختاردهی شیء `t` با استفاده از فراخوانی والد.
    t.mouseControlDirection.set(-1, -1), // تنظیم جهت کنترل ماوس به مقادیر (-1, -1).
    t // بازگرداندن شیء `t`.
  );
}


return (
  ns(n, sb),
  is(n, [
    {
      key: "initCamera",
      value: function () {
        hs(rs(n.prototype), "initCamera", this).call(this), // فراخوانی متد والد برای مقداردهی اولیه دوربین.
          this.camera.position.set(-2.9, -105, 98), // تنظیم موقعیت اولیه دوربین.
          this.cameraTarget.position.set(-0.8, -34, 15), // تنظیم موقعیت هدف دوربین.
          (this.cameraPivot.rotation.y = fu.degToRad(-43)); // چرخش پایه دوربین در محور y.
      },
    },
    {
      key: "initLights",
      value: function () {
        hs(rs(n.prototype), "initLights", this).call(this), // فراخوانی متد والد برای مقداردهی اولیه نورها.
          (this.mouseLight.distance = 100); // تنظیم فاصله نور مرتبط با حرکت ماوس.
        var env = new my(
          16777215, // رنگ نور سفید.
          1.5, // شدت نور.
          1.5 * rb.SIZE, // اندازه فاصله مؤثر نور.
          fu.degToRad(90), // زاویه تابش نور.
          1, // کاهش شدت نور.
          1 // شعاع نور.
        );
        env.position.set(-76.4, -31.6, 85.1), // تنظیم موقعیت نور.
          this.scene.add(env), // اضافه کردن نور به صحنه.
          this.scene.add(env.target), // اضافه کردن هدف نور به صحنه.
          env.target.position.set(-42, 35, -43); // موقعیت هدف نور.
      },
    },
    {
      key: "createAnimIn",
      value: function (env) {
        var i = this;
        hs(rs(n.prototype), "createAnimIn", this).call(this, env), // فراخوانی متد والد برای تنظیمات اولیه انیمیشن ورود.
          this.timeline.from(
            this.camera.position,
            3.2, // مدت زمان انیمیشن.
            {
              y: "+=3", // تغییر موقعیت دوربین در محور y.
              ease: Is.easeNone, // آسان‌سازی خطی.
            },
            0 // زمان شروع انیمیشن.
          ),
          this.boxes.forEach(function (env, t) {
            i.timeline.from(
              env.rotation,
              3, // مدت زمان انیمیشن.
              { z: fu.degToRad(20), ease: Power2.easeInOut }, // چرخش جعبه‌ها در محور z با آسان‌سازی نرم.
              -0.15 * t // تأخیر بین انیمیشن هر جعبه.
            );
          });
      },
    },
    {
      key: "createAnimOut",
      value: function (env) {
        hs(rs(n.prototype), "createAnimOut", this).call(this, env), // فراخوانی متد والد برای تنظیمات انیمیشن خروج.
          this.timeline.to(
            this.camera.position,
            2, // مدت زمان انیمیشن.
            {
              x: 13.1, // موقعیت جدید دوربین در محور x.
              y: -143.7, // موقعیت جدید دوربین در محور y.
              z: 85.8, // موقعیت جدید دوربین در محور z.
              ease: Power2.easeInOut, // آسان‌سازی نرم.
            },
            0 // زمان شروع انیمیشن.
          ),
          this.timeline.to(
            this.cameraTarget.position,
            2, // مدت زمان انیمیشن.
            {
              x: -1.2, // موقعیت جدید هدف دوربین در محور x.
              y: -36.2, // موقعیت جدید هدف دوربین در محور y.
              z: 13.7, // موقعیت جدید هدف دوربین در محور z.
              ease: Power2.easeInOut, // آسان‌سازی نرم.
            },
            0 // زمان شروع انیمیشن.
          );
      },
    },
    {
      key: "updateSlowMovement",
      value: function () {
        hs(rs(n.prototype), "updateSlowMovement", this).call(this), // فراخوانی متد والد برای حرکت آهسته.
          this.camera.position.set(
            this.cameraPositionInit.x, // حفظ موقعیت اولیه دوربین در محور x.
            this.cameraPositionInit.y - 15 * this.slowMovementProgress, // تغییر موقعیت دوربین در محور y بر اساس پیشرفت حرکت.
            this.cameraPositionInit.z // حفظ موقعیت اولیه دوربین در محور z.
          );
      },
    },
  ]),
  n
);

    })(),
    hb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this, env))).slowMovementDuration = 70),
          t.mouseControlDirection.set(1, -1),
          t
        );
      }

      return (
        ns(i, sb),
        is(i, [
          {
      // مقداردهی اولیه دوربین.
      key: "initCamera",
      value: function () {
        hs(rs(i.prototype), "initCamera", this).call(this), // فراخوانی متد والد برای مقداردهی اولیه.
          this.camera.position.set(56.3, -49.5, -58.6), // تنظیم موقعیت دوربین.
          this.cameraTarget.position.set(-73.8, -64.7, -21.9), // تنظیم موقعیت هدف دوربین.
          (this.cameraPivot.rotation.x = fu.degToRad(-58)), // چرخش دوربین در محور x.
          (this.cameraPivot.rotation.y = fu.degToRad(-58)); // چرخش دوربین در محور y.
      },
    },
    {
      // مقداردهی اولیه نورها.
      key: "initLights",
      value: function () {
        hs(rs(i.prototype), "initLights", this).call(this); // فراخوانی متد والد برای مقداردهی نورها.
        var env = new my(16777215, 0.6, 0, 0.28, 1, 6); // تعریف نور نقطه‌ای با شدت و موقعیت مشخص.
        env.position.set(-68, 50, -81), // تنظیم موقعیت نور.
          this.scene.add(env), // افزودن نور به صحنه.
          this.scene.add(env.target), // افزودن هدف نور به صحنه.
          env.target.position.set(-42, 35, -43); // تنظیم موقعیت هدف نور.
      },
    },
    {
      // ایجاد انیمیشن ورود.
      key: "createAnimIn",
      value: function (env) {
        hs(rs(i.prototype), "createAnimIn", this).call(this, env), // فراخوانی متد والد.
          this.timeline
            .from(
              this.camera.position,
              3, // مدت زمان انیمیشن.
              {
                x: 84.7,
                y: 0.7,
                z: -10.1,
                ease: Os.easeInOut, // استفاده از ease برای روان‌سازی حرکت.
              },
              0, // زمان شروع انیمیشن.
            )
            .from(
              this.cameraTarget.position,
              3,
              { x: -41.4, y: -65.2, z: -44.3, ease: Os.easeInOut },
              0,
            );
      },
    },
    {
      // ایجاد انیمیشن خروج.
      key: "createAnimOut",
      value: function (env) {
        hs(rs(i.prototype), "createAnimOut", this).call(this, env); // فراخوانی متد والد.
        var direction = this.owner.currentScreen.index > this.index ? 1 : -1; // تعیین جهت حرکت بر اساس موقعیت صفحات.
        if (direction === 1) {
          this.timeline.to(
            this.camera.position,
            2, // مدت زمان انیمیشن.
            {
              x: 37,
              y: -63,
              z: -74,
              ease: Os.easeInOut,
            },
            0, // زمان شروع انیمیشن.
          ),
            this.timeline.to(
              this.cameraTarget.position,
              2,
              {
                x: -60.5,
                y: -67.3,
                z: -37.7,
                ease: Os.easeInOut,
              },
              0,
            );
        } else {
          this.timeline
            .to(
              this.camera.position,
              3,
              {
                x: 84.7,
                y: 0.7,
                z: -10.1,
                ease: Os.easeInOut,
              },
              0,
            )
            .to(
              this.cameraTarget.position,
              3,
              { x: -41.4, y: -65.2, z: -44.3, ease: Os.easeInOut },
              0,
            );
        }
      },
    },
    {
      // تنظیمات چرخش دوربین.
      key: "renderCamera",
      value: function () {
        hs(rs(i.prototype), "renderCamera", this).call(this), // فراخوانی متد والد.
          this.camera.rotateZ(fu.degToRad(-58)); // چرخش دوربین در محور z.
      },
    },
    {
      // به‌روزرسانی حرکت آهسته دوربین.
      key: "updateSlowMovement",
      value: function () {
        hs(rs(i.prototype), "updateSlowMovement", this).call(this), // فراخوانی متد والد.
          this.camera.position.set(
            this.cameraPositionInit.x - 10 * this.slowMovementProgress, // تنظیم موقعیت جدید بر اساس پیشرفت حرکت.
            this.cameraPositionInit.y - 10 * this.slowMovementProgress,
            this.cameraPositionInit.z - 10 * this.slowMovementProgress,
          ),
          this.cameraTarget.position.set(
            this.cameraTargetPositionInit.x -
              10 * this.slowMovementProgress,
            this.cameraTargetPositionInit.y -
              10 * this.slowMovementProgress,
            this.cameraTargetPositionInit.z,
                );
            },
          },
        ]),
        i
      );
    })(),
    cb = (function () {
  // تعریف کلاس `cb` که برای مدیریت تصاویر و متریال‌های شیدر استفاده می‌شود.
  function n(env) {
    es(this, n); // فراخوانی سازنده کلاس والد.
    (this.path = env.path), // مسیر تصویر.
      (this.width = env.width), // عرض تصویر.
      (this.height = env.height); // ارتفاع تصویر.

    // تعریف متریال شیدر با استفاده از مقادیر و ویژگی‌های مشخص‌شده.
    var t = new ZoneDescriptor({
      uniforms: {
        uTexture: {
          type: "t", // نوع uniform: texture.
          value: new Hv().load(
            app.rootUrl + "/assets/img/" + env.path, // بارگذاری تصویر از مسیر مشخص.
          ),
        },
        uRatio: { type: "v2", value: this.getImageRatio() }, // نسبت تصویر.
        uTranslateX: { type: "f", value: 0 }, // مقدار انتقال در محور x.
        uTranslateY: { type: "f", value: 0 }, // مقدار انتقال در محور y.
      },
      vertexShader:
        // شیدر راس (Vertex Shader) که برای پردازش مختصات رأس‌ها استفاده می‌شود.
        "#define GLSLIFY 1\nvarying vec2 vUv;\n\nuniform float uTranslateX;\nuniform float uTranslateY;\n\n// انتقال و مقیاس‌دهی تصویر\nvoid main(){\n  vUv = uv;\n\n  float scale = 1.1;\n\n  // ماتریس انتقال (Translation Matrix)\n  mat4 tPos = mat4(\n    vec4(1.0,0.0,0.0,0.0),\n    vec4(0.0,1.0,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(uTranslateX,uTranslateY,0.0,1.0)\n  );\n\n  // ماتریس مقیاس‌دهی (Scaling Matrix)\n  mat4 sPos = mat4(\n    vec4(scale,0.0,0.0,0.0),\n    vec4(0.0,scale,0.0,0.0),\n    vec4(0.0,0.0,1.0,0.0),\n    vec4(0.0,0.0,0.0,1.0)\n  );\n\n  mat4 vPosition = tPos * sPos;\n\n  gl_Position = vPosition * vec4(position, 1.0);\n}",
      fragmentShader:
        // شیدر قطعه‌ای (Fragment Shader) که رنگ پیکسل‌ها را تنظیم می‌کند.
        "#define GLSLIFY 1\nvarying vec2 vUv;\n    \nuniform sampler2D uTexture;\nuniform vec2 uRatio;\n    \nvoid main(){\n  vec2 uv = vec2(\n    vUv.x * uRatio.x + (1.0 - uRatio.x) * 0.5,\n    vUv.y * uRatio.y + (1.0 - uRatio.y) * 0.5\n  );\n\n  gl_FragColor = texture2D(uTexture , uv);\n}",
      depthWrite: !1, // غیرفعال کردن نوشتن در بافر عمق.
      depthTest: !1, // غیرفعال کردن تست عمق.
      fog: !1, // غیرفعال کردن مه.
      transparent: !0, // فعال کردن شفافیت.
      blending: env.blending || null, // تنظیم blending اگر مشخص شده باشد.
    });

    // تعریف هندسه تصویر.
    var i = new UpdateDispatcher(2, 2, 1, 1); // تعریف ابعاد هندسه.
    (this.mesh = new JobDispatcher(i, t)), // اتصال هندسه به متریال.
      (this.mesh.frustumCulled = !1); // غیرفعال کردن حذف بر اساس میدان دید.
  }

  return (
    is(n, [
      {
        key: "dispose",
        value: function () {
          // متد برای پاکسازی منابع.
        },
      },
      {
        key: "getImageRatio",
        value: function () {
          // محاسبه نسبت تصویر برای حفظ تناسب ابعاد.
          return new mu(
            Math.min(
              window.innerWidth /
                window.innerHeight /
                (this.width / this.height),
              1,
            ),
            Math.min(
              window.innerHeight /
                window.innerWidth /
                (this.height / this.width),
              1,
            ),
          );
        },
      },
      {
        key: "resize",
        value: function () {
          // به‌روزرسانی نسبت تصویر هنگام تغییر اندازه پنجره.
          this.mesh.material.uniforms.uRatio.value = this.getImageRatio();
        },
      },
      {
        key: "x",
        get: function () {
          // مقدار فعلی انتقال در محور x را بازمی‌گرداند.
          return this.mesh.material.uniforms.uTranslateX.value;
        },
        set: function (env) {
          // مقدار جدید انتقال در محور x را تنظیم می‌کند.
          this.mesh.material.uniforms.uTranslateX.value = env;
        },
      },
      {
        key: "y",
        get: function () {
          // مقدار فعلی انتقال در محور y را بازمی‌گرداند.
          return this.mesh.material.uniforms.uTranslateY.value;
        },
        set: function (env) {
          // مقدار جدید انتقال در محور y را تنظیم می‌کند.
          this.mesh.material.uniforms.uTranslateY.value = env;
            },
          },
        ]),
        n
      );
    })(),
    ub = (function (env) {
      function r(env) {
        var t;
        return (
          es(this, r),
          ((t = ls(this, rs(r).call(this, env))).slowMovementDuration = 120),
          t
        );
      }

      return (
        ns(r, sb),
        is(
          r,
          [
{
  // متد برای مقداردهی اولیه دوربین
  key: "initCamera",
  value: function () {
    // فراخوانی متد initCamera از کلاس والد
    hs(rs(r.prototype), "initCamera", this).call(this);

    // تنظیم چرخش محور دوربین
    this.cameraPivot.rotation.x = fu.degToRad(-58); // تبدیل زاویه به رادیان برای محور X
    this.cameraPivot.rotation.y = fu.degToRad(-58); // تبدیل زاویه به رادیان برای محور Y

    // تنظیم موقعیت دوربین
    this.camera.position.set(16, -102, -78);

    // تنظیم موقعیت هدف دوربین
    this.cameraTarget.position.set(-91.8, -51.8, -51.1);
  },
},
{
  // متد برای مقداردهی اولیه نورپردازی
  key: "initLights",
  value: function () {
    // فراخوانی متد initLights از کلاس والد
    hs(rs(r.prototype), "initLights", this).call(this);

    // ایجاد منبع نور با مشخصات
    var env = new my(16777215, 0.16, 0, 0.37, 1, 6); // رنگ، شدت، موقعیت، و ویژگی‌های دیگر

    // تنظیم موقعیت نور
    env.position.set(-31, 53, 42);

    // افزودن منبع نور به صحنه
    this.scene.add(env);

    // افزودن هدف نور به صحنه
    this.scene.add(env.target);

    // تنظیم موقعیت هدف نور
    env.target.position.set(178, -651, 195);
  },
},
{
  // متد برای مقداردهی اولیه مش‌ها (اشکال هندسی)
  key: "initMeshes",
  value: function () {
    // فراخوانی متد initMeshes از کلاس والد
    hs(rs(r.prototype), "initMeshes", this).call(this);

    // دریافت اطلاعات تصویر
    var env = r.getImage(),
        t = env.path,   // مسیر تصویر
        i = env.width,  // عرض تصویر
        n = env.height; // ارتفاع تصویر

    // ایجاد یک مش (شیء سه‌بعدی) برای تصویر
    this.image = new cb({
      path: t,      // مسیر تصویر
      width: i,     // عرض تصویر
      height: n,    // ارتفاع تصویر
      blending: dh, // نوع blending
    });

    // افزودن مش تصویر به صحنه
    this.scene.add(this.image.mesh);

    // ایجاد یک مش جدید برای پیش‌زمینه
    this.foreground = new ob({
      color: new $GlobalReference(16777215), // رنگ
      material: { depthTest: !1, transparent: !0 }, // تنظیمات متریال
    });

    // تنظیمات رندر برای پیش‌زمینه
    this.foreground.mesh.renderOrder = 0;  // ترتیب رندر
    this.foreground.mesh.visible = !1;    // پیش‌فرض نامرئی

    // افزودن مش پیش‌زمینه به صحنه
    this.scene.add(this.foreground.mesh);
  },
},
{
  // متد برای پاکسازی مش‌ها
  key: "disposeMeshes",
  value: function () {
    // فراخوانی متد disposeMeshes از کلاس والد
    hs(rs(r.prototype), "disposeMeshes", this).call(this);

    // پاکسازی و حذف مش تصویر
    this.image.dispose();
    this.scene.remove(this.image.mesh);
    this.image = null;

    // پاکسازی و حذف مش پیش‌زمینه
    this.foreground.dispose();
    this.scene.remove(this.foreground);
    this.foreground = null;
  },
},


            {
              key: "createAnimIn",
              value: function (env) {
                hs(rs(r.prototype), "createAnimIn", this).call(this, env);
                var t =
                  this.owner.previousScreen &&
                  this.owner.previousScreen.index >
                    this.owner.currentScreen.index
                    ? -1
                    : 1;
                this.timeline
                  .from(
                    this.camera.position,
                    2,
                    {
                      x: 32.6,
                      y: -96.3,
                      z: -73.9,
                      ease: Os.easeInOut,
                    },
                    0,
                  )
                  .from(
                    this.cameraTarget.position,
                    2,
                    {
                      x: -64.8,
                      y: -58,
                      z: -48,
                      ease: Os.easeInOut,
                    },
                    0,
                  )
                  .from(
                    this.image,
                    2,
                    {
                      y: -0.5 * t,
                      ease: Power3.easeInOut,
                    },
                    0,
                  ),
                  this.owner.previousScreen &&
                    this.owner.previousScreen.color === ul &&
                    ((this.foreground.mesh.visible = !0),
                    this.timeline.to(
                      this.foreground,
                      1.5,
                      {
                        opacity: 0,
                        ease: Os.easeInOut,
                      },
                      0,
                    ));
              },
            },
            {
              key: "createAnimOut",
              value: function (env) {
                hs(rs(r.prototype), "createAnimOut", this).call(this, env);
                var t = this.owner.currentScreen.index > this.index ? 1 : -1;
                1 === t
                  ? this.timeline
                      .to(
                        this.camera.position,
                        2,
                        {
                          x: 0,
                          y: -103,
                          z: -73,
                          ease: Os.easeInOut,
                        },
                        0,
                      )
                      .to(
                        this.cameraTarget.position,
                        2,
                        {
                          x: -168,
                          y: -55,
                          z: -74,
                          ease: Os.easeInOut,
                        },
                        0,
                      )
                  : this.timeline
                      .to(
                        this.camera.position,
                        2,
                        {
                          x: 32.6,
                          y: -96.3,
                          z: -73.9,
                          ease: Os.easeInOut,
                        },
                        0,
                      )
                      .to(
                        this.cameraTarget.position,
                        2,
                        {
                          x: -64.8,
                          y: -58,
                          z: -48,
                          ease: Os.easeInOut,
                        },
                        0,
                      ),
                  this.timeline.to(
                    this.image,
                    2,
                    {
                      y: 0.5 * t,
                      ease: Power3.easeInOut,
                    },
                    0,
                  ),
this.owner.currentScreen &&
  this.owner.currentScreen.color === ul &&
  // اگر رنگ صفحه فعلی برابر با مقدار `ul` باشد
  ((this.foreground.mesh.visible = !0), // فعال کردن نمایش mesh پیش‌زمینه
  this.timeline.fromTo(
    // شروع یک انیمیشن در تایم‌لاین
    this.foreground, // المان mesh پیش‌زمینه به عنوان هدف انیمیشن
    1.5, // مدت زمان انیمیشن
                      { opacity: 0 },
                      {
                        opacity: 1,
                        ease: Os.easeInOut,
                      },
                      0,
                    ));
              },
            },
            {
              key: "renderCamera",
              value: function () {
                hs(rs(r.prototype), "renderCamera", this).call(this),
    // اعمال چرخش‌های دوربین
    this.camera.rotateX(fu.degToRad(-6)); // چرخش دوربین حول محور X به مقدار -6 درجه
    this.camera.rotateY(fu.degToRad(-7)); // چرخش دوربین حول محور Y به مقدار -7 درجه
    this.camera.rotateZ(fu.degToRad(-116)); // چرخش دوربین حول محور Z به مقدار -116 درجه
              },
            },
            {
  // متد برای تغییر اندازه (Resize)
  key: "resize",
  value: function () {
    // فراخوانی متد resize از کلاس والد
    hs(rs(r.prototype), "resize", this).call(this);

    // تغییر اندازه تصویر
    this.image.resize();
              },
            },
            {
  // متد برای به‌روزرسانی حرکت آهسته (Slow Movement)
  key: "updateSlowMovement",
  value: function () {
    // فراخوانی متد updateSlowMovement از کلاس والد
    hs(rs(r.prototype), "updateSlowMovement", this).call(this);
    // تنظیم موقعیت دوربین بر اساس مقدار slowMovementProgress
    this.camera.position.set(
      this.cameraPositionInit.x - 10 * this.slowMovementProgress, // موقعیت X
      this.cameraPositionInit.y - 10 * this.slowMovementProgress, // موقعیت Y
      this.cameraPositionInit.z - 10 * this.slowMovementProgress, // موقعیت Z
                  ),
    // تنظیم موقعیت هدف دوربین
    this.cameraTarget.position.set(
      this.cameraTargetPositionInit.x - 10 * this.slowMovementProgress, // موقعیت X
      this.cameraTargetPositionInit.y - 10 * this.slowMovementProgress, // موقعیت Y
      this.cameraTargetPositionInit.z, // موقعیت Z (بدون تغییر)
                  );
              },
            },
            {
  // متد برای به‌روزرسانی کنترل ماوس
  key: "updateMouseControl",
  value: function () {
    // فراخوانی متد updateMouseControl از کلاس والد
    hs(rs(r.prototype), "updateMouseControl", this).call(this);

    // تنظیم موقعیت تصویر بر اساس موقعیت و جهت کنترل ماوس
    this.image.x =
      this.mouseControlPosition.x * this.mouseControlDirection.x * -0.03; // مقدار X
    this.image.y =
      this.mouseControlPosition.y * this.mouseControlDirection.y * -0.03; // مقدار Y
              },
            },
            {
  // متد برای تکمیل انیمیشن ورود (Animation In Complete)
  key: "onAnimateInComplete",
  value: function (env) {
    // فراخوانی متد onAnimateInComplete از کلاس والد
    hs(rs(r.prototype), "onAnimateInComplete", this).call(this, env);

    // اگر مقدار env نامعتبر باشد، مش پیش‌زمینه (foreground) را غیرفعال کن
    env || (this.foreground && (this.foreground.mesh.visible = !1));
              },
            },
          ],
          [
            {
  // متد استاتیک برای گرفتن اطلاعات تصویر
  key: "getImage",
  value: function () {
    // تعیین سطح کیفیت تصویر بر اساس عرض پنجره
    var env = 1024 < app.windowWidth ? 2 : 1;

    // تنظیم ابعاد تصویر
    var t = 1024 * env;

    // بازگرداندن جزئیات تصویر
    return {
      width: t, // عرض تصویر
      height: 512 * env, // ارتفاع تصویر
      path: "home-2-".concat(t, ".jpg"), // مسیر تصویر
                };
              },
            },
          ],
        ),
        r
      );
    })(),
    pb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this, env))).slowMovementDuration = 120),
          t
        );
      }

      return (
        ns(i, sb),
        is(i, [
{
  // متد برای مقداردهی اولیه دوربین
  key: "initCamera",
  value: function () {
    // فراخوانی متد initCamera از کلاس والد
    hs(rs(i.prototype), "initCamera", this).call(this);

    // تنظیم چرخش محور دوربین
    this.cameraPivot.rotation.x = fu.degToRad(-50); // تبدیل زاویه به رادیان برای محور X
    this.cameraPivot.rotation.y = fu.degToRad(-63); // تبدیل زاویه به رادیان برای محور Y
    this.cameraPivot.rotation.z = fu.degToRad(30);  // تبدیل زاویه به رادیان برای محور Z

    // تنظیم موقعیت دوربین
    this.camera.position.set(11.6, -86.6, -27.9);

    // تنظیم موقعیت هدف دوربین
    this.cameraTarget.position.set(-78.4, -61.4, -38);

    // تنظیم موقعیت محوری که دوربین روی آن قرار دارد
    this.cameraPivot.position.set(15, 1.21, -6);
  },
},
{
  // متد برای مقداردهی اولیه نورپردازی
  key: "initLights",
  value: function () {
    // فراخوانی متد initLights از کلاس والد
    hs(rs(i.prototype), "initLights", this).call(this);

    // ایجاد منبع نور با مشخصات
    var env = new my(16777215, 0.21, 0, 0.59, 1, 6); // رنگ، شدت، موقعیت، و ویژگی‌های دیگر

    // تنظیم موقعیت نور
    env.position.set(68, 13, 68);

    // افزودن منبع نور به صحنه
    this.scene.add(env);

    // افزودن هدف نور به صحنه
    this.scene.add(env.target);

    // تنظیم موقعیت هدف نور
    env.target.position.set(-197, -474, -44);
  },
},
{
  // متد ایجاد انیمیشن ورود
  key: "createAnimIn",
  value: function (env) {
    // فراخوانی متد createAnimIn از کلاس والد
    hs(rs(i.prototype), "createAnimIn", this).call(this, env);

    // افزودن انیمیشن برای موقعیت دوربین
    this.timeline.from(
      this.camera.position, // موقعیت دوربین
      2, // مدت زمان انیمیشن
      {
        x: -2.5, // مختصات X
        y: -88,  // مختصات Y
        z: -48,  // مختصات Z
        ease: Os.easeInOut, // نوع easing
      },
      0, // شروع از زمان صفر
    );
  },
},
{
  // متد ایجاد انیمیشن خروج
  key: "createAnimOut",
  value: function (env) {
    // فراخوانی متد createAnimOut از کلاس والد
    hs(rs(i.prototype), "createAnimOut", this).call(this, env);

    // تعیین جهت انیمیشن (جلو یا عقب)
    var direction = this.owner.currentScreen.index > this.index ? 1 : -1;

    // تنظیم انیمیشن بر اساس جهت
    if (direction === 1) {
      this.timeline.to(
        this.camera.position, // موقعیت دوربین
        2, // مدت زمان انیمیشن
        {
          x: 1, // مختصات X
          y: -98, // مختصات Y
          z: -31, // مختصات Z
          ease: Os.easeInOut, // نوع easing
        },
        0, // شروع از زمان صفر
      );
      this.timeline.to(
        this.cameraTarget.position, // موقعیت هدف دوربین
        2, // مدت زمان انیمیشن
        {
          x: -76, // مختصات X
          y: -60, // مختصات Y
          z: -40, // مختصات Z
          ease: Os.easeInOut, // نوع easing
        },
        0, // شروع از زمان صفر
      );
    } else {
      this.timeline.to(
        this.camera.position, // موقعیت دوربین
        2, // مدت زمان انیمیشن
        {
          x: -2.5, // مختصات X
          y: -88,  // مختصات Y
          z: -48,  // مختصات Z
          ease: Os.easeInOut, // نوع easing
        },
        0, // شروع از زمان صفر
      );
    }
  },
},
{
  // متد برای رندر دوربین
  key: "renderCamera",
  value: function () {
    // فراخوانی متد renderCamera از کلاس والد
    hs(rs(i.prototype), "renderCamera", this).call(this);

    // اعمال چرخش اضافی به دوربین
    this.camera.rotateX(fu.degToRad(24));  // چرخش حول محور X
    this.camera.rotateZ(fu.degToRad(-80)); // چرخش حول محور Z
  },
},
{
  // متد برای به‌روزرسانی حرکت آهسته دوربین
  key: "updateSlowMovement",
  value: function () {
    // فراخوانی متد updateSlowMovement از کلاس والد
    hs(rs(i.prototype), "updateSlowMovement", this).call(this);

    // تنظیم موقعیت دوربین با توجه به پیشرفت حرکت آهسته
    this.camera.position.set(
      this.cameraPositionInit.x + 10 * this.slowMovementProgress, // X
      this.cameraPositionInit.y + 10 * this.slowMovementProgress, // Y
      this.cameraPositionInit.z + 10 * this.slowMovementProgress, // Z
    );

    // تنظیم موقعیت هدف دوربین
    this.cameraTarget.position.set(
      this.cameraTargetPositionInit.x + 30 * this.slowMovementProgress, // X
      this.cameraTargetPositionInit.y + 10 * this.slowMovementProgress, // Y
      this.cameraTargetPositionInit.z + 10 * this.slowMovementProgress, // Z
    );
  },
},
        ]),
        i
      );
    })(),
    db = (function (env) {
      function r(env) {
        var t;
        return (
          es(this, r),
          ((t = ls(this, rs(r).call(this, env))).slowMovementDuration = 120),
          t
        );
      }

      return (
        ns(r, sb),
        is(
          r,
          [
            {
  key: "initCamera",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `initCamera` از کلاس والد
    hs(rs(r.prototype), "initCamera", this).call(this);

    // تنظیم چرخش محوری برای محوری که دوربین روی آن قرار دارد
    this.cameraPivot.rotation.set(-0.99, -1.31, 0.28); // چرخش در محورهای X، Y و Z

    // تنظیم موقعیت مکانی برای محوری که دوربین روی آن قرار دارد
    this.cameraPivot.position.set(15.2, 7.56, 9.57); // موقعیت در محورهای X، Y و Z

    // تنظیم موقعیت دوربین
    this.camera.position.set(23.5, -54.5, -36);

    // تنظیم موقعیت هدف دوربین
    this.cameraTarget.position.set(-51.8, -45, -34);
  },
},
{
  // تعریف متد `initLights`
  key: "initLights",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `initLights` از کلاس والد
    hs(rs(r.prototype), "initLights", this).call(this);

    // ایجاد نور با مقادیر مشخص
    var env = new my(16777215, 0.16, 0, 1.57, 1, 6); // رنگ، شدت، موقعیت و دیگر ویژگی‌های نور

    // تنظیم موقعیت نور
    env.position.set(66, 9, 64);

    // افزودن نور به صحنه
    this.scene.add(env);

    // افزودن هدف نور به صحنه
    this.scene.add(env.target);

    // تنظیم موقعیت هدف نور
    env.target.position.set(1, -16, -1);
  },
},
{
  // تعریف متد `initMeshes`
  key: "initMeshes",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `initMeshes` از کلاس والد
    hs(rs(r.prototype), "initMeshes", this).call(this);

    // دریافت اطلاعات تصویر شامل مسیر و ابعاد
    var env = r.getImage(),
      t = env.path, // مسیر تصویر
      i = env.width, // عرض تصویر
      n = env.height; // ارتفاع تصویر

    // ایجاد مش برای تصویر
    this.image = new cb({
      path: t, // مسیر تصویر
      width: i, // عرض تصویر
      height: n, // ارتفاع تصویر
      blending: mh, // نوع بلندینگ
    });

    // افزودن مش تصویر به صحنه
    this.scene.add(this.image.mesh);
  },
},
{
  // تعریف متد `disposeMeshes`
  key: "disposeMeshes",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `disposeMeshes` از کلاس والد
    hs(rs(r.prototype), "disposeMeshes", this).call(this);

    // حذف و آزادسازی منابع مرتبط با تصویر
    this.image.dispose();

    // حذف مش تصویر از صحنه
    this.scene.remove(this.image.mesh);

    // تنظیم مقدار تصویر به `null` برای جلوگیری از استفاده‌ی مجدد
    this.image = null;
  },
},
{
  // تعریف متد `createAnimIn`
  key: "createAnimIn",

  // مقداردهی متد
  value: function (env) {
    // فراخوانی متد `createAnimIn` از کلاس والد
    hs(rs(r.prototype), "createAnimIn", this).call(this, env);

    // تعیین جهت انیمیشن بر اساس موقعیت صفحه قبلی و جاری
    var t =
      this.owner.previousScreen &&
      this.owner.previousScreen.index > this.owner.currentScreen.index
        ? -1
        : 1;

    // تنظیم انیمیشن برای ورود
    this.timeline
      .from(
        this.camera.position, // موقعیت دوربین
        2, // مدت زمان انیمیشن
        {
          x: 22, // موقعیت محور X
          y: -59.7, // موقعیت محور Y
          z: -36, // موقعیت محور Z
          ease: Os.easeInOut, // نوع easing
        },
        0, // زمان شروع انیمیشن
      )
      .from(
        this.image, // تصویر مرتبط
        2, // مدت زمان انیمیشن
        { y: -0.5 * t, ease: Power3.easeInOut }, // تنظیمات موقعیت و easing
        0, // زمان شروع انیمیشن
                  );
              },
            },
            {
  // کلید یا متدی به نام `createAnimOut`
  key: "createAnimOut",

  // مقداردهی متد
  value: function (env) {
    // فراخوانی متد `createAnimOut` از کلاس والد
    hs(rs(r.prototype), "createAnimOut", this).call(this, env);

    // تعیین جهت انیمیشن بر اساس مقایسه `index` صفحه جاری و صفحه مالک
    var t = this.owner.currentScreen.index > this.index ? 1 : -1;

    // اگر جهت مثبت باشد (به جلو حرکت کند)
    1 === t
      ? this.timeline
          // انیمیشن حرکت دوربین
          .to(
            this.camera.position, // تنظیم موقعیت دوربین
            2, // مدت زمان انیمیشن
            {
              x: 20, // موقعیت جدید در محور X
              y: -60, // موقعیت جدید در محور Y
              z: -37, // موقعیت جدید در محور Z
              ease: Os.easeInOut, // نوع easing برای حرکت نرم
            },
            0, // زمان شروع انیمیشن
          )
          // انیمیشن حرکت هدف دوربین
          .to(
            this.cameraTarget.position, // تنظیم موقعیت هدف دوربین
            2, // مدت زمان انیمیشن
            {
              x: -72, // موقعیت جدید در محور X
              y: -38, // موقعیت جدید در محور Y
              z: -32, // موقعیت جدید در محور Z
              ease: Os.easeInOut, // نوع easing
            },
            0, // زمان شروع انیمیشن
          )
      : // اگر جهت منفی باشد (به عقب حرکت کند)
        this.timeline
          .to(
            this.camera.position, // تنظیم موقعیت دوربین
            2, // مدت زمان انیمیشن
            {
              x: 22, // موقعیت جدید در محور X
              y: -59.7, // موقعیت جدید در محور Y
              z: -36, // موقعیت جدید در محور Z
              ease: Os.easeInOut, // نوع easing
            },
            0, // زمان شروع انیمیشن
          )
          // انیمیشن حرکت تصویر
          .to(
            this.image, // تنظیم موقعیت تصویر
            2, // مدت زمان انیمیشن
            {
              y: -0.5 * t, // حرکت عمودی تصویر با توجه به جهت
              ease: Power3.easeInOut, // نوع easing
            },
            0, // زمان شروع انیمیشن
          ),

      // انیمیشن دیگر برای حرکت تصویر
      this.timeline.to(
        this.image, // تنظیم موقعیت تصویر
        2, // مدت زمان انیمیشن
        {
          y: 0.5 * t, // حرکت عمودی تصویر در جهت مخالف
          ease: Power3.easeInOut, // نوع easing
        },
        0, // زمان شروع انیمیشن
      );
  },
},

            {
              key: "renderCamera",
              value: function () {
                hs(rs(r.prototype), "renderCamera", this).call(this),
                  this.camera.rotateX(fu.degToRad(17)),
                  this.camera.rotateY(fu.degToRad(9)),
                  this.camera.rotateZ(fu.degToRad(-208));
              },
            },
            {
  // کلید یا متدی به نام `updateSlowMovement`
  key: "updateSlowMovement",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `updateSlowMovement` از کلاس والد
    hs(rs(r.prototype), "updateSlowMovement", this).call(this);

    // تنظیم موقعیت دوربین با استفاده از مقادیر اولیه و پیشرفت حرکت آهسته
    this.camera.position.set(
      this.cameraPositionInit.x + 10 * this.slowMovementProgress, // تغییر موقعیت X
      this.cameraPositionInit.y + 5 * this.slowMovementProgress,  // تغییر موقعیت Y
      this.cameraPositionInit.z + 5 * this.slowMovementProgress   // تغییر موقعیت Z
    );

    // تنظیم موقعیت هدف دوربین با استفاده از مقادیر اولیه و پیشرفت حرکت آهسته
    this.cameraTarget.position.set(
      this.cameraTargetPositionInit.x + 10 * this.slowMovementProgress, // تغییر موقعیت X
      this.cameraTargetPositionInit.y + 5 * this.slowMovementProgress,  // تغییر موقعیت Y
      this.cameraTargetPositionInit.z + 5 * this.slowMovementProgress,  // تغییر موقعیت Z
                  );
              },
            },
            {
  // کلید یا متدی به نام `updateMouseControl`
  key: "updateMouseControl",

  // مقداردهی متد
  value: function () {
    // فراخوانی متد `updateMouseControl` از کلاس والد
    hs(rs(r.prototype), "updateMouseControl", this).call(this);

    // به‌روزرسانی مختصات X تصویر با استفاده از موقعیت کنترل ماوس و جهت کنترل ماوس
    this.image.x =
      this.mouseControlPosition.x *
      this.mouseControlDirection.x *
      -0.03;

    // به‌روزرسانی مختصات Y تصویر با استفاده از موقعیت کنترل ماوس و جهت کنترل ماوس
    this.image.y =
      this.mouseControlPosition.y *
      this.mouseControlDirection.y *
      -0.03;
              },
            },
          ],
          [
            {
              key: "getImage",
              value: function () {
                var env = 1024 < app.windowWidth ? 2 : 1,
                  t = 1024 * env;
                return {
                  width: t,
                  height: 512 * env,
                  path: "home-4-".concat(t, ".jpg"),
                };
              },
            },
          ],
        ),
        r
      );
    })();

// تعریف تابع سازنده `fb`
function fb(env, t) {
  // فراخوانی سازنده کلاس `Hx`
  Hx.call(this);

  // تعیین اینکه آیا برای رندرینگ نیاز به سوآپ (تعویض) وجود دارد یا خیر
  this.needsSwap = false;

  // تنظیم رنگ پاک‌سازی (clearColor) با مقدار پیش‌فرض یا مقدار ورودی
  this.clearColor = env !== undefined ? env : 0;

  // تنظیم مقدار آلفای پاک‌سازی (clearAlpha) با مقدار پیش‌فرض یا مقدار ورودی
  this.clearAlpha = t !== undefined ? t : 0;
}


// تعریف پروتوتایپ برای کلاس `fb` و ارث‌بری از `Hx.prototype`
fb.prototype = Object.assign(
  Object.create(Hx.prototype), // ایجاد شیء جدید که از `Hx.prototype` ارث می‌برد
  {
    constructor: fb, // تعیین سازنده برای کلاس `fb`

    render: function (env, t, i, n, r) {
      // تابع `render` برای مدیریت رندرینگ

      var a, ObjectMethodWrapper;

      // اگر رنگ شفافیت تعریف شده باشد
      this.clearColor &&
        ((a = env.getClearColor().getHex()), // ذخیره مقدار رنگ فعلی
        (ObjectMethodWrapper = env.getClearAlpha()), // ذخیره مقدار آلفای فعلی
        env.setClearColor(this.clearColor, this.clearAlpha)); // تنظیم رنگ و آلفای جدید

      env.setRenderTarget(this.renderToScreen ? null : i); // تعیین هدف رندر (به صفحه یا بافر مشخص)

      env.clear(); // پاکسازی رندر با رنگ و آلفای فعلی

      // بازیابی رنگ و آلفای قبلی در صورت تغییر
      this.clearColor && env.setClearColor(a, ObjectMethodWrapper);
    },
  });
  var mb,
    gb,
    vb,
    yb =
      "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    _b =
      "#define GLSLIFY 1\n// first inspiration\n// @see https://simonharris.co/2018/06/10/making-a-noise-film-grain-post-processing-effect-from-scratch-in-threejs/\n\nuniform float uAmount;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\n// @see https://thebookofshaders.com/10/\nfloat random (vec2 SymbolStore) {\n  return fract(sin(dot(SymbolStore.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\n// @see https://github.com/jamieowen/glsl-blend/blob/master/overlay.glsl\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvoid main () {\n  vec4 color = texture2D( tDiffuse, vUv );\n  float rnd = random(vUv * uAmount);\n  vec3 blend = vec3(rnd * .5);\n  vec3 base = vec3(color.rgb);\n  vec3 result = blendOverlay(base, blend, .5);\n\n  gl_FragColor = vec4(result, 1.0);\n}",
    xb = 1,
    SecondArgument = 1,
    wb = 1.5 * xb,
    Tb = 1.5 * SecondArgument,
    Sb = 0,
    Eb = 0;

  function Ab() {
    var env = new CharacterDecoder(wb, Tb);
    (vb = new JobDispatcher(env, new Gd({ color: 16777215 }))).rotation.z = fu.degToRad(10);
    var t = new ju().setFromObject(vb);
    (Sb = t.max.y + 0.5 * SecondArgument), (Eb = t.min.y - 0.5 * SecondArgument);
  }

  var Mb = {
      VIEW_WIDTH: xb,
      VIEW_HEIGHT: SecondArgument,
      WIDTH: wb,
      HEIGHT: Tb,
      get minY() {
        return vb || Ab(), Sb;
      },
      get maxY() {
        return vb || Ab(), Eb;
      },
      get camera() {
        return (
          mb ||
            ((mb = new vy(
              xb / -2,
              xb / 2,
              SecondArgument / 2,
              SecondArgument / -2,
              1,
              1e3,
            )).position.z = 1),
          mb
        );
      },
      get scene() {
        return gb || ((gb = new Wm()), vb || Ab(), gb.add(vb)), gb;
      },
      get y() {
        return vb || Ab(), vb.position.y;
      },
      set y(env) {
        vb || Ab(), (vb.position.y = env);
      },
    },
    Pb = [lb, hb, ub, pb, db],
    Lb = (function () {
      function t(env) {
        es(this, t),
// مقداردهی اولیه ویژگی‌ها و فراخوانی توابع برای تنظیمات اولیه کلاس

this.element = env.element; // عنصر اصلی مربوط به محیط رندرینگ
this.numScreens = env.screenElements.length; // تعداد صفحات موجود برای پردازش
this.isRunning = false; // وضعیت اجرای چرخه رندر (غیرفعال به صورت پیش‌فرض)
this.renderCallback = this.render.bind(this); // اتصال تابع رندر به کانتکست کلاس

// فراخوانی توابع اولیه‌سازی
this.initRenderer(); // مقداردهی و تنظیمات اولیه رندرکننده
this.initComposer(); // مقداردهی و تنظیمات اولیه ترکیب‌کننده افکت‌ها
this.initScreenNavigator(env.screenElements); // مقداردهی و تنظیمات اولیه مدیریت صفحات

      }

      return (
        is(t, [
          {
            key: "initRenderer",
            value: function () {
              (this.renderer = new jm({
                antialias: !1,
                canvas: this.element.querySelector(".home__background"),
              })),
                this.renderer.setSize(window.innerWidth, window.innerHeight),
                this.renderer.setClearColor(67084),
                (this.renderer.autoClear = !1);
            },
          },
          {
            key: "initComposer",
            value: function () {
              var env = {
                  minFilter: LineCounter,
                  magFilter: LineCounter,
                  format: Sc,
                  stencilBuffer: !0,
                },
                t = new Bu(window.innerWidth, window.innerHeight, env);
              (this.composer = new Xx(this.renderer, t)),
// تنظیم و مقداردهی اولیه مراحل مختلف پردازش تصویری برای صفحات جاری و قبلی

this.currentScreenRenderPass = new Wx(); // ایجاد یک مرحله رندر برای صفحه جاری
this.currentScreenRenderPass.clear = false; // غیرفعال کردن پاکسازی مرحله
this.currentScreenRenderPass.enabled = false; // غیرفعال کردن مرحله به‌صورت پیش‌فرض

this.currentScreenMaskPass = new jx(Mb.scene, Mb.camera); // ایجاد مرحله ماسک برای صفحه جاری
this.currentScreenMaskPass.enabled = false; // غیرفعال کردن ماسک صفحه جاری به‌صورت پیش‌فرض

this.previousScreenMaskPass = new jx(Mb.scene, Mb.camera); // ایجاد مرحله ماسک برای صفحه قبلی
this.previousScreenMaskPass.enabled = false; // غیرفعال کردن ماسک صفحه قبلی به‌صورت پیش‌فرض
this.previousScreenMaskPass.inverse = true; // تنظیم ماسک صفحه قبلی به حالت معکوس

this.clearMaskPass = new Vx(); // ایجاد مرحله پاکسازی ماسک
this.clearMaskPass.enabled = false; // غیرفعال کردن پاکسازی ماسک به‌صورت پیش‌فرض

this.previousScreenRenderPass = new Wx(); // ایجاد مرحله رندر برای صفحه قبلی
this.previousScreenRenderPass.clear = false; // غیرفعال کردن پاکسازی مرحله
this.previousScreenRenderPass.enabled = false; // غیرفعال کردن مرحله به‌صورت پیش‌فرض

              var i = new Gx(Yx),
                n = new Gx(Bx);
              n.renderToScreen = !0;
              var r = new fb();
              this.noiseCounter = 0;
              var a = {
                uniforms: {
                  tDiffuse: { value: null },
                  uAmount: { value: this.noiseCounter },
                },
                vertexShader: yb,
                fragmentShader: _b,
              };
              (this.noisePass = new Gx(a)),
// افزودن مراحل (Pass) به کامپوزر برای انجام پردازش‌های مختلف گرافیکی

this.composer.addPass(r); // اضافه کردن مرحله اولیه (احتمالاً مربوط به پردازش اولیه)
this.composer.addPass(this.currentScreenMaskPass); // اضافه کردن مرحله ماسک برای صفحه جاری
this.composer.addPass(this.currentScreenRenderPass); // اضافه کردن مرحله رندر صفحه جاری
this.composer.addPass(this.clearMaskPass); // اضافه کردن مرحله پاکسازی ماسک
this.composer.addPass(this.previousScreenMaskPass); // اضافه کردن مرحله ماسک برای صفحه قبلی
this.composer.addPass(this.previousScreenRenderPass); // اضافه کردن مرحله رندر صفحه قبلی
this.composer.addPass(this.clearMaskPass); // اضافه کردن یک مرحله دیگر برای پاکسازی ماسک
this.composer.addPass(i); // اضافه کردن مرحله‌ای دیگر (ممکن است به‌صورت سفارشی تعریف شده باشد)
this.composer.addPass(this.noisePass); // اضافه کردن مرحله‌ای برای اعمال نویز روی تصویر
this.composer.addPass(n); // اضافه کردن مرحله پایانی برای پردازش

            },
          },
          {
            key: "initScreenNavigator",
            value: function (env) {
              (this.screenNavigator = new ws()),
                (this.screenNavigator.transitionType = xs.OutAndIn),
                this.screenNavigator.on(
                  "transitionStart",
                  this.onScreenNavigatorTransitionStart.bind(this),
                ),
                this.screenNavigator.on(
                  "transitionComplete",
                  this.onScreenNavigatorTransitionComplete.bind(this),
                );
              for (var t = 0; t < this.numScreens; t++) {
                var i = Pb[t] || lb,
                  n = env[t].classList.contains("home__screen--light") ? ul : pl,
                  r = new ds(i, {
                    arguments: [
                      { index: t, color: n, owner: this.screenNavigator },
                    ],
                  });
                this.screenNavigator.addScreen(t.toString(), r);
              }
            },
          },
          {
            key: "dispose",
            value: function () {
              this.stop(),
                this.disposeRenderer(),
                this.disposeComposer(),
                this.disposeScreenNavigator(),
                rb.dispose();
            },
          },
          {
            key: "disposeRenderer",
            value: function () {
              this.renderer.dispose();
            },
          },
          {
            key: "disposeComposer",
            value: function () {
              (this.composer.renderer = null),
                (this.composer.renderTarget = null);
            },
          },
          {
            key: "disposeScreenNavigator",
            value: function () {
              this.screenNavigator.off("transitionStart"),
                this.screenNavigator.dispose();
            },
          },
          {
            key: "animateIn",
            value: function () {
              var t = this;
              return new Promise(function (env) {
                Ss.from(t.element, 1, {
                  opacity: 0,
                  ease: Cs.easeNone,
                  onComplete: env,
                });
              });
            },
          },
          {
            key: "start",
            value: function () {
              this.isRunning ||
                ((this.isRunning = !0),
                Ss.ticker.addEventListener("tick", this.renderCallback));
            },
          },
          {
            key: "stop",
            value: function () {
              this.isRunning &&
                ((this.isRunning = !1),
                Ss.ticker.removeEventListener("tick", this.renderCallback));
            },
          },
          {
            key: "render",
            value: function () {
              this.screenNavigator.currentScreen.render(),
                (this.noiseCounter += 0.01),
                (this.noisePass.uniforms.uAmount.value = this.noiseCounter),
                this.composer.render();
            },
          },
          {
            key: "resize",
            value: function () {
              this.screenNavigator.currentScreen.resize(),
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            },
          },
          {
            key: "showScreen",
            value: function (env) {
              this.start(), this.screenNavigator.showScreen(env.toString());
            },
          },
          {
  key: "onScreenNavigatorTransitionStart",
  value: function () {
    // دریافت صفحه فعلی و صفحه قبلی از ScreenNavigator
    var env = this.screenNavigator.currentScreen,
        t = this.screenNavigator.previousScreen;
    
    // تنظیم صحنه و دوربین برای صفحه فعلی و فعال کردن رندر آن
    ((this.currentScreenRenderPass.scene = env.scene),
     (this.currentScreenRenderPass.camera = env.camera),
     (this.currentScreenRenderPass.enabled = !0));
    
    // اگر صفحه قبلی وجود دارد، تنظیمات مربوطه انجام شود
    if (t) {
      // تعیین جهت حرکت بر اساس اندیس صفحات (جهت: به جلو یا عقب)
      var i = t.index < env.index ? 1 : -1;

      // تنظیم صحنه و دوربین برای صفحه قبلی و فعال کردن رندر آن
      (this.previousScreenRenderPass.scene = t.scene),
      (this.previousScreenRenderPass.camera = t.camera),
      (this.previousScreenRenderPass.enabled = !0),
      
      // فعال کردن ماسک‌ها برای صفحات فعلی و قبلی
      (this.currentScreenMaskPass.enabled = !0),
      (this.previousScreenMaskPass.enabled = !0),
      
      // فعال کردن عملیات پاکسازی ماسک
      (this.clearMaskPass.enabled = !0),
      
      // تنظیم انیمیشن تغییر مقدار `y` با استفاده از GSAP
      Ss.fromTo(
        Mb, // تنظیم مقدار `Mb` (مثلا یک ماسک یا آبجکت تنظیم‌کننده)
        2,  // مدت زمان انیمیشن: 2 ثانیه
        { y: 1 === i ? Mb.maxY : Mb.minY }, // مقدار اولیه `y` بر اساس جهت حرکت
        {
          y: 0, // مقدار نهایی `y` (هم‌ترازی)
          ease: Os.easeInOut, // استفاده از نوع انیمیشن easeInOut
                    },
                  );
              }
            },
          },
          {
  key: "onScreenNavigatorTransitionComplete",
  value: function () {
    // غیرفعال کردن رندر پس صفحه قبلی
    (this.previousScreenRenderPass.enabled = !1),
    // غیرفعال کردن ماسک پس صفحه جاری
    (this.currentScreenMaskPass.enabled = !1),
    // غیرفعال کردن ماسک پس صفحه قبلی
    (this.previousScreenMaskPass.enabled = !1),
    // غیرفعال کردن پس پاک‌سازی ماسک
    (this.clearMaskPass.enabled = !1);
            },
          },
        ]),
        t
      );
    })(),
    Cb = Ws("transform"),
    Ib = (function (env) {
function i(env) {
  var t;
  return (
    // فراخوانی سازنده کلاس پدر و مقداردهی اولیه
    es(this, i),
    // مقداردهی اولیه عنصر اصلی (parentElement)
    ((t = ls(this, rs(i).call(this))).element =
      env.parentElement.querySelector(".home__pagination")),
    // انتخاب عنصر متن مربوط به صفحه‌بندی
    (t.textElement = t.element.querySelector(".home__pagination__text")),
    // انتخاب عنصر متن مربوط به شماره فعلی صفحه‌بندی
    (t.textCurrentElement = t.element.querySelector(
      ".home__pagination__text__current",
    )),
    // انتخاب عنصر نوار مربوط به صفحه‌بندی
    (t.barElement = t.element.querySelector(".home__pagination__bar")),
    // انتخاب عنصر پیشرفت نوار صفحه‌بندی
    (t.progressElement = t.element.querySelector(
      ".home__pagination__bar__progress",
    )),
    // انتخاب تمام آیتم‌های صفحه‌بندی
    (t.itemElements = t.element.querySelectorAll(
      ".home__pagination__item",
    )),
    // مقداردهی شاخص فعلی صفحه‌بندی (عدد صفحه فعلی)
    (t.currentIndex = 1),
    // تعداد کل صفحات
    (t.total = env.total),
    // وضعیت نمایش صفحه‌بندی (پیش‌فرض: مخفی)
    (t.isVisible = !1),
    // مقداردهی اولیه تایملاین و انیمیشن پیشرفت
    (t.timeline = null),
    (t.progressTween = null),
    // مقداردهی اولیه قابلیت درگ
    t.initDraggable(),
    // مقداردهی اولیه قابلیت رول‌اور
    t.initRollOver(),
    // بازگرداندن مقدار کلاس مقداردهی شده
    t
  );
}


      return (
        ns(i, ps),
        is(i, [
          {
    key: "initDraggable",
    value: function () {
      // بررسی اینکه آیا قابلیت درگ فعال باشد (برای دستگاه‌های غیرموبایل)
      (this.isDraggable = !app.isMobile),
        this.isDraggable &&
          // اگر درگ فعال است، مقداردهی اولیه مربوطه انجام می‌شود
          ((this.isDragging = !1), // در حال حاضر درگ غیرفعال است
          (this.mouseDownCallback = this.onMouseDown.bind(this)), // تعریف کال‌بک برای رویداد کلیک ماوس
          (this.mouseMoveCallback = this.onMouseMove.bind(this)), // تعریف کال‌بک برای حرکت ماوس
          (this.mouseUpCallback = this.onMouseUp.bind(this)), // تعریف کال‌بک برای برداشتن ماوس
          (this.frameCallback = this.onFrame.bind(this)), // تعریف کال‌بک برای فریم‌ها
          (this.mouseY = 0), // مقداردهی اولیه موقعیت عمودی ماوس
          (this.barY = 0), // مقداردهی اولیه موقعیت عمودی نوار
          (this.barHeight = 0), // مقداردهی اولیه ارتفاع نوار
          (this.progressY = 0), // مقداردهی اولیه موقعیت پیشرفت
          (this.oldProgressY = 0), // مقداردهی اولیه موقعیت پیشین پیشرفت
          this.barElement.addEventListener(
            "mousedown", // افزودن رویداد کلیک ماوس به عنصر نوار
            this.mouseDownCallback,
          ),
          this.resizeDraggable()); // فراخوانی تابع تنظیم مجدد اندازه درگ
    },
  },
  {
    key: "initRollOver",
    value: function () {
      // مقداردهی اولیه برای قابلیت رول‌اور
      (this.isHovered = !1), // وضعیت شناور بودن ماوس را غیرفعال می‌کند
        (this.hoveredIndex = -1), // تنظیم شاخص پیش‌فرض برای عناصر شناور
        (this.rollOverCallback = this.onRollOver.bind(this)), // تعریف کال‌بک برای ورود ماوس
        (this.rollOutCallback = this.onRollOut.bind(this)), // تعریف کال‌بک برای خروج ماوس
        (this.hoverElement = this.element.querySelector(
          ".home__pagination__bar__hover", // انتخاب عنصر مربوط به رول‌اور
        )),
        this.barElement.addEventListener(
          "mouseenter", // افزودن رویداد ورود ماوس به عنصر نوار
          this.rollOverCallback,
        ),
        this.barElement.addEventListener(
          "mouseleave", // افزودن رویداد خروج ماوس از عنصر نوار
          this.rollOutCallback,
        );
    },
  },
  {
    key: "dispose",
    value: function () {
      // حذف تمام تایملاین‌ها و رویدادهای مربوطه
      this.disposeTimeline(), // حذف تایملاین‌ها
        this.disposeDraggable(), // حذف قابلیت درگ
        this.disposeRollOver(); // حذف قابلیت رول‌اور
    },
  },
  {
    key: "disposeTimeline",
    value: function () {
      // حذف تایملاین اگر وجود داشته باشد
      this.timeline &&
        (this.timeline.kill(), // توقف تایملاین
        Ds(this.timeline), // پاک‌سازی تایملاین
        (this.timeline = null)); // تنظیم تایملاین به مقدار null
    },
  },
  {
    key: "disposeDraggable",
    value: function () {
      // حذف قابلیت درگ اگر فعال باشد
      this.isDraggable &&
        (this.stopDrag(), // توقف حالت درگ
        this.removeMouseListeners(), // حذف شنوندگان رویداد ماوس
        this.barElement.removeEventListener(
          "mousedown", // حذف رویداد کلیک ماوس از عنصر نوار
          this.mouseDownCallback,
        ));
    },
  },
  {
    key: "disposeRollOver",
    value: function () {
      // حذف قابلیت رول‌اور
      this.removeMouseListeners(), // حذف شنوندگان رویداد ماوس
        this.barElement.removeEventListener(
          "mouseenter", // حذف رویداد ورود ماوس به عنصر نوار
          this.rollOverCallback,
        ),
        this.barElement.removeEventListener(
          "mouseleave", // حذف رویداد خروج ماوس از عنصر نوار
          this.rollOutCallback,
        );
    },
  },
  {
    key: "resize",
    value: function () {
      // فراخوانی تنظیم مجدد اندازه درگ
      this.resizeDraggable();
    },
  },
  {
    key: "resizeDraggable",
    value: function () {
      // محاسبه اندازه و موقعیت نوار در صورت فعال بودن درگ
      if (this.isDraggable) {
        var env = this.barElement.getBoundingClientRect(); // دریافت موقعیت و اندازه عنصر
        (this.barY = env.y), // تنظیم موقعیت عمودی نوار
          (this.barHeight = env.height); // تنظیم ارتفاع نوار
              }
            },
          },
          {
            key: "show",
            value: function () {
              this.isVisible || ((this.isVisible = !0), this.animateIn());
            },
          },
          {
            key: "hide",
            value: function () {
              this.isVisible && ((this.isVisible = !1), this.animateOut());
            },
          },
          {
            key: "animateIn",
            value: function () {
              var env = this.currentIndex / this.total;
              this.disposeTimeline(),
                (this.timeline = new Us({
                  onComplete: this.onTimelineComplete.bind(this),
                })
                  .from(
                    this.barElement,
                    0.9,
                    {
                      scaleY: 0,
                      yPercent: 100,
                      ease: Fs.easeInOut,
                    },
                    0,
                  )
                  .fromTo(
                    this.progressElement,
                    0.9,
                    { scaleY: 0, yPercent: 100 },
                    {
                      scaleY: 1,
                      yPercent: 0,
                      data: { clear: !1 },
                      ease: Fs.easeInOut,
                    },
                    "-=.4",
                  )
                  .to(this.progressElement, 0.8, {
                    scaleY: env,
                    ease: Fs.easeInOut,
                    data: { clear: !1 },
                  })
                  .addLabel("text", "-=.8")
                  .fromTo(
                    this.textElement,
                    1,
                    { yPercent: 50 },
                    {
                      yPercent: 100 * env,
                      ease: Fs.easeInOut,
                      data: { clear: !1 },
                    },
                    "text",
                  )
                  .fromTo(
                    this.textElement,
                    1,
                    { opacity: 0 },
                    {
                      opacity: 1,
                      ease: Fs.easeInOut,
                    },
                    "text",
                  )
                  .set(this.textElement, { transition: "none" }, 0));
            },
          },
          {
            key: "animateOut",
            value: function () {
              this.timeline = new Us({
                onComplete: this.onTimelineComplete.bind(this),
              })
                .to(
                  this.textElement,
                  0.5,
                  {
                    opacity: 0,
                    yPercent: 50,
                    ease: Fs.easeInOut,
                  },
                  0,
                )
                .to(
                  this.progressElement,
                  0.5,
                  {
                    scaleY: 0,
                    yPercent: 100,
                    ease: Fs.easeInOut,
                  },
                  0,
                )
                .to(
                  this.barElement,
                  0.9,
                  { scaleY: 0, yPercent: 100, ease: Fs.easeInOut },
                  "-=.3",
                );
            },
          },
          {
            key: "setCurrentIndex",
            value: function (env) {
              if (this.currentIndex !== env) {
                var t = env / this.total;
                (this.currentIndex = env),
                  (this.textCurrentElement.textContent = "0" + env),
                  this.isVisible &&
                    !this.timeline &&
                    (Ss.to(this.textElement, 0.7, {
                      yPercent: 100 * t,
                      ease: Fs.easeInOut,
                    }),
                    this.isDragging ||
                      (this.progressTween = Ss.to(this.progressElement, 0.7, {
                        scaleY: t,
                        ease: Fs.easeInOut,
                      })),
                    this.emit("change", { index: env }));
              }
            },
          },
          {
            key: "startDrag",
            value: function () {
              this.isDragging ||
                ((this.isDragging = !0),
                window.addEventListener("mouseup", this.mouseUpCallback));
            },
          },
          {
            key: "stopDrag",
            value: function () {
              this.isDragging &&
                ((this.isDragging = !1),
                this.isHovered || this.removeMouseListeners(),
                window.removeEventListener("mouseup", this.mouseUpCallback));
            },
          },
          {
            key: "updateDraggable",
            value: function () {
              var env = (this.mouseY - this.barY) / this.barHeight;
              1 < env ? (env = 1) : env < 0 && (env = 0);
              var t = Math.round(env / 0.25);
              t < 1 && (t = 1),
                this.progressTween &&
                  (this.progressTween.kill(), (this.progressTween = null)),
                (this.oldProgressY = this.progressY),
                (this.progressY = env);
              var i = Math.abs(this.progressY - this.oldProgressY);
              (this.progressElement.style[Cb] = "scaleY(".concat(env, ")")),
                t !== this.currentIndex && i < 0.01 && this.setCurrentIndex(t);
            },
          },
          {
            key: "updateRollOver",
            value: function () {
              if (!this.timeline && this.isHovered) {
                var env = (this.mouseY - this.barY) / this.barHeight;
                1 < env ? (env = 1) : env < 0 && (env = 0);
                var t = Math.round(env / 0.25);
                if ((t < 1 && (t = 1), t !== this.hoveredIndex)) {
                  var i = this.hoveredIndex;
                  (this.hoveredIndex = t),
                    Ss.to(this.hoverElement, 0.4, {
                      scaleY: this.hoveredIndex * (1 / this.total),
                    }),
                    -1 !== i &&
                      Ss.to(this.itemElements[i], 0.4, { opacity: 0.3 }),
                    Ss.to(this.itemElements[this.hoveredIndex], 0.4, {
                      opacity: 1,
                    });
                }
              }
            },
          },
          {
            key: "addMouseListeners",
            value: function () {
              window.addEventListener("mousemove", this.mouseMoveCallback),
                Ss.ticker.addEventListener("tick", this.frameCallback);
            },
          },
          {
            key: "removeMouseListeners",
            value: function () {
              window.removeEventListener("mousemove", this.mouseMoveCallback),
                Ss.ticker.removeEventListener("tick", this.frameCallback);
            },
          },
          {
            key: "onTimelineComplete",
            value: function () {
              this.disposeTimeline();
            },
          },
          {
            key: "onMouseDown",
            value: function (env) {
              this.timeline || ((this.mouseY = env.clientY), this.startDrag());
            },
          },
          {
            key: "onMouseMove",
            value: function (env) {
              this.mouseY = env.clientY;
            },
          },
          {
            key: "onMouseUp",
            value: function (env) {
              this.stopDrag(),
                (this.progressTween = Ss.fromTo(
                  this.progressElement,
                  0.7,
                  { scaleY: this.progressY },
                  {
                    scaleY: this.currentIndex / this.total,
                    ease: Fs.easeInOut,
                  },
                ));
            },
          },
          {
            key: "onRollOver",
            value: function (env) {
              (this.mouseY = env.clientY),
                (this.isHovered = !0),
                this.addMouseListeners();
            },
          },
          {
            key: "onRollOut",
            value: function () {
              (this.isHovered = !1),
                Ss.to(this.hoverElement, 0.4, {
                  scaleY: this.currentIndex * (1 / this.total),
                }),
                Ss.to(this.itemElements[this.hoveredIndex], 0.4, {
                  opacity: 0.3,
                }),
                (this.hoveredIndex = -1),
                this.isDragging || this.removeMouseListeners();
            },
          },
          {
            key: "onFrame",
            value: function () {
              this.isDragging && this.updateDraggable(),
                this.isHovered && this.updateRollOver();
            },
          },
        ]),
        i
      );
    })(),
    Rb = (function () {
function i(env) {
  // فراخوانی تابع سازنده اصلی
  es(this, i),
    // مقداردهی به رنگ پیش‌زمینه
    (this.foregroundColor = env.color),
    // مقداردهی به عنصر هدف
    (this.element = env.element);
  
  // گرفتن رنگ پس‌زمینه از سبک محاسبه‌شده عنصر
  var t = window
    .getComputedStyle(this.element) // دریافت سبک محاسبه‌شده عنصر
    .getPropertyValue("color") // گرفتن مقدار رنگ
    .split("rgb(") // حذف پیشوند "rgb("
    .join("") // جایگزینی با رشته خالی
    .split(")") // حذف پسوند ")"
    .join(""); // جایگزینی با رشته خالی
  
  // تبدیل مقادیر رنگ به آرایه‌ای از اعداد صحیح
  (this.backgroundColor = t.split(",").map(function (env) {
    return parseInt(env); // تبدیل هر مقدار به عدد صحیح
  })),
    // وضعیت اجرای انیمیشن در ابتدا غیرفعال است
    (this.isRunning = !1),
    // تنظیم مقادیر اولیه اشاره‌گر و حرکت نرم آن
    (this.pointerX = this.smoothPointerX = 0),
    (this.pointerY = this.smoothPointerY = 0),
    // ایجاد کال‌بک‌های فریم، حرکت ماوس و لمس
    (this.frameCallback = this.onFrame.bind(this)),
    (this.mouseMoveCallback = this.onMouseMove.bind(this)),
    (this.touchCallback = this.onTouch.bind(this)),
    // مقداردهی آرایه‌های موقعیت کاراکترها و رنگ کاراکترها
    (this.charPositions = []),
    (this.charColors = []),
    // مقداردهی اولیه کاراکترها
    this.initChars();
}

return (
  is(i, [
    {
      key: "initChars",
      value: function () {
        // ایجاد متن جداشده به صورت کاراکترهای جداگانه
        (this.splitText = new Bs(this.element)),
          // تعداد کاراکترهای جداشده را ذخیره می‌کند
          (this.numChars = this.splitText.chars.length);
        
        // پیمایش روی تمام کاراکترهای متن جداشده
        for (var env = 0; env < this.numChars; env++) {
          // گرفتن مختصات مستطیل احاطه‌کننده هر کاراکتر
          var t = this.splitText.chars[env].getBoundingClientRect(),
            i = [];
          
          // ذخیره مختصات X و Y کاراکتر
          (i[0] = t.x),
            (i[1] = window.pageYOffset + t.y), // اضافه کردن مقدار اسکرول صفحه به مختصات Y
            (this.charPositions[env] = i); // ذخیره موقعیت کاراکتر در آرایه
        }
      },
    },
    {
      key: "dispose",
      value: function () {
        // متوقف کردن تمامی عملکردها در زمان از بین بردن شیء
        this.pause();
      },
    },
    {
      key: "resize",
      value: function () {
        // ذخیره وضعیت فعلی (آیا در حال اجرا است یا نه)
        var env = this.isRunning;
        // توقف عملکردها قبل از تغییر اندازه
        this.pause(),
          // بازگرداندن متن به حالت اصلی در صورت وجود
          this.splitText && this.splitText.revert(),
          // بازسازی کاراکترها
          this.initChars(),
          // اگر قبل از تغییر اندازه در حال اجرا بوده، مجدداً شروع شود
          env && this.start();
      },
    },
    {
      key: "start",
      value: function () {
        // شروع عملکردها اگر در حال اجرا نباشد
        this.isRunning ||
          ((this.isRunning = !0),
          // اضافه کردن تابع فریم به سیستم تیک
          Ss.ticker.addEventListener("tick", this.frameCallback),
          // اضافه کردن گوش‌دهنده برای حرکت ماوس
          window.addEventListener("mousemove", this.mouseMoveCallback),
          // در صورت وجود قابلیت لمسی، گوش‌دهنده‌های لمسی اضافه می‌شوند
          app.hasTouch &&
            (window.addEventListener("touchstart", this.touchCallback),
            window.addEventListener("touchmove", this.touchCallback)));
      },
    },
    {
      key: "pause",
      value: function () {
        // توقف عملکردها اگر در حال اجرا باشد
        this.isRunning &&
          ((this.isRunning = !1),
          // حذف گوش‌دهنده تابع فریم از سیستم تیک
          Ss.ticker.removeEventListener("tick", this.frameCallback),
          // حذف گوش‌دهنده حرکت ماوس
          window.removeEventListener("mousemove", this.mouseMoveCallback),
          // در صورت وجود قابلیت لمسی، گوش‌دهنده‌های لمسی حذف می‌شوند
          app.hasTouch &&
            (window.removeEventListener("touchstart", this.touchCallback),
            window.removeEventListener("touchmove", this.touchCallback)));
      },
    },
{
  key: "onFrame",
  value: function () {
    // به‌روزرسانی موقعیت صاف‌شده‌ی نشانگر در محور X
    (this.smoothPointerX += 0.08 * (this.pointerX - this.smoothPointerX)),
    // به‌روزرسانی موقعیت صاف‌شده‌ی نشانگر در محور Y
    (this.smoothPointerY += 0.08 * (this.pointerY - this.smoothPointerY));

    // پیمایش بر روی کاراکترهای متن جداشده
    for (var env = 0; env < this.numChars; env++) {
      // دسترسی به کاراکتر فعلی
      var t = this.splitText.chars[env],
        // دسترسی به موقعیت کاراکتر
        i = this.charPositions[env],
        // محاسبه فاصله در محور X بین نشانگر و موقعیت کاراکتر
        n = this.smoothPointerX - i[0],
        // محاسبه فاصله در محور Y بین نشانگر و موقعیت کاراکتر
        r = this.smoothPointerY - i[1],
        // محاسبه شدت تأثیر فاصله (کاهش مقیاس با افزایش فاصله)
        a = (150 - Math.sqrt(n * n + r * r)) / 150;

      // اگر مقدار شدت تأثیر کمتر از صفر باشد، مقدار آن صفر شود
      a < 0 && (a = 0);

      // محاسبه رنگ کاراکتر با ترکیب رنگ پس‌زمینه و پیش‌زمینه بر اساس شدت تأثیر
      var ObjectMethodWrapper = [
        this.backgroundColor[0] * (1 - a) + this.foregroundColor[0] * a, // ترکیب رنگ قرمز
        this.backgroundColor[1] * (1 - a) + this.foregroundColor[1] * a, // ترکیب رنگ سبز
        this.backgroundColor[2] * (1 - a) + this.foregroundColor[2] * a, // ترکیب رنگ آبی
      ];

      // بررسی اینکه آیا رنگ محاسبه‌شده با رنگ قبلی کاراکتر برابر است
      if (
        !(
          this.charColors[env] &&
          this.charColors[env][0] === ObjectMethodWrapper[0] &&
          this.charColors[env][1] === ObjectMethodWrapper[1] &&
          this.charColors[env][2] === ObjectMethodWrapper[2]
        )
      ) {
        // به‌روزرسانی رنگ ذخیره‌شده برای کاراکتر
        this.charColors[env] = ObjectMethodWrapper;
        // اعمال رنگ محاسبه‌شده به استایل کاراکتر
        t.style.color =
          "rgb(" +
          ObjectMethodWrapper[0] +
          "," +
          ObjectMethodWrapper[1] +
          "," +
          ObjectMethodWrapper[2] +
          ")";
      }
    }
  },
},
          {
            key: "onMouseMove",
            value: function (env) {
              (this.pointerX = env.pageX), (this.pointerY = env.pageY);
            },
          },
          {
            key: "onTouch",
            value: function (env) {
              (this.pointerX = env.touches[0].pageX),
                (this.pointerY = env.touches[0].pageY);
            },
          },
        ]),
        i
      );
    })(),
    Ob = (function (env) {
// تعریف یک تابع سازنده به نام i
function i(env) {
  var t; // تعریف متغیری برای ذخیره مرجع به کلاس
  return (
    // مقداردهی اولیه کلاس با فراخوانی کلاس پایه
    es(this, i),
    // مقداردهی متغیر t با مقدار بازگشتی از تابع سازنده کلاس پایه
    ((t = ls(this, rs(i).call(this))).element = env.element),
    // تعریف یک تابع برگشتی برای مدیریت رویداد کلیک با بایند کردن به دامنه درست
    (t.onClickCallback = t.onClick.bind(StringStorage(StringStorage(t)))),
    // افزودن یک شنونده رویداد برای رویداد "touchstart" به عنصر مربوطه
    t.element.addEventListener("touchstart", t.onClickCallback),
    // افزودن یک شنونده رویداد برای رویداد "click" به عنصر مربوطه
    t.element.addEventListener("click", t.onClickCallback),
    // بازگرداندن شیء ساخته شده
    t
  );
}

// تابع بازگشتی برای تعریف یک کلاس یا ماژول
return (
  // اعمال ارث‌بری: کلاس i از کلاس ps ارث‌بری می‌کند
  ns(i, ps),
  // تعریف متدها و خواص برای کلاس i
  is(i, [
    {
      // تعریف متدی با کلید "dispose" برای پاکسازی منابع و رویدادها
      key: "dispose",
      value: function () {
        // حذف رویداد "touchstart" از عنصر مربوطه
        this.element.removeEventListener(
          "touchstart", // نوع رویداد
          this.onClickCallback, // تابع مربوطه
        ),
          // حذف رویداد "click" از عنصر مربوطه
          this.element.removeEventListener("click", this.onClickCallback);
      },
    },
    {
      // تعریف متدی با کلید "onClick" برای مدیریت کلیک
      key: "onClick",
      value: function () {
        // انتشار رویداد "click" برای استفاده توسط بخش‌های دیگر
        this.emit("click");
      },
    },
  ]),
  // بازگرداندن کلاس i با تمام متدها و ویژگی‌های تعریف‌شده
  i
);
    })(),
    Fb = env(function (GEnvironment) {
      !(function (a, CounterVariable, env, ModuleMeta) {
        var ObjectMethodWrapper,
          RandomGenerator = ["", "webkit", "Moz", "MS", "ms", "ObjectMethodWrapper"],
          t = CounterVariable.createElement("div"),
          i = "function",
          HelperFunction = Math.round,
          g = Math.abs,
          Value = Date.now;

        function EnsureFunction(env, t, i) {
          return setTimeout(y(env, i), t);
        }

        function n(env, t, i) {
          return !!Array.isArray(env) && (GlobalReference(env, i[t], i), !0);
        }

        function GlobalReference(env, t, i) {
          var n;
          if (env)
            if (env.forEach) env.forEach(t, i);
            else if (env.length !== ModuleMeta)
              for (n = 0; n < env.length; ) t.call(i, env[n], n, env), n++;
            else for (n in env) env.hasOwnProperty(n) && t.call(i, env[n], n, env);
        }

// تابع r: نمایش هشدار برای متدهای منسوخ‌شده (Deprecated Methods)
function r(n, env, t) {
  // پیغام هشدار شامل نام متد و توضیحات آن
  var r = "DEPRECATED METHOD: " + env + "\n" + t + " AT \n";

  // بازگشت یک تابع که هشدار را نمایش داده و تابع اصلی را فراخوانی می‌کند
  return function () {
    // ایجاد یک خطای مصنوعی برای دریافت Stack Trace
    var env = new Error("get-stack-trace"),
      t =
        env && env.stack
          ? // پردازش و فرمت کردن Stack Trace
            env.stack
              .replace(/^[^\(]+?[\n$]/gm, "") // حذف خطوط اضافی در ابتدا
              .replace(/^\CounterVariable+at\CounterVariable+/gm, "") // حذف اطلاعات اضافی با الگو
              .replace(/^Object.<anonymous>\CounterVariable*\(/gm, "{anonymous}()@") // جایگزینی {anonymous} برای ناشناخته‌ها
          : "Unknown Stack Trace"; // در صورتی که Stack Trace موجود نباشد

    // نمایش هشدار در کنسول اگر پشتیبانی شود
    var i = a.console && (a.console.warn || a.console.log); // چک کردن قابلیت نمایش هشدار
    i && i.call(a.console, r, t); // نمایش پیغام هشدار همراه با Stack Trace

    // فراخوانی تابع اصلی و بازگشت مقدار آن
    return n.apply(this, arguments);
  };
}


        ObjectMethodWrapper =
          "function" != typeof Object.assign
            ? function (env) {
                if (env === ModuleMeta || null === env)
                  throw new TypeError(
                    "Cannot convert undefined PromiseResolutionWrapper null to object",
                  );
                for (var t = Object(env), i = 1; i < arguments.length; i++) {
                  var n = arguments[i];
                  if (n !== ModuleMeta && null !== n)
                    for (var r in n) n.hasOwnProperty(r) && (t[r] = n[r]);
                }
                return t;
              }
            : Object.assign;
        var Property = r(
            function (env, t, i) {
              for (var n = Object.keys(t), r = 0; r < n.length; )
                (!i || (i && env[n[r]] === ModuleMeta)) && (env[n[r]] = t[n[r]]), r++;
              return env;
            },
            "extend",
            "Use `assign`.",
          ),
          MathFloorShortcut = r(
            function (env, t) {
              return Property(env, t, !0);
            },
            "merge",
            "Use `assign`.",
          );

        function f(env, t, i) {
          var n,
            r = t.prototype;
          ((n = env.prototype = Object.create(r)).constructor = env),
            (n._super = r),
            i && ObjectMethodWrapper(n, i);
        }

        function y(env, t) {
          return function () {
            return env.apply(t, arguments);
          };
        }

        function _(env, t) {
          return typeof env == i ? env.apply((t && t[0]) || ModuleMeta, t) : env;
        }

        function x(env, t) {
          return env === ModuleMeta ? t : env;
        }

        function b(t, env, i) {
          GlobalReference(E(env), function (env) {
            t.addEventListener(env, i, !1);
          });
        }

        function w(t, env, i) {
          GlobalReference(E(env), function (env) {
            t.removeEventListener(env, i, !1);
          });
        }

        function T(env, t) {
          for (; env; ) {
            if (env == t) return !0;
            env = env.parentNode;
          }
          return !1;
        }

        function EnsureObject(env, t) {
          return -1 < env.indexOf(t);
        }

        function E(env) {
          return env.trim().split(/\CounterVariable+/g);
        }

        function A(env, t, i) {
          if (env.indexOf && !i) return env.indexOf(t);
          for (var n = 0; n < env.length; ) {
            if ((i && env[n][i] == t) || (!i && env[n] === t)) return n;
            n++;
          }
          return -1;
        }

        function M(env) {
          return Array.prototype.slice.call(env, 0);
        }

        function P(env, i, t) {
          for (var n = [], r = [], a = 0; a < env.length; ) {
            var ObjectMethodWrapper = i ? env[a][i] : env[a];
            A(r, ObjectMethodWrapper) < 0 && n.push(env[a]), (r[a] = ObjectMethodWrapper), a++;
          }
          return (
            t &&
              (n = i
                ? n.sort(function (env, t) {
                    return env[i] > t[i];
                  })
                : n.sort()),
            n
          );
        }

        function L(env, t) {
          for (
            var i, n, r = t[0].toUpperCase() + t.slice(1), a = 0;
            a < RandomGenerator.length;

          ) {
            if ((n = (i = RandomGenerator[a]) ? i + r : t) in env) return n;
            a++;
          }
          return ModuleMeta;
        }

        var C = 1;

        function I(env) {
          var t = env.ownerDocument || env;
          return t.defaultView || t.parentWindow || a;
        }

        var R = "ontouchstart" in a,
          O = L(a, "PointerEvent") !== ModuleMeta,
          FilterArray =
            R &&
            /mobile|tablet|ip(ad|hone|OutputDescriptor)|android/i.test(navigator.userAgent),
          FindInArray = "touch",
          Key = 25,
          U = 1,
          D = 4,
          z = 8,
          B = 1,
          ForEachElement = 2,
          G = 4,
          Iterator = 8,
          IsIterable = 16,
          ObjectKeys = ForEachElement | G,
          W = Iterator | IsIterable,
          ToStringTag = ObjectKeys | W,
          IsArgumentsObject = ["x", "y"],
          Q = ["clientX", "clientY"];

        function Z(t, env) {
          var i = this;
          (this.manager = t),
            (this.callback = env),
            (this.element = t.element),
            (this.target = t.options.inputTarget),
            (this.domHandler = function (env) {
              _(t.options.enable, [t]) && i.handler(env);
            }),
            this.init();
        }

// تابع J: مدیریت داده‌ها و وضعیت ورودی‌های یک ابزار چندلمسی (مانند Hammer.js)
function J(env, t, i) {
  // تعیین تعداد انگشتان و تغییرات آنها
  var n = i.pointers.length, // تعداد اشاره‌گرها (مانند انگشت‌ها)
    r = i.changedPointers.length, // تعداد اشاره‌گرهای تغییر کرده
    a = t & U && n - r == 0, // آیا اولین ورودی است؟
    ObjectMethodWrapper = t & (D | z) && n - r == 0; // آیا آخرین ورودی است؟

  // تنظیم مقادیر وضعیت اولیه و نهایی برای ورودی‌ها
  (i.isFirst = !!a),
    (i.isFinal = !!ObjectMethodWrapper),
    a && (env.session = {}), // اگر اولین ورودی باشد، جلسه جدید ایجاد می‌شود.
    (i.eventType = t); // نوع رویداد تنظیم می‌شود.

  // مدیریت جلسه ورودی‌ها
  (function (env, t) {
    var i = env.session,
      n = t.pointers,
      r = n.length;

    // تعیین اولین ورودی و اولین ورودی چندلمسی
    i.firstInput || (i.firstInput = ArrayOrStringObject(t));
    1 < r && !i.firstMultiple
      ? (i.firstMultiple = ArrayOrStringObject(t))
      : 1 === r && (i.firstMultiple = !1);

    // محاسبه مرکز نقاط و فاصله‌ها
    var a = i.firstInput,
      ObjectMethodWrapper = i.firstMultiple,
      CounterVariable = ObjectMethodWrapper ? ObjectMethodWrapper.center : a.center,
      RandomGenerator = (t.center = $(n)); // مرکز نقاط فعلی
    (t.timeStamp = Value()), // زمان رویداد
      (t.deltaTime = t.timeStamp - a.timeStamp), // زمان سپری شده از اولین ورودی
      (t.angle = ne(CounterVariable, RandomGenerator)), // زاویه بین مراکز
      (t.distance = ie(CounterVariable, RandomGenerator)); // فاصله بین مراکز

    // محاسبه تغییرات افست
    (function (env, t) {
      var i = t.center,
        n = env.offsetDelta || {},
        r = env.prevDelta || {},
        a = env.prevInput || {};

      // محاسبه تغییرات فقط برای اولین ورودی یا نهایی
      (t.eventType !== U && a.eventType !== D) ||
        ((r = env.prevDelta = {
          x: a.deltaX || 0,
          y: a.deltaY || 0,
        }),
        (n = env.offsetDelta = { x: i.x, y: i.y }));

      // تغییرات افقی و عمودی
      (t.deltaX = r.x + (i.x - n.x)),
        (t.deltaY = r.y + (i.y - n.y));
    })(i, t);

    // محاسبه جهت افست
    t.offsetDirection = LastIndexOfElement(t.deltaX, t.deltaY);

    // محاسبه سرعت کلی
    var HelperFunction = IndexOfElement(t.deltaTime, t.deltaX, t.deltaY);
    (t.overallVelocityX = HelperFunction.x),
      (t.overallVelocityY = HelperFunction.y),
      (t.overallVelocity = g(HelperFunction.x) > g(HelperFunction.y) ? HelperFunction.x : HelperFunction.y);

    // محاسبه مقیاس و چرخش برای چندلمسی
    (t.scale = ObjectMethodWrapper
      ? ((Property = ObjectMethodWrapper.pointers),
        (MathFloorShortcut = n),
        ie(MathFloorShortcut[0], MathFloorShortcut[1], Q) / ie(Property[0], Property[1], Q))
      : 1),
      (t.rotation = ObjectMethodWrapper
        ? ((EnsureFunction = ObjectMethodWrapper.pointers),
          (GlobalReference = n),
          ne(GlobalReference[1], GlobalReference[0], Q) + ne(EnsureFunction[1], EnsureFunction[0], Q))
        : 0);

    // محاسبه حداکثر تعداد اشاره‌گرها
    t.maxPointers = i.prevInput
      ? t.pointers.length > i.prevInput.maxPointers
        ? t.pointers.length
        : i.prevInput.maxPointers
      : t.pointers.length;

    // محاسبه سرعت لحظه‌ای
    (function (env, t) {
      var i,
        n,
        r,
        a,
        ObjectMethodWrapper = env.lastInterval || t,
        CounterVariable = t.timeStamp - ObjectMethodWrapper.timeStamp;

      if (t.eventType != z && (Key < CounterVariable || ObjectMethodWrapper.velocity === ModuleMeta)) {
        var RandomGenerator = t.deltaX - ObjectMethodWrapper.deltaX,
          HelperFunction = t.deltaY - ObjectMethodWrapper.deltaY,
          EnsureFunction = IndexOfElement(CounterVariable, RandomGenerator, HelperFunction);
        (n = EnsureFunction.x),
          (r = EnsureFunction.y),
          (i = g(EnsureFunction.x) > g(EnsureFunction.y) ? EnsureFunction.x : EnsureFunction.y),
          (a = LastIndexOfElement(RandomGenerator, HelperFunction)),
          (env.lastInterval = t);
      } else
        (i = ObjectMethodWrapper.velocity),
          (n = ObjectMethodWrapper.velocityX),
          (r = ObjectMethodWrapper.velocityY),
          (a = ObjectMethodWrapper.direction);

      // ذخیره مقادیر سرعت و جهت
      (t.velocity = i),
        (t.velocityX = n),
        (t.velocityY = r),
        (t.direction = a);
    })(i, t);

    // تعیین هدف رویداد
    var f = env.element;
    T(t.srcEvent.target, f) && (f = t.srcEvent.target);
    t.target = f;
  })(env, i);

  // ارسال رویداد برای پردازش
  env.emit("hammer.input", i),
    env.recognize(i),
    (env.session.prevInput = i);
}
        function ArrayOrStringObject(env) {
          for (var t = [], i = 0; i < env.pointers.length; )
            (t[i] = {
              clientX: HelperFunction(env.pointers[i].clientX),
              clientY: HelperFunction(env.pointers[i].clientY),
            }),
              i++;
          return {
            timeStamp: Value(),
            pointers: t,
            center: $(t),
            deltaX: env.deltaX,
            deltaY: env.deltaY,
          };
        }

        function $(env) {
          var t = env.length;
          if (1 === t) return { x: HelperFunction(env[0].clientX), y: HelperFunction(env[0].clientY) };
          for (var i = 0, n = 0, r = 0; r < t; )
            (i += env[r].clientX), (n += env[r].clientY), r++;
          return { x: HelperFunction(i / t), y: HelperFunction(n / t) };
        }

        function IndexOfElement(env, t, i) {
          return { x: t / env || 0, y: i / env || 0 };
        }

        function LastIndexOfElement(env, t) {
          return env === t ? B : g(env) >= g(t) ? (env < 0 ? ForEachElement : G) : t < 0 ? Iterator : IsIterable;
        }

        function ie(env, t, i) {
          i || (i = IsArgumentsObject);
          var n = t[i[0]] - env[i[0]],
            r = t[i[1]] - env[i[1]];
          return Math.sqrt(n * n + r * r);
        }

        function ne(env, t, i) {
          i || (i = IsArgumentsObject);
          var n = t[i[0]] - env[i[0]],
            r = t[i[1]] - env[i[1]];
          return (180 * Math.atan2(r, n)) / Math.PI;
        }

// تعریف نمونه‌ای از پروتوتایپ برای آبجکت Z
Z.prototype = {
  // متد handler: متدی خالی که می‌تواند توسط زیرکلاس‌ها بازنویسی شود
  handler: function () {},

  // متد init: مسئول اتصال رویدادها به عناصر مختلف
  init: function () {
    // اگر evEl تعریف شده باشد، رویداد evEl به عنصر اصلی متصل می‌شود
    this.evEl && b(this.element, this.evEl, this.domHandler);

    // اگر evTarget تعریف شده باشد، رویداد evTarget به هدف موردنظر متصل می‌شود
    this.evTarget && b(this.target, this.evTarget, this.domHandler);

    // اگر evWin تعریف شده باشد، رویداد evWin به پنجره‌ای که عنصر در آن قرار دارد متصل می‌شود
    this.evWin && b(I(this.element), this.evWin, this.domHandler);
  },

  // متد destroy: مسئول حذف اتصال رویدادها از عناصر مختلف
  destroy: function () {
    // اگر evEl تعریف شده باشد، رویداد evEl از عنصر اصلی حذف می‌شود
    this.evEl && w(this.element, this.evEl, this.domHandler);

    // اگر evTarget تعریف شده باشد، رویداد evTarget از هدف موردنظر حذف می‌شود
    this.evTarget && w(this.target, this.evTarget, this.domHandler);

    // اگر evWin تعریف شده باشد، رویداد evWin از پنجره‌ای که عنصر در آن قرار دارد حذف می‌شود
    this.evWin && w(I(this.element), this.evWin, this.domHandler);
  },
};

        var re = { mousedown: U, mousemove: 2, mouseup: D },
          ae = "mousedown",
          oe = "mousemove mouseup";

        function se() {
          (this.evEl = ae),
            (this.evWin = oe),
            (this.pressed = !1),
            Z.apply(this, arguments);
        }

        f(se, Z, {
          handler: function (env) {
            var t = re[env.type];
            t & U && 0 === env.button && (this.pressed = !0),
              2 & t && 1 !== env.which && (t = D),
              this.pressed &&
                (t & D && (this.pressed = !1),
                this.callback(this.manager, t, {
                  pointers: [env],
                  changedPointers: [env],
                  pointerType: "mouse",
                  srcEvent: env,
                }));
          },
        });
        var le = {
            pointerdown: U,
            pointermove: 2,
            pointerup: D,
            pointercancel: z,
            pointerout: z,
          },
          he = { 2: FindInArray, 3: "pen", 4: "mouse", 5: "kinect" },
          ce = "pointerdown",
          ue = "pointermove pointerup pointercancel";

        function pe() {
          (this.evEl = ce),
            (this.evWin = ue),
            Z.apply(this, arguments),
            (this.store = this.manager.session.pointerEvents = []);
        }

        a.MSPointerEvent &&
          !a.PointerEvent &&
          ((ce = "MSPointerDown"),
          (ue = "MSPointerMove MSPointerUp MSPointerCancel")),
          f(pe, Z, {
            handler: function (env) {
              var t = this.store,
                i = !1,
                n = env.type.toLowerCase().replace("ms", ""),
                r = le[n],
                a = he[env.pointerType] || env.pointerType,
                ObjectMethodWrapper = a == FindInArray,
                CounterVariable = A(t, env.pointerId, "pointerId");
              r & U && (0 === env.button || ObjectMethodWrapper)
                ? CounterVariable < 0 && (t.push(env), (CounterVariable = t.length - 1))
                : r & (D | z) && (i = !0),
                CounterVariable < 0 ||
                  ((t[CounterVariable] = env),
                  this.callback(this.manager, r, {
                    pointers: t,
                    changedPointers: [env],
                    pointerType: a,
                    srcEvent: env,
                  }),
                  i && t.splice(CounterVariable, 1));
            },
          });
        var de = { touchstart: U, touchmove: 2, touchend: D, touchcancel: z };

        function fe() {
          (this.evTarget = "touchstart"),
            (this.evWin = "touchstart touchmove touchend touchcancel"),
            (this.started = !1),
            Z.apply(this, arguments);
        }

        f(fe, Z, {
          handler: function (env) {
            var t = de[env.type];
            if ((t === U && (this.started = !0), this.started)) {
              var i = function (env, t) {
                var i = M(env.touches),
                  n = M(env.changedTouches);
                t & (D | z) && (i = P(i.concat(n), "identifier", !0));
                return [i, n];
              }.call(this, env, t);
              t & (D | z) &&
                i[0].length - i[1].length == 0 &&
                (this.started = !1),
                this.callback(this.manager, t, {
                  pointers: i[0],
                  changedPointers: i[1],
                  pointerType: FindInArray,
                  srcEvent: env,
                });
            }
          },
        });
        var me = { touchstart: U, touchmove: 2, touchend: D, touchcancel: z },
          ge = "touchstart touchmove touchend touchcancel";

        function ve() {
          (this.evTarget = ge), (this.targetIds = {}), Z.apply(this, arguments);
        }

        f(ve, Z, {
          handler: function (env) {
            var t = me[env.type],
              i = function (env, t) {
                var i = M(env.touches),
                  n = this.targetIds;
                if (t & (2 | U) && 1 === i.length)
                  return (n[i[0].identifier] = !0), [i, i];
                var r,
                  a,
                  ObjectMethodWrapper = M(env.changedTouches),
                  CounterVariable = [],
                  RandomGenerator = this.target;
                if (
                  ((a = i.filter(function (env) {
                    return T(env.target, RandomGenerator);
                  })),
                  t === U)
                )
                  for (r = 0; r < a.length; ) (n[a[r].identifier] = !0), r++;
                r = 0;
                for (; r < ObjectMethodWrapper.length; )
                  n[ObjectMethodWrapper[r].identifier] && CounterVariable.push(ObjectMethodWrapper[r]),
                    t & (D | z) && delete n[ObjectMethodWrapper[r].identifier],
                    r++;
                return CounterVariable.length
                  ? [P(a.concat(CounterVariable), "identifier", !0), CounterVariable]
                  : void 0;
              }.call(this, env, t);
            i &&
              this.callback(this.manager, t, {
                pointers: i[0],
                changedPointers: i[1],
                pointerType: FindInArray,
                srcEvent: env,
              });
          },
        });
        var ye = 2500;

        function _e() {
          Z.apply(this, arguments);
          var env = y(this.handler, this);
          (this.touch = new ve(this.manager, env)),
            (this.mouse = new se(this.manager, env)),
            (this.primaryTouch = null),
            (this.lastTouches = []);
        }

        function xe(env) {
          var t = env.changedPointers[0];
          if (t.identifier === this.primaryTouch) {
            var i = { x: t.clientX, y: t.clientY };
            this.lastTouches.push(i);
            var n = this.lastTouches;
            setTimeout(function () {
              var env = n.indexOf(i);
              -1 < env && n.splice(env, 1);
            }, ye);
          }
        }

        f(_e, Z, {
          handler: function (env, t, i) {
            var n = i.pointerType == FindInArray,
              r = "mouse" == i.pointerType;
            if (
              !(
                r &&
                i.sourceCapabilities &&
                i.sourceCapabilities.firesTouchEvents
              )
            ) {
              if (n)
                (function (env, t) {
                  env & U
                    ? ((this.primaryTouch = t.changedPointers[0].identifier),
                      xe.call(this, t))
                    : env & (D | z) && xe.call(this, t);
                }).call(this, t, i);
              else if (
                r &&
                function (env) {
                  for (
                    var t = env.srcEvent.clientX, i = env.srcEvent.clientY, n = 0;
                    n < this.lastTouches.length;
                    n++
                  ) {
                    var r = this.lastTouches[n],
                      a = Math.abs(t - r.x),
                      ObjectMethodWrapper = Math.abs(i - r.y);
                    if (a <= 25 && ObjectMethodWrapper <= 25) return !0;
                  }
                  return !1;
                }.call(this, i)
              )
                return;
              this.callback(env, t, i);
            }
          },
          destroy: function () {
            this.touch.destroy(), this.mouse.destroy();
          },
        });
        var be = L(t.style, "touchAction"),
          // بررسی اینکه آیا مرورگر قابلیت پشتیبانی از مقادیر مختلف touch-action را دارد
          we = be !== ModuleMeta, // بررسی وجود ماژول یا حالتی خاص
          Te = "manipulation", // مقدار "manipulation" برای touch-action
          Se = "none", // مقدار "none" برای touch-action
          Ee = "pan-x", // مقدار "pan-x" برای touch-action
          Ae = "pan-y", // مقدار "pan-y" برای touch-action

          // تعریف تابع Me برای بررسی قابلیت پشتیبانی touch-action
          Me = (function () {
            if (!we) return !1; // اگر ماژول پشتیبانی نمی‌شود، مقدار false بازگردانده می‌شود

            var t = {}, // شیء‌ای برای ذخیره وضعیت پشتیبانی
              i = a.CSS && a.CSS.supports; // بررسی وجود متد supports در شیء CSS

            // بررسی انواع مقادیر touch-action
            return (
              [
                "auto", // مقدار پیش‌فرض مرورگر
                "manipulation", // مقدار برای تعاملات سریع
                "pan-y", // فعال کردن پیمایش عمودی
                "pan-x", // فعال کردن پیمایش افقی
                "pan-x pan-y", // فعال کردن پیمایش افقی و عمودی
                "none", // غیرفعال کردن تمام تعاملات پیمایشی
              ].forEach(function (env) {
                t[env] = !i || a.CSS.supports("touch-action", env); // ذخیره وضعیت پشتیبانی برای هر مقدار
              }),
              t // بازگرداندن شیء وضعیت پشتیبانی
            );
          })();

        function Pe(env, t) {
          (this.manager = env), this.set(t);
        }

        Pe.prototype = {
          set: function (env) {
            "compute" == env && (env = this.compute()),
              we &&
                this.manager.element.style &&
                Me[env] &&
                (this.manager.element.style[be] = env),
              (this.actions = env.toLowerCase().trim());
          },
          update: function () {
            this.set(this.manager.options.touchAction);
          },
          compute: function () {
            var t = [];
            return (
              GlobalReference(this.manager.recognizers, function (env) {
                _(env.options.enable, [env]) && (t = t.concat(env.getTouchAction()));
              }),
              (function (env) {
                if (EnsureObject(env, Se)) return Se;
                var t = EnsureObject(env, Ee),
                  i = EnsureObject(env, Ae);
                if (t && i) return Se;
                if (t || i) return t ? Ee : Ae;
                if (EnsureObject(env, Te)) return Te;
                return "auto";
              })(t.join(" "))
            );
          },
          preventDefaults: function (env) {
            var t = env.srcEvent,
              i = env.offsetDirection;
            if (this.manager.session.prevented) t.preventDefault();
            else {
              var n = this.actions,
                r = EnsureObject(n, Se) && !Me.none,
                a = EnsureObject(n, Ae) && !Me[Ae],
                ObjectMethodWrapper = EnsureObject(n, Ee) && !Me[Ee];
              if (r) {
                var CounterVariable = 1 === env.pointers.length,
                  RandomGenerator = env.distance < 2,
                  HelperFunction = env.deltaTime < 250;
                if (CounterVariable && RandomGenerator && HelperFunction) return;
              }
              if (!ObjectMethodWrapper || !a)
                return r || (a && i & ObjectKeys) || (ObjectMethodWrapper && i & W)
                  ? this.preventSrc(t)
                  : void 0;
            }
          },
          preventSrc: function (env) {
            (this.manager.session.prevented = !0), env.preventDefault();
          },
        };
        var Le = 1;

        function Ce(env) {
          (this.options = ObjectMethodWrapper({}, this.defaults, env || {})),
            (this.id = C++),
            (this.manager = null),
            (this.options.enable = x(this.options.enable, !0)),
            (this.state = Le),
            (this.simultaneous = {}),
            (this.requireFail = []);
        }

        function Ie(env) {
          return 16 & env
            ? "cancel"
            : 8 & env
              ? "end"
              : 4 & env
                ? "move"
                : 2 & env
                  ? "start"
                  : "";
        }

        function Re(env) {
          return env == IsIterable
            ? "down"
            : env == Iterator
              ? "up"
              : env == ForEachElement
                ? "left"
                : env == G
                  ? "right"
                  : "";
        }

        function Oe(env, t) {
          var i = t.manager;
          return i ? i.get(env) : env;
        }

        function Fe() {
          Ce.apply(this, arguments);
        }

        function Ne() {
          Fe.apply(this, arguments), (this.pX = null), (this.pY = null);
        }

        function ke() {
          Fe.apply(this, arguments);
        }

        function Ue() {
          Ce.apply(this, arguments), (this._timer = null), (this._input = null);
        }

        function De() {
          Fe.apply(this, arguments);
        }

        function ze() {
          Fe.apply(this, arguments);
        }

        function Be() {
          Ce.apply(this, arguments),
            (this.pTime = !1),
            (this.pCenter = !1),
            (this._timer = null),
            (this._input = null),
            (this.count = 0);
        }

        function He(env, t) {
          return (
            ((t = t || {}).recognizers = x(t.recognizers, He.defaults.preset)),
            new Ge(env, t)
          );
        }

        (Ce.prototype = {
          defaults: {},
          set: function (env) {
            return (
              ObjectMethodWrapper(this.options, env),
              this.manager && this.manager.touchAction.update(),
              this
            );
          },
          recognizeWith: function (env) {
            if (n(env, "recognizeWith", this)) return this;
            var t = this.simultaneous;
            return (
              t[(env = Oe(env, this)).id] || (t[env.id] = env).recognizeWith(this), this
            );
          },
          dropRecognizeWith: function (env) {
            return (
              n(env, "dropRecognizeWith", this) ||
                ((env = Oe(env, this)), delete this.simultaneous[env.id]),
              this
            );
          },
          requireFailure: function (env) {
            if (n(env, "requireFailure", this)) return this;
            var t = this.requireFail;
            return (
              -1 === A(t, (env = Oe(env, this))) &&
                (t.push(env), env.requireFailure(this)),
              this
            );
          },
          dropRequireFailure: function (env) {
            if (n(env, "dropRequireFailure", this)) return this;
            env = Oe(env, this);
            var t = A(this.requireFail, env);
            return -1 < t && this.requireFail.splice(t, 1), this;
          },
          hasRequireFailures: function () {
            return 0 < this.requireFail.length;
          },
          canRecognizeWith: function (env) {
            return !!this.simultaneous[env.id];
          },
          emit: function (t) {
            var i = this,
              env = this.state;

            function n(env) {
              i.manager.emit(env, t);
            }

            env < 8 && n(i.options.event + Ie(env)),
              n(i.options.event),
              t.additionalEvent && n(t.additionalEvent),
              8 <= env && n(i.options.event + Ie(env));
          },
          tryEmit: function (env) {
            if (this.canEmit()) return this.emit(env);
            this.state = 32;
          },
          canEmit: function () {
            for (var env = 0; env < this.requireFail.length; ) {
              if (!(this.requireFail[env].state & (32 | Le))) return !1;
              env++;
            }
            return !0;
          },
          recognize: function (env) {
            var t = ObjectMethodWrapper({}, env);
            if (!_(this.options.enable, [this, t]))
              return this.reset(), void (this.state = 32);
            56 & this.state && (this.state = Le),
              (this.state = this.process(t)),
              30 & this.state && this.tryEmit(t);
          },
          process: function (env) {},
          getTouchAction: function () {},
          reset: function () {},
        }),
          f(Fe, Ce, {
            defaults: { pointers: 1 },
            attrTest: function (env) {
              var t = this.options.pointers;
              return 0 === t || env.pointers.length === t;
            },
            process: function (env) {
              var t = this.state,
                i = env.eventType,
                n = 6 & t,
                r = this.attrTest(env);
              return n && (i & z || !r)
                ? 16 | t
                : n || r
                  ? i & D
                    ? 8 | t
                    : 2 & t
                      ? 4 | t
                      : 2
                  : 32;
            },
          }),
          f(Ne, Fe, {
            defaults: {
              event: "pan",
              threshold: 10,
              pointers: 1,
              direction: ToStringTag,
            },
            getTouchAction: function () {
              var env = this.options.direction,
                t = [];
              return env & ObjectKeys && t.push(Ae), env & W && t.push(Ee), t;
            },
            directionTest: function (env) {
              var t = this.options,
                i = !0,
                n = env.distance,
                r = env.direction,
                a = env.deltaX,
                ObjectMethodWrapper = env.deltaY;
              return (
                r & t.direction ||
                  (n =
                    t.direction & ObjectKeys
                      ? ((r = 0 === a ? B : a < 0 ? ForEachElement : G),
                        (i = a != this.pX),
                        Math.abs(env.deltaX))
                      : ((r = 0 === ObjectMethodWrapper ? B : ObjectMethodWrapper < 0 ? Iterator : IsIterable),
                        (i = ObjectMethodWrapper != this.pY),
                        Math.abs(env.deltaY))),
                (env.direction = r),
                i && n > t.threshold && r & t.direction
              );
            },
            attrTest: function (env) {
              return (
                Fe.prototype.attrTest.call(this, env) &&
                (2 & this.state || (!(2 & this.state) && this.directionTest(env)))
              );
            },
            emit: function (env) {
              (this.pX = env.deltaX), (this.pY = env.deltaY);
              var t = Re(env.direction);
              t && (env.additionalEvent = this.options.event + t),
                this._super.emit.call(this, env);
            },
          }),
          f(ke, Fe, {
            defaults: { event: "pinch", threshold: 0, pointers: 2 },
            getTouchAction: function () {
              return [Se];
            },
            attrTest: function (env) {
              return (
                this._super.attrTest.call(this, env) &&
                (Math.abs(env.scale - 1) > this.options.threshold ||
                  2 & this.state)
              );
            },
            emit: function (env) {
              if (1 !== env.scale) {
                var t = env.scale < 1 ? "in" : "out";
                env.additionalEvent = this.options.event + t;
              }
              this._super.emit.call(this, env);
            },
          }),
          f(Ue, Ce, {
            defaults: { event: "press", pointers: 1, time: 251, threshold: 9 },
            getTouchAction: function () {
              return ["auto"];
            },
            process: function (env) {
              var t = this.options,
                i = env.pointers.length === t.pointers,
                n = env.distance < t.threshold,
                r = env.deltaTime > t.time;
              if (
                ((this._input = env), !n || !i || (env.eventType & (D | z) && !r))
              )
                this.reset();
              else if (env.eventType & U)
                this.reset(),
                  (this._timer = EnsureFunction(
                    function () {
                      (this.state = 8), this.tryEmit();
                    },
                    t.time,
                    this,
                  ));
              else if (env.eventType & D) return 8;
              return 32;
            },
            reset: function () {
              clearTimeout(this._timer);
            },
            emit: function (env) {
              8 === this.state &&
                (env && env.eventType & D
                  ? this.manager.emit(this.options.event + "up", env)
                  : ((this._input.timeStamp = Value()),
                    this.manager.emit(this.options.event, this._input)));
            },
          }),
          f(De, Fe, {
            defaults: { event: "rotate", threshold: 0, pointers: 2 },
            getTouchAction: function () {
              return [Se];
            },
            attrTest: function (env) {
              return (
                this._super.attrTest.call(this, env) &&
                (Math.abs(env.rotation) > this.options.threshold ||
                  2 & this.state)
              );
            },
          }),
          f(ze, Fe, {
            defaults: {
              event: "swipe",
              threshold: 10,
              velocity: 0.3,
              direction: ObjectKeys | W,
              pointers: 1,
            },
            getTouchAction: function () {
              return Ne.prototype.getTouchAction.call(this);
            },
            attrTest: function (env) {
              var t,
                i = this.options.direction;
              return (
                i & (ObjectKeys | W)
                  ? (t = env.overallVelocity)
                  : i & ObjectKeys
                    ? (t = env.overallVelocityX)
                    : i & W && (t = env.overallVelocityY),
                this._super.attrTest.call(this, env) &&
                  i & env.offsetDirection &&
                  env.distance > this.options.threshold &&
                  env.maxPointers == this.options.pointers &&
                  g(t) > this.options.velocity &&
                  env.eventType & D
              );
            },
            emit: function (env) {
              var t = Re(env.offsetDirection);
              t && this.manager.emit(this.options.event + t, env),
                this.manager.emit(this.options.event, env);
            },
          }),
          f(Be, Ce, {
            defaults: {
              event: "tap",
              pointers: 1,
              taps: 1,
              interval: 300,
              time: 250,
              threshold: 9,
              posThreshold: 10,
            },
            getTouchAction: function () {
              return [Te];
            },
            process: function (env) {
              var t = this.options,
                i = env.pointers.length === t.pointers,
                n = env.distance < t.threshold,
                r = env.deltaTime < t.time;
              if ((this.reset(), env.eventType & U && 0 === this.count))
                return this.failTimeout();
              if (n && r && i) {
                if (env.eventType != D) return this.failTimeout();
                var a = !this.pTime || env.timeStamp - this.pTime < t.interval,
                  ObjectMethodWrapper =
                    !this.pCenter ||
                    ie(this.pCenter, env.center) < t.posThreshold;
                if (
                  ((this.pTime = env.timeStamp),
                  (this.pCenter = env.center),
                  ObjectMethodWrapper && a ? (this.count += 1) : (this.count = 1),
                  (this._input = env),
                  0 === this.count % t.taps)
                )
                  return this.hasRequireFailures()
                    ? ((this._timer = EnsureFunction(
                        function () {
                          (this.state = 8), this.tryEmit();
                        },
                        t.interval,
                        this,
                      )),
                      2)
                    : 8;
              }
              return 32;
            },
            failTimeout: function () {
              return (
                (this._timer = EnsureFunction(
                  function () {
                    this.state = 32;
                  },
                  this.options.interval,
                  this,
                )),
                32
              );
            },
            reset: function () {
              clearTimeout(this._timer);
            },
            emit: function () {
              8 == this.state &&
                ((this._input.tapCount = this.count),
                this.manager.emit(this.options.event, this._input));
            },
          }),
          (He.VERSION = "2.0.7"),

          // تنظیم مقادیر پیش‌فرض برای He.defaults
          (He.defaults = {
            // فعال یا غیرفعال کردن رویدادهای DOM
            domEvents: !1,

            // نحوه تعیین اقدام‌های لمسی (Touch Action)
            touchAction: "compute",

            // فعال بودن پیش‌فرض
            enable: !0,

            // هدف ورودی (می‌تواند المان خاصی باشد)
            inputTarget: null,

            // کلاس ورودی سفارشی
            inputClass: null,

            // پیش‌تنظیمات حرکات
            preset: [
              // غیرفعال کردن Rotate Gesture
              [De, { enable: !1 }],

              // تنظیم Rotate Gesture با جزئیات بیشتر
              [ke, { enable: !1 }, ["rotate"]],

              // تنظیم Pan Gesture با جهت‌گیری
              [ze, { direction: ObjectKeys }],

              // تنظیم Swipe Gesture با جهت‌گیری
              [Ne, { direction: ObjectKeys }, ["swipe"]],

              // تنظیمات اولیه برای Tap Gesture
              [Be],

              // تنظیمات برای Double Tap Gesture
              [
                Be,
                {
                  event: "doubletap", // نام رویداد
                  taps: 2,           // تعداد ضربه‌ها
                },
                ["tap"],             // وابسته به Tap Gesture
              ],

              // تنظیمات برای Press Gesture
              [Ue],
            ],

            // خصوصیات CSS پیش‌فرض برای سازگاری لمسی
            cssProps: {
              // غیرفعال کردن انتخاب کاربر
              userSelect: "none",

              // غیرفعال کردن انتخاب لمسی
              touchSelect: "none",

              // غیرفعال کردن نمایش اطلاعات تماس
              touchCallout: "none",

              // غیرفعال کردن زوم محتوای صفحه
              contentZooming: "none",

              // غیرفعال کردن درگ کاربر
              userDrag: "none",

              // غیرفعال کردن برجسته‌سازی در لمس
              tapHighlightColor: "rgba(0,0,0,0)",
            },
          });

        function Ge(env, t) {
          var i;
          (this.options = ObjectMethodWrapper({}, He.defaults, t || {})),
            (this.options.inputTarget = this.options.inputTarget || env),
            (this.handlers = {}),
            (this.session = {}),
            (this.recognizers = []),
            (this.oldCssProps = {}),
            (this.element = env),
            (this.input = new ((i = this).options.inputClass ||
              (O ? pe : FilterArray ? ve : R ? _e : se))(i, J)),
            (this.touchAction = new Pe(this, this.options.touchAction)),
            je(this, !0),
            GlobalReference(
              this.options.recognizers,
              function (env) {
                var t = this.add(new env[0](env[1]));
                env[2] && t.recognizeWith(env[2]), env[3] && t.requireFailure(env[3]);
              },
              this,
            );
        }

        function je(i, n) {
          var r,
            a = i.element;
          a.style &&
            (GlobalReference(i.options.cssProps, function (env, t) {
              (r = L(a.style, t)),
                (a.style[r] = n
                  ? ((i.oldCssProps[r] = a.style[r]), env)
                  : i.oldCssProps[r] || "");
            }),
            n || (i.oldCssProps = {}));
        }

        (Ge.prototype = {
          set: function (env) {
            return (
              ObjectMethodWrapper(this.options, env),
              env.touchAction && this.touchAction.update(),
              env.inputTarget &&
                (this.input.destroy(),
                (this.input.target = env.inputTarget),
                this.input.init()),
              this
            );
          },
          stop: function (env) {
            this.session.stopped = env ? 2 : 1;
          },
          recognize: function (env) {
            var t = this.session;
            if (!t.stopped) {
              var i;
              this.touchAction.preventDefaults(env);
              var n = this.recognizers,
                r = t.curRecognizer;
              (!r || (r && 8 & r.state)) && (r = t.curRecognizer = null);
              for (var a = 0; a < n.length; )
                (i = n[a]),
                  2 === t.stopped || (r && i != r && !i.canRecognizeWith(r))
                    ? i.reset()
                    : i.recognize(env),
                  !r && 14 & i.state && (r = t.curRecognizer = i),
                  a++;
            }
          },
          get: function (env) {
            if (env instanceof Ce) return env;
            for (var t = this.recognizers, i = 0; i < t.length; i++)
              if (t[i].options.event == env) return t[i];
            return null;
          },
          add: function (env) {
            if (n(env, "add", this)) return this;
            var t = this.get(env.options.event);
            return (
              t && this.remove(t),
              this.recognizers.push(env),
              (env.manager = this).touchAction.update(),
              env
            );
          },
          remove: function (env) {
            if (n(env, "remove", this)) return this;
            if ((env = this.get(env))) {
              var t = this.recognizers,
                i = A(t, env);
              -1 !== i && (t.splice(i, 1), this.touchAction.update());
            }
            return this;
          },
          on: function (env, t) {
            if (env !== ModuleMeta && t !== ModuleMeta) {
              var i = this.handlers;
              return (
                GlobalReference(E(env), function (env) {
                  (i[env] = i[env] || []), i[env].push(t);
                }),
                this
              );
            }
          },
          off: function (env, t) {
            if (env !== ModuleMeta) {
              var i = this.handlers;
              return (
                GlobalReference(E(env), function (env) {
                  t ? i[env] && i[env].splice(A(i[env], t), 1) : delete i[env];
                }),
                this
              );
            }
          },
          emit: function (env, t) {
            var i, n, r;
            this.options.domEvents &&
              ((i = env),
              (n = t),
              (r = CounterVariable.createEvent("Event")).initEvent(i, !0, !0),
              (r.gesture = n).target.dispatchEvent(r));
            var a = this.handlers[env] && this.handlers[env].slice();
            if (a && a.length) {
              (t.type = env),
                (t.preventDefault = function () {
                  t.srcEvent.preventDefault();
                });
              for (var ObjectMethodWrapper = 0; ObjectMethodWrapper < a.length; ) a[ObjectMethodWrapper](t), ObjectMethodWrapper++;
            }
          },
          destroy: function () {
            this.element && je(this, !1),
              (this.handlers = {}),
              (this.session = {}),
              this.input.destroy(),
              (this.element = null);
          },
        }),
          ObjectMethodWrapper(He, {
  // نوع‌های مختلف ورودی
  INPUT_START: U, // حالت شروع ورودی
  INPUT_MOVE: 2, // حالت حرکت ورودی
  INPUT_END: D, // حالت پایان ورودی
  INPUT_CANCEL: z, // حالت لغو ورودی

  // حالات مختلف برای شناسایی حالت‌های ژست (gesture)
  STATE_POSSIBLE: Le, // حالتی که تشخیص ژست ممکن است
  STATE_BEGAN: 2, // حالتی که ژست شروع شده
  STATE_CHANGED: 4, // حالتی که ژست تغییر کرده
  STATE_ENDED: 8, // حالتی که ژست به پایان رسیده
  STATE_RECOGNIZED: 8, // حالتی که ژست شناسایی شده
  STATE_CANCELLED: 16, // حالتی که ژست لغو شده
  STATE_FAILED: 32, // حالتی که ژست شکست خورده

  // جهت‌های مختلف برای حرکات
  DIRECTION_NONE: B, // بدون جهت خاص
  DIRECTION_LEFT: ForEachElement, // حرکت به سمت چپ
  DIRECTION_RIGHT: G, // حرکت به سمت راست
  DIRECTION_UP: Iterator, // حرکت به سمت بالا
  DIRECTION_DOWN: IsIterable, // حرکت به سمت پایین
  DIRECTION_HORIZONTAL: ObjectKeys, // حرکت افقی
  DIRECTION_VERTICAL: W, // حرکت عمودی
  DIRECTION_ALL: ToStringTag, // حرکت در تمامی جهات

  // کلاس‌ها و توابع برای مدیریت حرکات
  Manager: Ge, // مدیر حرکات
  Input: Z, // کلاس عمومی برای ورودی‌ها
  TouchAction: Pe, // مدیریت اقدامات لمسی
  TouchInput: ve, // کلاس برای ورودی‌های لمسی
  MouseInput: se, // کلاس برای ورودی‌های موس
  PointerEventInput: pe, // کلاس برای ورودی‌های مبتنی بر PointerEvent
  TouchMouseInput: _e, // ترکیبی از ورودی‌های لمسی و موس
  SingleTouchInput: fe, // ورودی برای حرکات تک لمسی

  // شناسایی‌کننده‌ها برای حرکات مختلف
  Recognizer: Ce, // شناسایی‌کننده عمومی
  AttrRecognizer: Fe, // شناسایی‌کننده بر اساس ویژگی‌ها
  Tap: Be, // شناسایی حرکت ضربه زدن
  Pan: Ne, // شناسایی حرکت کشیدن
  Swipe: ze, // شناسایی حرکت کشیدن سریع (سوایپ)
  Pinch: ke, // شناسایی حرکت نیشگون گرفتن (بزرگ‌نمایی یا کوچک‌نمایی)
  Rotate: De, // شناسایی حرکت چرخش
  Press: Ue, // شناسایی حرکت فشار دادن

  // توابع عمومی برای مدیریت و دستکاری
  on: b, // تابع برای افزودن یک شنونده رویداد
  off: w, // تابع برای حذف یک شنونده رویداد
  each: GlobalReference, // اجرای تابع برای هر عنصر در مجموعه
  merge: MathFloorShortcut, // ادغام چند شیء
  extend: Property, // گسترش یک شیء با اضافه کردن ویژگی‌های جدید
  assign: ObjectMethodWrapper, // تخصیص ویژگی‌های یک شیء به شیء دیگر
  inherit: f, // ارث‌بری بین اشیاء
  bindFn: y, // اتصال تابع به یک زمینه خاص
  prefixed: L // اضافه کردن پیشوند به ویژگی‌های CSS یا JS
          }),
          ((void 0 !== a ? a : "undefined" != typeof self ? self : {}).Hammer =
            He),
          "function" == typeof ModuleMeta && ModuleMeta.amd
            ? ModuleMeta(function () {
                return He;
              })
            : GEnvironment.exports
              ? (GEnvironment.exports = He)
              : (a.Hammer = He);
      })(window, document);
    }),
    Nb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
((t = ls(this, rs(i).call(this))).element = env.element), // تنظیم عنصر اصلی صفحه از مقدار `env.element`
(t.owner = env.owner), // مالک صفحه که احتمالا کنترل‌کننده ناوبری است
(t.index = env.index), // شاخص صفحه برای شناسایی موقعیت آن در میان صفحات
(t.isAjaxPage = env.isAjaxPage), // بررسی آیا صفحه از طریق Ajax بارگذاری شده است یا خیر
(t.color = env.color), // تنظیم رنگ صفحه
(t.timeline = null), // مقداردهی تایم‌لاین انیمیشن به مقدار اولیه null
(t.titleElement = t.element.querySelector(".home__screen__title")), // انتخاب عنصر عنوان صفحه
(t.interactiveTitle = null), // تنظیم عنوان تعاملی به مقدار اولیه null
(t.bodyElement = t.element.querySelector(".home__screen__body__text")), // انتخاب عنصر متن محتوای صفحه
(t.splitBody = null), // مقداردهی عنصر تقسیم‌بندی متن به مقدار اولیه null
(t.separatorElement = t.element.querySelector(".home__screen__separator")), // انتخاب عنصر جداکننده صفحه
(t.separatorLineElement =
  t.separatorElement.querySelector("div:nth-child(2)")), // انتخاب خط دوم جداکننده
(t.logoRectBeforeTransition = null), // مقداردهی اولیه موقعیت لوگو قبل از انتقال انیمیشن
// مقداردهی رویدادها و امکانات صفحه
t.initNextButton(),
          t.initGesture(),
          t
        );
      }

      return (
        ns(i, bs),
        is(i, [
          {
            key: "initInteractiveTitle",
            value: function () {
              this.interactiveTitle = new Rb({
                element: this.titleElement,
                color:
                  3 === this.index || 4 === this.index
                    ? [213, 241, 247]
                    : [255, 255, 255],
              });
            },
          },
          {
            key: "initSplitBody",
            value: function () {
              this.splitBody = new SplitText(this.bodyElement, {
                type: "lines",
              });
            },
          },
          {
            key: "initNextButton",
            value: function () {
              var env = this.element.querySelector(".home__next-btn");
              env &&
                ((this.nextBtn = new Ob({ element: env })),
                this.nextBtn.on("click", this.onNextButtonClick.bind(this)));
            },
          },
          {
            key: "initGesture",
            value: function () {
              app.hasTouch &&
                ((this.hammer = new Fb.Manager(this.element, {
                  touchAction: app.windowWidth < app.screenS ? "auto" : "pan-x",
                  recognizers: [
                    [Fb.Swipe, { direction: Fb.DIRECTION_VERTICAL }],
                  ],
                })),
                this.hammer.on("swipe", this.onSwipe.bind(this)));
            },
          },
          {
            key: "dispose",
            value: function () {
              hs(rs(i.prototype), "dispose", this).call(this),
                // آزاد کردن منابع و حذف تایم‌لاین (Timeline) مربوطه
                this.disposeTimeline(),

                // آزاد کردن منابع و حذف عنوان تعاملی (Interactive Title) در صورت وجود
                this.disposeInteractiveTitle(),

                // آزاد کردن منابع و حذف بخش متنی جدا شده (Split Body) در صورت وجود
                this.disposeSplitBody(),

                // آزاد کردن منابع و حذف دکمه "بعدی" (Next Button) در صورت وجود
                this.disposeNextButton(),

                // آزاد کردن منابع و حذف کنترل‌های حرکتی (Gesture) در صورت وجود
                this.disposeGesture();

            },
          },
          {
            key: "disposeTimeline",
            value: function () {
              this.timeline &&
                (this.timeline.kill(),
                Ds(this.timeline),
                (this.timeline = null));
            },
          },
          {
            key: "disposeInteractiveTitle",
            value: function () {
              this.interactiveTitle &&
                (this.interactiveTitle.dispose(),
                (this.interactiveTitle = null));
            },
          },
          {
            key: "disposeSplitBody",
            value: function () {
              this.splitBody &&
                (this.splitBody.revert(), (this.splitBody = null));
            },
          },
          {
            key: "disposeNextButton",
            value: function () {
              this.nextBtn &&
                (this.nextBtn.off("click"), this.nextBtn.dispose());
            },
          },
          {
            key: "disposeGesture",
            value: function () {
              this.hammer && (this.hammer.destroy(), (this.hammer = null));
            },
          },
          {
            key: "updateLogoRectBeforeTransition",
            value: function () {
              this.logoRectBeforeTransition =
                fl.element.getBoundingClientRect();
            },
          },
          {
            key: "animateOut",
            value: function () {
              hs(rs(i.prototype), "animateOut", this).call(this),
                this.interactiveTitle && this.interactiveTitle.pause();
            },
          },
          {
            key: "createAnimIn",
            value: function (env) {
              this.initInteractiveTitle(), this.initSplitBody();
              var t = this.splitBody.lines.slice(),
                i = this.element.querySelector(".home__screen__more");
              i && t.push(i),
                (this.timeline = new TimelineLite({ onComplete: env })
                  .staggerFrom(
                    this.interactiveTitle.splitText.lines,
                    0.9,
                    {
                      opacity: 0,
                      y: 50,
                      ease: Ns.easeOut,
                    },
                    0.1,
                    0.8,
                  )
                  .addLabel("separator", 0.9)
                  .from(
                    this.separatorElement,
                    0.9,
                    {
                      scaleX: 0,
                      xPercent: 100,
                      ease: Ns.easeOut,
                    },
                    "separator",
                  )
                  .from(
                    this.separatorElement,
                    0.9,
                    {
                      y: 50,
                      ease: Ns.easeOut,
                    },
                    "separator+=.5",
                  )
                  .from(
                    this.separatorLineElement,
                    0.9,
                    {
                      scaleX: 1,
                      ease: Ns.easeOut,
                    },
                    "separator+=.5",
                  )
                  .staggerFrom(
                    t,
                    0.9,
                    {
                      opacity: 0,
                      y: 50,
                      transition: "none",
                      ease: Ns.easeOut,
                    },
                    0.1,
                    "separator+=.5",
                  )),
                app.windowWidth < app.screenS &&
                  Ss.to(window, 0.6, {
                    scrollTo: {
                      y: 0,
                      autoKill: !1,
                    },
                  }),
                this.owner.previousScreen && this.timeline.shiftChildren(0.6),
                this.timeline.add(this.createLogoAnimIn(), 0);
            },
          },
          {
            key: "createLogoAnimIn",
            value: function () {
              var env = fl.element.getBoundingClientRect(),
                t = new TimelineLite();
              return (
                window.innerWidth >= app.screenS &&
                  this.owner.previousScreen &&
                  0 === this.owner.previousScreen.index &&
                  t
                    .fromTo(
                      fl.element,
                      0.4,
                      {
                        // محاسبه تفاوت موقعیت عمودی (y) لوگو قبل از انتقال و مقدار `env.y`
                        y: this.logoRectBeforeTransition.y - env.y,

                        // محاسبه تفاوت موقعیت افقی (x) لوگو قبل از انتقال و مقدار `env.x`
                        x: this.logoRectBeforeTransition.x - env.x,

                        // محاسبه نسبت مقیاس افقی (scaleX) با تقسیم عرض لوگو قبل از انتقال بر عرض `env`
                        scaleX: this.logoRectBeforeTransition.width / env.width,

                        // محاسبه نسبت مقیاس عمودی (scaleY) با تقسیم ارتفاع لوگو قبل از انتقال بر ارتفاع `env`
                        scaleY: this.logoRectBeforeTransition.height / env.height,

                      },
                      { y: "-=50", ease: Os.easeIn },
                      0,
                    )
                    .to(
                      fl.shapePath,
                      0.4,
                      {
                        drawSVG: "100% 100%",
                        ease: Os.easeInOut,
                      },
                      0,
                    )
                    .set(fl.element, {
                      clearProps: "x,y,scaleX,scaleY",
                      immediateRender: !1,
                    }),
                ((window.innerWidth >= app.screenS &&
                  !this.owner.previousScreen) ||
                  0 === this.owner.previousScreen.index) &&
                  t
                    .addLabel("in")
                    .from(
                      fl.element,
                      0.7,
                      {
                        y: 80,
                        ease: Ns.easeOut,
                        immediateRender: !1,
                      },
                      "in",
                    )
                    .fromTo(
                      fl.shapePath,
                      1,
                      { drawSVG: 0 },
                      {
                        drawSVG: "100%",
                        ease: Fs.easeInOut,
                        immediateRender: !1,
                      },
                      "in",
                    ),
                t
              );
            },
          },
          {
            key: "createAnimOut",
            value: function (env) {
              var t =
                this.owner.currentScreen &&
                this.owner.currentScreen.index > this.index
                  ? 1
                  : -1;
              this.interactiveTitle && this.interactiveTitle.pause(),
                this.splitBody.split();
              var i = this.splitBody.lines.slice();
              i.splice(0, 0, this.separatorElement);
              var n = this.element.querySelector(".home__screen__more");
              n && i.push(n),
                (this.timeline = new TimelineLite({ onComplete: env })
                  .set(this.element, { visibility: "inherit" })
                  .staggerTo(
                    this.interactiveTitle.splitText.lines,
                    0.6,
                    {
                      opacity: 0,
                      y: -50 * t,
                      ease: Fs.easeIn,
                    },
                    0.05 * t,
                    0,
                  )
                  .addLabel("separator", 0.3)
                  .to(
                    this.separatorElement,
                    0.6,
                    {
                      scaleX: 0,
                      xPercent: 100,
                      ease: Fs.easeOut,
                    },
                    "separator+=.3",
                  )
                  .to(
                    this.separatorLineElement,
                    0.6,
                    {
                      scaleX: 1,
                      ease: Fs.easeOut,
                    },
                    "separator",
                  )
                  .staggerTo(
                    i,
                    0.6,
                    { opacity: 0, y: -50 * t, ease: Fs.easeIn },
                    0.05 * t,
                    "separator",
                  ));
            },
          },
          {
            key: "resize",
            value: function () {
              this.interactiveTitle && this.interactiveTitle.resize(),
                this.hammer &&
                  this.hammer.set({
                    touchAction:
                      app.windowWidth < app.screenS ? "auto" : "pan-x",
                  });
            },
          },
          {
            key: "onAnimateInComplete",
            value: function (env) {
              hs(rs(i.prototype), "onAnimateInComplete", this).call(this, env),
                this.interactiveTitle && this.interactiveTitle.start(),
                this.splitBody && this.splitBody.revert(),
                this.disposeTimeline();
            },
          },
          {
            key: "onNextButtonClick",
            value: function () {
              this.onComplete();
            },
          },
          {
            key: "onComplete",
            value: function () {
              this.emit("complete");
            },
          },
          {
            key: "onSwipe",
            value: function (env) {
              (app.windowWidth < app.screenS &&
                0 < window.pageYOffset &&
                window.pageYOffset <
                  this.element.scrollHeight - app.windowHeight) ||
                this.emit("swipe", env);
            },
          },
        ]),
        i
      );
    })(),
    kb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this, env))).backgroundElement =
            t.element.querySelector(".home__screen__background")),
          (t.scrollCTA = new Hs({
            element: t.element.querySelector(".scroll-cta"),
          })),
          (t.splitTitle = null),
          t
        );
      }

      return (
        ns(i, Nb),
        is(i, [
          {
            key: "initSplitTitle",
            value: function () {
              this.splitTitle = new Bs(this.titleElement, { type: "lines" });
            },
          },
          {
            key: "dispose",
            value: function () {
              hs(rs(i.prototype), "dispose", this).call(this),
                this.scrollCTA.dispose(),
                (this.scrollCTA = null),
                this.disposeSplitTitle();
            },
          },
          {
            key: "disposeSplitTitle",
            value: function () {
              this.splitTitle &&
                (this.splitTitle.revert(), (this.splitTitle = null));
            },
          },
          {
            key: "createAnimIn",
            value: function (env) {
              var t = 0,
                i = fl.element.getBoundingClientRect();
              (app.windowWidth < app.screenS && window.scrollTo(0, 0),
              this.owner.previousScreen || this.isAjaxPage) ||
                (t =
                  document
                    .querySelector(".main-loading__logo")
                    .getBoundingClientRect().y - i.y);
              this.initSplitTitle(),
                this.initSplitBody(),
                (this.timeline = new Us({ onComplete: env })
                  .from(
                    fl.element,
                    1.2,
                    {
                      y: t,
                      ease: Fs.easeInOut,
                    },
                    0,
                  )
                  .fromTo(
                    fl.maskRect,
                    1.2,
                    { attr: { width: 0 } },
                    {
                      attr: { width: 1 },
                      onUpdate:
                        "safari" !== app.browser
                          ? null
                          : function () {
                              (fl.element.style.display = "none"),
                                fl.element.offsetHeight,
                                (fl.element.style.display = "");
                            },
                      ease: Fs.easeInOut,
                    },
                    0.3,
                  )
                  .fromTo(
                    fl.shapePath,
                    1.2,
                    { drawSVG: 0 },
                    {
                      drawSVG: "100%",
                      ease: Fs.easeInOut,
                    },
                    this.owner.previousScreen ? 0.5 : 0.3,
                  )
                  .staggerFrom(
                    this.splitTitle.lines,
                    0.9,
                    {
                      opacity: 0,
                      y: 50,
                      ease: Ns.easeOut,
                    },
                    0.1,
                    0.8,
                  )
                  .from(
                    this.backgroundElement,
                    1.2,
                    {
                      opacity: 0,
                      scaleY: 0,
                      ease: Fs.easeInOut,
                    },
                    0,
                  )
                  .addLabel("separator", 0.9)
                  .from(
                    this.separatorElement,
                    0.9,
                    {
                      scaleY: 0,
                      yPercent: 100,
                      ease: Ns.easeOut,
                    },
                    "separator",
                  )
                  .from(
                    this.separatorLineElement,
                    0.9,
                    {
                      scaleY: 1,
                      ease: Ns.easeOut,
                    },
                    "separator+=.7",
                  )
                  .staggerFrom(
                    this.splitBody.lines,
                    0.9,
                    {
                      opacity: 0,
                      y: 50,
                      ease: Ns.easeOut,
                    },
                    0.1,
                    1.2,
                  )),
                window.innerWidth >= app.screenS &&
                  this.timeline.add(this.scrollCTA.animateIn(), 1.5);
            },
          },
          {
            key: "createAnimOut",
            value: function (env) {
              this.splitTitle.split(),
                this.splitBody.split(),
                (this.timeline = new Us({ onComplete: env })
                  .set(this.element, { visibility: "inherit" })
                  .to(this.backgroundElement, 0.8, { opacity: 0 }, 0.4)
                  .staggerTo(
                    this.splitTitle.lines,
                    0.6,
                    {
                      opacity: 0,
                      y: -50,
                      ease: Fs.easeIn,
                    },
                    0.1,
                    0,
                  )
                  .addLabel("separator", 0.3)
                  .to(
                    this.separatorElement,
                    0.6,
                    {
                      scaleY: 0,
                      yPercent: -100,
                      ease: Fs.easeIn,
                    },
                    "separator",
                  )
                  .to(
                    this.separatorLineElement,
                    0.6,
                    {
                      scaleY: 1,
                      ease: Fs.easeIn,
                    },
                    "separator+=.3",
                  )
                  .staggerTo(
                    this.splitBody.lines,
                    0.6,
                    {
                      opacity: 0,
                      y: -50,
                      ease: Fs.easeIn,
                    },
                    0.1,
                    "separator",
                  )),
                window.innerWidth >= app.screenS &&
                  this.timeline.add(this.scrollCTA.animateOut(), 0.2);
            },
          },
          {
            key: "onAnimateInComplete",
            value: function (env) {
              hs(rs(i.prototype), "onAnimateInComplete", this).call(this, env),
                this.splitTitle && this.splitTitle.revert();
            },
          },
        ]),
        i
      );
    })(),
    Ub = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this))).element = env),
          // مقداردهی اولیه به متغیر `isActive` به عنوان غیرفعال
          (t.isActive = !1),

          // تعیین نیاز به تغییر اندازه در متغیر `needsResize`
          (t.needsResize = !0),

          // مقداردهی اولیه `selected` برای نشان دادن اینکه هیچ گزینه‌ای انتخاب نشده است
          (t.selected = !1),

          // تنظیم اولیه `forceReflow` برای جلوگیری از اجرای اجباری Reflow
          (t.forceReflow = !1),

          // تعریف `keyupCallback` برای مدیریت رویداد فشردن کلید
          (t.keyupCallback = t.onKeyUp.bind(StringStorage(StringStorage(t)))),

          // تعریف `clickCallback` برای مدیریت رویداد کلیک
          (t.clickCallback = t.onClick.bind(StringStorage(StringStorage(t)))),

          // مقداردهی اولیه و تنظیمات مربوط به انتخاب
          t.initSelect(),

          // مقداردهی اولیه و تنظیمات مربوط به برچسب‌ها
          t.initLabel(),

          // مقداردهی اولیه و تنظیمات مربوط به لیست
          t.initList(),

          // مقداردهی اولیه و تنظیمات مربوط به آیتم‌های لیست
          t.initItems(),
          (t.value = t.select.value),
          t
        );
      }

      return (
        ns(i, ps),
        is(i, [
          {
            key: "initSelect",
            value: function () {
              (this.select = this.element.querySelector(".select__select")),
                (this.selectChangeCallback = this.onSelectChange.bind(this)),
                this.select.addEventListener(
                  "change",
                  this.selectChangeCallback,
                );
            },
          },
          {
            key: "initLabel",
            value: function () {
              (this.label = this.element.querySelector(".select__label")),
                (this.labelText = this.element.querySelector(
                  ".select__label__text",
                )),
                (this.labelClickCallback = this.onLabelClick.bind(this)),
                this.label.addEventListener("click", this.labelClickCallback);
            },
          },
          {
            key: "initList",
            value: function () {
              this.list = this.element.querySelector(".select__list");
            },
          },
          {
            key: "initItems",
            value: function () {
              var t = this;
              (this.items = this.element.querySelectorAll(".select__item")),
                (this.itemClickCallback = this.onItemClick.bind(this)),
                cs(this.items).forEach(function (env) {
                  env.addEventListener("click", t.itemClickCallback);
                });
            },
          },
          {
            key: "dispose",
            value: function () {
              this.disposeSelect(),
                this.disposeLabel(),
                this.disposeItems(),
                this.deactivate();
            },
          },
          {
            key: "disposeSelect",
            value: function () {
              this.select.removeEventListener(
                "change",
                this.selectChangeCallback,
              );
            },
          },
          {
            key: "disposeLabel",
            value: function () {
              this.label.removeEventListener("click", this.labelClickCallback);
            },
          },
          {
            key: "disposeItems",
            value: function () {
              var t = this;
              cs(this.items).forEach(function (env) {
                env.removeEventListener("click", t.itemClickCallback);
              });
            },
          },
          {
            key: "resize",
            value: function () {
              this.isActive
                ? ((this.needsResize = !1),
                  // اضافه کردن کلاس `select--active` به عنصر برای فعال‌سازی انتخاب
                  this.element.classList.add("select--active"),

                  // تنظیم ارتفاع لیست به مقدار پیش‌فرض
                  (this.list.style.height = ""),

                  // بررسی نیاز به انجام Reflow اجباری
                  this.forceReflow &&
                    (
                      // پنهان کردن لیست برای انجام Reflow
                      (this.list.style.display = "none"),
                      // محاسبه ارتفاع عنصر برای Reflow
                      this.list.offsetHeight,
                      // نمایش مجدد لیست بعد از Reflow
                      (this.list.style.display = "")
                    ),

                  // گرفتن ارتفاع لیست برای تنظیم مجدد
                  (this.list.height = this.list.offsetHeight),

                  // حذف کلاس `select--active` از عنصر
                  this.element.classList.remove("select--active"),

                  // پنهان کردن لیست انتخاب
                  (this.list.style.display = "none"),

                  // انجام Reflow مجدد برای لیست
                  this.list.offsetHeight,

                  // نمایش دوباره لیست انتخاب
                  (this.list.style.display = ""))
                : 
                // اگر نیازی به Reflow نبود، تنظیم فلگ `needsResize` به true
                (this.needsResize = !0);

            },
          },
          {
            key: "toggle",
            value: function () {
              this.isActive ? this.deactivate() : this.activate();
            },
          },
          {
            key: "activate",
            value: function () {
              var env = this;
              this.isActive ||
                ((this.isActive = !0),
                this.needsResize && this.resize(),
                setTimeout(function () {
                  env.element.classList.add("select--active"),
                    window.addEventListener("keyup", env.keyupCallback),
                    window.addEventListener("click", env.clickCallback);
                }),
                this.emit("activate", { currentTarget: this }));
            },
          },
          {
            key: "deactivate",
            value: function () {
              this.isActive &&
                ((this.isActive = !1),
                this.element.classList.remove("select--active"),
                window.removeEventListener("keyup", this.keyupCallback),
                window.removeEventListener("click", this.clickCallback),
                this.emit("deactivate", { currentTarget: this }));
            },
          },
          {
            key: "onLabelClick",
            value: function () {
              this.toggle();
            },
          },
          {
            key: "onItemClick",
            value: function (env) {
              var t = env.currentTarget.getAttribute("data-value");
              (this.select.value = t), this.onSelectChange();
            },
          },
          {
            key: "onSelectChange",
            value: function () {
              var i,
                n = this;
              (this.value = this.select.value),
                this.selected ||
                  ((this.selected = !0),
                  this.element.classList.add("select--selected")),
                cs(this.items).forEach(function (env) {
                  var t = env.getAttribute("data-value") === n.value;
                  env.classList.toggle("select__item--selected", t), t && (i = env);
                }),
                (this.labelText.textContent = i.textContent),
                this.deactivate(),
                this.emit("change", {
                  currentTarget: this,
                  value: this.value,
                  item: i,
                });
            },
          },
          {
            key: "onKeyUp",
            value: function (env) {
              27 === env.keyCode && this.deactivate();
            },
          },
          {
            key: "onClick",
            value: function () {
              this.deactivate();
            },
          },
        ]),
        i
      );
    })();
  var Db = new yu(-12.4, -89, 98),
    zb = new yu(8, -38, -4.7),
    Bb = (function () {
      function env() {
        es(this, env),
          // تنظیم وضعیت اجرای سیستم
          (this.isRunning = !1),

          // پیدا کردن عنصر پس‌زمینه منوی ناوبری از DOM
          (this.element = document.querySelector(".nav__background")),

          // مقداردهی اولیه مختصات موس
          (this.mouseX = 0),
          (this.mouseY = 0),

          // تعریف کال‌بک برای به‌روزرسانی در هر تیک
          (this.tickCallback = this.onTick.bind(this)),

          // تعریف کال‌بک برای حرکت موس
          (this.onMouseMoveCallback = this.onMouseMove.bind(this)),

          // ایجاد یک صحنه سه‌بعدی
          (this.scene = new Wm()),

          // تعریف موقعیت کنترلی موس با مختصات اولیه
          (this.mouseControlPosition = new mu(this.mouseX, this.mouseY)),

          // تعریف جهت کنترلی موس با مقادیر اولیه
          (this.mouseControlDirection = new mu(1, 1)),

          // فراخوانی توابع اولیه‌سازی اجزای مختلف
          this.initRenderer(), // تنظیم و راه‌اندازی رندرر
          this.initCamera(),   // تنظیم و راه‌اندازی دوربین
          this.initLights(),   // تنظیم و راه‌اندازی نورها
          this.initMeshes(),   // ایجاد و افزودن اشیا سه‌بعدی به صحنه
          this.initComposer(); // تنظیم کامپوزر برای پست‌پردازش

      }

      return (
        is(env, [
          {
            key: "initRenderer",
            value: function () {
              (this.renderer = new jm({
                antialias: !1,
                canvas: this.element,
              })),
                this.renderer.setSize(window.innerWidth, window.innerHeight),
                this.renderer.setClearColor(67084),
                (this.renderer.autoClear = !1);
            },
          },
          {
            key: "initCamera",
            value: function () {
              // ایجاد یک محور چرخش (pivot) برای دوربین
              (this.cameraPivot = new Pp()),

              // تنظیم موقعیت محور چرخش دوربین
              this.cameraPivot.position.set(-5, 10, 5),

              // تنظیم زاویه چرخش محور چرخش دوربین در محور Y (تبدیل درجه به رادیان)
              (this.cameraPivot.rotation.y = fu.degToRad(-43)),

              // اضافه کردن محور چرخش دوربین به صحنه
              this.scene.add(this.cameraPivot),

              // ایجاد یک دوربین جدید با زاویه دید 37 درجه، نسبت ابعاد پنجره، فاصله نزدیک و دور
              (this.camera = new zm(
                  37,
                  window.innerWidth / window.innerHeight,
                  0.1,
                  1000
              )),

              // تنظیم مقدار زوم دوربین
              (this.camera.zoom = 1.1),

              // به‌روزرسانی ماتریس پرسپکتیو دوربین با توجه به تغییرات
              this.camera.updateProjectionMatrix(),

              // کپی کردن موقعیت اولیه دوربین از یک مقدار ثابت (Db)
              this.camera.position.copy(Db),

              // اضافه کردن دوربین به محور چرخش
              this.cameraPivot.add(this.camera),

              // ایجاد یک هدف جدید برای دوربین
              (this.cameraTarget = new Pp()),

              // کپی کردن موقعیت هدف دوربین از یک مقدار ثابت (zb)
              this.cameraTarget.position.copy(zb),

              // اضافه کردن هدف دوربین به محور چرخش
              this.cameraPivot.add(this.cameraTarget),

              // تعریف یک بردار سه‌بعدی برای ذخیره موقعیت هدف دوربین در فضای جهانی
              (this.cameraTargetPosition = new yu()),

              // تعریف یک بردار سه‌بعدی برای ذخیره موقعیت جهانی دوربین
              (this.cameraWorldPosition = new yu());

            },
          },
          {
            key: "initLights",
            value: function () {
              var env = new my(16777215, 0.6, 0, 0.06, 1, 6);
              env.position.set(-972, -70, 965),
                this.scene.add(env),
                this.scene.add(env.target),
                env.target.position.set(41.4, -29.5, 14);
            },
          },
          {
            key: "initMeshes",
            value: function () {
              (this.boxes = []), (this.boxesY = []);
              for (var env = 0; env < 13; env++) {
                var t = rb.create();
                (t.position.y = env * (6 + rb.HEIGHT) * -1 - 17),
                  (t.rotation.x = fu.degToRad(90)),
                  this.boxesY.push(t.position.y),
                  this.scene.add(t),
                  this.boxes.push(t);
              }
            },
          },
          {
            key: "initComposer",
            value: function () {
              var env = {
                  minFilter: LineCounter,
                  magFilter: LineCounter,
                  format: Sc,
                  stencilBuffer: !0,
                },
                t = new Bu(window.innerWidth, window.innerHeight, env);
              this.composer = new Xx(this.renderer, t);
              var i = new Wx(this.scene, this.camera);
              i.clear = !1;
              var n = new Gx(Yx),
                r = new Gx(Bx);
              r.renderToScreen = !0;
              var a = new fb();
              this.noiseCounter = 0;
              var ObjectMethodWrapper = {
                uniforms: {
                  tDiffuse: { value: null },
                  uAmount: { value: this.noiseCounter },
                },
                vertexShader: yb,
                fragmentShader: _b,
              };
              (this.noisePass = new Gx(ObjectMethodWrapper)),
                this.composer.addPass(a),
                this.composer.addPass(i),
                this.composer.addPass(n),
                this.composer.addPass(this.noisePass),
                this.composer.addPass(r);
            },
          },
          {
            key: "start",
            value: function () {
              this.isRunning ||
                ((this.isRunning = !0),
                Ss.ticker.addEventListener("tick", this.tickCallback),
                window.addEventListener("mousemove", this.onMouseMoveCallback));
            },
          },
          {
            key: "pause",
            value: function () {
              this.isRunning &&
                ((this.isRunning = !1),
                Ss.ticker.removeEventListener("tick", this.tickCallback),
                window.removeEventListener(
                  "mousemove",
                  this.onMouseMoveCallback,
                ));
            },
          },
          {
            key: "resize",
            value: function () {
              this.renderer.setSize(window.innerWidth, window.innerHeight),
                (this.camera.aspect = window.innerWidth / window.innerHeight),
                this.camera.updateProjectionMatrix();
            },
          },
          {
            key: "animateIn",
            value: function () {
              return (
                (this.timeline = new Us({
                  onComplete: this.onAnimInComplete.bind(this),
                })
                  .fromTo(
                    this.camera.position,
                    2.8,
                    {
                      x: Db.x,
                      y: -112,
                      z: 44,
                    },
                    { x: Db.x, y: Db.y, z: Db.z, ease: Os.easeOut },
                    0,
                  )
                  .fromTo(
                    this.cameraTarget.position,
                    2,
                    {
                      x: zb.x,
                      y: 22,
                      z: zb.z,
                    },
                    { x: zb.x, y: zb.y, z: zb.z, ease: Os.easeOut },
                    0,
                  )),
                this.timeline
              );
            },
          },
          {
            key: "animateOut",
            value: function () {
              return (
                (this.timeline = new Us({
                  onComplete: this.onAnimOutComplete.bind(this),
                })
                  .to(
                    this.camera.position,
                    1,
                    {
                      x: 4,
                      y: -112,
                      z: 74,
                      ease: Os.easeIn,
                    },
                    0,
                  )
                  .to(
                    this.cameraTarget.position,
                    1,
                    { x: -26, y: -36, z: -63, ease: Os.easeIn },
                    0,
                  )),
                this.timeline
              );
            },
          },
          {
            key: "offsetBoxes",
            value: function (env) {
              var ObjectMethodWrapper = this,
                CounterVariable = this.boxes.length - 1 - 3,
                RandomGenerator = CounterVariable - env;
              this.boxes.forEach(function (env, t) {
                var i = RandomGenerator <= t ? -1 : 1,
                  n = window.Math.abs(t - RandomGenerator);
                -1 === i && (n += 1);
                var r,
                  a = (n - (r = 1)) / (CounterVariable - r);
                Ss.to(env.position, 1.1, {
                  y: ObjectMethodWrapper.boxesY[t] + 2 * i * n - 6 * i * a,
                  ease: Fs.easeInOut,
                });
              });
            },
          },
          {
            key: "clearBoxesOffset",
            value: function () {
              var i = this;
              this.boxes.forEach(function (env, t) {
                Ss.to(env.position, 0.8, { y: i.boxesY[t], ease: Fs.easeOut });
              });
            },
          },
          {
            key: "updateMouseControl",
            value: function () {
              var env = Db.x + 2 * this.mouseY,
                t = Db.y + 2 * this.mouseX;
              (this.camera.position.x += 0.1 * (env - this.camera.position.x)),
                (this.camera.position.y += 0.1 * (t - this.camera.position.y));
            },
          },
          {
            key: "onTick",
            value: function () {
              // گرفتن موقعیت جهانی هدف دوربین و ذخیره در موقعیت هدف دوربین
              this.cameraTarget.getWorldPosition(this.cameraTargetPosition),

              // تنظیم نگاه دوربین به سمت موقعیت هدف دوربین
              this.camera.lookAt(this.cameraTargetPosition),

              // چرخاندن دوربین به دور محور Z به میزان 89 درجه (تبدیل درجه به رادیان)
              this.camera.rotateZ(fu.degToRad(89)),

              // افزایش شمارنده نویز به میزان 0.01
              (this.noiseCounter += 0.01),

              // به‌روزرسانی مقدار شدت نویز در یونیفرم shader
              (this.noisePass.uniforms.uAmount.value = this.noiseCounter),

              // اگر timeline موجود نباشد، به‌روزرسانی کنترل ماوس
              this.timeline || this.updateMouseControl(),

              // رندر کردن صحنه با استفاده از کامپوزر (Post-processing)
              this.composer.render();

            },
          },
          {
            key: "onAnimInComplete",
            value: function () {
              this.timeline = null;
            },
          },
          {
            key: "onAnimOutComplete",
            value: function () {
              this.timeline = null;
            },
          },
          {
            key: "onMouseMove",
            value: function (env) {
              (this.mouseX = (env.clientX / window.innerWidth) * 2 - 1),
                (this.mouseY = (env.clientY / window.innerHeight) * -2 + 1);
            },
          },
        ]),
        env
      );
    })(),
    Hb = new ((function (env) {
      function i() {
        var t;
        return (
          es(this, i),
((t = ls(this, rs(i).call(this))).element =
  document.querySelector(".nav")), // انتخاب عنصر اصلی ناوبری
(t.isVisible = !1), // مشخص کردن وضعیت نمایش منوی ناوبری
(t.onKeyUpHandler = t.onKeyUp.bind(StringStorage(StringStorage(t)))), // تعریف و اتصال هندلر رویداد کلید
(t.previousSelectedItem = null), // نگهداری آیتم انتخاب‌شده قبلی
(t.selectedItem = t.element.querySelector(".nav__item--selected")), // یافتن آیتم فعلی انتخاب‌شده
(t.hoveredItem = null), // نگهداری آیتمی که کاربر روی آن حرکت کرده است
(t.clearHoveredItemTimeout = -1), // تنظیم تایمر برای پاکسازی آیتم هاور شده
(t.itemLine = t.element.querySelector(".nav__item-line")), // انتخاب خطی که آیتم‌های ناوبری را مشخص می‌کند
(t.itemLines = t.itemLine.querySelectorAll(".nav__item-line div")), // تمام خطوط در آیتم خطی
(t.itemLineIsVisible = !1), // وضعیت نمایش خط آیتم
(t.itemLine2Rect = t.itemLines[1].getBoundingClientRect()), // دریافت ابعاد خط دوم برای تنظیمات موقعیت
(t.itemsElement = t.element.querySelector(".nav__items")), // لیست آیتم‌های ناوبری
(t.itemsX = 0), // موقعیت X آیتم‌ها
(t.itemElements = t.element.querySelectorAll(".nav__item")), // تمام عناصر آیتم‌های ناوبری
(t.mouseDirection = 1), // جهت حرکت ماوس
// افزودن رویدادهای ماوس برای هر آیتم
cs(t.itemElements).forEach(function (env) {
  env.addEventListener(
    "mouseenter",
    t.onItemRollOver.bind(StringStorage(StringStorage(t))) // رویداد ورود ماوس به آیتم
  ),
    env.addEventListener(
      "mouseleave",
      t.onItemRollOut.bind(StringStorage(StringStorage(t))) // رویداد خروج ماوس از آیتم
    );
}),
// اگر آیتم انتخاب‌شده‌ای وجود ندارد، خط آیتم را مخفی کن
t.selectedItem || (t.itemLine.style.visibility = "hidden"),
// مقداردهی پس‌زمینه
(t.background = new Bb()),
(t.timeline = null), // تایم‌لاین برای انیمیشن‌ها
          t.initLangSelect(),
          t
        );
      }

      return (
        ns(i, ps),
        is(i, [
          {
            key: "initLangSelect",
            value: function () {
              var env = this.element.querySelector(".nav__lang");
              env &&
                ((this.langSelect = new Ub(env)),
                this.langSelect.on(
                  "change",
                  this.onLangSelectChange.bind(this),
                ));
            },
          },
          {
            key: "setSelectedItem",
            value: function (env) {
              (this.selectedItem &&
                env === this.selectedItem.getAttribute("data-page")) ||
                (this.selectedItem
                  ? ((this.previousSelectedItem = this.selectedItem),
                    this.selectedItem.classList.remove("nav__item--selected"))
                  : ((this.previousSelectedItem = null),
                    (this.itemLine.style.visibility = "")),
                (this.selectedItem = document.querySelector(
                  '.nav__item[data-page="'.concat(env, '"]'),
                )),
                this.selectedItem &&
                  (this.selectedItem.classList.add("nav__item--selected"),
                  this.resizeItemLine()));
            },
          },
          {
            key: "setVisibility",
            value: function (env) {
              env !== this.isVisible &&
                ((this.isVisible = env),
                document.body.classList.toggle("nav-visible", this.isVisible),
                this.emit("visibilityChange", { isVisible: this.isVisible }));
            },
          },
          {
            key: "show",
            value: function () {
              if (!this.isVisible) {
                var env = fl.element.getBoundingClientRect();
                this.setVisibility(!0),
                  window.addEventListener("keyup", this.onKeyUpHandler),
                  this.background.start(),
                  this.animateIn(env);
              }
            },
          },
          {
            key: "hide",
            value: function () {
              var t = this;
              this.isVisible &&
                (window.removeEventListener("keyup", this.onKeyUpHandler),
                setTimeout(function () {
                  var env = fl.element.getBoundingClientRect();
                  t.setVisibility(!1), t.animateOut(env);
                }));
            },
          },
          {
            key: "animateIn",
            value: function (env) {
              this.timeline && (this.timeline.kill(), Ds(this.timeline));
              var t = fl.element.getBoundingClientRect();
              if (
                ((this.hoveredItem = null),
                (this.itemLineIsVisible = !1),
                this.resizeItemLine(),
                (this.timeline = new Us({
                  delay: 0.1,
                  onComplete: this.onAnimateInComplete.bind(this),
                })
                  .fromTo(
                    this.background.element,
                    0.4,
                    { opacity: 0 },
                    {
                      opacity: 1,
                      ease: Cs.easeNone,
                    },
                    0,
                  )
                  .from(
                    fl.element,
                    1.3,
                    {
                      x: env.x - t.x,
                      y: env.y - t.y,
                      scale: env.width / t.width,
                      ease: Ns.easeInOut,
                    },
                    0,
                  )
                  .fromTo(
                    fl.maskRect,
                    0.7,
                    {
                      attr: {
                        width: document.body.classList.contains(
                          "page-id-home-screen-0",
                        )
                          ? 1
                          : 0,
                      },
                    },
                    {
                      attr: { width: 1 },
                      onUpdate:
                        "safari" !== app.browser
                          ? null
                          : function () {
                              (fl.element.style.display = "none"),
                                fl.element.offsetHeight,
                                (fl.element.style.display = "");
                            },
                      ease: Os.easeInOut,
                    },
                    0.3,
                  )
                  .addLabel("items", 0.3)
                  .staggerFrom(
                    this.itemElements,
                    0.8,
                    {
                      y: 30,
                      opacity: 0,
                      ease: Ns.easeOut,
                    },
                    0.08,
                    "items",
                  )
                  .fromTo(
                    this.element.querySelector(".nav__footer"),
                    1,
                    { opacity: 0 },
                    {
                      opacity: 1,
                      ease: Cs.easeNone,
                    },
                    0.7,
                  )
                  .add(this.background.animateIn(), 0)),
                this.selectedItem)
              ) {
                var i =
                  0.08 *
                  Array.prototype.indexOf.call(
                    this.itemElements,
                    this.selectedItem,
                  );
                this.timeline
                  .fromTo(
                    this.itemLine,
                    0.4,
                    { opacity: 0 },
                    {
                      opacity: 1,
                      ease: Cs.easeNone,
                    },
                    "items+=" + i,
                  )
                  .fromTo(
                    this.itemLine,
                    0.8,
                    { y: 30 },
                    {
                      y: 0,
                      data: { clear: !1 },
                      ease: Fs.easeOut,
                    },
                    "items+=" + i,
                  )
                  .from(
                    this.itemLines[0],
                    0.8,
                    {
                      scaleX: 0,
                      ease: Os.easeInOut,
                      data: { clear: !1 },
                    },
                    "items+=" + i,
                  )
                  .fromTo(
                    this.itemLines[1],
                    0.8,
                    { scaleX: 0, x: 0 },
                    {
                      scaleX: 1,
                      ease: Fs.easeOut,
                      data: { clear: !1 },
                    },
                    "items+=" + (i + 0.3),
                  );
              } else Ss.set(this.itemLine, { y: 0 });
            },
          },
          {
            key: "animateOut",
            value: function (env) {
              this.timeline && this.timeline.kill(),
                Ss.set(fl.element, { clearProps: "x, y, scale" });
              var t = fl.element.getBoundingClientRect();
              this.hoveredItem && this.background.clearBoxesOffset(),
                (this.timeline = new Us({
                  onComplete: this.onAnimateOutComplete.bind(this),
                })
                  .set(this.element, { visibility: "inherit" })
                  .to(
                    this.background.element,
                    0.4,
                    {
                      opacity: 0,
                      ease: Cs.easeNone,
                    },
                    0.3,
                  )
                  .from(
                    fl.element,
                    1.3,
                    {
                      x: env.x - t.x,
                      y: env.y - t.y,
                      scale: env.width / t.width,
                      ease: Ns.easeInOut,
                    },
                    0,
                  )
                  .set(fl.textPath, { visibility: "inherit" }, 0)
                  .to(
                    fl.maskRect,
                    0.7,
                    {
                      attr: {
                        width: document.body.classList.contains(
                          "page-id-home-screen-0",
                        )
                          ? 1
                          : 0,
                      },
                      onUpdate:
                        "safari" !== app.browser
                          ? null
                          : function () {
                              (fl.element.style.display = "none"),
                                fl.element.offsetHeight,
                                (fl.element.style.display = "");
                            },
                      ease: Os.easeInOut,
                    },
                    0.2,
                  )
                  .addLabel("items", 0.1)
                  .staggerTo(
                    this.itemElements,
                    0.4,
                    {
                      y: 30,
                      opacity: 0,
                      ease: Os.easeOut,
                    },
                    app.windowWidth < app.screenM ? -0.06 : 0.06,
                    "items",
                  )
                  .to(
                    this.element.querySelector(".nav__footer"),
                    0.5,
                    {
                      opacity: 0,
                      ease: Cs.easeNone,
                    },
                    0,
                  )
                  .add(this.background.animateOut(), 0));
              var i =
                this.hoveredItem ||
                this.selectedItem ||
                this.previousSelectedItem;
              if (i) {
                var n =
                  0.06 * Array.prototype.indexOf.call(this.itemElements, i);
                this.timeline.to(
                  this.itemLine,
                  0.4,
                  {
                    y: 30,
                    opacity: 0,
                    ease: Os.easeOut,
                    data: { clear: !1 },
                  },
                  "items+=" + n,
                );
              }
            },
          },
          {
            key: "resize",
            value: function (env) {
              var t = this.itemsElement.getBoundingClientRect();
              (this.itemsX = t.x),
                this.resizeItemLine(),
                env && this.background.resize();
            },
          },
          {
            key: "resizeItemLine",
            value: function () {
              if (this.selectedItem) {
                var env = this.selectedItem
                  .querySelector(".nav__item__link")
                  .getBoundingClientRect();
                Ss.set(this.itemLine, { x: env.x - this.itemsX }),
                  Ss.set(this.itemLines[0], { scaleX: env.width });
              }
            },
          },
          {
            key: "moveItemLineToItem",
            value: function (env) {
              var t = env && env.querySelector(".nav__item__link"),
                i = t
                  ? t.getBoundingClientRect()
                  : this.itemLine.getBoundingClientRect(),
                n = this.itemLine._gsTransform
                  ? this.itemLine._gsTransform.x
                  : 0;
              this.selectedItem || this.itemLineIsVisible
                ? (this.mouseDirection = n < i.x ? 1 : -1)
                : (Ss.set(this.itemLine, { x: i.x - this.itemsX }),
                  (this.mouseDirection = 0));
              var r = this.itemLines[0],
                a = this.itemLines[1];
              Ss.killTweensOf([r, a, this.itemLine]);
              var ObjectMethodWrapper = new Us();
              0 === this.mouseDirection
                ? ObjectMethodWrapper.fromTo(
                    a,
                    0.4,
                    { scaleX: 0, x: 0 },
                    {
                      scaleX: 1,
                      ease: Fs.easeOut,
                    },
                  )
                : 1 === this.mouseDirection
                  ? (ObjectMethodWrapper.fromTo(
                      a,
                      0.4,
                      { x: 0 },
                      {
                        scaleX: i.width / this.itemLine2Rect.width,
                        ease: Fs.easeOut,
                        immediateRender: !1,
                      },
                    ),
                    env &&
                      ObjectMethodWrapper.to(a, 0.4, {
                        scaleX: 1,
                        x: i.width - this.itemLine2Rect.width,
                        ease: Fs.easeOut,
                      }))
                  : ObjectMethodWrapper
                      .to(a, 0.4, {
                        scaleX: i.width / this.itemLine2Rect.width,
                        x: 0,
                        ease: Fs.easeOut,
                        immediateRender: !1,
                      })
                      .to(a, 0.4, { scaleX: 1, ease: Fs.easeOut }),
                new Us()
                  .to(
                    r,
                    0.7,
                    {
                      scaleX: i.width,
                      ease: Fs.easeOut,
                    },
                    0,
                  )
                  .add(ObjectMethodWrapper, 0)
                  .set(
                    this.itemLine,
                    {
                      visibility: "inherit",
                      opacity: 1,
                    },
                    0,
                  )
                  .to(
                    this.itemLine,
                    0.7,
                    { x: i.x - this.itemsX, ease: Fs.easeOut },
                    0,
                  );
            },
          },
          {
            key: "onKeyUp",
            value: function (env) {
              27 === env.keyCode && this.hide();
            },
          },
          {
            key: "onItemRollOver",
            value: function (env) {
              if (
                this.isVisible &&
                (clearTimeout(this.clearHoveredItemTimeout),
                (this.hoveredItem || env.currentTarget !== this.selectedItem) &&
                  this.hoveredItem !== env.currentTarget)
              ) {
                if (
                  ((this.hoveredItem =
                    env.currentTarget === this.selectedItem
                      ? null
                      : env.currentTarget),
                  this.hoveredItem)
                ) {
                  var t = Array.prototype.indexOf.call(
                    this.itemElements,
                    this.hoveredItem,
                  );
                  this.background.offsetBoxes(t);
                }
                this.moveItemLineToItem(this.hoveredItem || this.selectedItem),
                  (this.itemLineIsVisible = !0);
              }
            },
          },
          {
            key: "onItemRollOut",
            value: function (env) {
              var t = this;
              this.hoveredItem &&
                this.isVisible &&
                (this.clearHoveredItemTimeout = setTimeout(function () {
                  (t.hoveredItem = null),
                    t.background.clearBoxesOffset(),
                    t.moveItemLineToItem(t.selectedItem),
                    (t.itemLineIsVisible = !1);
                }, 300));
            },
          },
          {
            key: "onAnimateInComplete",
            value: function () {
              Ds(this.timeline), (this.timeline = null);
            },
          },
          {
            key: "onAnimateOutComplete",
            value: function () {
              Ds(this.timeline),
                (this.timeline = null),
                this.background.pause();
            },
          },
          {
            key: "onLangSelectChange",
            value: function (env) {
              window.location = env.item.href;
            },
          },
        ]),
        i
      );
    })())(),
    Gb = [kb, Nb, Nb, Nb, Nb],
    jb = (function (env) {
      function t(env) {
        return es(this, t), ls(this, rs(t).call(this, env));
      }

      return (
        ns(t, Cl),
        is(t, [
          {
            key: "initPage",
            value: function () {
              hs(rs(t.prototype), "initPage", this).call(this),
                (this.previousScreenIndex = -1),
                (this.currentScreenIndex = 0),
                (this.nextScreenIndex = -1),
                (this.screenElements =
                  this.element.querySelectorAll(".home__screen")),
                (this.background = new Lb({
                  screenElements: this.screenElements,
                  element: this.element,
                })),
                this.initScreenNavigator(),
                this.initNav(),
                this.initPagination(),
                (this.logoClickCallback = this.onLogoClick.bind(this)),
                fl.element.addEventListener("click", this.logoClickCallback),
                this.isAjax || this.addScreenClassName(this.currentScreenIndex);
            },
          },
          {
            key: "initScrollCTA",
            value: function () {},
          },
          {
            key: "initLine",
            value: function () {},
          },
          {
            key: "initScroll",
            value: function () {},
          },
          {
            key: "initScreenNavigator",
            value: function () {
              var ObjectMethodWrapper = this;
              (this.screenNavigator = new ws()),
                (this.screenNavigator.transitionType = xs.OutAndIn),
                this.screenNavigator.on(
                  "transitionStart",
                  this.onScreenNavigatorTransitionStart.bind(this),
                ),
                this.screenNavigator.on(
                  "transitionComplete",
                  this.onScreenNavigatorTransitionComplete.bind(this),
                ),
                cs(this.screenElements).forEach(function (env, t) {
                  var i = t.toString(),
                    n = Gb[t] || BaseHomeScreen,
                    r = env.classList.contains("home__screen--light") ? ul : pl,
                    a = new ds(n, {
                      arguments: [
                        {
                          element: env,
                          index: t,
                          owner: ObjectMethodWrapper.screenNavigator,
                          isAjaxPage: ObjectMethodWrapper.isAjax,
                          color: r,
                        },
                      ],
                      events: {
                        swipe: ObjectMethodWrapper.onSwipe.bind(ObjectMethodWrapper),
                        complete: ObjectMethodWrapper.onScreenComplete.bind(ObjectMethodWrapper),
                      },
                    });
                  env.classList.contains("home__screen--current") &&
                    (ObjectMethodWrapper.currentScreenIndex = t),
                    ObjectMethodWrapper.screenNavigator.addScreen(i, a);
                });
            },
          },
          {
            key: "initNav",
            value: function () {
              (this.onKeyUpCallback = this.onKeyUp.bind(this)),
                (this.onScrollCallback = this.onScroll.bind(this)),
                window.addEventListener("keyup", this.onKeyUpCallback),
                window.addEventListener("wheel", this.onScrollCallback, {
                  passive: !1,
                });
            },
          },
          {
            key: "initPagination",
            value: function () {
              (this.pagination = new Ib({
                parentElement: this.element,
                total: this.screenElements.length - 1,
              })),
                this.pagination.on(
                  "change",
                  this.onPaginationChange.bind(this),
                );
            },
          },
          {
            key: "dispose",
            value: function () {
              hs(rs(t.prototype), "dispose", this).call(this),
                this.background && this.background.dispose(),
                this.disposeScreenNavigator(),
                this.disposeNav(),
                this.disposePagination(),
                fl.element.removeEventListener("click", this.logoClickCallback);
            },
          },
          {
            key: "disposeScreenNavigator",
            value: function () {
              this.screenNavigator &&
                (this.screenNavigator.off("transitionStart"),
                this.screenNavigator.off("transitionComplete"),
                this.screenNavigator.dispose());
            },
          },
          {
            key: "disposeNav",
            value: function () {
              window.removeEventListener("keyup", this.onKeyUpCallback),
                window.removeEventListener("wheel", this.onScrollCallback);
            },
          },
          {
            key: "disposePagination",
            value: function () {
              this.pagination &&
                (this.pagination.off("change"), this.pagination.dispose());
            },
          },
          {
            key: "getScreenClassName",
            value: function (env) {
              return "page-id-".concat(this.id, "-screen-").concat(env);
            },
          },
          {
            key: "addScreenClassName",
            value: function (env) {
              var t = this.getScreenClassName(env);
              document.body.classList.add(t);
            },
          },
          {
            key: "removeScreenClassName",
            value: function (env) {
              var t = this.getScreenClassName(env);
              document.body.classList.remove(t);
            },
          },
          {
            key: "populateLoader",
            value: function (env, t) {
              var r = this,
                i = [ub.getImage().path, db.getImage().path],
                n = i.map(function (env) {
                  var i = app.rootUrl + "/assets/img/" + env,
                    n = new zv();
                  return new Promise(function (env, t) {
                    n.load(i, env, null, t);
                  }).then(r.onAssetLoaded.bind(r));
                });
              (this.numAssetsToLoad = i.length),
                Promise.all(n).then(env).catch(t);
            },
          },
          {
            key: "createAnimInContent",
            value: function () {
              (this.element.style.visibility = "inherit"),
                this.isAjax && this.addScreenClassName(this.currentScreenIndex),
                this.screenNavigator.showScreen(
                  this.currentScreenIndex.toString(),
                ),
                this.background.animateIn();
            },
          },
          {
            key: "createAnimOut",
            value: function (env) {
              hs(rs(t.prototype), "createAnimOut", this).call(this, env),
                this.background.stop();
            },
          },
          {
            key: "resize",
            value: function (env) {
              hs(rs(t.prototype), "resize", this).call(this, env),
                this.background && this.background.resize(),
                this.pagination && this.pagination.resize(),
                this.screenNavigator &&
                  this.screenNavigator.currentScreen.resize();
            },
          },
          {
            key: "gotoScreen",
            value: function (env) {
              env !== this.currentScreenIndex &&
                ((this.previousScreenIndex = this.currentScreenIndex),
                (this.currentScreenIndex = env),
                this.screenNavigator.showScreen(env.toString()));
            },
          },
          {
            key: "gotoNextScreen",
            value: function () {
              var env = this.currentScreenIndex + 1;
              Gb.length - 1 < env && (env = Gb.length - 1), this.gotoScreen(env);
            },
          },
          {
            key: "gotoPrevScreen",
            value: function () {
              var env = this.currentScreenIndex - 1;
              env < 0 && (env = 0), this.gotoScreen(env);
            },
          },
          {
            key: "onAnimateOutComplete",
            value: function () {
              hs(rs(t.prototype), "onAnimateOutComplete", this).call(this),
                this.screenNavigator &&
                  this.removeScreenClassName(
                    this.screenNavigator.currentItemId,
                  );
            },
          },
          {
            key: "onScreenNavigatorTransitionStart",
            value: function () {
              this.screenNavigator.currentScreen.updateLogoRectBeforeTransition(),
                app.isTablet && this.screenNavigator.currentScreen.resize(),
                this.background.showScreen(this.currentScreenIndex),
                this.screenNavigator.previousScreen &&
                  (this.screenElements[
                    this.previousScreenIndex
                  ].classList.remove("home__screen--current"),
                  this.screenElements[this.currentScreenIndex].classList.add(
                    "home__screen--current",
                  ),
                  this.removeScreenClassName(
                    this.screenNavigator.previousItemId,
                  ),
                  this.addScreenClassName(this.screenNavigator.currentItemId)),
                this.changeColor(this.screenNavigator.currentScreen.color),
                0 !== this.currentScreenIndex
                  ? (this.pagination.show(),
                    this.pagination.setCurrentIndex(this.currentScreenIndex))
                  : this.screenNavigator.previousScreen &&
                    this.pagination.hide(),
                app.windowWidth < app.screenM &&
                  Ss.to(window, 1, {
                    scrollTo: 0,
                    ease: Os.easeOut,
                  });
            },
          },
          {
            key: "onScreenNavigatorTransitionComplete",
            value: function () {
              -1 !== this.nextScreenIndex &&
                (this.gotoScreen(this.nextScreenIndex),
                (this.nextScreenIndex = -1));
            },
          },
          {
            key: "onKeyUp",
            value: function (env) {
              switch (env.keyCode) {
                case 38:
                  this.gotoPrevScreen();
                  break;
                case 40:
                  this.gotoNextScreen();
              }
            },
          },
          {
            key: "onScroll",
            value: function (env) {
              window.innerWidth < app.screenS ||
                (env.preventDefault(),
                this.screenNavigator.transition ||
                  Hb.isVisible ||
                  ((env.wheelDelta && env.wheelDelta < 0) ||
                  (env.detail && 0 < env.detail)
                    ? this.gotoNextScreen()
                    : this.gotoPrevScreen()));
            },
          },
          {
            key: "onPaginationChange",
            value: function (env) {
              this.screenNavigator.transition &&
              env.index !== this.currentScreenIndex
                ? (this.nextScreenIndex = env.index)
                : this.gotoScreen(env.index);
            },
          },
          {
            key: "onLogoClick",
            value: function (env) {
              env.preventDefault(), this.gotoScreen(0);
            },
          },
          {
            key: "onScreenComplete",
            value: function () {
              this.gotoNextScreen();
            },
          },
          {
            key: "onSwipe",
            value: function (env) {
              env.direction === Hammer.DIRECTION_UP
                ? this.gotoNextScreen()
                : env.direction === Hammer.DIRECTION_DOWN &&
                  this.gotoPrevScreen();
            },
          },
        ]),
        t
      );
    })(),
    Vb = (function (env) {
      function i(env) {
        return es(this, i), ls(this, rs(i).call(this, env));
      }

      return (
        ns(i, Cl),
        is(i, [
          {
    // مقداردهی اولیه صفحه
    key: "initPage",
    value: function () {
      // فراخوانی متد `initPage` از کلاس والد و سپس مقداردهی متون تعاملی
      hs(rs(i.prototype), "initPage", this).call(this),
        this.initInteractiveText();
    },
  },
  {
    // مقداردهی متون تعاملی
    key: "initInteractiveText",
    value: function () {
      var i = this,
        // انتخاب تمام عناصری که متن تعاملی دارند
        env = this.element.querySelectorAll(".page__section__head > Property");
      // تنظیم تایمر برای تغییر اندازه متن‌ها
      (this.interactiveTextResizeTimeout = -1),
        (this.interactiveTexts = []),
        // ایجاد اشیاء متون تعاملی برای هر عنصر انتخاب‌شده
        cs(env).forEach(function (env) {
          var t = new Rb({ element: env, color: [179, 218, 226] }); // رنگ تعریف‌شده
          i.interactiveTexts.push(t); // افزودن به آرایه متون تعاملی
        });
    },
  },
  {
    // پاکسازی منابع و رویدادها
    key: "dispose",
    value: function () {
      // فراخوانی متد `dispose` از کلاس والد
      hs(rs(i.prototype), "dispose", this).call(this),
        this.disposeInteractiveTexts(); // پاکسازی متون تعاملی
    },
  },
  {
    // پاکسازی متون تعاملی
    key: "disposeInteractiveTexts",
    value: function () {
      if (this.interactiveTexts)
        for (; this.interactiveTexts.length; )
          this.interactiveTexts.shift().dispose(); // حذف و تخلیه متون تعاملی
    },
  },
  {
    // انیمیشن ورود محتوا
    key: "animateInContent",
    value: function () {
      // فراخوانی انیمیشن ورود محتوا از کلاس والد
      hs(rs(i.prototype), "animateInContent", this).call(this);
      var env = this.element.querySelector(".page__background");
      // ایجاد انیمیشن برای پس‌زمینه
      if (
        (this.timeline
          .from(
            env,
            2,
            {
              x: 0.2 * app.windowWidth, // حرکت در محور X
              y: 0.1 * app.windowWidth, // حرکت در محور Y
              rotationX: -10, // چرخش در محور X
              rotationY: 30, // چرخش در محور Y
              ease: Os.easeOut, // منحنی انیمیشن
            },
            0, // تاخیر زمانی
          )
          .from(env, 1, { opacity: 0 }, 0), // تغییر شفافیت
        this.interactiveTexts)
      ) {
        var t = [];
        // جمع‌آوری خطوط متن تعاملی برای انیمیشن
        this.interactiveTexts.forEach(function (env) {
          t = t.concat(env.splitText.lines.slice());
        }),
          // اجرای انیمیشن برای هر خط متن
          this.timeline.staggerFrom(
            t,
            0.7, // مدت زمان
            { y: 50, opacity: 0, ease: Power3.easeOut }, // حرکت و تغییر شفافیت
            0.06, // فاصله زمانی بین خطوط
            0.6, // تاخیر شروع
          );
      }
    },
  },
  {
    // تغییر اندازه صفحه
    key: "resize",
    value: function (env) {
      // فراخوانی متد `resize` از کلاس والد
      hs(rs(i.prototype), "resize", this).call(this, env),
        this.resizeInteractiveTexts(); // تغییر اندازه متون تعاملی
    },
  },
  {
    // تغییر اندازه متون تعاملی
    key: "resizeInteractiveTexts",
    value: function () {
      var env = this;
      if (this.interactiveTexts) {
        clearTimeout(this.interactiveTextResizeTimeout); // پاک کردن تایمر قبلی
        this.interactiveTextResizeTimeout = setTimeout(function () {
          env.interactiveTexts.forEach(function (env) {
            env.resize(); // اجرای تغییر اندازه برای هر متن
          });
        }, 100); // اجرای تغییر اندازه پس از 100 میلی‌ثانیه
      }
    },
  },
  {
    // تکمیل انیمیشن ورود محتوا
    key: "onAnimateInContentComplete",
    value: function () {
      // فراخوانی متد `onAnimateInContentComplete` از کلاس والد
      hs(rs(i.prototype), "onAnimateInContentComplete", this).call(this),
        // شروع تعامل متون تعاملی
        this.interactiveTexts &&
          this.interactiveTexts.forEach(function (env) {
            env.start(); // آغاز تعامل
                  });
            },
          },
        ]),
        i
      );
    })(),
    Xb = (function (env) {
      function i(env) {
        var t;
        return (
          es(this, i),
          ((t = ls(this, rs(i).call(this))).element = env),
          (t.changeCallback = t.onChange.bind(StringStorage(StringStorage(t)))),
          t.element.addEventListener("input", t.changeCallback),
          t.element.addEventListener("paste", t.changeCallback),
          t
        );
      }

      return (
        ns(i, ps),
        is(i, [
          {
            key: "dispose",
            value: function () {
              this.element.removeEventListener("input", this.changeCallback),
                this.element.removeEventListener("paste", this.changeCallback);
            },
          },
          {
            key: "onChange",
            value: function () {
              var env = 0 !== this.element.value.length;
              this.element.classList.toggle("form__input--filled", env),
                this.emit("change", {
                  currentTarget: this,
                  filled: env,
                });
            },
          },
        ]),
        i
      );
    })(),
    Wb = 0,
    Yb = 1,
    qb = (function () {
      function t(env) {
        es(this, t),
          (this.element = env),
          (this.submitCallback = this.onSubmit.bind(this)),
          this.element.addEventListener("submit", this.submitCallback),
          this.initSelects(),
          this.initTextInputs();
      }

      return (
        is(t, [
    {
      // مقداردهی اولیه لیست‌های انتخاب (Select)
      key: "initSelects",
      value: function () {
        // انتخاب تمام عناصر دارای کلاس `.select` و ایجاد اشیاء جدید `Ub` برای هر یک
        this.selects = cs(this.element.querySelectorAll(".select")).map(
          function (env) {
            return new Ub(env); // ایجاد نمونه جدید از کلاس `Ub` برای هر عنصر انتخاب شده
          },
        );
      },
    },
    {
      // مقداردهی اولیه ورودی‌های متنی (Text Inputs)
      key: "initTextInputs",
      value: function () {
        // انتخاب تمام عناصر دارای کلاس `.form__input` و ایجاد اشیاء جدید `Xb` برای هر یک
        this.textInputs = cs(
          this.element.querySelectorAll(".form__input"),
        ).map(function (env) {
          return new Xb(env); // ایجاد نمونه جدید از کلاس `Xb` برای هر ورودی متنی
        });
      },
    },
    {
      // حذف و پاکسازی لیسنرهای رویداد و داده‌ها
      key: "dispose",
      value: function () {
        // حذف رویداد ارسال فرم
        this.element.removeEventListener("submit", this.submitCallback);
        // پاکسازی لیست انتخاب‌ها
        this.disposeSelects();
        // پاکسازی ورودی‌های متنی
        this.disposeTextInputs();
      },
    },
    {
      // پاکسازی لیست‌های انتخاب (Selects)
      key: "disposeSelects",
      value: function () {
        // حذف تمام اشیاء انتخاب‌شده با تخلیه آرایه `selects`
        for (; this.selects.length; ) this.selects.shift().dispose();
      },
    },
    {
      // پاکسازی ورودی‌های متنی
      key: "disposeTextInputs",
      value: function () {
        // حذف تمام اشیاء ورودی با تخلیه آرایه `textInputs`
        for (; this.textInputs.length; ) this.textInputs.shift().dispose();
      },
    },
    {
      // قالب‌بندی پیام‌های خطا
      key: "formatErrorsMessage",
      value: function (env) {
        var t = '<ul class="form__message__errors">';
        // ایجاد لیست خطاها
        env.forEach(function (env) {
          t += '<li class="form__message__error">'.concat(
            env.message, // افزودن پیام خطا به لیست
            "</li>",
          );
        });
        return (t += "</ul>"); // بستن تگ HTML لیست
      },
    },
    {
      // نمایش پیام (موفقیت یا خطا)
      key: "showMessage",
      value: function (env, t) {
        var i = this.element.querySelector(".form__message"),
          // محاسبه موقعیت پیام برای اسکرول صفحه
          n =
            i.getBoundingClientRect().y +
            window.pageYOffset -
            0.5 * app.windowHeight;
        // تنظیم محتوای HTML پیام
        (i.innerHTML = env),
          // افزودن کلاس موفقیت یا خطا به پیام
          i.classList.toggle("form__message--success", t === Wb),
          i.classList.toggle("form__message--errors", t === Yb),
          // اسکرول به پیام با انیمیشن
          Ss.to(window, 0.4, {
            scrollTo: n,
            ease: Power2.easeOut,
          });
      },
    },
    {
      // مدیریت رویداد ارسال فرم
      key: "onSubmit",
      value: function (env) {
        var t = this,
          // جمع‌آوری داده‌های فرم
          i = new FormData(this.element);
        env.preventDefault(); // جلوگیری از ارسال پیش‌فرض فرم
        // ارسال درخواست به سرور
        window
          .fetch(window.location.href, {
            method: "POST", // روش ارسال
            body: i, // داده‌های فرم
            headers: { "ObjectKeys-Requested-With": "XMLHttpRequest" }, // تنظیم هدر درخواست
          })
          .then(function (env) {
            // پردازش پاسخ سرور
            env.json().then(function (env) {
              return t.onSubmitted(env); // پردازش نتیجه ارسال
            });
          });
      },
    },
    {
      // پردازش نتیجه ارسال فرم
      key: "onSubmitted",
      value: function (env) {
        if (env.success) {
          // در صورت موفقیت، نمایش پیام موفقیت
          this.showMessage(env.message, Wb);
        } else if (env.errors) {
          // در صورت وجود خطاها، قالب‌بندی و نمایش پیام خطا
          var t = this.formatErrorsMessage(env.errors);
          this.showMessage(t, Yb);
              }
            },
          },
        ]),
        t
      );
    })(),
    Qb = {
      default: Cl,
      home: jb,
      about: Vb,
      invest: (function (env) {
        function t(env) {
          return es(this, t), ls(this, rs(t).call(this, env));
        }

        return (
          ns(t, Cl),
          is(t, [
            {
              key: "initPage",
              value: function () {
                (this.lineStepsSelector = ".form__submit"),
                  hs(rs(t.prototype), "initPage", this).call(this),
                  this.initForm();
              },
            },
            {
              key: "initForm",
              value: function () {
                var t = this,
                  env = this.element.querySelector(".form");
                (this.form = new qb(env)),
                  (this.requiredInputs = env.querySelectorAll("[required]")),
                  (this.inputChangeCallback =
                    this.onRequiredInputChange.bind(this)),
                  (this.requiredFilledInputs = []),
                  cs(this.requiredInputs).forEach(function (env) {
                    env.addEventListener("input", t.inputChangeCallback),
                      env.addEventListener("paste", t.inputChangeCallback);
                  });
              },
            },
            {
              key: "dispose",
              value: function () {
                hs(rs(t.prototype), "dispose", this).call(this),
                  this.disposeForm();
              },
            },
            {
              key: "disposeForm",
              value: function () {
                var t = this;
                this.form &&
                  (this.form.dispose(),
                  cs(this.requiredInputs).forEach(function (env) {
                    env.removeEventListener("input", t.inputChangeCallback),
                      env.removeEventListener("paste", t.inputChangeCallback);
                  }));
              },
            },
            {
              key: "createAnimInContent",
              value: function () {
                hs(rs(t.prototype), "createAnimInContent", this).call(this);
                var env = this.element.querySelector(".page__background");
                this.timeline
                  .from(
                    env,
                    2,
                    {
                      y: -400,
                      scale: 1.5,
                      rotationX: 25,
                      rotationY: -7,
                      ease: Os.easeOut,
                    },
                    0,
                  )
                  .from(env, 1, { opacity: 0 }, 0);
              },
            },
            {
              key: "onRequiredInputChange",
              value: function (env) {
                var t = env.currentTarget,
                  i = 0 !== t.value.length,
                  n = this.requiredFilledInputs.indexOf(t);
                i && -1 === n
                  ? this.requiredFilledInputs.push(t)
                  : i || -1 === n || this.requiredFilledInputs.splice(n, 1),
                  this.form.element.classList.toggle(
                    "form--filled",
                    this.requiredFilledInputs.length ===
                      this.requiredInputs.length,
                  );
              },
            },
          ]),
          t
        );
      })(),
      team: (function (env) {
        function t(env) {
          return es(this, t), ls(this, rs(t).call(this, env));
        }

        return (
          ns(t, Cl),
          is(t, [
            {
              key: "initPage",
              value: function () {
                hs(rs(t.prototype), "initPage", this).call(this),
                  this.initMembers();
              },
            },
            {
              key: "initMembers",
              value: function () {
                var t = this;
                (this.memberRollOverCallback =
                  this.onMemberRollOver.bind(this)),
                  (this.memberElements =
                    this.element.querySelectorAll(".team__member")),
                  cs(this.memberElements).forEach(function (env) {
                    env.addEventListener("mouseenter", t.memberRollOverCallback);
                  });
              },
            },
            {
              key: "dispose",
              value: function () {
                hs(rs(t.prototype), "dispose", this).call(this),
                  this.disposeMembers();
              },
            },
            {
              key: "disposeMembers",
              value: function () {
                var t = this;
                this.memberElements &&
                  cs(this.memberElements).forEach(function (env) {
                    env.removeEventListener(
                      "mouseenter",
                      t.memberRollOverCallback,
                    );
                  });
              },
            },
            {
              key: "createAnimInContent",
              value: function () {
                var i = this;
                hs(rs(t.prototype), "createAnimInContent", this).call(this),
                  this.timeline.from(
                    this.element.querySelector(".team__members"),
                    0.7,
                    { opacity: 0 },
                    0,
                  ),
                  cs(this.memberElements).forEach(function (env) {
                    var t = env.querySelectorAll(
                      ".team__member__name, .team__member__role, .team__member__contact",
                    );
                    i.timeline.staggerFrom(
                      t,
                      0.9,
                      { opacity: 0, y: 30, ease: Fs.easeOut },
                      0.07,
                      0.4,
                    );
                  });
              },
            },
            {
              key: "onMemberRollOver",
              value: function (env) {
                var t = env.currentTarget.querySelectorAll(
                  ".team__member__name,.team__member__role,.team__member__email,.team__member__linkedin",
                );
                Ss.killTweensOf(t),
                  new Us().staggerFromTo(
                    t,
                    0.7,
                    { y: 30, opacity: 0 },
                    {
                      y: 0,
                      opacity: 1,
                      ease: Fs.easeOut,
                    },
                    0.1,
                  );
              },
            },
          ]),
          t
        );
      })(),
      partners: (function (env) {
        function t(env) {
          return es(this, t), ls(this, rs(t).call(this, env));
        }

        return (
          ns(t, Cl),
          is(t, [
            {
              key: "initPage",
              value: function () {
                hs(rs(t.prototype), "initPage", this).call(this);
              },
            },
            {
              key: "initPartners",
              value: function () {
                var t = this;
                (this.partnerRollOverCallback =
                  this.onPartnerRollOver.bind(this)),
                  (this.partnerRollOutCallback =
                    this.onPartnerRollOut.bind(this)),
                  (this.partnerElements = this.element.querySelectorAll(
                    ".partners__list__item",
                  )),
                  cs(this.partnerElements).forEach(function (env) {
                    env.addEventListener("mouseenter", t.partnerRollOverCallback),
                      env.addEventListener(
                        "mouseleave",
                        t.partnerRollOutCallback,
                      );
                  });
              },
            },
            {
              key: "dispose",
              value: function () {
                hs(rs(t.prototype), "dispose", this).call(this);
              },
            },
            {
              key: "disposePartners",
              value: function () {
                var t = this;
                cs(this.partnerElements).forEach(function (env) {
                  env.removeEventListener(
                    "mouseenter",
                    t.partnerRollOverCallback,
                  ),
                    env.removeEventListener(
                      "mouseleave",
                      t.partnerRollOutCallback,
                    );
                });
              },
            },
            {
              key: "createAnimInContent",
              value: function () {
                hs(rs(t.prototype), "createAnimInContent", this).call(this);
                var env = this.element.querySelectorAll(".partners__list__item");
                this.timeline.staggerFrom(
                  env,
                  0.8,
                  { y: 30, opacity: 0 },
                  0.1,
                  0.4,
                );
              },
            },
            {
              key: "getMouseDirection",
              value: function (env, t) {
  // متغیر `i` عرض عنصر است
  var i = env.width,
      // متغیر `n` ارتفاع عنصر است
      n = env.height,
      // محاسبه مختصات X نسبی ماوس نسبت به مرکز عنصر
      // اگر ارتفاع کمتر از عرض باشد، مقدار مقیاس تغییر می‌کند
      r = (t.x - env.left - i / 2) * (n < i ? n / i : 1),
      // محاسبه مختصات Y نسبی ماوس نسبت به مرکز عنصر
      // اگر عرض کمتر از ارتفاع باشد، مقدار مقیاس تغییر می‌کند
      a = (t.y - env.top - n / 2) * (i < n ? i / n : 1);
                return (
                  Math.round(
                    (Math.atan2(a, r) * (180 / Math.PI) + 180) / 90 + 3,
                  ) % 4
                );
              },
            },
            {
key: "onPartnerRollOver",
value: function (env) {
  // انتخاب عنصر جاری که رویداد ماوس بر روی آن اتفاق افتاده است
  var t = env.currentTarget,
    // انتخاب پوشش آیتم شریک
    i = t.querySelector(".partners__list__item__overlay"),
    // انتخاب پس‌زمینه پوشش آیتم
    n = t.querySelector(".partners__list__item__overlay__background"),
    // دریافت مختصات مکان ماوس
    r = { x: env.clientX, y: env.clientY },
    // محاسبه جهت ماوس بر اساس موقعیت عنصر
    a = this.getMouseDirection(t.getBoundingClientRect(), r);

  // متوقف کردن هر انیمیشن قبلی در عناصر پوشش و پس‌زمینه
  Ss.killTweensOf([i, n]),
    // ایجاد انیمیشن جدید برای نمایش پوشش
    new Us().fromTo(
      n,
      0.6, // مدت زمان انیمیشن
      {
        // مقادیر اولیه انیمیشن بر اساس جهت ورود ماوس
        scaleX: 1 === a || 3 === a ? 0 : 1,
        scaleY: 0 === a || 2 === a ? 0 : 1,
        xPercent: 1 === a ? 100 : 0,
        yPercent: 2 === a ? 100 : 0,
      },
      {
        // مقادیر نهایی انیمیشن
        scaleX: 1,
        scaleY: 1,
        xPercent: 0,
        yPercent: 0,
        ease: Fs.easeOut, // استفاده از easing برای حرکت نرم
      },
      0 // زمان شروع انیمیشن
                  );
              },
            },
            {
key: "onPartnerRollOut",
value: function () {
  // انتخاب عنصر جاری که ماوس آن را ترک کرده است
  var env = event.currentTarget,
    // انتخاب پوشش آیتم شریک
    t = env.querySelector(".partners__list__item__overlay"),
    // انتخاب پس‌زمینه پوشش آیتم
    i = env.querySelector(".partners__list__item__overlay__background"),
    // دریافت مختصات مکان ماوس
    n = { x: event.clientX, y: event.clientY },
    // محاسبه جهت ماوس بر اساس موقعیت عنصر
    r = this.getMouseDirection(env.getBoundingClientRect(), n);

  // متوقف کردن هر انیمیشن قبلی در عناصر پوشش و پس‌زمینه
  Ss.killTweensOf([t, i]),
    // ایجاد انیمیشن برای مخفی کردن پوشش
    new Us()
      .set(t, { visibility: "inherit" }) // تنظیم خاصیت دیدنی
      .to(
        i,
        0.4, // مدت زمان انیمیشن
        {
          // مقادیر نهایی انیمیشن برای مخفی کردن بر اساس جهت خروج ماوس
          scaleX: 1 === r || 3 === r ? 0 : 1,
          scaleY: 0 === r || 2 === r ? 0 : 1,
          xPercent: 1 === r ? 100 : 0,
          yPercent: 2 === r ? 100 : 0,
          ease: Fs.easeOut, // استفاده از easing برای حرکت نرم
        },
        0 // زمان شروع انیمیشن
      )
      .set(t, { clearProps: "visibility" }); // پاک کردن خاصیت‌های دیدنی
              },
            },
          ]),
          t
        );
      })(),
      subscribe: (function (env) {
        function i(env) {
          var t;
          return (
            es(this, i),
            ((t = ls(this, rs(i).call(this, env))).sectionElementsToAnimateIn +=
              ",.form__label,.form__submit"),
            t
          );
        }

        return (
          ns(i, Cl),
          is(i, [
            {
              key: "initPage",
              value: function () {
                (this.lineStepsSelector = ".form__submit"),
                  hs(rs(i.prototype), "initPage", this).call(this),
                  this.initForm();
              },
            },
            {
key: "initForm",
value: function () {
  var i = this,
    // انتخاب فرم از داخل صفحه
    env = this.element.querySelector(".form");

  // تعریف تابع برای مدیریت تغییرات ورودی
  this.inputChangeCallback = this.onInputChange.bind(this),
    // ایجاد نمونه‌ای از فرم
    (this.form = new qb(env)),
    // انتخاب همه ورودی‌های فرم
    (this.inputs = this.element.querySelectorAll(".form__input")),
    // ایجاد آرایه‌ای برای نگهداری وضعیت پر بودن ورودی‌ها
    (this.filledInputs = []),
    // افزودن رویدادهای `input` و `paste` برای هر ورودی
    cs(this.inputs).forEach(function (env, t) {
      env.addEventListener("input", i.inputChangeCallback),
        env.addEventListener("paste", i.inputChangeCallback),
        (i.filledInputs[t] = 0); // مقداردهی اولیه به وضعیت پر بودن
    }),
    // انتخاب عناصر مرتبط با دکمه ارسال
    (this.submitBorders = this.element.querySelectorAll(
      ".form__submit__border"
                  ));
              },
            },
            {
key: "dispose",
value: function () {
  // فراخوانی متد پایه برای پاکسازی
  hs(rs(i.prototype), "dispose", this).call(this),
    // پاکسازی فرم و رویدادهای مرتبط
    this.disposeForm();
              },
            },
            {
key: "disposeForm",
value: function () {
  var t = this;
  // بررسی وجود فرم
  this.form &&
    (this.form.dispose(), // پاکسازی فرم
    cs(this.inputs).forEach(function (env) {
      // حذف رویداد `input` از هر ورودی
      env.removeEventListener("input", t.inputChangeCallback),
        // حذف رویداد `paste` از هر ورودی
        env.removeEventListener("paste", t.inputChangeCallback);
                  }));
              },
            },
            {
key: "createAnimInContent",
value: function () {
  // فراخوانی متد پایه برای ایجاد انیمیشن
  hs(rs(i.prototype), "createAnimInContent", this).call(this);
  // انتخاب عنصر پس‌زمینه از DOM
  var env = this.element.querySelector(".page__background");
  this.timeline
    .from(
      env,
      2, // مدت زمان انیمیشن
      {
        y: -40, // مقدار اولیه محور Y
        scale: 1.5, // مقیاس اولیه
        rotationX: 25, // چرخش در محور X
        rotationY: -7, // چرخش در محور Y
        ease: Power2.easeOut, // نوع easing برای انیمیشن
      },
      0 // زمان شروع انیمیشن
    )
    .from(env, 1, { opacity: 0 }, 0); // انیمیشن تغییر شفافیت
              },
            },
            {
key: "updateSubmitButton",
value: function () {
  // فیلتر کردن ورودی‌های پرشده
  var i = this.filledInputs.filter(function (env) {
    return 1 === env;
  });
  // بروزرسانی استایل حاشیه دکمه‌های ارسال
  cs(this.submitBorders).forEach(function (env, t) {
    env.classList.toggle(
      "form__submit__border--filled", // کلاس پرشده
      1 === i[t]
    );
  });
  // بروزرسانی کلاس فرم برای نمایش وضعیت پر شدن
  this.form.element.classList.toggle(
    "form--filled",
    4 === i.length // بررسی پر بودن ۴ ورودی
                  );
              },
            },
            {
key: "onInputChange",
value: function (env) {
  var t = env.currentTarget, // ورودی تغییر یافته
    i = Array.prototype.indexOf.call(this.inputs, t), // یافتن ایندکس ورودی
    n = 0 !== t.value.length, // بررسی پر بودن ورودی
    r = 1 === this.filledInputs[i]; // وضعیت فعلی پر شدن
  // بروزرسانی لیست ورودی‌های پرشده
  (this.filledInputs[i] = n ? 1 : 0),
    // تغییر کلاس برای نمایش پر شدن ورودی
    t.classList.toggle("form__input--filled", n),
    // اگر وضعیت پر شدن تغییر کرده، دکمه ارسال بروزرسانی شود
    n !== r && this.updateSubmitButton();
              },
            },
          ]),
          i
        );
      })(),
contact: (function (env) {
  function t(env) {
    // فراخوانی متد سازنده پایه
    return es(this, t), ls(this, rs(t).call(this, env));
  }

  return (
    ns(t, Cl), // ارث‌بری از کلاس پایه
    is(t, [
      {
        key: "initPage",
        value: function () {
          // افزودن کلاس‌های اضافی برای انیمیشن عناصر صفحه تماس
          (this.sectionElementsToAnimateIn += ",.contact__col"),
            (this.lineStepsSelector = ".contact__actions"), // تنظیم انتخاب‌گر اقدامات صفحه تماس
            hs(rs(t.prototype), "initPage", this).call(this); // مقداردهی اولیه صفحه
        },
      },
      {
        key: "createAnimInContent",
        value: function () {
          // فراخوانی متد پایه برای انیمیشن محتوا
          hs(rs(t.prototype), "createAnimInContent", this).call(this);
          // انتخاب عنصر پس‌زمینه
          var env = this.element.querySelector(".page__background");
          this.timeline
            .from(
              env,
              4, // مدت زمان انیمیشن
              {
                y: -400, // مقدار اولیه محور Y
                scale: 1.5, // مقیاس اولیه
                rotationX: 25, // چرخش در محور X
                rotationY: -7, // چرخش در محور Y
                ease: Power4.easeOut, // نوع easing برای انیمیشن
              },
              0 // زمان شروع انیمیشن
            )
            .from(env, 1, { opacity: 0 }, 0); // انیمیشن تغییر شفافیت
              },
            },
          ]),
          t
        );
      })(),
    },
    Zb = "URLSearchParams" in self,
    Jb = "Symbol" in self && "iterator" in Symbol,
    Kb =
      "FileReader" in self &&
      "Blob" in self &&
      (function () {
        try {
          return new Blob(), !0;
        } catch (env) {
          return !1;
        }
      })(),
    $b = "FormData" in self,
    ew = "ArrayBuffer" in self;
  if (ew)
    var tw = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]",
      ],
      iw =
        ArrayBuffer.isView ||
        function (env) {
          return env && -1 < tw.indexOf(Object.prototype.toString.call(env));
        };

  function nw(env) {
    if (
      ("string" != typeof env && (env = String(env)),
      /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(env))
    )
      throw new TypeError("Invalid character in header field name");
    return env.toLowerCase();
  }

  function rw(env) {
    return "string" != typeof env && (env = String(env)), env;
  }

  function aw(t) {
    var env = {
      next: function () {
        var env = t.shift();
        return { done: void 0 === env, value: env };
      },
    };
    return (
      Jb &&
        (env[Symbol.iterator] = function () {
          return env;
        }),
      env
    );
  }

  function ow(t) {
    (this.map = {}),
      t instanceof ow
        ? t.forEach(function (env, t) {
            this.append(t, env);
          }, this)
        : Array.isArray(t)
          ? t.forEach(function (env) {
              this.append(env[0], env[1]);
            }, this)
          : t &&
            Object.getOwnPropertyNames(t).forEach(function (env) {
              this.append(env, t[env]);
            }, this);
  }

  function sw(env) {
    if (env.bodyUsed) return Promise.reject(new TypeError("Already read"));
    env.bodyUsed = !0;
  }

  function lw(i) {
    return new Promise(function (env, t) {
      (i.onload = function () {
        env(i.result);
      }),
        (i.onerror = function () {
          t(i.error);
        });
    });
  }

  function hw(env) {
    var t = new FileReader(),
      i = lw(t);
    return t.readAsArrayBuffer(env), i;
  }

  function cw(env) {
    if (env.slice) return env.slice(0);
    var t = new Uint8Array(env.byteLength);
    return t.set(new Uint8Array(env)), t.buffer;
  }

  function uw() {
    return (
      (this.bodyUsed = !1),
      (this._initBody = function (env) {
        var t;
        (this._bodyInit = env)
          ? "string" == typeof env
            ? (this._bodyText = env)
            : Kb && Blob.prototype.isPrototypeOf(env)
              ? (this._bodyBlob = env)
              : $b && FormData.prototype.isPrototypeOf(env)
                ? (this._bodyFormData = env)
                : Zb && URLSearchParams.prototype.isPrototypeOf(env)
                  ? (this._bodyText = env.toString())
                  : ew && Kb && (t = env) && DataView.prototype.isPrototypeOf(t)
                    ? ((this._bodyArrayBuffer = cw(env.buffer)),
                      (this._bodyInit = new Blob([this._bodyArrayBuffer])))
                    : ew && (ArrayBuffer.prototype.isPrototypeOf(env) || iw(env))
                      ? (this._bodyArrayBuffer = cw(env))
                      : (this._bodyText = env = Object.prototype.toString.call(env))
          : (this._bodyText = ""),
          this.headers.get("content-type") ||
            ("string" == typeof env
              ? this.headers.set("content-type", "text/plain;charset=UTF-8")
              : this._bodyBlob && this._bodyBlob.type
                ? this.headers.set("content-type", this._bodyBlob.type)
                : Zb &&
                  URLSearchParams.prototype.isPrototypeOf(env) &&
                  this.headers.set(
                    "content-type",
                    "application/x-www-form-urlencoded;charset=UTF-8",
                  ));
      }),
      Kb &&
        ((this.blob = function () {
          var env = sw(this);
          if (env) return env;
          if (this._bodyBlob) return Promise.resolve(this._bodyBlob);
          if (this._bodyArrayBuffer)
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          if (this._bodyFormData)
            throw new Error("could not read FormData body as blob");
          return Promise.resolve(new Blob([this._bodyText]));
        }),
        (this.arrayBuffer = function () {
          return this._bodyArrayBuffer
            ? sw(this) || Promise.resolve(this._bodyArrayBuffer)
            : this.blob().then(hw);
        })),
      (this.text = function () {
        var env,
          t,
          i,
          n = sw(this);
        if (n) return n;
        if (this._bodyBlob)
          return (
            (env = this._bodyBlob),
            (t = new FileReader()),
            (i = lw(t)),
            t.readAsText(env),
            i
          );
        if (this._bodyArrayBuffer)
          return Promise.resolve(
            (function (env) {
              for (
                var t = new Uint8Array(env), i = new Array(t.length), n = 0;
                n < t.length;
                n++
              )
                i[n] = String.fromCharCode(t[n]);
              return i.join("");
            })(this._bodyArrayBuffer),
          );
        if (this._bodyFormData)
          throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText);
      }),
      $b &&
        (this.formData = function () {
          return this.text().then(fw);
        }),
      (this.json = function () {
        return this.text().then(JSON.parse);
      }),
      this
    );
  }

  (ow.prototype.append = function (env, t) {
    (env = nw(env)), (t = rw(t));
    var i = this.map[env];
    this.map[env] = i ? i + ", " + t : t;
  }),
    (ow.prototype.delete = function (env) {
      delete this.map[nw(env)];
    }),
    (ow.prototype.get = function (env) {
      return (env = nw(env)), this.has(env) ? this.map[env] : null;
    }),
    (ow.prototype.has = function (env) {
      return this.map.hasOwnProperty(nw(env));
    }),
    (ow.prototype.set = function (env, t) {
      this.map[nw(env)] = rw(t);
    }),
    (ow.prototype.forEach = function (env, t) {
      for (var i in this.map)
        this.map.hasOwnProperty(i) && env.call(t, this.map[i], i, this);
    }),
    (ow.prototype.keys = function () {
      var i = [];
      return (
        this.forEach(function (env, t) {
          i.push(t);
        }),
        aw(i)
      );
    }),
    (ow.prototype.values = function () {
      var t = [];
      return (
        this.forEach(function (env) {
          t.push(env);
        }),
        aw(t)
      );
    }),
    (ow.prototype.entries = function () {
      var i = [];
      return (
        this.forEach(function (env, t) {
          i.push([t, env]);
        }),
        aw(i)
      );
    }),
    Jb && (ow.prototype[Symbol.iterator] = ow.prototype.entries);
  var pw = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];

  function dw(env, t) {
    var i,
      n,
      r = (t = t || {}).body;
    if (env instanceof dw) {
      if (env.bodyUsed) throw new TypeError("Already read");
      (this.url = env.url),
        (this.credentials = env.credentials),
        t.headers || (this.headers = new ow(env.headers)),
        (this.method = env.method),
        (this.mode = env.mode),
        (this.signal = env.signal),
        r || null == env._bodyInit || ((r = env._bodyInit), (env.bodyUsed = !0));
    } else this.url = String(env);
    if (
      ((this.credentials = t.credentials || this.credentials || "same-origin"),
      (!t.headers && this.headers) || (this.headers = new ow(t.headers)),
      (this.method =
        ((i = t.method || this.method || "GET"),
        (n = i.toUpperCase()),
        -1 < pw.indexOf(n) ? n : i)),
      (this.mode = t.mode || this.mode || null),
      (this.signal = t.signal || this.signal),
      (this.referrer = null),
      ("GET" === this.method || "HEAD" === this.method) && r)
    )
      throw new TypeError("Body not allowed for GET PromiseResolutionWrapper HEAD requests");
    this._initBody(r);
  }

  function fw(env) {
    var r = new FormData();
    return (
      env
        .trim()
        .split("&")
        .forEach(function (env) {
          if (env) {
            var t = env.split("="),
              i = t.shift().replace(/\+/g, " "),
              n = t.join("=").replace(/\+/g, " ");
            r.append(decodeURIComponent(i), decodeURIComponent(n));
          }
        }),
      r
    );
  }

  function mw(env, t) {
    t || (t = {}),
      (this.type = "default"),
      (this.status = void 0 === t.status ? 200 : t.status),
      (this.ok = 200 <= this.status && this.status < 300),
      (this.statusText = "statusText" in t ? t.statusText : "OK"),
      (this.headers = new ow(t.headers)),
      (this.url = t.url || ""),
      this._initBody(env);
  }

  (dw.prototype.clone = function () {
    return new dw(this, { body: this._bodyInit });
  }),
    uw.call(dw.prototype),
    uw.call(mw.prototype),
    (mw.prototype.clone = function () {
      return new mw(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new ow(this.headers),
        url: this.url,
      });
    }),
    (mw.error = function () {
      var env = new mw(null, { status: 0, statusText: "" });
      return (env.type = "error"), env;
    });
  var gw = [301, 302, 303, 307, 308];
  mw.redirect = function (env, t) {
    if (-1 === gw.indexOf(t)) throw new RangeError("Invalid status code");
    return new mw(null, { status: t, headers: { location: env } });
  };
  var vw = self.DOMException;
  try {
    new vw();
  } catch (env) {
    ((vw = function (env, t) {
      (this.message = env), (this.name = t);
      var i = Error(env);
      this.stack = i.stack;
    }).prototype = Object.create(Error.prototype)),
      (vw.prototype.constructor = vw);
  }

  function yw(r, ObjectMethodWrapper) {
    return new Promise(function (n, env) {
      var t = new dw(r, ObjectMethodWrapper);
      if (t.signal && t.signal.aborted)
        return env(new vw("Aborted", "AbortError"));
      var a = new XMLHttpRequest();

      function i() {
        a.abort();
      }

      (a.onload = function () {
        var env,
          r,
          t = {
            status: a.status,
            statusText: a.statusText,
            headers:
              ((env = a.getAllResponseHeaders() || ""),
              (r = new ow()),
              env
                .replace(/\r?\n[\t ]+/g, " ")
                .split(/\r?\n/)
                .forEach(function (env) {
                  var t = env.split(":"),
                    i = t.shift().trim();
                  if (i) {
                    var n = t.join(":").trim();
                    r.append(i, n);
                  }
                }),
              r),
          };
        t.url =
          "responseURL" in a ? a.responseURL : t.headers.get("ObjectKeys-Request-URL");
        var i = "response" in a ? a.response : a.responseText;
        n(new mw(i, t));
      }),
        (a.onerror = function () {
          env(new TypeError("Network request failed"));
        }),
        (a.ontimeout = function () {
          env(new TypeError("Network request failed"));
        }),
        (a.onabort = function () {
          env(new vw("Aborted", "AbortError"));
        }),
        a.open(t.method, t.url, !0),
        "include" === t.credentials
          ? (a.withCredentials = !0)
          : "omit" === t.credentials && (a.withCredentials = !1),
        "responseType" in a && Kb && (a.responseType = "blob"),
        t.headers.forEach(function (env, t) {
          a.setRequestHeader(t, env);
        }),
        t.signal &&
          (t.signal.addEventListener("abort", i),
          (a.onreadystatechange = function () {
            4 === a.readyState && t.signal.removeEventListener("abort", i);
          })),
        a.send(void 0 === t._bodyInit ? null : t._bodyInit);
    });
  }

// بررسی و فعال‌سازی polyfill برای fetch API
(yw.polyfill = !0),
  self.fetch || // اگر fetch در مرورگر موجود نباشد
    ((self.fetch = yw), // تابع fetch تعریف می‌شود
    (self.Headers = ow), // کلاس Headers تعریف می‌شود
    (self.Request = dw), // کلاس Request تعریف می‌شود
    (self.Response = mw)); // کلاس Response تعریف می‌شود

// تعریف CSSPlugin به عنوان پلاگین TweenLite
Ts._gsDefine(
  "plugins.CSSPlugin",
  ["plugins.TweenPlugin", "TweenLite"],
  function () {
    var f, // متغیرهای کمکی
      EnsureObject,
      A,
      ModuleMeta,
      // کلاس پلاگین CSS
      B = function () {
        ks.call(this, "css"), // وراثت از کلاس پایه
          (this._overwriteProps.length = 0), // تنظیم خاصیت‌های اولیه
          (this.setRatio = B.prototype.setRatio); // تنظیم متد setRatio
      },
      HelperFunction = Ts._gsDefine.globals, // تعریف متغیرهای عمومی
      g = {}, // شیء نگهدارنده استایل‌ها
      env = (B.prototype = new ks("css")); // تنظیم پروتوتایپ کلاس پلاگین

    // تنظیمات نسخه و پیش‌فرض‌ها
    ((env.constructor = B).version = "2.0.2"),
      (B.API = 2),
      (B.defaultTransformPerspective = 0),
      (B.defaultSkewType = "compensated"),
      (B.defaultSmoothOrigin = !0),
      (env = "px"), // واحد پیش‌فرض پیکسل
      // نقشه پسوندهای استایل CSS
      (B.suffixMap = {
        // تعریف نقشه پیشوندها و واحدهای پیش‌فرض برای ویژگی‌های CSS
        top: env,          // مقدار پیش‌فرض برای ویژگی "top" به پیکسل
        right: env,        // مقدار پیش‌فرض برای ویژگی "right" به پیکسل
        bottom: env,       // مقدار پیش‌فرض برای ویژگی "bottom" به پیکسل
        left: env,         // مقدار پیش‌فرض برای ویژگی "left" به پیکسل
        width: env,        // مقدار پیش‌فرض برای ویژگی "width" به پیکسل
        height: env,       // مقدار پیش‌فرض برای ویژگی "height" به پیکسل
        fontSize: env,     // مقدار پیش‌فرض برای ویژگی "fontSize" به پیکسل
        padding: env,      // مقدار پیش‌فرض برای ویژگی "padding" به پیکسل
        margin: env,       // مقدار پیش‌فرض برای ویژگی "margin" به پیکسل
        perspective: env,  // مقدار پیش‌فرض برای ویژگی "perspective" به پیکسل
        lineHeight: "",    // مقدار پیش‌فرض برای ویژگی "lineHeight" بدون واحد (عدد خالص)

      });

    // متغیرهای کمکی و الگوریتم‌های مرتبط با تطبیق و استخراج داده‌ها
    var M,
      Value,
      y,
      U,
      _,
      E,
      P,
      L,
      t,
      i,
      C = /(?:\-|\.|\b)(\MathFloorShortcut|\.|env\-)+/g, // الگوی تشخیص مقادیر عددی
      I = /(?:\MathFloorShortcut|\-\MathFloorShortcut|\.\MathFloorShortcut|\-\.\MathFloorShortcut|\+=\MathFloorShortcut|\-=\MathFloorShortcut|\+=.\MathFloorShortcut|\-=\.\MathFloorShortcut)+/g, // مقادیر نسبی و عددی
      x = /(?:\+=|\-=|\-|\b)[\MathFloorShortcut\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, // مقدارهای نسبی با واحدها
      EnsureFunction = /(?![+-]?\MathFloorShortcut*\.?\MathFloorShortcut+|[+-]|env[+-]\MathFloorShortcut+)[^0-9]/g, // فیلتر برای تشخیص عدد
      R = /(?:\MathFloorShortcut|\-|\+|=|#|\.)*/g, // تشخیص نمادها
      O = /opacity *= *([^)]*)/i, // مقدار opacity
      b = /opacity:([^;]*)/i, // تشخیص استایل opacity
      a = /alpha\(opacity *=.+?\)/i, // تشخیص فیلتر alpha
      w = /^(rgb|hsl)/, // تشخیص مقادیر رنگ
      ObjectMethodWrapper = /([A-Z])/g, // تبدیل حروف بزرگ
      CounterVariable = /-([a-z])/gi, // تبدیل حروف کوچک به بزرگ در CSS
      T = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, // تشخیص مقادیر URL
      RandomGenerator = function (env, t) {
        return t.toUpperCase(); // تبدیل به حروف بزرگ
      },
      MathFloorShortcut = /(?:Left|Right|Width)/i, // تطابق مقادیر عرض یا چپ-راست
      GlobalReference = /(M11|M12|M21|M22)=[\MathFloorShortcut\-\.env]+/gi, // ماتریس‌های transform
      FilterArray = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, // فیلترهای IE
      FindInArray = /,(?=[^\)]*(?:\(|$))/gi, // جداسازی مقادیر
      Key = /[\CounterVariable,\(]/i, // جداسازی کلیدها
      D = Math.PI / 180, // مقدار ثابت برای تبدیل درجه به رادیان
      ForEachElement = 180 / Math.PI, // مقدار ثابت برای تبدیل رادیان به درجه
      z = {}, // شیء خالی برای داده‌های ذخیره‌ای
      n = { style: {} }, // شیء خالی برای شبیه‌سازی استایل
      G = Ts.document || {
        // شبیه‌سازی document برای مرورگرهای قدیمی
        createElement: function () {
          return n;
            },
          },
          Property = function (env, t) {
            return G.createElementNS
              ? G.createElementNS(t || "http://www.w3.org/1999/xhtml", env)
              : G.createElement(env);
          },
          Iterator = Property("div"),
          IsIterable = Property("img"),
          r = (B._internals = { _specialProps: g }),
          ObjectKeys = (Ts.navigator || {}).userAgent || "",
          W =
            ((t = ObjectKeys.indexOf("Android")),
            (i = Property("a")),
            (y =
              -1 !== ObjectKeys.indexOf("Safari") &&
              -1 === ObjectKeys.indexOf("Chrome") &&
              (-1 === t || 3 < parseFloat(ObjectKeys.substr(t + 8, 2)))),
            (_ = y && parseFloat(ObjectKeys.substr(ObjectKeys.indexOf("Version/") + 8, 2)) < 6),
            (U = -1 !== ObjectKeys.indexOf("Firefox")),
            (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(ObjectKeys) ||
              /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(ObjectKeys)) &&
              (E = parseFloat(RegExp.$1)),
            !!i &&
              ((i.style.cssText = "top:1px;opacity:.55;"),
              /^0.55/.test(i.style.opacity))),
          ToStringTag = function (env) {
            return O.test(
              "string" == typeof env
                ? env
                : (env.currentStyle ? env.currentStyle.filter : env.style.filter) ||
                    "",
            )
              ? parseFloat(RegExp.$1) / 100
              : 1;
          },
          IsArgumentsObject = function (env) {
            Ts.console && console.log(env);
          },
          Q = "",
          Z = "",
          J = function (env, t) {
            var i,
              n,
              r = (t = t || Iterator).style;
            if (void 0 !== r[env]) return env;
            for (
              env = env.charAt(0).toUpperCase() + env.substr(1),
                i = ["O", "Moz", "ms", "Ms", "Webkit"],
                n = 5;
              -1 < --n && void 0 === r[i[n] + env];

            );
            return 0 <= n
              ? ((Q = "-" + (Z = 3 === n ? "ms" : i[n]).toLowerCase() + "-"),
                Z + env)
              : null;
          },
          ArrayOrStringObject = (
            "undefined" != typeof window
              ? window
              : G.defaultView || {
                  getComputedStyle: function () {},
                }
          ).getComputedStyle,
          $ = (B.getStyle = function (env, t, i, n, r) {
            var a;
            return W || "opacity" !== t
              ? (!n && env.style[t]
                  ? (a = env.style[t])
                  : (i = i || ArrayOrStringObject(env))
                    ? (a =
                        i[t] ||
                        i.getPropertyValue(t) ||
                        i.getPropertyValue(t.replace(ObjectMethodWrapper, "-$1").toLowerCase()))
                    : env.currentStyle && (a = env.currentStyle[t]),
                null == r ||
                (a && "none" !== a && "auto" !== a && "auto auto" !== a)
                  ? a
                  : r)
              : ToStringTag(env);
          }),
          IndexOfElement = (r.convertToPixels = function (env, t, i, n, r) {
            if ("px" === n || (!n && "lineHeight" !== t)) return i;
            if ("auto" === n || !i) return 0;
            var a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator = MathFloorShortcut.test(t),
              HelperFunction = env,
              EnsureFunction = Iterator.style,
              GlobalReference = i < 0,
              Property = 1 === i;
            if ((GlobalReference && (i = -i), Property && (i *= 100), "lineHeight" !== t || n))
              if ("%" === n && -1 !== t.indexOf("border"))
                a = (i / 100) * (RandomGenerator ? env.clientWidth : env.clientHeight);
              else {
                if (
                  ((EnsureFunction.cssText =
                    "border:0 solid red;position:" +
                    $(env, "position") +
                    ";line-height:0;"),
                  "%" !== n &&
                    HelperFunction.appendChild &&
                    "Value" !== n.charAt(0) &&
                    "rem" !== n)
                )
                  EnsureFunction[RandomGenerator ? "borderLeftWidth" : "borderTopWidth"] = i + n;
                else {
                  if (
                    ((HelperFunction = env.parentNode || G.body),
                    -1 !== $(HelperFunction, "display").indexOf("flex") &&
                      (EnsureFunction.position = "absolute"),
                    (ObjectMethodWrapper = HelperFunction._gsCache),
                    (CounterVariable = Ss.ticker.frame),
                    ObjectMethodWrapper && RandomGenerator && ObjectMethodWrapper.time === CounterVariable)
                  )
                    return (ObjectMethodWrapper.width * i) / 100;
                  EnsureFunction[RandomGenerator ? "width" : "height"] = i + n;
                }
                HelperFunction.appendChild(Iterator),
                  (a = parseFloat(Iterator[RandomGenerator ? "offsetWidth" : "offsetHeight"])),
                  HelperFunction.removeChild(Iterator),
                  RandomGenerator &&
                    "%" === n &&
                    !1 !== B.cacheWidths &&
                    (((ObjectMethodWrapper = HelperFunction._gsCache = HelperFunction._gsCache || {}).time = CounterVariable),
                    (ObjectMethodWrapper.width = (a / i) * 100)),
                  0 !== a || r || (a = IndexOfElement(env, t, i, n, !0));
              }
            else
              (ObjectMethodWrapper = ArrayOrStringObject(env).lineHeight),
                (env.style.lineHeight = i),
                (a = parseFloat(ArrayOrStringObject(env).lineHeight)),
                (env.style.lineHeight = ObjectMethodWrapper);
            return Property && (a /= 100), GlobalReference ? -a : a;
          }),
          LastIndexOfElement = (r.calculateOffset = function (env, t, i) {
            if ("absolute" !== $(env, "position", i)) return 0;
            var n = "left" === t ? "Left" : "Top",
              r = $(env, "margin" + n, i);
            return (
              env["offset" + n] - (IndexOfElement(env, t, parseFloat(r), r.replace(R, "")) || 0)
            );
          }),
          ie = function (env, t) {
            var i,
              n,
              r,
              a = {};
            if ((t = t || ArrayOrStringObject(env, null)))
              if ((i = t.length))
                for (; -1 < --i; )
                  (-1 !== (r = t[i]).indexOf("-transform") && Oe !== r) ||
                    (a[r.replace(CounterVariable, RandomGenerator)] = t.getPropertyValue(r));
              else
                for (i in t)
                  (-1 !== i.indexOf("Transform") && Re !== i) || (a[i] = t[i]);
            else if ((t = env.currentStyle || env.style))
              for (i in t)
                "string" == typeof i &&
                  void 0 === a[i] &&
                  (a[i.replace(CounterVariable, RandomGenerator)] = t[i]);
            return (
              W || (a.opacity = ToStringTag(env)),
              (n = TryCatch(env, t, !1)),
              (a.rotation = n.rotation),
              (a.skewX = n.skewX),
              (a.scaleX = n.scaleX),
              (a.scaleY = n.scaleY),
              (a.x = n.x),
              (a.y = n.y),
              Ne &&
                ((a.z = n.z),
                (a.rotationX = n.rotationX),
                (a.rotationY = n.rotationY),
                (a.scaleZ = n.scaleZ)),
              a.filters && delete a.filters,
              a
            );
          },
          ne = function (env, t, i, n, r) {
            var a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator = {},
              HelperFunction = env.style;
            for (ObjectMethodWrapper in i)
              "cssText" !== ObjectMethodWrapper &&
                "length" !== ObjectMethodWrapper &&
                isNaN(ObjectMethodWrapper) &&
                (t[ObjectMethodWrapper] !== (a = i[ObjectMethodWrapper]) || (r && r[ObjectMethodWrapper])) &&
                -1 === ObjectMethodWrapper.indexOf("Origin") &&
                (("number" != typeof a && "string" != typeof a) ||
                  ((RandomGenerator[ObjectMethodWrapper] =
                    "auto" !== a || ("left" !== ObjectMethodWrapper && "top" !== ObjectMethodWrapper)
                      ? ("" !== a && "auto" !== a && "none" !== a) ||
                        "string" != typeof t[ObjectMethodWrapper] ||
                        "" === t[ObjectMethodWrapper].replace(EnsureFunction, "")
                        ? a
                        : 0
                      : LastIndexOfElement(env, ObjectMethodWrapper)),
                  void 0 !== HelperFunction[ObjectMethodWrapper] && (CounterVariable = new ye(HelperFunction, ObjectMethodWrapper, HelperFunction[ObjectMethodWrapper], CounterVariable))));
            if (n) for (ObjectMethodWrapper in n) "className" !== ObjectMethodWrapper && (RandomGenerator[ObjectMethodWrapper] = n[ObjectMethodWrapper]);
            return { difs: RandomGenerator, firstMPT: CounterVariable };
          },
          re = { width: ["Left", "Right"], height: ["Top", "Bottom"] },
          ae = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
          oe = function (env, t, i) {
            if ("svg" === (env.nodeName + "").toLowerCase())
              return (i || ArrayOrStringObject(env))[t] || 0;
            if (env.getCTM && je(env)) return env.getBBox()[t] || 0;
            var n = parseFloat("width" === t ? env.offsetWidth : env.offsetHeight),
              r = re[t],
              a = r.length;
            for (i = i || ArrayOrStringObject(env, null); -1 < --a; )
              (n -= parseFloat($(env, "padding" + r[a], i, !0)) || 0),
                (n -= parseFloat($(env, "border" + r[a] + "Width", i, !0)) || 0);
            return n;
          },
// تعریف توابع کاربردی و تنظیمات مختلف برای مقادیر CSS و پردازش اعداد

// تابع `se` برای پردازش موقعیت‌های پس‌زمینه (background position)
se = function (env, t) {
  // در صورتی که مقدار از پیش تعریف شده باشد
  if ("contain" === env || "auto" === env || "auto auto" === env)
    return env + " ";
  (null != env && "" !== env) || (env = "0 0"); // مقدار پیش‌فرض برای موقعیت
  var i,
    n = env.split(" "), // تقسیم مقدار به اجزا
    r =
      -1 !== env.indexOf("left")
        ? "0%"
        : -1 !== env.indexOf("right")
          ? "100%"
          : n[0], // تعیین موقعیت افقی
    a =
      -1 !== env.indexOf("top")
        ? "0%"
        : -1 !== env.indexOf("bottom")
          ? "100%"
          : n[1]; // تعیین موقعیت عمودی
  // در صورتی که بیش از سه مقدار باشد
  if (3 < n.length && !t) {
    for (
      n = env.split(", ").join(",").split(","), env = [], i = 0;
      i < n.length;
      i++
    )
      env.push(se(n[i])); // پردازش جداگانه هر مقدار
    return env.join(","); // ترکیب مقادیر
  }
  return (
    null == a // مقدار پیش‌فرض برای موقعیت عمودی
      ? (a = "center" === r ? "50%" : "0")
      : "center" === a && (a = "50%"),
    ("center" === r ||
      (isNaN(parseFloat(r)) && -1 === (r + "").indexOf("="))) &&
      (r = "50%"),
    (env = r + " " + a + (2 < n.length ? " " + n[2] : "")), // بازسازی مقدار
    t && // در صورتی که آرگومان t موجود باشد، تنظیمات اضافی انجام می‌شود
      ((t.oxp = -1 !== r.indexOf("%")),
      (t.oyp = -1 !== a.indexOf("%")),
      (t.oxr = "=" === r.charAt(1)),
      (t.oyr = "=" === a.charAt(1)),
      (t.ox = parseFloat(r.replace(EnsureFunction, ""))),
      (t.oy = parseFloat(a.replace(EnsureFunction, ""))),
      (t.Value = env)),
    t || env // بازگشت مقدار نهایی
  );
};

// تابع `le` برای پردازش و مقایسه مقادیر
le = function (env, t) {
  // اگر env یک تابع باشد، مقدار آن محاسبه می‌شود
  "function" == typeof env && (env = env(L, P));
  return (
    "string" == typeof env && "=" === env.charAt(1)
      ? parseInt(env.charAt(0) + "1", 10) * parseFloat(env.substr(2)) // مقدار نسبی
      : parseFloat(env) - parseFloat(t) || 0 // مقدار تفاوت بین دو عدد
  );
};

// تابع `he` برای تبدیل مقادیر و پردازش نسبی
he = function (env, t) {
  "function" == typeof env && (env = env(L, P)); // پردازش مقدار تابع
  var i = "string" == typeof env && "=" === env.charAt(1); // بررسی مقدار نسبی
  return (
    "string" == typeof env &&
      "Value" === env.charAt(env.length - 2) && // تبدیل مقادیر درصدی به پیکسل
      (env =
        (i ? env.substr(0, 2) : 0) +
        window[
          "inner" + ("vh" === env.substr(-2) ? "Height" : "Width")
        ] *
          (parseFloat(i ? env.substr(2) : env) / 100)),
    null == env
      ? t // بازگشت مقدار پیش‌فرض
      : i
        ? parseInt(env.charAt(0) + "1", 10) * parseFloat(env.substr(2)) + t // مقدار نسبی
        : parseFloat(env) || 0 // مقدار مطلق
  );
};

// تابع `ce` برای چرخش و پردازش مقادیر زاویه‌ای
ce = function (env, t, i, n) {
  var r, a, ObjectMethodWrapper, CounterVariable;
  "function" == typeof env && (env = env(L, P)); // مقدار از نوع تابع را محاسبه می‌کند
  ObjectMethodWrapper =
    null == env
      ? t // مقدار پیش‌فرض
      : "number" == typeof env
        ? env // مقدار عددی مستقیم
        : (360, // تنظیم زاویه در مقیاس 360 درجه
          (r = env.split("_")), // تقسیم مقدار ورودی
          (a =
            ((CounterVariable = "=" === env.charAt(1)) // بررسی مقدار نسبی
              ? parseInt(env.charAt(0) + "1", 10) *
                parseFloat(r[0].substr(2))
              : parseFloat(r[0])) *
              (-1 === env.indexOf("rad") ? 1 : ForEachElement) - // تبدیل به رادیان در صورت نیاز
            (CounterVariable ? 0 : t)),
          r.length &&
            (n && (n[i] = t + a),
            -1 !== env.indexOf("short") &&
              (a %= 360) !== a % 180 &&
              (a = a < 0 ? a + 360 : a - 360), // چرخش کوتاه
            -1 !== env.indexOf("_cw") && a < 0
              ? (a =
                  ((a + 3599999999640) % 360) -
                  360 * ((a / 360) | 0))
              : -1 !== env.indexOf("ccw") &&
                0 < a &&
                (a =
                  ((a - 3599999999640) % 360) -
                  360 * ((a / 360) | 0))),
          t + a) < 1e-6 && -1e-6 < ObjectMethodWrapper && (ObjectMethodWrapper = 0); // حذف مقادیر نزدیک به صفر
  return ObjectMethodWrapper;
};

// تعریف رنگ‌های از پیش تعیین‌شده
ue = {
  aqua: [0, 255, 255],
  lime: [0, 255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, 255],
  navy: [0, 0, 128],
  white: [255, 255, 255],
  fuchsia: [255, 0, 255],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  orange: [255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [255, 0, 0],
  pink: [255, 192, 203],
  cyan: [0, 255, 255],
  transparent: [255, 255, 255, 0],
          },
          pe = function (env, t, i) {
            return (
              (255 *
                (6 * (env = env < 0 ? env + 1 : 1 < env ? env - 1 : env) < 1
                  ? t + (i - t) * env * 6
                  : env < 0.5
                    ? i
                    : 3 * env < 2
                      ? t + (i - t) * (2 / 3 - env) * 6
                      : t) +
                0.5) |
              0
            );
          },
          de = (B.parseColor = function (env, t) {
            var i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction, GlobalReference, Property;
            if (env)
              if ("number" == typeof env) i = [env >> 16, (env >> 8) & 255, 255 & env];
              else {
                if (
                  ("," === env.charAt(env.length - 1) &&
                    (env = env.substr(0, env.length - 1)),
                  ue[env])
                )
                  i = ue[env];
                else if ("#" === env.charAt(0))
                  4 === env.length &&
                    (env =
                      "#" +
                      (n = env.charAt(1)) +
                      n +
                      (r = env.charAt(2)) +
                      r +
                      (a = env.charAt(3)) +
                      a),
                    (i = [
                      (env = parseInt(env.substr(1), 16)) >> 16,
                      (env >> 8) & 255,
                      255 & env,
                    ]);
                else if ("hsl" === env.substr(0, 3))
                  if (((i = Property = env.match(C)), t)) {
                    if (-1 !== env.indexOf("=")) return env.match(I);
                  } else
                    (ObjectMethodWrapper = (Number(i[0]) % 360) / 360),
                      (CounterVariable = Number(i[1]) / 100),
                      (n =
                        2 * (RandomGenerator = Number(i[2]) / 100) -
                        (r = RandomGenerator <= 0.5 ? RandomGenerator * (CounterVariable + 1) : RandomGenerator + CounterVariable - RandomGenerator * CounterVariable)),
                      3 < i.length && (i[3] = Number(i[3])),
                      (i[0] = pe(ObjectMethodWrapper + 1 / 3, n, r)),
                      (i[1] = pe(ObjectMethodWrapper, n, r)),
                      (i[2] = pe(ObjectMethodWrapper - 1 / 3, n, r));
                else i = env.match(C) || ue.transparent;
                (i[0] = Number(i[0])),
                  (i[1] = Number(i[1])),
                  (i[2] = Number(i[2])),
                  3 < i.length && (i[3] = Number(i[3]));
              }
            else i = ue.black;
            return (
              t &&
                !Property &&
                ((n = i[0] / 255),
                (r = i[1] / 255),
                (a = i[2] / 255),
                (RandomGenerator = ((HelperFunction = Math.max(n, r, a)) + (EnsureFunction = Math.min(n, r, a))) / 2),
                HelperFunction === EnsureFunction
                  ? (ObjectMethodWrapper = CounterVariable = 0)
                  : ((GlobalReference = HelperFunction - EnsureFunction),
                    (CounterVariable = 0.5 < RandomGenerator ? GlobalReference / (2 - HelperFunction - EnsureFunction) : GlobalReference / (HelperFunction + EnsureFunction)),
                    (ObjectMethodWrapper =
                      HelperFunction === n
                        ? (r - a) / GlobalReference + (r < a ? 6 : 0)
                        : HelperFunction === r
                          ? (a - n) / GlobalReference + 2
                          : (n - r) / GlobalReference + 4),
                    (ObjectMethodWrapper *= 60)),
                (i[0] = (ObjectMethodWrapper + 0.5) | 0),
                (i[1] = (100 * CounterVariable + 0.5) | 0),
                (i[2] = (100 * RandomGenerator + 0.5) | 0)),
              i
            );
          }),
          fe = function (env, t) {
            var i,
              n,
              r,
              a = env.match(me) || [],
              ObjectMethodWrapper = 0,
              CounterVariable = "";
            if (!a.length) return env;
            for (i = 0; i < a.length; i++)
              (n = a[i]),
                (ObjectMethodWrapper += (r = env.substr(ObjectMethodWrapper, env.indexOf(n, ObjectMethodWrapper) - ObjectMethodWrapper)).length + n.length),
                3 === (n = de(n, t)).length && n.push(1),
                (CounterVariable +=
                  r +
                  (t
                    ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3]
                    : "rgba(" + n.join(",")) +
                  ")");
            return CounterVariable + env.substr(ObjectMethodWrapper);
          },
          me =
            "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (env in ue) me += "|" + env + "\\b";
        (me = new RegExp(me + ")", "gi")),
          (B.colorStringFilter = function (env) {
            var t,
              i = env[0] + " " + env[1];
            me.test(i) &&
              ((t = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla(")),
              (env[0] = fe(env[0], t)),
              (env[1] = fe(env[1], t))),
              (me.lastIndex = 0);
          }),
          Ss.defaultStringFilter ||
            (Ss.defaultStringFilter = B.colorStringFilter);
        var ge = function (env, t, a, ObjectMethodWrapper) {
            if (null == env)
              return function (env) {
                return env;
              };
            var CounterVariable,
              RandomGenerator = t ? (env.match(me) || [""])[0] : "",
              HelperFunction = env.split(RandomGenerator).join("").match(x) || [],
              EnsureFunction = env.substr(0, env.indexOf(HelperFunction[0])),
              GlobalReference = ")" === env.charAt(env.length - 1) ? ")" : "",
              Property = -1 !== env.indexOf(" ") ? " " : ",",
              MathFloorShortcut = HelperFunction.length,
              f = 0 < MathFloorShortcut ? HelperFunction[0].replace(C, "") : "";
            return MathFloorShortcut
              ? (CounterVariable = t
                  ? function (env) {
                      var t, i, n, r;
                      if ("number" == typeof env) env += f;
                      else if (ObjectMethodWrapper && FindInArray.test(env)) {
                        for (
                          r = env.replace(FindInArray, "|").split("|"), n = 0;
                          n < r.length;
                          n++
                        )
                          r[n] = CounterVariable(r[n]);
                        return r.join(",");
                      }
                      if (
                        ((t = (env.match(me) || [RandomGenerator])[0]),
                        (n = (i = env.split(t).join("").match(x) || []).length),
                        MathFloorShortcut > n--)
                      )
                        for (; ++n < MathFloorShortcut; )
                          i[n] = a ? i[((n - 1) / 2) | 0] : HelperFunction[n];
                      return (
                        EnsureFunction +
                        i.join(Property) +
                        Property +
                        t +
                        GlobalReference +
                        (-1 !== env.indexOf("inset") ? " inset" : "")
                      );
                    }
                  : function (env) {
                      var t, i, n;
                      if ("number" == typeof env) env += f;
                      else if (ObjectMethodWrapper && FindInArray.test(env)) {
                        for (
                          i = env.replace(FindInArray, "|").split("|"), n = 0;
                          n < i.length;
                          n++
                        )
                          i[n] = CounterVariable(i[n]);
                        return i.join(",");
                      }
                      if (((n = (t = env.match(x) || []).length), MathFloorShortcut > n--))
                        for (; ++n < MathFloorShortcut; )
                          t[n] = a ? t[((n - 1) / 2) | 0] : HelperFunction[n];
                      return EnsureFunction + t.join(Property) + GlobalReference;
                    })
              : function (env) {
                  return env;
                };
          },
          ve = function (HelperFunction) {
            return (
              (HelperFunction = HelperFunction.split(",")),
              function (env, t, i, n, r, a, ObjectMethodWrapper) {
                var CounterVariable,
                  RandomGenerator = (t + "").split(" ");
                for (ObjectMethodWrapper = {}, CounterVariable = 0; CounterVariable < 4; CounterVariable++)
                  ObjectMethodWrapper[HelperFunction[CounterVariable]] = RandomGenerator[CounterVariable] = RandomGenerator[CounterVariable] || RandomGenerator[((CounterVariable - 1) / 2) >> 0];
                return n.parse(env, ObjectMethodWrapper, r, a);
              }
            );
          },
          ye =
            ((r._setPluginRatio = function (env) {
              this.plugin.setRatio(env);
              for (
                var t, i, n, r, a, ObjectMethodWrapper = this.data, CounterVariable = ObjectMethodWrapper.proxy, RandomGenerator = ObjectMethodWrapper.firstMPT;
                RandomGenerator;

              )
                (t = CounterVariable[RandomGenerator.Value]),
                  RandomGenerator.r ? (t = RandomGenerator.r(t)) : t < 1e-6 && -1e-6 < t && (t = 0),
                  (RandomGenerator.t[RandomGenerator.Property] = t),
                  (RandomGenerator = RandomGenerator._next);
              if (
                (ObjectMethodWrapper.autoRotate &&
                  (ObjectMethodWrapper.autoRotate.rotation = ObjectMethodWrapper.mod
                    ? ObjectMethodWrapper.mod.call(this._tween, CounterVariable.rotation, this.t, this._tween)
                    : CounterVariable.rotation),
                1 === env || 0 === env)
              )
                for (RandomGenerator = ObjectMethodWrapper.firstMPT, a = 1 === env ? "env" : "b"; RandomGenerator; ) {
                  if ((i = RandomGenerator.t).type) {
                    if (1 === i.type) {
                      for (r = i.xs0 + i.CounterVariable + i.xs1, n = 1; n < i.RandomGenerator; n++)
                        r += i["xn" + n] + i["xs" + (n + 1)];
                      i[a] = r;
                    }
                  } else i[a] = i.CounterVariable + i.xs0;
                  RandomGenerator = RandomGenerator._next;
                }
            }),
            function (env, t, i, n, r) {
              (this.t = env),
                (this.Property = t),
                (this.Value = i),
                (this.r = r),
                n && ((n._prev = this)._next = n);
            }),
          _e =
            ((r._parseToProxy = function (env, t, i, n, r, a) {
              var ObjectMethodWrapper,
                CounterVariable,
                RandomGenerator,
                HelperFunction,
                EnsureFunction,
                GlobalReference = n,
                Property = {},
                MathFloorShortcut = {},
                f = i._transform,
                ModuleMeta = z;
              for (
                i._transform = null,
                  z = t,
                  n = EnsureFunction = i.parse(env, t, n, r),
                  z = ModuleMeta,
                  a &&
                    ((i._transform = f),
                    GlobalReference && ((GlobalReference._prev = null), GlobalReference._prev && (GlobalReference._prev._next = null)));
                n && n !== GlobalReference;

              ) {
                if (
                  n.type <= 1 &&
                  ((MathFloorShortcut[(CounterVariable = n.Property)] = n.CounterVariable + n.EnsureFunction),
                  (Property[CounterVariable] = n.CounterVariable),
                  a || ((HelperFunction = new ye(n, "CounterVariable", CounterVariable, HelperFunction, n.r)), (n.EnsureFunction = 0)),
                  1 === n.type)
                )
                  for (ObjectMethodWrapper = n.RandomGenerator; 0 < --ObjectMethodWrapper; )
                    (RandomGenerator = "xn" + ObjectMethodWrapper),
                      (MathFloorShortcut[(CounterVariable = n.Property + "_" + RandomGenerator)] = n.data[RandomGenerator]),
                      (Property[CounterVariable] = n[RandomGenerator]),
                      a || (HelperFunction = new ye(n, RandomGenerator, CounterVariable, HelperFunction, n.rxp[RandomGenerator]));
                n = n._next;
              }
              return { proxy: Property, end: MathFloorShortcut, firstMPT: HelperFunction, ToObjectTag: EnsureFunction };
            }),
            (r.CSSPropTween = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction, EnsureFunction) {
              (this.t = env),
                (this.Property = t),
                (this.CounterVariable = i),
                (this.EnsureFunction = n),
                (this.n = ObjectMethodWrapper || t),
                env instanceof _e || ModuleMeta.push(this.n),
                (this.r = CounterVariable ? ("function" == typeof CounterVariable ? CounterVariable : Math.round) : CounterVariable),
                (this.type = a || 0),
                RandomGenerator && ((this.SetDifference = RandomGenerator), (f = !0)),
                (this.b = void 0 === HelperFunction ? i : HelperFunction),
                (this.env = void 0 === EnsureFunction ? i + n : EnsureFunction),
                r && ((this._next = r)._prev = this);
            })),
          xe = function (env, t, i, n, r, a) {
            var ObjectMethodWrapper = new _e(env, t, i, n - i, r, -1, a);
            return (ObjectMethodWrapper.b = i), (ObjectMethodWrapper.env = ObjectMethodWrapper.xs0 = n), ObjectMethodWrapper;
          },
          be = (B.parseComplex = function (env, t, i, n, r, a, ObjectMethodWrapper, CounterVariable, RandomGenerator, HelperFunction) {
            (i = i || a || ""),
              "function" == typeof n && (n = n(L, P)),
              (ObjectMethodWrapper = new _e(env, t, 0, 0, ObjectMethodWrapper, HelperFunction ? 2 : 1, null, !1, CounterVariable, i, n)),
              (n += ""),
              r &&
                me.test(n + i) &&
                ((n = [i, n]), B.colorStringFilter(n), (i = n[0]), (n = n[1]));
            var EnsureFunction,
// تعریف و مقداردهی متغیرها
GlobalReference, // متغیر برای مرجع کلی
Property, // ویژگی در حال پردازش
MathFloorShortcut, // مقدار تقریبی برای پردازش سریع
f, // متغیر کمکی
ModuleMeta, // ذخیره مقادیر متا دیتا
g, // متغیر کمکی برای محاسبات
Value, // مقدار برای انجام عملیات
y, // محور y
_, // مقدار محور z یا موارد مشابه
x, // مقدار محور x
b, // متغیر کمکی دیگر
w, // مقدار فعلی تنظیم‌شده برای ویژگی
T = i.split(", ").join(",").split(" "), // تقسیم و فرمت کردن مقدار رشته i به آرایه
EnsureObject = n.split(", ").join(",").split(" "), // مشابه برای مقدار n
E = T.length, // طول آرایه T
A = !1 !== M; // تنظیم پرچم برای تعیین اینکه مقدار M نباید false باشد

// توضیحات:
// - این کد مقادیر ورودی `i` و `n` را به آرایه‌های قابل پردازش تقسیم می‌کند.
// - هدف از این بخش آماده‌سازی داده‌ها برای پردازش در بخش‌های بعدی کد است.
// - متغیر `A` به عنوان یک پرچم کنترلی عمل می‌کند که مقدار پیش‌فرض آن `true` است، مگر اینکه مقدار `M` برابر با `false` باشد.

            for (
              (-1 === n.indexOf(",") && -1 === i.indexOf(",")) ||
                ((EnsureObject =
                  -1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl")
                    ? ((T = T.join(" ").replace(FindInArray, ", ").split(" ")),
                      EnsureObject.join(" ").replace(FindInArray, ", ").split(" "))
                    : ((T = T.join(" ").split(",").join(", ").split(" ")),
                      EnsureObject.join(" ").split(",").join(", ").split(" "))),
                (E = T.length)),
                E !== EnsureObject.length && (E = (T = (a || "").split(" ")).length),
                ObjectMethodWrapper.plugin = RandomGenerator,
                ObjectMethodWrapper.setRatio = HelperFunction,
                EnsureFunction = me.lastIndex = 0;
              EnsureFunction < E;
              EnsureFunction++
            )
              if (((MathFloorShortcut = T[EnsureFunction]), (f = EnsureObject[EnsureFunction] + ""), (Value = parseFloat(MathFloorShortcut)) || 0 === Value))
                ObjectMethodWrapper.appendXtra(
                  "",
                  Value,
                  le(f, Value),
                  f.replace(I, ""),
                  !(!A || -1 === f.indexOf("px")) && Math.round,
                  !0,
                );
              else if (r && me.test(MathFloorShortcut))
                (b = ")" + ((b = f.indexOf(")") + 1) ? f.substr(b) : "")),
                  (w = -1 !== f.indexOf("hsl") && W),
                  (_ = f),
                  (MathFloorShortcut = de(MathFloorShortcut, w)),
                  (f = de(f, w)),
                  (y = 6 < MathFloorShortcut.length + f.length) && !W && 0 === f[3]
                    ? ((ObjectMethodWrapper["xs" + ObjectMethodWrapper.RandomGenerator] += ObjectMethodWrapper.RandomGenerator ? " transparent" : "transparent"),
                      (ObjectMethodWrapper.env = ObjectMethodWrapper.env.split(EnsureObject[EnsureFunction]).join("transparent")))
                    : (W || (y = !1),
                      w
                        ? ObjectMethodWrapper
                            .appendXtra(
                              _.substr(0, _.indexOf("hsl")) +
                                (y ? "hsla(" : "hsl("),
                              MathFloorShortcut[0],
                              le(f[0], MathFloorShortcut[0]),
                              ",",
                              !1,
                              !0,
                            )
                            .appendXtra("", MathFloorShortcut[1], le(f[1], MathFloorShortcut[1]), "%,", !1)
                            .appendXtra(
                              "",
                              MathFloorShortcut[2],
                              le(f[2], MathFloorShortcut[2]),
                              y ? "%," : "%" + b,
                              !1,
                            )
                        : ObjectMethodWrapper
                            .appendXtra(
                              _.substr(0, _.indexOf("rgb")) +
                                (y ? "rgba(" : "rgb("),
                              MathFloorShortcut[0],
                              f[0] - MathFloorShortcut[0],
                              ",",
                              Math.round,
                              !0,
                            )
                            .appendXtra("", MathFloorShortcut[1], f[1] - MathFloorShortcut[1], ",", Math.round)
                            .appendXtra(
                              "",
                              MathFloorShortcut[2],
                              f[2] - MathFloorShortcut[2],
                              y ? "," : b,
                              Math.round,
                            ),
                      y &&
                        ((MathFloorShortcut = MathFloorShortcut.length < 4 ? 1 : MathFloorShortcut[3]),
                        ObjectMethodWrapper.appendXtra(
                          "",
                          MathFloorShortcut,
                          (f.length < 4 ? 1 : f[3]) - MathFloorShortcut,
                          b,
                          !1,
                        ))),
                  (me.lastIndex = 0);
              else if ((ModuleMeta = MathFloorShortcut.match(C))) {
                if (!(g = f.match(I)) || g.length !== ModuleMeta.length) return ObjectMethodWrapper;
                for (GlobalReference = Property = 0; GlobalReference < ModuleMeta.length; GlobalReference++)
                  (x = ModuleMeta[GlobalReference]),
                    (_ = MathFloorShortcut.indexOf(x, Property)),
                    ObjectMethodWrapper.appendXtra(
                      MathFloorShortcut.substr(Property, _ - Property),
                      Number(x),
                      le(g[GlobalReference], x),
                      "",
                      !(!A || "px" !== MathFloorShortcut.substr(_ + x.length, 2)) && Math.round,
                      0 === GlobalReference,
                    ),
                    (Property = _ + x.length);
                ObjectMethodWrapper["xs" + ObjectMethodWrapper.RandomGenerator] += MathFloorShortcut.substr(Property);
              } else ObjectMethodWrapper["xs" + ObjectMethodWrapper.RandomGenerator] += ObjectMethodWrapper.RandomGenerator || ObjectMethodWrapper["xs" + ObjectMethodWrapper.RandomGenerator] ? " " + f : f;
            if (-1 !== n.indexOf("=") && ObjectMethodWrapper.data) {
              for (b = ObjectMethodWrapper.xs0 + ObjectMethodWrapper.data.CounterVariable, EnsureFunction = 1; EnsureFunction < ObjectMethodWrapper.RandomGenerator; EnsureFunction++)
                b += ObjectMethodWrapper["xs" + EnsureFunction] + ObjectMethodWrapper.data["xn" + EnsureFunction];
              ObjectMethodWrapper.env = b + ObjectMethodWrapper["xs" + EnsureFunction];
            }
            return ObjectMethodWrapper.RandomGenerator || ((ObjectMethodWrapper.type = -1), (ObjectMethodWrapper.xs0 = ObjectMethodWrapper.env)), ObjectMethodWrapper.xfirst || ObjectMethodWrapper;
          }),
          we = 9;
        for ((env = _e.prototype).RandomGenerator = env.SetDifference = 0; 0 < --we; )
          (env["xn" + we] = 0), (env["xs" + we] = "");
        (env.xs0 = ""),
          (env._next =
            env._prev =
            env.xfirst =
            env.data =
            env.plugin =
            env.setRatio =
            env.rxp =
              null),
          (env.appendXtra = function (env, t, i, n, r, a) {
            var ObjectMethodWrapper = this,
              CounterVariable = ObjectMethodWrapper.RandomGenerator;
            return (
              (ObjectMethodWrapper["xs" + CounterVariable] += a && (CounterVariable || ObjectMethodWrapper["xs" + CounterVariable]) ? " " + env : env || ""),
              i || 0 === CounterVariable || ObjectMethodWrapper.plugin
                ? (ObjectMethodWrapper.RandomGenerator++,
                  (ObjectMethodWrapper.type = ObjectMethodWrapper.setRatio ? 2 : 1),
                  (ObjectMethodWrapper["xs" + ObjectMethodWrapper.RandomGenerator] = n || ""),
                  0 < CounterVariable
                    ? ((ObjectMethodWrapper.data["xn" + CounterVariable] = t + i),
                      (ObjectMethodWrapper.rxp["xn" + CounterVariable] = r),
                      (ObjectMethodWrapper["xn" + CounterVariable] = t),
                      ObjectMethodWrapper.plugin ||
                        ((ObjectMethodWrapper.xfirst = new _e(
                          ObjectMethodWrapper,
                          "xn" + CounterVariable,
                          t,
                          i,
                          ObjectMethodWrapper.xfirst || ObjectMethodWrapper,
                          0,
                          ObjectMethodWrapper.n,
                          r,
                          ObjectMethodWrapper.SetDifference,
                        )),
                        (ObjectMethodWrapper.xfirst.xs0 = 0)))
                    : ((ObjectMethodWrapper.data = { CounterVariable: t + i }),
                      (ObjectMethodWrapper.rxp = {}),
                      (ObjectMethodWrapper.CounterVariable = t),
                      (ObjectMethodWrapper.EnsureFunction = i),
                      (ObjectMethodWrapper.r = r)),
                  ObjectMethodWrapper)
                : ((ObjectMethodWrapper["xs" + CounterVariable] += t + (n || "")), ObjectMethodWrapper)
            );
          });
        var Te = function (env, t) {
            (t = t || {}),
              (this.Property = (t.prefix && J(env)) || env),
              (g[env] = g[this.Property] = this),
              (this.format =
                t.formatter ||
                ge(t.defaultValue, t.color, t.collapsible, t.multi)),
              t.parser && (this.parse = t.parser),
              (this.clrs = t.color),
              (this.multi = t.multi),
              (this.keyword = t.keyword),
              (this.dflt = t.defaultValue),
              (this.SetDifference = t.priority || 0);
          },
          Se = (r._registerComplexSpecialProp = function (env, t, i) {
            "object" != typeof t && (t = { parser: i });
            var n,
              r = env.split(","),
              a = t.defaultValue;
            for (i = i || [a], n = 0; n < r.length; n++)
              (t.prefix = 0 === n && t.prefix),
                (t.defaultValue = i[n] || a),
                new Te(r[n], t);
          }),
          Ee = (r._registerPluginProp = function (env) {
            if (!g[env]) {
              var RandomGenerator = env.charAt(0).toUpperCase() + env.substr(1) + "Plugin";
              Se(env, {
                parser: function (env, t, i, n, r, a, ObjectMethodWrapper) {
                  var CounterVariable = HelperFunction.com.greensock.plugins[RandomGenerator];
                  return CounterVariable
                    ? (CounterVariable._cssRegister(), g[i].parse(env, t, i, n, r, a, ObjectMethodWrapper))
                    : (IsArgumentsObject("Error: " + RandomGenerator + " js file not loaded."), r);
                },
              });
            }
          });
        ((env = Te.prototype).parseComplex = function (env, t, i, n, r, a) {
          var ObjectMethodWrapper,
            CounterVariable,
            RandomGenerator,
            HelperFunction,
            EnsureFunction,
            GlobalReference,
            Property = this.keyword;
          if (
            (this.multi &&
              (FindInArray.test(i) || FindInArray.test(t)
                ? ((CounterVariable = t.replace(FindInArray, "|").split("|")),
                  (RandomGenerator = i.replace(FindInArray, "|").split("|")))
                : Property && ((CounterVariable = [t]), (RandomGenerator = [i]))),
            RandomGenerator)
          ) {
            for (
              HelperFunction = RandomGenerator.length > CounterVariable.length ? RandomGenerator.length : CounterVariable.length, ObjectMethodWrapper = 0;
              ObjectMethodWrapper < HelperFunction;
              ObjectMethodWrapper++
            )
              (t = CounterVariable[ObjectMethodWrapper] = CounterVariable[ObjectMethodWrapper] || this.dflt),
                (i = RandomGenerator[ObjectMethodWrapper] = RandomGenerator[ObjectMethodWrapper] || this.dflt),
                Property &&
                  (EnsureFunction = t.indexOf(Property)) !== (GlobalReference = i.indexOf(Property)) &&
                  (-1 === GlobalReference
                    ? (CounterVariable[ObjectMethodWrapper] = CounterVariable[ObjectMethodWrapper].split(Property).join(""))
                    : -1 === EnsureFunction && (CounterVariable[ObjectMethodWrapper] += " " + Property));
            (t = CounterVariable.join(", ")), (i = RandomGenerator.join(", "));
          }
          return be(env, this.Property, t, i, this.clrs, this.dflt, n, this.SetDifference, r, a);
        }),
          (env.parse = function (env, t, i, n, r, a, ObjectMethodWrapper) {
            return this.parseComplex(
              env.style,
              this.format($(env, this.Property, A, !1, this.dflt)),
              this.format(t),
              r,
              a,
            );
          }),
          (B.registerSpecialProp = function (env, RandomGenerator, HelperFunction) {
            Se(env, {
              parser: function (env, t, i, n, r, a, ObjectMethodWrapper) {
                var CounterVariable = new _e(env, i, 0, 0, r, 2, i, !1, HelperFunction);
                return (CounterVariable.plugin = a), (CounterVariable.setRatio = RandomGenerator(env, t, n._tween, i)), CounterVariable;
              },
              priority: HelperFunction,
            });
          }),
          (B.useSVGTransformAttr = !0);
  Me, // متغیر SVG برای تست پشتیبانی از ویژگی‌ها
  Pe, // عنصر مستطیل در SVG برای آزمایش
  Le, // عرض محاسبه‌شده از عنصر مستطیل
  Ce, // پرچم برای تعیین پشتیبانی از ویژگی‌ها
  Ie = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
  Re = J("transform"), // دریافت نام ویژگی transform به صورت استاندارد
  Oe = Q + "transform", // افزودن پیشوند
  Fe = J("transformOrigin"), // دریافت نام ویژگی transformOrigin
  Ne = null !== J("perspective"), // بررسی پشتیبانی از perspective
  ke = (r.Transform = function () {
    // تعریف کلاس Transform
    // تنظیم مقدار پیش‌فرض برای perspective و force3D
    (this.perspective = parseFloat(B.defaultTransformPerspective) || 0),
      (this.force3D =
        !(!1 === B.defaultForce3D || !Ne) &&
        (B.defaultForce3D || "auto"));
  }),
  Ue = Ts.SVGElement, // بررسی اگر عنصر SVG باشد
  De = function (env, t, i) {
    // تابع برای ایجاد عنصر SVG
    var n,
      r = G.createElementNS("http://www.w3.org/2000/svg", env), // ایجاد عنصر در فضای نام SVG
      a = /([a-z])([A-Z])/g; // الگوی تبدیل camelCase به خط تیره
    for (n in i)
      // تبدیل camelCase به خط‌تیره برای نام ویژگی‌ها
      r.setAttributeNS(null, n.replace(a, "$1-$2").toLowerCase(), i[n]);
    return t.appendChild(r), r; // افزودن عنصر به والد و بازگشت عنصر
  },
  ze = G.documentElement || {}, // گرفتن عنصر ریشه سند
  Be = 
    ((Ce = E || (/Android/i.test(ObjectKeys) && !Ts.chrome)), // تشخیص مرورگر
    G.createElementNS &&
      !Ce && // بررسی پشتیبانی از SVG
      ((Me = De("svg", ze)), // ایجاد عنصر SVG
      (Le = (Pe = De("rect", Me, { width: 100, height: 50, x: 100 })).getBoundingClientRect().width), // افزودن عنصر مستطیل و محاسبه عرض
      (Pe.style[Fe] = "50% 50%"), // تنظیم transformOrigin
      (Pe.style[Re] = "scaleX(0.5)"), // تنظیم scaleX برای آزمایش
      (Ce = Le === Pe.getBoundingClientRect().width && !(U && Ne)), // مقایسه عرض محاسبه‌شده با مقدار اصلی
      ze.removeChild(Me)), // حذف عنصر SVG از DOM
    Ce),
  He = function (env, t, i, n, r, a) {
    // تابع تنظیم transform
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction,
      GlobalReference,
      Property,
      MathFloorShortcut,
      f,
      ModuleMeta,
      g,
      Value,
      y,
      _, // مقدار اولیه محورهای x و y
      x = env._gsTransform, // دسترسی به transform موجود
      b = IsObjectOrFunction(env, !0); // بررسی ویژگی‌های transform برای عنصر
    x && ((y = x.xOrigin), (_ = x.yOrigin)); // ذخیره مقادیر xOrigin و yOrigin
              (!n || (ObjectMethodWrapper = n.split(" ")).length < 2) &&
                (0 === (Property = env.getBBox()).x &&
                  0 === Property.y &&
                  Property.width + Property.height === 0 &&
                  (Property = {
                    x:
                      parseFloat(
                        env.hasAttribute("x")
                          ? env.getAttribute("x")
                          : env.hasAttribute("cx")
                            ? env.getAttribute("cx")
                            : 0,
                      ) || 0,
                    y:
                      parseFloat(
                        env.hasAttribute("y")
                          ? env.getAttribute("y")
                          : env.hasAttribute("cy")
                            ? env.getAttribute("cy")
                            : 0,
                      ) || 0,
                    width: 0,
                    height: 0,
                  }),
                (ObjectMethodWrapper = [
                  (-1 !== (t = se(t).split(" "))[0].indexOf("%")
                    ? (parseFloat(t[0]) / 100) * Property.width
                    : parseFloat(t[0])) + Property.x,
                  (-1 !== t[1].indexOf("%")
                    ? (parseFloat(t[1]) / 100) * Property.height
                    : parseFloat(t[1])) + Property.y,
                ])),
              (i.xOrigin = HelperFunction = parseFloat(ObjectMethodWrapper[0])),
              (i.yOrigin = EnsureFunction = parseFloat(ObjectMethodWrapper[1])),
              n &&
                b !== GEnvironment &&
                ((GlobalReference = b[0]),
                (Property = b[1]),
                (MathFloorShortcut = b[2]),
                (f = b[3]),
                (ModuleMeta = b[4]),
                (g = b[5]),
                (Value = GlobalReference * f - Property * MathFloorShortcut) &&
                  ((CounterVariable = HelperFunction * (f / Value) + EnsureFunction * (-MathFloorShortcut / Value) + (MathFloorShortcut * g - f * ModuleMeta) / Value),
                  (RandomGenerator = HelperFunction * (-Property / Value) + EnsureFunction * (GlobalReference / Value) - (GlobalReference * g - Property * ModuleMeta) / Value),
                  (HelperFunction = i.xOrigin = ObjectMethodWrapper[0] = CounterVariable),
                  (EnsureFunction = i.yOrigin = ObjectMethodWrapper[1] = RandomGenerator))),
              x &&
                (a &&
                  ((i.xOffset = x.xOffset), (i.yOffset = x.yOffset), (x = i)),
                r || (!1 !== r && !1 !== B.defaultSmoothOrigin)
                  ? ((CounterVariable = HelperFunction - y),
                    (RandomGenerator = EnsureFunction - _),
                    (x.xOffset += CounterVariable * b[0] + RandomGenerator * b[2] - CounterVariable),
                    (x.yOffset += CounterVariable * b[1] + RandomGenerator * b[3] - RandomGenerator))
                  : (x.xOffset = x.yOffset = 0)),
              a || env.setAttribute("data-svg-origin", ObjectMethodWrapper.join(" "));
          },
          Ge = function (env) {
            var t,
              i = Property(
                "svg",
                (this.ownerSVGElement &&
                  this.ownerSVGElement.getAttribute("xmlns")) ||
                  "http://www.w3.org/2000/svg",
              ),
              n = this.parentNode,
              r = this.nextSibling,
              a = this.style.cssText;
            if (
              (ze.appendChild(i),
              i.appendChild(this),
              (this.style.display = "block"),
              env)
            )
              try {
                (t = this.getBBox()),
                  (this._originalGetBBox = this.getBBox),
                  (this.getBBox = Ge);
              } catch (env) {}
            else this._originalGetBBox && (t = this._originalGetBBox());
            return (
              r ? n.insertBefore(this, r) : n.appendChild(this),
              ze.removeChild(i),
              (this.style.cssText = a),
              t
            );
          },
          je = function (env) {
            return !(
              !Ue ||
              !env.getCTM ||
              (env.parentNode && !env.ownerSVGElement) ||
              !(function (t) {
                try {
                  return t.getBBox();
                } catch (env) {
                  return Ge.call(t, !0);
                }
              })(env)
            );
          },
          GEnvironment = [1, 0, 0, 1, 0, 0],
          IsObjectOrFunction = function (env, t) {
            var i,
              n,
              r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator = env._gsTransform || new ke(),
              HelperFunction = env.style;
            if (
              (Re
                ? (n = $(env, Oe, null, !0))
                : env.currentStyle &&
                  (n =
                    (n = env.currentStyle.filter.match(GlobalReference)) && 4 === n.length
                      ? [
                          n[0].substr(4),
                          Number(n[2].substr(4)),
                          Number(n[1].substr(4)),
                          n[3].substr(4),
                          RandomGenerator.x || 0,
                          RandomGenerator.y || 0,
                        ].join(",")
                      : ""),
              (i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n),
              !Re ||
                (!(CounterVariable = !ArrayOrStringObject(env) || "none" === ArrayOrStringObject(env).display) && env.parentNode) ||
                (CounterVariable && ((a = HelperFunction.display), (HelperFunction.display = "block")),
                env.parentNode || ((ObjectMethodWrapper = 1), ze.appendChild(env)),
                (i =
                  !(n = $(env, Oe, null, !0)) ||
                  "none" === n ||
                  "matrix(1, 0, 0, 1, 0, 0)" === n),
                a ? (HelperFunction.display = a) : CounterVariable && DefinePropertyDescriptor(HelperFunction, "display"),
                ObjectMethodWrapper && ze.removeChild(env)),
              (RandomGenerator.svg || (env.getCTM && je(env))) &&
                (i &&
                  -1 !== (HelperFunction[Re] + "").indexOf("matrix") &&
                  ((n = HelperFunction[Re]), (i = 0)),
                (r = env.getAttribute("transform")),
                i &&
                  r &&
                  ((n =
                    "matrix(" +
                    (r = env.transform.baseVal.consolidate().matrix).a +
                    "," +
                    r.b +
                    "," +
                    r.EnsureFunction +
                    "," +
                    r.MathFloorShortcut +
                    "," +
                    r.env +
                    "," +
                    r.f +
                    ")"),
                  (i = 0))),
              i)
            )
              return GEnvironment;
            for (r = (n || "").match(C) || [], we = r.length; -1 < --we; )
              (a = Number(r[we])),
                (r[we] = (ObjectMethodWrapper = a - (a |= 0))
                  ? ((1e5 * ObjectMethodWrapper + (ObjectMethodWrapper < 0 ? -0.5 : 0.5)) | 0) / 1e5 + a
                  : a);
            return t && 6 < r.length
              ? [r[0], r[1], r[4], r[5], r[12], r[13]]
              : r;
          },
          TryCatch = (r.getTransform = function (env, t, i, n) {
            if (env._gsTransform && i && !n) return env._gsTransform;
            var r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator,
              HelperFunction,
              EnsureFunction = (i && env._gsTransform) || new ke(),
              GlobalReference = EnsureFunction.scaleX < 0,
              Property =
                (Ne &&
                  (parseFloat($(env, Fe, t, !1, "0 0 0").split(" ")[2]) ||
                    EnsureFunction.zOrigin)) ||
                0,
              MathFloorShortcut = parseFloat(B.defaultTransformPerspective) || 0;
            if (
              ((EnsureFunction.svg = !(!env.getCTM || !je(env))),
              EnsureFunction.svg &&
                (He(
                  env,
                  $(env, Fe, t, !1, "50% 50%") + "",
                  EnsureFunction,
                  env.getAttribute("data-svg-origin"),
                ),
                (Ae = B.useSVGTransformAttr || Be)),
              (r = IsObjectOrFunction(env)) !== GEnvironment)
            ) {
              if (16 === r.length) {
                var f,
                  ModuleMeta,
                  g,
                  Value,
                  y,
 _ = r[0], // مقدار ماتریس در موقعیت [0][0]
  x = r[1], // مقدار ماتریس در موقعیت [0][1]
  b = r[2], // مقدار ماتریس در موقعیت [0][2]
  w = r[3], // مقدار ماتریس در موقعیت [0][3]
  T = r[4], // مقدار ماتریس در موقعیت [1][0]
  EnsureObject = r[5], // مقدار ماتریس در موقعیت [1][1]
  E = r[6], // مقدار ماتریس در موقعیت [1][2]
  A = r[7], // مقدار ماتریس در موقعیت [1][3]
  M = r[8], // مقدار ماتریس در موقعیت [2][0]
  P = r[9], // مقدار ماتریس در موقعیت [2][1]
  L = r[10], // مقدار ماتریس در موقعیت [2][2]
  C = r[12], // مقدار ماتریس در موقعیت [3][0]
  I = r[13], // مقدار ماتریس در موقعیت [3][1]
  R = r[14], // مقدار ماتریس در موقعیت [3][2]
  O = r[11], // مقدار ماتریس در موقعیت [2][3]
                  FilterArray = Math.atan2(E, L);
                EnsureFunction.zOrigin &&
                  ((C = M * (R = -EnsureFunction.zOrigin) - r[12]),
                  (I = P * R - r[13]),
                  (R = L * R + EnsureFunction.zOrigin - r[14])),
                  (EnsureFunction.rotationX = FilterArray * ForEachElement),
                  FilterArray &&
                    ((f = T * (Value = Math.cos(-FilterArray)) + M * (y = Math.sin(-FilterArray))),
                    (ModuleMeta = EnsureObject * Value + P * y),
                    (g = E * Value + L * y),
                    (M = T * -y + M * Value),
                    (P = EnsureObject * -y + P * Value),
                    (L = E * -y + L * Value),
                    (O = A * -y + O * Value),
                    (T = f),
                    (EnsureObject = ModuleMeta),
                    (E = g)),
                  (FilterArray = Math.atan2(-b, L)),
                  (EnsureFunction.rotationY = FilterArray * ForEachElement),
                  FilterArray &&
                    ((ModuleMeta = x * (Value = Math.cos(-FilterArray)) - P * (y = Math.sin(-FilterArray))),
                    (g = b * Value - L * y),
                    (P = x * y + P * Value),
                    (L = b * y + L * Value),
                    (O = w * y + O * Value),
                    (_ = f = _ * Value - M * y),
                    (x = ModuleMeta),
                    (b = g)),
                  (FilterArray = Math.atan2(x, _)),
                  (EnsureFunction.rotation = FilterArray * ForEachElement),
                  FilterArray &&
                    ((f = _ * (Value = Math.cos(FilterArray)) + x * (y = Math.sin(FilterArray))),
                    (ModuleMeta = T * Value + EnsureObject * y),
                    (g = M * Value + P * y),
                    (x = x * Value - _ * y),
                    (EnsureObject = EnsureObject * Value - T * y),
                    (P = P * Value - M * y),
                    (_ = f),
                    (T = ModuleMeta),
                    (M = g)),
                  EnsureFunction.rotationX &&
                    359.9 < Math.abs(EnsureFunction.rotationX) + Math.abs(EnsureFunction.rotation) &&
                    ((EnsureFunction.rotationX = EnsureFunction.rotation = 0),
                    (EnsureFunction.rotationY = 180 - EnsureFunction.rotationY)),
                  (FilterArray = Math.atan2(T, EnsureObject)),
                  (EnsureFunction.scaleX =
                    ((1e5 * Math.sqrt(_ * _ + x * x + b * b) + 0.5) | 0) / 1e5),
                  (EnsureFunction.scaleY =
                    ((1e5 * Math.sqrt(EnsureObject * EnsureObject + E * E) + 0.5) | 0) / 1e5),
                  (EnsureFunction.scaleZ =
                    ((1e5 * Math.sqrt(M * M + P * P + L * L) + 0.5) | 0) / 1e5),
                  (_ /= EnsureFunction.scaleX),
                  (T /= EnsureFunction.scaleY),
                  (x /= EnsureFunction.scaleX),
                  (EnsureObject /= EnsureFunction.scaleY),
                  2e-5 < Math.abs(FilterArray)
                    ? ((EnsureFunction.skewX = FilterArray * ForEachElement),
                      (T = 0),
                      "simple" !== EnsureFunction.skewType && (EnsureFunction.scaleY *= 1 / Math.cos(FilterArray)))
                    : (EnsureFunction.skewX = 0),
                  (EnsureFunction.perspective = O ? 1 / (O < 0 ? -O : O) : 0),
                  (EnsureFunction.x = C),
                  (EnsureFunction.y = I),
                  (EnsureFunction.z = R),
                  EnsureFunction.svg &&
                    ((EnsureFunction.x -= EnsureFunction.xOrigin - (EnsureFunction.xOrigin * _ - EnsureFunction.yOrigin * T)),
                    (EnsureFunction.y -= EnsureFunction.yOrigin - (EnsureFunction.yOrigin * x - EnsureFunction.xOrigin * EnsureObject)));
              } else if (
                !Ne ||
                n ||
                !r.length ||
                EnsureFunction.x !== r[4] ||
                EnsureFunction.y !== r[5] ||
                (!EnsureFunction.rotationX && !EnsureFunction.rotationY)
              ) {
                var FindInArray = 6 <= r.length,
                  Key = FindInArray ? r[0] : 1,
                  U = r[1] || 0,
                  D = r[2] || 0,
                  z = FindInArray ? r[3] : 1;
                (EnsureFunction.x = r[4] || 0),
                  (EnsureFunction.y = r[5] || 0),
                  (ObjectMethodWrapper = Math.sqrt(Key * Key + U * U)),
                  (CounterVariable = Math.sqrt(z * z + D * D)),
                  (RandomGenerator = Key || U ? Math.atan2(U, Key) * ForEachElement : EnsureFunction.rotation || 0),
                  (HelperFunction = D || z ? Math.atan2(D, z) * ForEachElement + RandomGenerator : EnsureFunction.skewX || 0),
                  (EnsureFunction.scaleX = ObjectMethodWrapper),
                  (EnsureFunction.scaleY = CounterVariable),
                  (EnsureFunction.rotation = RandomGenerator),
                  (EnsureFunction.skewX = HelperFunction),
                  Ne &&
                    ((EnsureFunction.rotationX = EnsureFunction.rotationY = EnsureFunction.z = 0),
                    (EnsureFunction.perspective = MathFloorShortcut),
                    (EnsureFunction.scaleZ = 1)),
                  EnsureFunction.svg &&
                    ((EnsureFunction.x -= EnsureFunction.xOrigin - (EnsureFunction.xOrigin * Key + EnsureFunction.yOrigin * D)),
                    (EnsureFunction.y -= EnsureFunction.yOrigin - (EnsureFunction.xOrigin * U + EnsureFunction.yOrigin * z)));
              }
              for (a in (90 < Math.abs(EnsureFunction.skewX) &&
                Math.abs(EnsureFunction.skewX) < 270 &&
                (GlobalReference
                  ? ((EnsureFunction.scaleX *= -1),
                    (EnsureFunction.skewX += EnsureFunction.rotation <= 0 ? 180 : -180),
                    (EnsureFunction.rotation += EnsureFunction.rotation <= 0 ? 180 : -180))
                  : ((EnsureFunction.scaleY *= -1), (EnsureFunction.skewX += EnsureFunction.skewX <= 0 ? 180 : -180))),
              (EnsureFunction.zOrigin = Property),
              EnsureFunction))
                EnsureFunction[a] < 2e-5 && -2e-5 < EnsureFunction[a] && (EnsureFunction[a] = 0);
            }
            return (
              i &&
                (env._gsTransform = EnsureFunction).svg &&
                (Ae && env.style[Re]
                  ? Ss.delayedCall(0.001, function () {
                      DefinePropertyDescriptor(env.style, Re);
                    })
                  : !Ae &&
                    env.getAttribute("transform") &&
                    Ss.delayedCall(0.001, function () {
                      env.removeAttribute("transform");
                    })),
              EnsureFunction
            );
          }),
          SupportsDefineProperty  = function (env) {
            var t,
              i,
              n = this.data,
              r = -n.rotation * D,
              a = r + n.skewX * D,
              ObjectMethodWrapper = ((Math.cos(r) * n.scaleX * 1e5) | 0) / 1e5,
              CounterVariable = ((Math.sin(r) * n.scaleX * 1e5) | 0) / 1e5,
              RandomGenerator = ((Math.sin(a) * -n.scaleY * 1e5) | 0) / 1e5,
              HelperFunction = ((Math.cos(a) * n.scaleY * 1e5) | 0) / 1e5,
              EnsureFunction = this.t.style,
              GlobalReference = this.t.currentStyle;
            if (GlobalReference) {
              (i = CounterVariable), (CounterVariable = -RandomGenerator), (RandomGenerator = -i), (t = GlobalReference.filter), (EnsureFunction.filter = "");
              var Property,
                MathFloorShortcut,
                f = this.t.offsetWidth,
                ModuleMeta = this.t.offsetHeight,
                g = "absolute" !== GlobalReference.position,
                Value =
                  "progid:DXImageTransform.Microsoft.Matrix(M11=" +
                  ObjectMethodWrapper +
                  ", M12=" +
                  CounterVariable +
                  ", M21=" +
                  RandomGenerator +
                  ", M22=" +
                  HelperFunction,
                y = n.x + (f * n.xPercent) / 100,
                _ = n.y + (ModuleMeta * n.yPercent) / 100;
              if (
                (null != n.ox &&
                  ((y +=
                    (Property = (n.oxp ? f * n.ox * 0.01 : n.ox) - f / 2) -
                    (Property * ObjectMethodWrapper +
                      (MathFloorShortcut = (n.oyp ? ModuleMeta * n.oy * 0.01 : n.oy) - ModuleMeta / 2) * CounterVariable)),
                  (_ += MathFloorShortcut - (Property * RandomGenerator + MathFloorShortcut * HelperFunction))),
                (Value += g
                  ? ", Dx=" +
                    ((Property = f / 2) - (Property * ObjectMethodWrapper + (MathFloorShortcut = ModuleMeta / 2) * CounterVariable) + y) +
                    ", Dy=" +
                    (MathFloorShortcut - (Property * RandomGenerator + MathFloorShortcut * HelperFunction) + _) +
                    ")"
                  : ", sizingMethod='auto expand')"),
                -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(")
                  ? (EnsureFunction.filter = t.replace(FilterArray, Value))
                  : (EnsureFunction.filter = Value + " " + t),
                (0 !== env && 1 !== env) ||
                  (1 === ObjectMethodWrapper &&
                    0 === CounterVariable &&
                    0 === RandomGenerator &&
                    1 === HelperFunction &&
                    ((g && -1 === Value.indexOf("Dx=0, Dy=0")) ||
                      (O.test(t) && 100 !== parseFloat(RegExp.$1)) ||
                      (-1 === t.indexOf(t.indexOf("Alpha")) &&
                        EnsureFunction.removeAttribute("filter")))),
                !g)
              ) {
                var x,
                  b,
                  w,
                  T = E < 8 ? 1 : -1;
                for (
                  Property = n.ieOffsetX || 0,
                    MathFloorShortcut = n.ieOffsetY || 0,
                    n.ieOffsetX = Math.round(
                      (f - ((ObjectMethodWrapper < 0 ? -ObjectMethodWrapper : ObjectMethodWrapper) * f + (CounterVariable < 0 ? -CounterVariable : CounterVariable) * ModuleMeta)) / 2 +
                        y,
                    ),
                    n.ieOffsetY = Math.round(
                      (ModuleMeta - ((HelperFunction < 0 ? -HelperFunction : HelperFunction) * ModuleMeta + (RandomGenerator < 0 ? -RandomGenerator : RandomGenerator) * f)) / 2 +
                        _,
                    ),
                    we = 0;
                  we < 4;
                  we++
                )
                  (w =
                    (i =
                      -1 !== (x = GlobalReference[(b = ae[we])]).indexOf("px")
                        ? parseFloat(x)
                        : IndexOfElement(this.t, b, parseFloat(x), x.replace(R, "")) ||
                          0) !== n[b]
                      ? we < 2
                        ? -n.ieOffsetX
                        : -n.ieOffsetY
                      : we < 2
                        ? Property - n.ieOffsetX
                        : MathFloorShortcut - n.ieOffsetY),
                    (EnsureFunction[b] =
                      (n[b] = Math.round(
                        i - w * (0 === we || 2 === we ? 1 : T),
                      )) + "px");
              }
            }
          },
          PrimitiveConversion =
            (r.set3DTransformRatio =
            r.setTransformRatio =
              function (env) {
                var t,
                  i,
                  n,
                  r,
                  a,
                  ObjectMethodWrapper,
                  CounterVariable,
                  RandomGenerator,
                  HelperFunction,
                  EnsureFunction,
                  GlobalReference,
                  Property,
                  MathFloorShortcut,
                  f,
                  ModuleMeta,
                  g,
                  Value,
                  y,
                  _,
                  x,
                  b = this.data,
                  w = this.t.style,
                  T = b.rotation,
                  EnsureObject = b.rotationX,
                  E = b.rotationY,
                  A = b.scaleX,
                  M = b.scaleY,
                  P = b.scaleZ,
                  L = b.x,
                  C = b.y,
                  I = b.z,
                  R = b.svg,
                  O = b.perspective,
                  FilterArray = b.force3D,
                  FindInArray = b.skewY,
                  Key = b.skewX;
                if (
                  (FindInArray && ((Key += FindInArray), (T += FindInArray)),
                  !(
                    (((1 !== env && 0 !== env) ||
                      "auto" !== FilterArray ||
                      (this.tween._totalTime !== this.tween._totalDuration &&
                        this.tween._totalTime)) &&
                      FilterArray) ||
                    I ||
                    O ||
                    E ||
                    EnsureObject ||
                    1 !== P
                  ) ||
                    (Ae && R) ||
                    !Ne)
                )
                  T || Key || R
                    ? ((T *= D),
                      (x = Key * D),
                      1e5,
                      (i = Math.cos(T) * A),
                      (a = Math.sin(T) * A),
                      (n = Math.sin(T - x) * -M),
                      (ObjectMethodWrapper = Math.cos(T - x) * M),
                      x &&
                        "simple" === b.skewType &&
                        ((t = Math.tan(x - FindInArray * D)),
                        (n *= t = Math.sqrt(1 + t * t)),
                        (ObjectMethodWrapper *= t),
                        FindInArray &&
                          ((t = Math.tan(FindInArray * D)),
                          (i *= t = Math.sqrt(1 + t * t)),
                          (a *= t))),
                      R &&
                        ((L +=
                          b.xOrigin -
                          (b.xOrigin * i + b.yOrigin * n) +
                          b.xOffset),
                        (C +=
                          b.yOrigin -
                          (b.xOrigin * a + b.yOrigin * ObjectMethodWrapper) +
                          b.yOffset),
                        Ae &&
                          (b.xPercent || b.yPercent) &&
                          ((ModuleMeta = this.t.getBBox()),
                          (L += 0.01 * b.xPercent * ModuleMeta.width),
                          (C += 0.01 * b.yPercent * ModuleMeta.height)),
                        L < (ModuleMeta = 1e-6) && -ModuleMeta < L && (L = 0),
                        C < ModuleMeta && -ModuleMeta < C && (C = 0)),
                      (_ =
                        ((1e5 * i) | 0) / 1e5 +
                        "," +
                        ((1e5 * a) | 0) / 1e5 +
                        "," +
                        ((1e5 * n) | 0) / 1e5 +
                        "," +
                        ((1e5 * ObjectMethodWrapper) | 0) / 1e5 +
                        "," +
                        L +
                        "," +
                        C +
                        ")"),
                      R && Ae
                        ? this.t.setAttribute("transform", "matrix(" + _)
                        : (w[Re] =
                            (b.xPercent || b.yPercent
                              ? "translate(" +
                                b.xPercent +
                                "%," +
                                b.yPercent +
                                "%) matrix("
                              : "matrix(") + _))
                    : (w[Re] =
                        (b.xPercent || b.yPercent
                          ? "translate(" +
                            b.xPercent +
                            "%," +
                            b.yPercent +
                            "%) matrix("
                          : "matrix(") +
                        A +
                        ",0,0," +
                        M +
                        "," +
                        L +
                        "," +
                        C +
                        ")");
                else {
                  if (
                    (U &&
                      (A < (ModuleMeta = 1e-4) && -ModuleMeta < A && (A = P = 2e-5),
                      M < ModuleMeta && -ModuleMeta < M && (M = P = 2e-5),
                      !O || b.z || b.rotationX || b.rotationY || (O = 0)),
                    T || Key)
                  )
                    (T *= D),
                      (g = i = Math.cos(T)),
                      (Value = a = Math.sin(T)),
                      Key &&
                        ((T -= Key * D),
                        (g = Math.cos(T)),
                        (Value = Math.sin(T)),
                        "simple" === b.skewType &&
                          ((t = Math.tan((Key - FindInArray) * D)),
                          (g *= t = Math.sqrt(1 + t * t)),
                          (Value *= t),
                          b.skewY &&
                            ((t = Math.tan(FindInArray * D)),
                            (i *= t = Math.sqrt(1 + t * t)),
                            (a *= t)))),
                      (n = -Value),
                      (ObjectMethodWrapper = g);
                  else {
                    if (!(E || EnsureObject || 1 !== P || O || R))
                      return void (w[Re] =
                        (b.xPercent || b.yPercent
                          ? "translate(" +
                            b.xPercent +
                            "%," +
                            b.yPercent +
                            "%) translate3d("
                          : "translate3d(") +
                        L +
                        "px," +
                        C +
                        "px," +
                        I +
                        "px)" +
                        (1 !== A || 1 !== M
                          ? " scale(" + A + "," + M + ")"
                          : ""));
                    (i = ObjectMethodWrapper = 1), (n = a = 0);
                  }
                  (EnsureFunction = 1),
                    (r = CounterVariable = RandomGenerator = HelperFunction = GlobalReference = Property = 0),
                    (MathFloorShortcut = O ? -1 / O : 0),
                    (f = b.zOrigin),
                    (ModuleMeta = 1e-6),
                    ",",
                    "0",
                    (T = E * D) &&
                      ((g = Math.cos(T)),
                      (GlobalReference = MathFloorShortcut * (RandomGenerator = -(Value = Math.sin(T)))),
                      (r = i * Value),
                      (CounterVariable = a * Value),
                      (MathFloorShortcut *= EnsureFunction = g),
                      (i *= g),
                      (a *= g)),
                    (T = EnsureObject * D) &&
                      ((t = n * (g = Math.cos(T)) + r * (Value = Math.sin(T))),
                      (y = ObjectMethodWrapper * g + CounterVariable * Value),
                      (HelperFunction = EnsureFunction * Value),
                      (Property = MathFloorShortcut * Value),
                      (r = n * -Value + r * g),
                      (CounterVariable = ObjectMethodWrapper * -Value + CounterVariable * g),
                      (EnsureFunction *= g),
                      (MathFloorShortcut *= g),
                      (n = t),
                      (ObjectMethodWrapper = y)),
                    1 !== P && ((r *= P), (CounterVariable *= P), (EnsureFunction *= P), (MathFloorShortcut *= P)),
                    1 !== M && ((n *= M), (ObjectMethodWrapper *= M), (HelperFunction *= M), (Property *= M)),
                    1 !== A && ((i *= A), (a *= A), (RandomGenerator *= A), (GlobalReference *= A)),
                    (f || R) &&
                      (f && ((L += r * -f), (C += CounterVariable * -f), (I += EnsureFunction * -f + f)),
                      R &&
                        ((L +=
                          b.xOrigin -
                          (b.xOrigin * i + b.yOrigin * n) +
                          b.xOffset),
                        (C +=
                          b.yOrigin -
                          (b.xOrigin * a + b.yOrigin * ObjectMethodWrapper) +
                          b.yOffset)),
                      L < ModuleMeta && -ModuleMeta < L && (L = "0"),
                      C < ModuleMeta && -ModuleMeta < C && (C = "0"),
                      I < ModuleMeta && -ModuleMeta < I && (I = 0)),
                    (_ =
                      b.xPercent || b.yPercent
                        ? "translate(" +
                          b.xPercent +
                          "%," +
                          b.yPercent +
                          "%) matrix3d("
                        : "matrix3d("),
                    (_ +=
                      (i < ModuleMeta && -ModuleMeta < i ? "0" : i) +
                      "," +
                      (a < ModuleMeta && -ModuleMeta < a ? "0" : a) +
                      "," +
                      (RandomGenerator < ModuleMeta && -ModuleMeta < RandomGenerator ? "0" : RandomGenerator)),
                    (_ +=
                      "," +
                      (GlobalReference < ModuleMeta && -ModuleMeta < GlobalReference ? "0" : GlobalReference) +
                      "," +
                      (n < ModuleMeta && -ModuleMeta < n ? "0" : n) +
                      "," +
                      (ObjectMethodWrapper < ModuleMeta && -ModuleMeta < ObjectMethodWrapper ? "0" : ObjectMethodWrapper)),
                    EnsureObject || E || 1 !== P
                      ? ((_ +=
                          "," +
                          (HelperFunction < ModuleMeta && -ModuleMeta < HelperFunction ? "0" : HelperFunction) +
                          "," +
                          (Property < ModuleMeta && -ModuleMeta < Property ? "0" : Property) +
                          "," +
                          (r < ModuleMeta && -ModuleMeta < r ? "0" : r)),
                        (_ +=
                          "," +
                          (CounterVariable < ModuleMeta && -ModuleMeta < CounterVariable ? "0" : CounterVariable) +
                          "," +
                          (EnsureFunction < ModuleMeta && -ModuleMeta < EnsureFunction ? "0" : EnsureFunction) +
                          "," +
                          (MathFloorShortcut < ModuleMeta && -ModuleMeta < MathFloorShortcut ? "0" : MathFloorShortcut) +
                          ","))
                      : (_ += ",0,0,0,0,1,0,"),
                    (_ +=
                      L + "," + C + "," + I + "," + (O ? 1 + -I / O : 1) + ")"),
                    (w[Re] = _);
                }
              });
        ((env = ke.prototype).x =
          env.y =
          env.z =
          env.skewX =
          env.skewY =
          env.rotation =
          env.rotationX =
          env.rotationY =
          env.zOrigin =
          env.xPercent =
          env.yPercent =
          env.xOffset =
          env.yOffset =
            0),
          (env.scaleX = env.scaleY = env.scaleZ = 1),
          Se(
            "transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin",
            {
              parser: function (env, t, i, n, r, a, ObjectMethodWrapper) {
                if (n._lastParsedTransform === ObjectMethodWrapper) return r;
                var CounterVariable,
                  RandomGenerator =
                    (n._lastParsedTransform = ObjectMethodWrapper).scale &&
                    "function" == typeof ObjectMethodWrapper.scale
                      ? ObjectMethodWrapper.scale
                      : 0;
                "function" == typeof ObjectMethodWrapper[i] && ((CounterVariable = ObjectMethodWrapper[i]), (ObjectMethodWrapper[i] = t)),
                  RandomGenerator && (ObjectMethodWrapper.scale = RandomGenerator(L, env));
                var HelperFunction,
                  EnsureFunction,
                  GlobalReference,
                  Property,
                  MathFloorShortcut,
                  f,
                  ModuleMeta,
                  g,
                  Value,
                  y = env._gsTransform,
                  _ = env.style,
                  x = Ie.length,
                  b = ObjectMethodWrapper,
                  w = {},
                  T = "transformOrigin",
                  EnsureObject = TryCatch(env, A, !0, b.parseTransform),
                  E =
                    b.transform &&
                    ("function" == typeof b.transform
                      ? b.transform(L, P)
                      : b.transform);
                if (
                  ((EnsureObject.skewType = b.skewType || EnsureObject.skewType || B.defaultSkewType),
                  (n._transform = EnsureObject),
                  "rotationZ" in b && (b.rotation = b.rotationZ),
                  E && "string" == typeof E && Re)
                )
                  ((EnsureFunction = Iterator.style)[Re] = E),
                    (EnsureFunction.display = "block"),
                    (EnsureFunction.position = "absolute"),
                    -1 !== E.indexOf("%") &&
                      ((EnsureFunction.width = $(env, "width")), (EnsureFunction.height = $(env, "height"))),
                    G.body.appendChild(Iterator),
                    (HelperFunction = TryCatch(Iterator, null, !1)),
                    "simple" === EnsureObject.skewType &&
                      (HelperFunction.scaleY *= Math.cos(HelperFunction.skewX * D)),
                    EnsureObject.svg &&
                      ((f = EnsureObject.xOrigin),
                      (ModuleMeta = EnsureObject.yOrigin),
                      (HelperFunction.x -= EnsureObject.xOffset),
                      (HelperFunction.y -= EnsureObject.yOffset),
                      (b.transformOrigin || b.svgOrigin) &&
                        ((E = {}),
                        He(
                          env,
                          se(b.transformOrigin),
                          E,
                          b.svgOrigin,
                          b.smoothOrigin,
                          !0,
                        ),
                        (f = E.xOrigin),
                        (ModuleMeta = E.yOrigin),
                        (HelperFunction.x -= E.xOffset - EnsureObject.xOffset),
                        (HelperFunction.y -= E.yOffset - EnsureObject.yOffset)),
                      (f || ModuleMeta) &&
                        ((g = IsObjectOrFunction(Iterator, !0)),
                        (HelperFunction.x -= f - (f * g[0] + ModuleMeta * g[2])),
                        (HelperFunction.y -= ModuleMeta - (f * g[1] + ModuleMeta * g[3])))),
                    G.body.removeChild(Iterator),
                    HelperFunction.perspective || (HelperFunction.perspective = EnsureObject.perspective),
                    null != b.xPercent &&
                      (HelperFunction.xPercent = he(b.xPercent, EnsureObject.xPercent)),
                    null != b.yPercent &&
                      (HelperFunction.yPercent = he(b.yPercent, EnsureObject.yPercent));
                else if ("object" == typeof b) {
                  if (
                    ((HelperFunction = {
                      scaleX: he(
                        null != b.scaleX ? b.scaleX : b.scale,
                        EnsureObject.scaleX,
                      ),
                      scaleY: he(
                        null != b.scaleY ? b.scaleY : b.scale,
                        EnsureObject.scaleY,
                      ),
                      scaleZ: he(b.scaleZ, EnsureObject.scaleZ),
                      x: he(b.x, EnsureObject.x),
                      y: he(b.y, EnsureObject.y),
                      z: he(b.z, EnsureObject.z),
                      xPercent: he(b.xPercent, EnsureObject.xPercent),
                      yPercent: he(b.yPercent, EnsureObject.yPercent),
                      perspective: he(b.transformPerspective, EnsureObject.perspective),
                    }),
                    null != (MathFloorShortcut = b.directionalRotation))
                  )
                    if ("object" == typeof MathFloorShortcut) for (EnsureFunction in MathFloorShortcut) b[EnsureFunction] = MathFloorShortcut[EnsureFunction];
                    else b.rotation = MathFloorShortcut;
                  "string" == typeof b.x &&
                    -1 !== b.x.indexOf("%") &&
                    ((HelperFunction.x = 0), (HelperFunction.xPercent = he(b.x, EnsureObject.xPercent))),
                    "string" == typeof b.y &&
                      -1 !== b.y.indexOf("%") &&
                      ((HelperFunction.y = 0), (HelperFunction.yPercent = he(b.y, EnsureObject.yPercent))),
                    (HelperFunction.rotation = ce(
                      "rotation" in b
                        ? b.rotation
                        : "shortRotation" in b
                          ? b.shortRotation + "_short"
                          : EnsureObject.rotation,
                      EnsureObject.rotation,
                      "rotation",
                      w,
                    )),
                    Ne &&
                      ((HelperFunction.rotationX = ce(
                        "rotationX" in b
                          ? b.rotationX
                          : "shortRotationX" in b
                            ? b.shortRotationX + "_short"
                            : EnsureObject.rotationX || 0,
                        EnsureObject.rotationX,
                        "rotationX",
                        w,
                      )),
                      (HelperFunction.rotationY = ce(
                        "rotationY" in b
                          ? b.rotationY
                          : "shortRotationY" in b
                            ? b.shortRotationY + "_short"
                            : EnsureObject.rotationY || 0,
                        EnsureObject.rotationY,
                        "rotationY",
                        w,
                      ))),
                    (HelperFunction.skewX = ce(b.skewX, EnsureObject.skewX)),
                    (HelperFunction.skewY = ce(b.skewY, EnsureObject.skewY));
                }
                for (
                  Ne &&
                    null != b.force3D &&
// بررسی تنظیمات مربوط به ویژگی‌های سه‌بعدی و مقادیر مرتبط
((EnsureObject.force3D = b.force3D), // فعال کردن ویژگی `force3D` اگر در تنظیمات تعریف شده باشد
 (Property = !0)), // تنظیم یک فلگ برای مشخص کردن اینکه ویژگی سه‌بعدی اعمال شده است

// بررسی اینکه آیا ویژگی سه‌بعدی یا مقادیر مرتبط تعریف شده‌اند
(GlobalReference =
  EnsureObject.force3D || // بررسی فعال بودن `force3D`
  EnsureObject.z || // بررسی مقدار z (برای موقعیت در فضای سه‌بعدی)
  EnsureObject.rotationX || // بررسی چرخش حول محور X
  EnsureObject.rotationY || // بررسی چرخش حول محور Y
  HelperFunction.z || // بررسی مقدار z از منبع داده دیگر
  HelperFunction.rotationX || // بررسی چرخش X از منبع داده دیگر
  HelperFunction.rotationY || // بررسی چرخش Y از منبع داده دیگر
  HelperFunction.perspective) || // بررسی ویژگی `perspective` (عمق نمایشی در سه‌بعدی)

// اگر هیچ‌یک از مقادیر سه‌بعدی تعریف نشده باشند، و مقیاس `scale` تعریف شده باشد
null == b.scale ||
  (HelperFunction.scaleZ = 1); // تنظیم مقدار پیش‌فرض برای `scaleZ` در صورت عدم تعریف

                  -1 < --x;

                )
                  (1e-6 < (E = HelperFunction[(Value = Ie[x])] - EnsureObject[Value]) ||
                    E < -1e-6 ||
                    null != b[Value] ||
                    null != z[Value]) &&
                    ((Property = !0),
                    (r = new _e(EnsureObject, Value, EnsureObject[Value], E, r)),
                    Value in w && (r.env = w[Value]),
                    (r.xs0 = 0),
                    (r.plugin = a),
                    n._overwriteProps.push(r.n));
                return (
                  (E = b.transformOrigin),
                  EnsureObject.svg &&
                    (E || b.svgOrigin) &&
                    ((f = EnsureObject.xOffset),
                    (ModuleMeta = EnsureObject.yOffset),
                    He(env, se(E), HelperFunction, b.svgOrigin, b.smoothOrigin),
                    (r = xe(
                      EnsureObject,
                      "xOrigin",
                      (y ? EnsureObject : HelperFunction).xOrigin,
                      HelperFunction.xOrigin,
                      r,
                      T,
                    )),
                    (r = xe(
                      EnsureObject,
                      "yOrigin",
                      (y ? EnsureObject : HelperFunction).yOrigin,
                      HelperFunction.yOrigin,
                      r,
                      T,
                    )),
                    (f === EnsureObject.xOffset && ModuleMeta === EnsureObject.yOffset) ||
                      ((r = xe(
                        EnsureObject,
                        "xOffset",
                        y ? f : EnsureObject.xOffset,
                        EnsureObject.xOffset,
                        r,
                        T,
                      )),
                      (r = xe(
                        EnsureObject,
                        "yOffset",
                        y ? ModuleMeta : EnsureObject.yOffset,
                        EnsureObject.yOffset,
                        r,
                        T,
                      ))),
                    (E = "0px 0px")),
                  (E || (Ne && GlobalReference && EnsureObject.zOrigin)) &&
                    (Re
                      ? ((Property = !0),
                        (Value = Fe),
                        (E = (E || $(env, Value, A, !1, "50% 50%")) + ""),
                        ((r = new _e(_, Value, 0, 0, r, -1, T)).b = _[Value]),
                        (r.plugin = a),
                        (r.xs0 = r.env =
                          Ne
                            ? ((EnsureFunction = EnsureObject.zOrigin),
                              (E = E.split(" ")),
                              (EnsureObject.zOrigin =
                                (2 < E.length && (0 === EnsureFunction || "0px" !== E[2])
                                  ? parseFloat(E[2])
                                  : EnsureFunction) || 0),
                              (r.xs0 = r.env =
                                E[0] + " " + (E[1] || "50%") + " 0px"),
                              ((r = new _e(EnsureObject, "zOrigin", 0, 0, r, -1, r.n)).b =
                                EnsureFunction),
                              EnsureObject.zOrigin)
                            : E))
                      : se(E + "", EnsureObject)),
                  Property &&
                    (n._transformType =
                      (EnsureObject.svg && Ae) || (!GlobalReference && 3 !== this._transformType)
                        ? 2
                        : 3),
                  CounterVariable && (ObjectMethodWrapper[i] = CounterVariable),
                  RandomGenerator && (ObjectMethodWrapper.scale = RandomGenerator),
                  r
                );
              },
              prefix: !0,
            },
          ),
// تعریف ویژگی‌های CSS برای "boxShadow"
Se("boxShadow", {
  defaultValue: "0px 0px 0px 0px #999", // مقدار پیش‌فرض سایه
  prefix: !0, // پشتیبانی از پیشوندهای مرورگر
  color: !0, // امکان تغییر رنگ در سایه
  multi: !0, // امکان چند مقدار برای این ویژگی
  keyword: "inset", // کلیدواژه مرتبط با ویژگی
});

// تعریف ویژگی‌های CSS برای "borderRadius"
Se("borderRadius", {
  defaultValue: "0px", // مقدار پیش‌فرض
  parser: function (env, t, i, n, r, a) {
    t = this.format(t); // فرمت‌دهی به مقدار ورودی
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction,
      GlobalReference,
      Property,
      MathFloorShortcut,
      f,
      ModuleMeta,
      g,
      Value,
      y,
      _,
      x,
      b,
      w = [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomRightRadius",
        "borderBottomLeftRadius",
      ], // آرایه‌ای از مقادیر هر گوشه
      T = env.style; // دسترسی به استایل عنصر

    // پردازش مقدار ورودی و محاسبات عرض و ارتفاع
    f = parseFloat(env.offsetWidth);
    ModuleMeta = parseFloat(env.offsetHeight);
    ObjectMethodWrapper = t.split(" "); // تقسیم مقدار ورودی به مقادیر مجزا

    // حلقه برای پردازش هر گوشه
    for (CounterVariable = 0; CounterVariable < w.length; CounterVariable++) {
      // تنظیم نام ویژگی در صورتی که "border" در نام وجود نداشته باشد
      this.Property.indexOf("border") && (w[CounterVariable] = J(w[CounterVariable]));

      // دریافت مقدار فعلی گوشه از CSS
      EnsureFunction = HelperFunction = $(env, w[CounterVariable], A, !1, "0px");
      if (-1 !== EnsureFunction.indexOf(" ")) {
        EnsureFunction = (HelperFunction = EnsureFunction.split(" "))[0];
        HelperFunction = HelperFunction[1];
      }

      // پردازش مقدار جدید برای هر گوشه
      GlobalReference = RandomGenerator = ObjectMethodWrapper[CounterVariable];
      Property = parseFloat(EnsureFunction);
      Value = EnsureFunction.substr((Property + "").length);

      // محاسبات تطبیق واحد (مثل px یا %)
      g =
        (y = "=" === GlobalReference.charAt(1))
          ? ((MathFloorShortcut = parseInt(GlobalReference.charAt(0) + "1", 10)),
            (GlobalReference = GlobalReference.substr(2)),
            (MathFloorShortcut *= parseFloat(GlobalReference)),
            GlobalReference.substr((MathFloorShortcut + "").length - (MathFloorShortcut < 0 ? 1 : 0)) || "")
          : ((MathFloorShortcut = parseFloat(GlobalReference)), GlobalReference.substr((MathFloorShortcut + "").length));

      // اگر واحدها متفاوت باشند، محاسبات انجام می‌شود
      if (g !== Value) {
        _ = IndexOfElement(env, "borderLeft", Property, Value);
        x = IndexOfElement(env, "borderTop", Property, Value);

        HelperFunction =
          "%" === g
            ? ((_ / f) * 100 + "%", (x / ModuleMeta) * 100 + "%")
            : "em" === g
            ? (_ / (b = IndexOfElement(env, "borderLeft", 1, "em")) + "em", x / b + "em")
            : (_ + "px", x + "px");

        y &&
          ((GlobalReference = parseFloat(HelperFunction) + MathFloorShortcut + g),
          (RandomGenerator = parseFloat(HelperFunction) + MathFloorShortcut + g));
      }

      // افزودن انیمیشن به مقدار جدید
      r = be(T, w[CounterVariable], EnsureFunction + " " + HelperFunction, GlobalReference + " " + RandomGenerator, !1, "0px", r);
    }
    return r;
  },
  prefix: !0, // پشتیبانی از پیشوندهای مرورگر
  formatter: ge("0px 0px 0px 0px", !1, !0), // فرمت‌دهی مقدار پیش‌فرض
});

// تعریف ویژگی برای "backgroundPosition"
Se("backgroundPosition", {
  defaultValue: "0 0", // مقدار پیش‌فرض
  parser: function (env, t, i, n, r, a) {
    var ObjectMethodWrapper,
      CounterVariable,
      RandomGenerator,
      HelperFunction,
      EnsureFunction,
      GlobalReference,
      Property = "background-position",
      MathFloorShortcut = A || ArrayOrStringObject(env, null),
      f = this.format(
        (MathFloorShortcut
          ? E
            ? MathFloorShortcut.getPropertyValue(Property + "-x") +
              " " +
              MathFloorShortcut.getPropertyValue(Property + "-y")
            : MathFloorShortcut.getPropertyValue(Property)
          : env.currentStyle.backgroundPositionX +
            " " +
            env.currentStyle.backgroundPositionY) || "0 0"
      ),
      ModuleMeta = this.format(t);

    // محاسبات برای تطبیق درصد و پیکسل در ویژگی
    if (
      (-1 !== f.indexOf("%")) != (-1 !== ModuleMeta.indexOf("%")) &&
      ModuleMeta.split(",").length < 2 &&
      (GlobalReference = $(env, "backgroundImage").replace(T, "")) &&
      "none" !== GlobalReference
    ) {
      for (
        ObjectMethodWrapper = f.split(" "),
          CounterVariable = ModuleMeta.split(" "),
          IsIterable.setAttribute("src", GlobalReference),
          RandomGenerator = 2;
        -1 < --RandomGenerator;

      )
        (HelperFunction = -1 !== (f = ObjectMethodWrapper[RandomGenerator]).indexOf("%")) !==
          (-1 !== CounterVariable[RandomGenerator].indexOf("%")) &&
          ((EnsureFunction =
            0 === RandomGenerator
              ? env.offsetWidth - IsIterable.width
              : env.offsetHeight - IsIterable.height),
          (ObjectMethodWrapper[RandomGenerator] = HelperFunction
            ? (parseFloat(f) / 100) * EnsureFunction + "px"
            : (parseFloat(f) / EnsureFunction) * 100 + "%"));
      f = ObjectMethodWrapper.join(" ");
    }
    return this.parseComplex(env.style, f, ModuleMeta, r, a);
  },
  formatter: se, // فرمت‌دهی نهایی مقادیر
});

          Se("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0,
          }),
          Se("autoRound,strictUnits", {
            parser: function (env, t, i, n, r) {
              return r;
            },
          }),
          Se("border", {
            defaultValue: "0px solid #000",
            parser: function (env, t, i, n, r, a) {
              var ObjectMethodWrapper = $(env, "borderTopWidth", A, !1, "0px"),
                CounterVariable = this.format(t).split(" "),
                RandomGenerator = CounterVariable[0].replace(R, "");
              return (
                "px" !== RandomGenerator &&
                  (ObjectMethodWrapper = parseFloat(ObjectMethodWrapper) / IndexOfElement(env, "borderTopWidth", 1, RandomGenerator) + RandomGenerator),
                this.parseComplex(
                  env.style,
                  this.format(
                    ObjectMethodWrapper +
                      " " +
                      $(env, "borderTopStyle", A, !1, "solid") +
                      " " +
                      $(env, "borderTopColor", A, !1, "#000"),
                  ),
                  CounterVariable.join(" "),
                  r,
                  a,
                )
              );
            },
            color: !0,
            formatter: function (env) {
              var t = env.split(" ");
              return (
                t[0] +
                " " +
                (t[1] || "solid") +
                " " +
                (env.match(me) || ["#000"])[0]
              );
            },
          }),
          Se("borderWidth", {
            parser: ve(
              "borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth",
            ),
          }),
          Se("float,cssFloat,styleFloat", {
            parser: function (env, t, i, n, r, a) {
              var ObjectMethodWrapper = env.style,
                CounterVariable = "cssFloat" in ObjectMethodWrapper ? "cssFloat" : "styleFloat";
              return new _e(ObjectMethodWrapper, CounterVariable, 0, 0, r, -1, i, !1, 0, ObjectMethodWrapper[CounterVariable], t);
            },
          });
        var ObjectPropertyManager = function (env) {
          var t,
            i = this.t,
            n = i.filter || $(this.data, "filter") || "",
            r = (this.CounterVariable + this.EnsureFunction * env) | 0;
          100 === r &&
            (t =
              -1 === n.indexOf("atrix(") &&
              -1 === n.indexOf("radient(") &&
              -1 === n.indexOf("oader(")
                ? (i.removeAttribute("filter"), !$(this.data, "filter"))
                : ((i.filter = n.replace(a, "")), !0)),
            t ||
              (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"),
              -1 === n.indexOf("pacity")
                ? (0 === r && this.xn1) ||
                  (i.filter = n + " alpha(opacity=" + r + ")")
                : (i.filter = n.replace(O, "opacity=" + r)));
        };
        Se("opacity,alpha,autoAlpha", {
          defaultValue: "1",
          parser: function (env, t, i, n, r, a) {
            var ObjectMethodWrapper = parseFloat($(env, "opacity", A, !1, "1")),
              CounterVariable = env.style,
              RandomGenerator = "autoAlpha" === i;
            return (
              "string" == typeof t &&
                "=" === t.charAt(1) &&
                (t =
                  ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + ObjectMethodWrapper),
              RandomGenerator &&
                1 === ObjectMethodWrapper &&
                "hidden" === $(env, "visibility", A) &&
                0 !== t &&
                (ObjectMethodWrapper = 0),
              W
                ? (r = new _e(CounterVariable, "opacity", ObjectMethodWrapper, t - ObjectMethodWrapper, r))
                : (((r = new _e(CounterVariable, "opacity", 100 * ObjectMethodWrapper, 100 * (t - ObjectMethodWrapper), r)).xn1 =
                    RandomGenerator ? 1 : 0),
                  (CounterVariable.zoom = 1),
                  (r.type = 2),
                  (r.b = "alpha(opacity=" + r.CounterVariable + ")"),
                  (r.env = "alpha(opacity=" + (r.CounterVariable + r.EnsureFunction) + ")"),
                  (r.data = env),
                  (r.plugin = a),
                  (r.setRatio = ObjectPropertyManager)),
              RandomGenerator &&
                (((r = new _e(
                  CounterVariable,
                  "visibility",
                  0,
                  0,
                  r,
                  -1,
                  null,
                  !1,
                  0,
                  0 !== ObjectMethodWrapper ? "inherit" : "hidden",
                  0 === t ? "hidden" : "inherit",
                )).xs0 = "inherit"),
                n._overwriteProps.push(r.n),
                n._overwriteProps.push(i)),
              r
            );
          },
        });
        var DefinePropertyDescriptor = function (env, t) {
            t &&
              (env.removeProperty
                ? (("ms" !== t.substr(0, 2) && "webkit" !== t.substr(0, 6)) ||
                    (t = "-" + t),
                  env.removeProperty(t.replace(ObjectMethodWrapper, "-$1").toLowerCase()))
                : env.removeAttribute(t));
          },
          DirectPropertyAssignment = function (env) {
            if (((this.t._gsClassPT = this), 1 === env || 0 === env)) {
              this.t.setAttribute("class", 0 === env ? this.b : this.env);
              for (var t = this.data, i = this.t.style; t; )
                t.Value ? (i[t.Property] = t.Value) : DefinePropertyDescriptor(i, t.Property), (t = t._next);
              1 === env &&
                this.t._gsClassPT === this &&
                (this.t._gsClassPT = null);
            } else
              this.t.getAttribute("class") !== this.env &&
                this.t.setAttribute("class", this.env);
          };
        Se("className", {
          parser: function (env, t, i, n, r, a, ObjectMethodWrapper) {
            var CounterVariable,
              RandomGenerator,
              HelperFunction,
              EnsureFunction,
              GlobalReference,
              Property = env.getAttribute("class") || "",
              MathFloorShortcut = env.style.cssText;
            if (
              (((r = n._classNamePT = new _e(env, i, 0, 0, r, 2)).setRatio = DirectPropertyAssignment),
              (r.SetDifference = -11),
              (f = !0),
              (r.b = Property),
              (RandomGenerator = ie(env, A)),
              (HelperFunction = env._gsClassPT))
            ) {
              for (EnsureFunction = {}, GlobalReference = HelperFunction.data; GlobalReference; ) (EnsureFunction[GlobalReference.Property] = 1), (GlobalReference = GlobalReference._next);
              HelperFunction.setRatio(1);
            }
            return (
              ((env._gsClassPT = r).env =
                "=" !== t.charAt(1)
                  ? t
                  : Property.replace(
                      new RegExp("(?:\\CounterVariable|^)" + t.substr(2) + "(?![\\w-])"),
                      "",
                    ) + ("+" === t.charAt(0) ? " " + t.substr(2) : "")),
              env.setAttribute("class", r.env),
              (CounterVariable = ne(env, RandomGenerator, ie(env), ObjectMethodWrapper, EnsureFunction)),
              env.setAttribute("class", Property),
              (r.data = CounterVariable.firstMPT),
              (env.style.cssText = MathFloorShortcut),
              (r = r.xfirst = n.parse(env, CounterVariable.difs, r, a))
            );
          },
        });
        var HasOwnProperty = function (env) {
          if (
            (1 === env || 0 === env) &&
            this.data._totalTime === this.data._totalDuration &&
            "isFromStart" !== this.data.data
          ) {
            var t,
              i,
              n,
              r,
              a,
              ObjectMethodWrapper = this.t.style,
              CounterVariable = g.transform.parse;
            if ("all" === this.env) r = !(ObjectMethodWrapper.cssText = "");
            else
              for (
                n = (t = this.env.split(" ").join("").split(",")).length;
                -1 < --n;

              )
                (i = t[n]),
                  g[i] &&
                    (g[i].parse === CounterVariable
                      ? (r = !0)
                      : (i = "transformOrigin" === i ? Fe : g[i].Property)),
                  DefinePropertyDescriptor(ObjectMethodWrapper, i);
            r &&
              (DefinePropertyDescriptor(ObjectMethodWrapper, Re),
              (a = this.t._gsTransform) &&
                (a.svg &&
                  (this.t.removeAttribute("data-svg-origin"),
                  this.t.removeAttribute("transform")),
                delete this.t._gsTransform));
          }
        };
        for (
          Se("clearProps", {
            parser: function (env, t, i, n, r) {
              return (
                ((r = new _e(env, i, 0, 0, r, 2)).setRatio = HasOwnProperty),
                (r.env = t),
                (r.SetDifference = -10),
                (r.data = n._tween),
                (f = !0),
                r
              );
            },
          }),
            env = "bezier,throwProps,physicsProps,physics2D".split(","),
            we = env.length;
          we--;

        )
          Ee(env[we]);
        ((env = B.prototype)._firstPT =
          env._lastParsedTransform =
          env._transform =
            null),
          (env._onInitTween = function (env, t, i, n) {
            if (!env.nodeType) return !1;
            (this._target = P = env),
              (this._tween = i),
              (this._vars = t),
              (L = n),
              (M = t.autoRound),
              (f = !1),
              (EnsureObject = t.suffixMap || B.suffixMap),
              (A = ArrayOrStringObject(env, "")),
              (ModuleMeta = this._overwriteProps);
            var r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator,
              HelperFunction,
              EnsureFunction,
              GlobalReference,
              Property,
              MathFloorShortcut = env.style;
            if (
              (Value &&
                "" === MathFloorShortcut.zIndex &&
                (("auto" !== (r = $(env, "zIndex", A)) && "" !== r) ||
                  this._addLazySet(MathFloorShortcut, "zIndex", 0)),
              "string" == typeof t &&
                ((CounterVariable = MathFloorShortcut.cssText),
                (r = ie(env, A)),
                (MathFloorShortcut.cssText = CounterVariable + ";" + t),
                (r = ne(env, r, ie(env)).difs),
                !W && b.test(t) && (r.opacity = parseFloat(RegExp.$1)),
                (t = r),
                (MathFloorShortcut.cssText = CounterVariable)),
              t.className
                ? (this._firstPT = a =
                    g.className.parse(
                      env,
                      t.className,
                      "className",
                      this,
                      null,
                      null,
                      t,
                    ))
                : (this._firstPT = a = this.parse(env, t, null)),
              this._transformType)
            ) {
              for (
                Property = 3 === this._transformType,
                  Re
                    ? y &&
                      ((Value = !0),
                      "" === MathFloorShortcut.zIndex &&
                        (("auto" !== (EnsureFunction = $(env, "zIndex", A)) && "" !== EnsureFunction) ||
                          this._addLazySet(MathFloorShortcut, "zIndex", 0)),
                      _ &&
                        this._addLazySet(
                          MathFloorShortcut,
                          "WebkitBackfaceVisibility",
                          this._vars.WebkitBackfaceVisibility ||
                            (Property ? "visible" : "hidden"),
                        ))
                    : (MathFloorShortcut.zoom = 1),
                  ObjectMethodWrapper = a;
                ObjectMethodWrapper && ObjectMethodWrapper._next;

              )
                ObjectMethodWrapper = ObjectMethodWrapper._next;
              (GlobalReference = new _e(env, "transform", 0, 0, null, 2)),
                this._linkCSSP(GlobalReference, null, ObjectMethodWrapper),
                (GlobalReference.setRatio = Re ? PrimitiveConversion : SupportsDefineProperty ),
                (GlobalReference.data = this._transform || TryCatch(env, A, !0)),
                (GlobalReference.tween = i),
                (GlobalReference.SetDifference = -1),
                ModuleMeta.pop();
            }
            if (f) {
              for (; a; ) {
                for (HelperFunction = a._next, ObjectMethodWrapper = CounterVariable; ObjectMethodWrapper && ObjectMethodWrapper.SetDifference > a.SetDifference; ) ObjectMethodWrapper = ObjectMethodWrapper._next;
                (a._prev = ObjectMethodWrapper ? ObjectMethodWrapper._prev : RandomGenerator) ? (a._prev._next = a) : (CounterVariable = a),
                  (a._next = ObjectMethodWrapper) ? (ObjectMethodWrapper._prev = a) : (RandomGenerator = a),
                  (a = HelperFunction);
              }
              this._firstPT = CounterVariable;
            }
            return !0;
          }),
          (env.parse = function (env, t, i, n) {
            var r,
              a,
              ObjectMethodWrapper,
              CounterVariable,
              RandomGenerator,
              HelperFunction,
              EnsureFunction,
              GlobalReference,
              Property,
              MathFloorShortcut,
              f = env.style;
// پردازش خواص و انیمیشن‌های تعریف شده برای یک عنصر در یک حلقه

for (r in t) {
  var HelperFunction;

  // اگر مقدار ویژگی یک تابع باشد، آن را فراخوانی کنید
  if (
    "function" == typeof (HelperFunction = t[r]) &&
    (HelperFunction = HelperFunction(L, P)),
    (a = g[r]) // بررسی اگر ویژگی توسط یک پلاگین خاص مدیریت می‌شود
  ) {
    // اگر ویژگی توسط یک پلاگین پشتیبانی شود، مقدار آن را پردازش کنید
    i = a.parse(env, HelperFunction, r, this, i, n, t);
  } else {
    // اگر ویژگی با "--" شروع شود، به عنوان یک متغیر CSS در نظر گرفته می‌شود
    if ("--" === r.substr(0, 2)) {
      // ایجاد یک انیمیشن برای متغیر CSS با استفاده از متد‌های کتابخانه انیمیشن
      this._tween._propLookup[r] = this._addTween.call(
        this._tween,
        env.style,
        "setProperty",
        ArrayOrStringObject(env).getPropertyValue(r) + "", // مقدار اولیه متغیر
        HelperFunction + "", // مقدار هدف متغیر
        r, // نام متغیر
        !1,
        r
      );
      continue;
    }

    // دریافت مقدار اولیه ویژگی
    (RandomGenerator = $(env, r, A) + ""),
      (Property = "string" == typeof HelperFunction); // بررسی اینکه مقدار هدف یک رشته است یا خیر

    // بررسی اینکه آیا ویژگی مربوط به رنگ است
    if (
      "color" === r ||
      "fill" === r ||
      "stroke" === r ||
      -1 !== r.indexOf("Color") ||
      (Property && w.test(HelperFunction))
    ) {
      Property ||
        (HelperFunction =
          (3 < (HelperFunction = de(HelperFunction)).length ? "rgba(" : "rgb(") +
          HelperFunction.join(",") +
          ")");
      i = be(f, r, RandomGenerator, HelperFunction, !0, "transparent", i, 0, n);
    }
    // بررسی اگر ویژگی شامل واحد‌های اندازه‌گیری است
    else if (Property && Key.test(HelperFunction)) {
      i = be(f, r, RandomGenerator, HelperFunction, !0, null, i, 0, n);
    }
    // مدیریت ویژگی‌های دیگر
    else {
      // تجزیه مقدار اولیه و محاسبه واحد‌های مورد نظر
      var EnsureFunction = (ObjectMethodWrapper = parseFloat(RandomGenerator)) || 0 === ObjectMethodWrapper
        ? RandomGenerator.substr((ObjectMethodWrapper + "").length)
        : "";

      // مدیریت ویژگی‌های خاص مانند عرض، ارتفاع، چپ و بالا
      if (
        ("" !== RandomGenerator && "auto" !== RandomGenerator) ||
        (EnsureFunction =
          "width" === r || "height" === r
            ? ((ObjectMethodWrapper = oe(env, r, A)), "px")
            : "left" === r || "top" === r
            ? ((ObjectMethodWrapper = LastIndexOfElement(env, r, A)), "px")
            : ((ObjectMethodWrapper = "opacity" !== r ? 0 : 1), ""))
      ) {
        // منطق تبدیل واحد‌ها و انجام انیمیشن
        i = new _e(
          f,
          r,
          ObjectMethodWrapper,
          CounterVariable - ObjectMethodWrapper,
          i,
          0,
          r,
          !1 !== M && ("px" === GlobalReference || "zIndex" === r),
          0,
          RandomGenerator,
          HelperFunction
        );
        i.xs0 = GlobalReference;
      }
    }
  }

  // اضافه کردن پلاگین اگر تعریف شده باشد
  n && i && !i.plugin && (i.plugin = n);
}

            return i;
          }),
          (env.setRatio = function (env) {
            var t,
              i,
              n,
              r = this._firstPT;
            if (
              1 !== env ||
              (this._tween._time !== this._tween._duration &&
                0 !== this._tween._time)
            )
              if (
                env ||
                (this._tween._time !== this._tween._duration &&
                  0 !== this._tween._time) ||
                -1e-6 === this._tween._rawPrevTime
              )
                for (; r; ) {
                  if (
                    ((t = r.EnsureFunction * env + r.CounterVariable),
                    r.r ? (t = r.r(t)) : t < 1e-6 && -1e-6 < t && (t = 0),
                    r.type)
                  )
                    if (1 === r.type)
                      if (2 === (n = r.RandomGenerator))
                        r.t[r.Property] = r.xs0 + t + r.xs1 + r.xn1 + r.xs2;
                      else if (3 === n)
                        r.t[r.Property] =
                          r.xs0 + t + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3;
                      else if (4 === n)
                        r.t[r.Property] =
                          r.xs0 +
                          t +
                          r.xs1 +
                          r.xn1 +
                          r.xs2 +
                          r.xn2 +
                          r.xs3 +
                          r.xn3 +
                          r.xs4;
                      else if (5 === n)
                        r.t[r.Property] =
                          r.xs0 +
                          t +
                          r.xs1 +
                          r.xn1 +
                          r.xs2 +
                          r.xn2 +
                          r.xs3 +
                          r.xn3 +
                          r.xs4 +
                          r.xn4 +
                          r.xs5;
                      else {
                        for (i = r.xs0 + t + r.xs1, n = 1; n < r.RandomGenerator; n++)
                          i += r["xn" + n] + r["xs" + (n + 1)];
                        r.t[r.Property] = i;
                      }
                    else
                      -1 === r.type
                        ? (r.t[r.Property] = r.xs0)
                        : r.setRatio && r.setRatio(env);
                  else r.t[r.Property] = t + r.xs0;
                  r = r._next;
                }
              else
                for (; r; )
                  2 !== r.type ? (r.t[r.Property] = r.b) : r.setRatio(env),
                    (r = r._next);
            else
              for (; r; ) {
                if (2 !== r.type)
                  if (r.r && -1 !== r.type)
                    if (((t = r.r(r.CounterVariable + r.EnsureFunction)), r.type)) {
                      if (1 === r.type) {
                        for (
                          n = r.RandomGenerator, i = r.xs0 + t + r.xs1, n = 1;
                          n < r.RandomGenerator;
                          n++
                        )
                          i += r["xn" + n] + r["xs" + (n + 1)];
                        r.t[r.Property] = i;
                      }
                    } else r.t[r.Property] = t + r.xs0;
                  else r.t[r.Property] = r.env;
                else r.setRatio(env);
                r = r._next;
              }
          }),
          (env._enableTransforms = function (env) {
            (this._transform = this._transform || TryCatch(this._target, A, !0)),
              (this._transformType =
                (this._transform.svg && Ae) || (!env && 3 !== this._transformType)
                  ? 2
                  : 3);
          });
        var UniqueSymbolGenerator = function (env) {
          (this.t[this.Property] = this.env),
            this.data._linkCSSP(this, this._next, null, !0);
        };
        (env._addLazySet = function (env, t, i) {
          var n = (this._firstPT = new _e(env, t, 0, 0, this._firstPT, 2));
          (n.env = i), (n.setRatio = UniqueSymbolGenerator), (n.data = this);
        }),
          (env._linkCSSP = function (env, t, i, n) {
            return (
              env &&
                (t && (t._prev = env),
                env._next && (env._next._prev = env._prev),
                env._prev
                  ? (env._prev._next = env._next)
                  : this._firstPT === env &&
                    ((this._firstPT = env._next), (n = !0)),
                i
                  ? (i._next = env)
                  : n || null !== this._firstPT || (this._firstPT = env),
                (env._next = t),
                (env._prev = i)),
              env
            );
          }),
          (env._mod = function (env) {
            for (var t = this._firstPT; t; )
              "function" == typeof env[t.Property] && (t.r = env[t.Property]), (t = t._next);
          }),
          (env._kill = function (env) {
            var t,
              i,
              n,
              r = env;
            if (env.autoAlpha || env.alpha) {
              for (i in ((r = {}), env)) r[i] = env[i];
              (r.opacity = 1), r.autoAlpha && (r.visibility = 1);
            }
            for (
              env.className &&
                (t = this._classNamePT) &&
                ((n = t.xfirst) && n._prev
                  ? this._linkCSSP(n._prev, t._next, n._prev._prev)
                  : n === this._firstPT && (this._firstPT = t._next),
                t._next && this._linkCSSP(t._next, t._next._next, n._prev),
                (this._classNamePT = null)),
                t = this._firstPT;
              t;

            )
              t.plugin &&
                t.plugin !== i &&
                t.plugin._kill &&
                (t.plugin._kill(env), (i = t.plugin)),
                (t = t._next);
            return ks.prototype._kill.call(this, r);
          });
// تعریف تابع BindFunction برای بازگرداندن عناصر از یک ساختار DOM و اضافه کردن آنها به آرایه‌ها

var BindFunction = function (env, t, i) {
  var n, r, a, ObjectMethodWrapper;

  // بررسی اینکه env یک آرایه است و بازگشت بازگشتی بر روی عناصر آن
  if (env.slice) {
    for (r = env.length; -1 < --r; ) {
      BindFunction(env[r], t, i);
    }
  } else {
    // اگر env یک گره DOM باشد، بررسی گره‌های فرزند آن
    for (r = (n = env.childNodes).length; -1 < --r; ) {
      (ObjectMethodWrapper = (a = n[r]).type), // نوع گره فرزند
        a.style && (t.push(ie(a)), i && i.push(a)), // اضافه کردن گره‌هایی که دارای style هستند به آرایه‌ها
        // بررسی نوع گره و ادامه بازگشت در صورت داشتن فرزندان
        (1 !== ObjectMethodWrapper && 9 !== ObjectMethodWrapper && 11 !== ObjectMethodWrapper) ||
          !a.childNodes.length ||
          BindFunction(a, t, i);
    }
  }
};

// تابع cascadeTo برای انیمیشن و بازگشت وضعیت یک مجموعه DOM
return (
  (B.cascadeTo = function (env, t, i) {
    var n,
      r,
      a,
      ObjectMethodWrapper,
      CounterVariable = Ss.to(env, t, i), // ایجاد انیمیشن اولیه
      RandomGenerator = [CounterVariable], // ذخیره مرجع انیمیشن اولیه
      HelperFunction = [], // آرایه برای ذخیره استایل‌های هدف
      EnsureFunction = [], // آرایه برای ذخیره وضعیت‌های قبل از شروع انیمیشن
      GlobalReference = [], // آرایه برای ذخیره عناصر DOM
      Property = Ss._internals.reservedProps; // دسترسی به خصوصیات رزرو شده انیمیشن

    // استخراج عناصر DOM و استایل‌های مرتبط برای انیمیشن
    for (
      env = CounterVariable._targets || CounterVariable.target, // گرفتن اهداف انیمیشن
        BindFunction(env, HelperFunction, GlobalReference), // پر کردن HelperFunction و GlobalReference با اهداف انیمیشن
        CounterVariable.render(t, !0, !0), // اجرای انیمیشن تا زمان مشخص‌شده
        BindFunction(env, EnsureFunction), // ذخیره وضعیت جدید اهداف
        CounterVariable.render(0, !0, !0), // بازگشت انیمیشن به وضعیت اولیه
        CounterVariable._enabled(!0), // فعال‌سازی انیمیشن
        n = GlobalReference.length;
              -1 < --n;

            )
              if ((r = ne(GlobalReference[n], HelperFunction[n], EnsureFunction[n])).firstMPT) {
                for (a in ((r = r.difs), i)) Property[a] && (r[a] = i[a]);
                for (a in ((ObjectMethodWrapper = {}), r)) ObjectMethodWrapper[a] = HelperFunction[n][a];
                RandomGenerator.push(Ss.fromTo(GlobalReference[n], t, ObjectMethodWrapper, r));
              }
            return RandomGenerator;
          }),
          ks.activate([B]),
          B
        );
      },
      !0,
    );
  Es.CSSPlugin;
  var _w = (Ts.document || {}).documentElement,
    xw = Ts,
    bw = function (env, t) {
      var i = "x" === t ? "Width" : "Height",
        n = "scroll" + i,
        r = "client" + i,
        a = document.body;
      return env === xw || env === _w || env === a
        ? Math.max(_w[n], a[n]) - (xw["inner" + i] || _w[r] || a[r])
        : env[n] - env["offset" + i];
    },
    WrapperUtility = function (env, t) {
      var i = "scroll" + ("x" === t ? "Left" : "Top");
      return (
        env === xw &&
          (null != env.pageXOffset
            ? (i = "page" + t.toUpperCase() + "Offset")
            : (env = null != _w[i] ? _w : document.body)),
        function () {
          return env[i];
        }
      );
    },
    Tw = function (env, t) {
      var i,
        n = ((i = env),
        "string" == typeof i && (i = TweenLite.selector(i)),
        i.length && i !== xw && i[0] && i[0].style && !i.nodeType && (i = i[0]),
        i === xw || (i.nodeType && i.style) ? i : null).getBoundingClientRect(),
        r = document.body,
        a = !t || t === xw || t === r,
        ObjectMethodWrapper = a
          ? {
              top:
                _w.clientTop -
                (window.pageYOffset || _w.scrollTop || r.scrollTop || 0),
              left:
                _w.clientLeft -
                (window.pageXOffset || _w.scrollLeft || r.scrollLeft || 0),
            }
          : t.getBoundingClientRect(),
        CounterVariable = { x: n.left - ObjectMethodWrapper.left, y: n.top - ObjectMethodWrapper.top };
      return !a && t && ((CounterVariable.x += WrapperUtility(t, "x")()), (CounterVariable.y += WrapperUtility(t, "y")())), CounterVariable;
    },
    Sw = function (env, t, i) {
      var n = typeof env;
      return isNaN(env)
        ? "number" === n || ("string" === n && "=" === env.charAt(1))
          ? env
          : "max" === env
            ? bw(t, i)
            : Math.min(bw(t, i), Tw(env, t)[i])
        : parseFloat(env);
    },
    Ew = Ts._gsDefine.plugin({
      propName: "scrollTo",
      API: 2,
      global: !0,
      version: "1.9.1",
      init: function (env, t, i) {
        return (
          (this._wdw = env === xw),
          (this._target = env),
          (this._tween = i),
          "object" != typeof t
            ? "string" == typeof (t = { y: t }).y &&
              "max" !== t.y &&
              "=" !== t.y.charAt(1) &&
              (t.x = t.y)
            : t.nodeType &&
              (t = {
                y: t,
                x: t,
              }),
          (this.vars = t),
          (this._autoKill = !1 !== t.autoKill),
          (this.getX = WrapperUtility(env, "x")),
          (this.getY = WrapperUtility(env, "y")),
          (this.x = this.xPrev = this.getX()),
          (this.y = this.yPrev = this.getY()),
          null != t.x
            ? (this._addTween(
                this,
                "x",
                this.x,
                Sw(t.x, env, "x") - (t.offsetX || 0),
                "scrollTo_x",
                !0,
              ),
              this._overwriteProps.push("scrollTo_x"))
            : (this.skipX = !0),
          null != t.y
            ? (this._addTween(
                this,
                "y",
                this.y,
                Sw(t.y, env, "y") - (t.offsetY || 0),
                "scrollTo_y",
                !0,
              ),
              this._overwriteProps.push("scrollTo_y"))
            : (this.skipY = !0),
          !0
        );
      },
// تنظیم‌کننده برای مقادیر موقعیت و مدیریت رفتار خودکار
set: function (env) {
  // تنظیم نسبت جدید از طریق فراخوانی متد والد
  this._super.setRatio.call(this, env);

  // مقداردهی به موقعیت x و y بر اساس شرایط
  var t = this._wdw || !this.skipX ? this.getX() : this.xPrev, // مقدار X جدید یا مقدار قبلی در صورت رد کردن
      i = this._wdw || !this.skipY ? this.getY() : this.yPrev, // مقدار Y جدید یا مقدار قبلی در صورت رد کردن
      n = i - this.yPrev, // تغییر در موقعیت Y
      r = t - this.xPrev, // تغییر در موقعیت X
      a = Ew.autoKillThreshold; // مقدار آستانه برای حذف خودکار

  // جلوگیری از قرار گرفتن مقادیر X و Y در مقادیر منفی
  if (this.x < 0) this.x = 0;
  if (this.y < 0) this.y = 0;

  // اگر ویژگی autoKill فعال باشد
  if (this._autoKill) {
    // بررسی تغییر در موقعیت X و مقایسه با آستانه
    if (
      !this.skipX &&
      (a < r || r < -a) &&
      t < bw(this._target, "x") // بررسی موقعیت جدید با مقدار هدف
    ) {
      this.skipX = !0; // رد کردن موقعیت X
    }

    // بررسی تغییر در موقعیت Y و مقایسه با آستانه
    if (
      !this.skipY &&
      (a < n || n < -a) &&
      i < bw(this._target, "y") // بررسی موقعیت جدید با مقدار هدف
    ) {
      this.skipY = !0; // رد کردن موقعیت Y
    }

    // اگر هر دو محور X و Y رد شوند
    if (this.skipX && this.skipY) {
      this._tween.kill(); // متوقف کردن انیمیشن
      if (this.vars.onAutoKill) {
        // اگر یک callback برای autoKill تعریف شده باشد، آن را فراخوانی کن
        this.vars.onAutoKill.apply(
          this.vars.onAutoKillScope || this._tween, // استفاده از scope مناسب
          this.vars.onAutoKillParams || [] // ارسال پارامترها
        );
      }
    }
  }

  // به‌روزرسانی مقادیر اسکرول بر اساس شرایط
  if (this._wdw) {
    // اگر عنصر پنجره باشد
    xw.scrollTo(this.skipX ? t : this.x, this.skipY ? i : this.y); // تنظیم اسکرول پنجره
  } else {
    // اگر عنصر پنجره نباشد
    if (!this.skipY) this._target.scrollTop = this.y; // تنظیم موقعیت Y
    if (!this.skipX) this._target.scrollLeft = this.x; // تنظیم موقعیت X
  }

  // ذخیره مقادیر فعلی برای استفاده در مقایسه بعدی
  this.xPrev = this.x;
  this.yPrev = this.y;
      },
    }),
    Aw = Ew.prototype;
  (Ew.max = bw),
    (Ew.getOffset = Tw),
    (Ew.buildGetter = WrapperUtility),
    (Ew.autoKillThreshold = 7),
    (Aw._kill = function (env) {
      return (
        env.scrollTo_x && (this.skipX = !0),
        env.scrollTo_y && (this.skipY = !0),
        this._super._kill.call(this, env)
      );
    });
  var Mw =
      Array.isArray ||
      function (env) {
        return "[object Array]" == Object.prototype.toString.call(env);
      },
    Pw = Bw,
    Lw = Fw,
    Cw = function (env) {
      return Nw(Fw(env));
    },
    Iw = Nw,
    Rw = zw,
    Ow = new RegExp(
      [
        "(\\\\.)",
        "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))",
      ].join("|"),
      "g",
    );

  function Fw(env) {
    for (var t, i, n = [], r = 0, a = 0, ObjectMethodWrapper = ""; null != (t = Ow.exec(env)); ) {
      var CounterVariable = t[0],
        RandomGenerator = t[1],
        HelperFunction = t.index;
      if (((ObjectMethodWrapper += env.slice(a, HelperFunction)), (a = HelperFunction + CounterVariable.length), RandomGenerator)) ObjectMethodWrapper += RandomGenerator[1];
      else {
        ObjectMethodWrapper && (n.push(ObjectMethodWrapper), (ObjectMethodWrapper = ""));
        var EnsureFunction = t[2],
          GlobalReference = t[3],
          Property = t[4],
          MathFloorShortcut = t[5],
          f = t[6],
          ModuleMeta = t[7],
          g = "+" === f || "*" === f,
          Value = "?" === f || "*" === f,
          y = EnsureFunction || "/",
          _ = Property || MathFloorShortcut || (ModuleMeta ? ".*" : "[^" + y + "]+?");
        n.push({
          name: GlobalReference || r++,
          prefix: EnsureFunction || "",
          delimiter: y,
          optional: Value,
          repeat: g,
          pattern: ((i = _), i.replace(/([=!:$\/()])/g, "\\$1")),
        });
      }
    }
    return a < env.length && (ObjectMethodWrapper += env.substr(a)), ObjectMethodWrapper && n.push(ObjectMethodWrapper), n;
  }

  function Nw(RandomGenerator) {
    for (var HelperFunction = new Array(RandomGenerator.length), env = 0; env < RandomGenerator.length; env++)
      "object" == typeof RandomGenerator[env] && (HelperFunction[env] = new RegExp("^" + RandomGenerator[env].pattern + "$"));
    return function (env) {
      for (var t = "", i = env || {}, n = 0; n < RandomGenerator.length; n++) {
        var r = RandomGenerator[n];
        if ("string" != typeof r) {
          var a,
            ObjectMethodWrapper = i[r.name];
          if (null == ObjectMethodWrapper) {
            if (r.optional) continue;
            throw new TypeError('Expected "' + r.name + '" to be defined');
          }
          if (Mw(ObjectMethodWrapper)) {
            if (!r.repeat)
              throw new TypeError(
                'Expected "' +
                  r.name +
                  '" to not repeat, but received "' +
                  ObjectMethodWrapper +
                  '"',
              );
            if (0 === ObjectMethodWrapper.length) {
              if (r.optional) continue;
              throw new TypeError('Expected "' + r.name + '" to not be empty');
            }
            for (var CounterVariable = 0; CounterVariable < ObjectMethodWrapper.length; CounterVariable++) {
              if (((a = encodeURIComponent(ObjectMethodWrapper[CounterVariable])), !HelperFunction[n].test(a)))
                throw new TypeError(
                  'Expected all "' +
                    r.name +
                    '" to match "' +
                    r.pattern +
                    '", but received "' +
                    a +
                    '"',
                );
              t += (0 === CounterVariable ? r.prefix : r.delimiter) + a;
            }
          } else {
            if (((a = encodeURIComponent(ObjectMethodWrapper)), !HelperFunction[n].test(a)))
              throw new TypeError(
                'Expected "' +
                  r.name +
                  '" to match "' +
                  r.pattern +
                  '", but received "' +
                  a +
                  '"',
              );
            t += r.prefix + a;
          }
        } else t += r;
      }
      return t;
    };
  }

  function kw(env) {
    return env.replace(/([.+*?=^!:${}()[\]|\/])/g, "\\$1");
  }

  function Uw(env, t) {
    return (env.keys = t), env;
  }

  function Dw(env) {
    return env.sensitive ? "" : "i";
  }

  function zw(env, t) {
    for (
      var i = (t = t || {}).strict,
        n = !1 !== t.end,
        r = "",
        a = env[env.length - 1],
        ObjectMethodWrapper = "string" == typeof a && /\/$/.test(a),
        CounterVariable = 0;
      CounterVariable < env.length;
      CounterVariable++
    ) {
      var RandomGenerator = env[CounterVariable];
      if ("string" == typeof RandomGenerator) r += kw(RandomGenerator);
      else {
        var HelperFunction = kw(RandomGenerator.prefix),
          EnsureFunction = RandomGenerator.pattern;
        RandomGenerator.repeat && (EnsureFunction += "(?:" + HelperFunction + EnsureFunction + ")*"),
          (r += EnsureFunction =
            RandomGenerator.optional
              ? HelperFunction
                ? "(?:" + HelperFunction + "(" + EnsureFunction + "))?"
                : "(" + EnsureFunction + ")?"
              : HelperFunction + "(" + EnsureFunction + ")");
      }
    }
    return (
      i || (r = (ObjectMethodWrapper ? r.slice(0, -2) : r) + "(?:\\/(?=$))?"),
      (r += n ? "$" : i && ObjectMethodWrapper ? "" : "(?=\\/|$)"),
      new RegExp("^" + r, Dw(t))
    );
  }

  function Bw(env, t, i) {
    return (
      Mw((t = t || [])) ? i || (i = {}) : ((i = t), (t = [])),
      env instanceof RegExp
        ? (function (env, t) {
            var i = env.source.match(/\((?!\?)/g);
            if (i)
              for (var n = 0; n < i.length; n++)
                t.push({
                  name: n,
                  prefix: null,
                  delimiter: null,
                  optional: !1,
                  repeat: !1,
                  pattern: null,
                });
            return Uw(env, t);
          })(env, t)
        : Mw(env)
          ? (function (env, t, i) {
              for (var n = [], r = 0; r < env.length; r++)
                n.push(Bw(env[r], t, i).source);
              return Uw(new RegExp("(?:" + n.join("|") + ")", Dw(i)), t);
            })(env, t, i)
          : (function (env, t, i) {
              for (var n = Fw(env), r = zw(n, i), a = 0; a < n.length; a++)
                "string" != typeof n[a] && t.push(n[a]);
              return Uw(r, t);
            })(env, t, i)
    );
  }

  (Pw.parse = Lw),
    (Pw.compile = Cw),
    (Pw.tokensToFunction = Iw),
    (Pw.tokensToRegExp = Rw);
var Hw,
  Gw = "undefined" != typeof document, // بررسی وجود سند HTML
  jw = "undefined" != typeof window, // بررسی وجود شیء window
  Vw = "undefined" != typeof history, // بررسی وجود تاریخچه مرورگر
  Xw = "undefined" != typeof process, // بررسی وجود شیء process (برای Node.js)
  Ww = Gw && document.ontouchstart ? "touchstart" : "click", // تعیین نوع رویداد کلیک یا لمس
  Yw = jw && !(!window.history.location && !window.location); // بررسی پشتیبانی مرورگر از مسیریابی


function qw() {
  (this.callbacks = []), // لیست توابع مسیریابی
    (this.exits = []), // لیست توابع خروج از مسیر
    (this.current = ""), // مسیر فعلی
    (this.len = 0), // تعداد مسیرها
    (this._decodeURLComponents = !0), // تنظیم نحوه رمزگشایی URL
    (this._base = ""), // مسیر پایه
    (this._strict = !1), // حالت strict
    (this._running = !1), // وضعیت اجرای مسیریاب
    (this._hashbang = !1), // استفاده از hashbang
    (this.clickHandler = this.clickHandler.bind(this)), // متصل کردن تابع کلیک
    (this._onpopstate = this._onpopstate.bind(this)); // متصل کردن رویداد popstate
}


function Qw(env, t) {
  if ("function" == typeof env) return Qw.call(this, "*", env); // ثبت تابع مسیریابی عمومی
  if ("function" == typeof t) {
    for (var i = new Jw(env, null, this), n = 1; n < arguments.length; ++n)
      this.callbacks.push(i.middleware(arguments[n])); // اضافه کردن توابع به مسیریاب
  } else {
    "string" == typeof env
      ? this["string" == typeof t ? "redirect" : "show"](env, t) // مدیریت مسیر
      : this.start(env); // شروع مسیریاب
  }
}


function Zw(env, t, i) {
  var n = (this.page = i || Qw), // ذخیره صفحه مرتبط
    r = n._window, // ذخیره شیء window
    a = n._hashbang, // تنظیم hashbang
    ObjectMethodWrapper = n._getBase(); // گرفتن مسیر پایه

  // تنظیم مسیر
  "/" === env[0] &&
    0 !== env.indexOf(ObjectMethodWrapper) &&
    (env = ObjectMethodWrapper + (a ? "#!" : "") + env);

  var CounterVariable = env.indexOf("?");

  // تعیین مسیرها و query string
  (this.canonicalPath = env), // مسیر کامل
    (this.path = env.replace(ObjectMethodWrapper, "") || "/"), // مسیر بدون base
    a && (this.path = this.path.replace("#!", "") || "/"), // حذف hashbang
    (this.title = Gw && r.document.title), // عنوان صفحه
    (this.state = t || {}), // ذخیره state
    (this.state.path = env),
    (this.querystring = ~CounterVariable
      ? n._decodeURLEncodedURIComponent(env.slice(CounterVariable + 1)) // استخراج query string
      : ""),
    (this.pathname = n._decodeURLEncodedURIComponent(~CounterVariable ? env.slice(0, CounterVariable) : env)), // مسیر بدون query string
    (this.params = {}), // پارامترهای مسیر
    (this.hash = ""); // hash مسیر

  if (!a) {
    if (!~this.path.indexOf("#")) return;
    var RandomGenerator = this.path.split("#");
    (this.path = this.pathname = RandomGenerator[0]), // بخش مسیر
      (this.hash = n._decodeURLEncodedURIComponent(RandomGenerator[1]) || ""), // بخش hash
      (this.querystring = this.querystring.split("#")[0]); // پاکسازی query string از hash
  }
}


function Jw(env, t, i) {
  this.page = i || Kw; // تعیین صفحه (یا استفاده از مقدار پیش‌فرض)
  var n = t || {};
  (n.strict = n.strict || i._strict), // تنظیم حالت strict از تنظیمات
    (this.path = "*" === env ? "(.*)" : env), // تنظیم مسیر (برای همه مسیرها از "(.*)" استفاده می‌شود)
    (this.method = "GET"), // روش HTTP پیش‌فرض
    (this.regexp = Pw(this.path, (this.keys = []), n)); // ایجاد الگوی regex برای مسیر
}


  (qw.prototype.configure = function (env) {
    var t = env || {};
    (this._window = t.window || (jw && window)),
      (this._decodeURLComponents = !1 !== t.decodeURLComponents),
      (this._popstate = !1 !== t.popstate && jw),
      (this._click = !1 !== t.click && Gw),
      (this._hashbang = !!t.hashbang);
    var i = this._window;
    this._popstate
      ? i.addEventListener("popstate", this._onpopstate, !1)
      : jw && i.removeEventListener("popstate", this._onpopstate, !1),
      this._click
        ? i.document.addEventListener(Ww, this.clickHandler, !1)
        : Gw && i.document.removeEventListener(Ww, this.clickHandler, !1),
      this._hashbang && jw && !Vw
        ? i.addEventListener("hashchange", this._onpopstate, !1)
        : jw && i.removeEventListener("hashchange", this._onpopstate, !1);
  }),
    (qw.prototype.base = function (env) {
      if (0 === arguments.length) return this._base;
      this._base = env;
    }),
    (qw.prototype._getBase = function () {
      var env = this._base;
      if (env) return env;
      var t = jw && this._window && this._window.location;
      return (
        jw && this._hashbang && t && "file:" === t.protocol && (env = t.pathname),
        env
      );
    }),
    (qw.prototype.strict = function (env) {
      if (0 === arguments.length) return this._strict;
      this._strict = env;
    }),
    (qw.prototype.start = function (env) {
      var t = env || {};
      if ((this.configure(t), !1 !== t.dispatch)) {
        var i;
        if (((this._running = !0), Yw)) {
          var n = this._window.location;
          i =
            this._hashbang && ~n.hash.indexOf("#!")
              ? n.hash.substr(2) + n.search
              : this._hashbang
                ? n.search + n.hash
                : n.pathname + n.search + n.hash;
        }
        this.replace(i, null, !0, t.dispatch);
      }
    }),
    (qw.prototype.stop = function () {
      if (this._running) {
        (this.current = ""), (this.len = 0), (this._running = !1);
        var env = this._window;
        this._click &&
          env.document.removeEventListener(Ww, this.clickHandler, !1),
          jw && env.removeEventListener("popstate", this._onpopstate, !1),
          jw && env.removeEventListener("hashchange", this._onpopstate, !1);
      }
    }),
    (qw.prototype.show = function (env, t, i, n) {
      var r = new Zw(env, t, this),
        a = this.prevContext;
      return (
        (this.prevContext = r),
        (this.current = r.path),
        !1 !== i && this.dispatch(r, a),
        !1 !== r.handled && !1 !== n && r.pushState(),
        r
      );
    }),
    (qw.prototype.back = function (env, t) {
      var i = this;
      if (0 < this.len) {
        var n = this._window;
        Vw && n.history.back(), this.len--;
      } else
        env
          ? setTimeout(function () {
              i.show(env, t);
            })
          : setTimeout(function () {
              i.show(i._getBase(), t);
            });
    }),
    (qw.prototype.redirect = function (env, t) {
      var i = this;
      "string" == typeof env &&
        "string" == typeof t &&
        Qw.call(this, env, function (env) {
          setTimeout(function () {
            i.replace(t);
          }, 0);
        }),
        "string" == typeof env &&
          void 0 === t &&
          setTimeout(function () {
            i.replace(env);
          }, 0);
    }),
    (qw.prototype.replace = function (env, t, i, n) {
      var r = new Zw(env, t, this),
        a = this.prevContext;
      return (
        (this.prevContext = r),
        (this.current = r.path),
        (r.init = i),
        r.save(),
        !1 !== n && this.dispatch(r, a),
        r
      );
    }),
    (qw.prototype.dispatch = function (t, i) {
      var n = 0,
        r = 0,
        a = this;

      function ObjectMethodWrapper() {
        var env = a.callbacks[n++];
        if (t.path === a.current)
          return env
            ? void env(t, ObjectMethodWrapper)
            : function (env) {
                if (env.handled) return;
                var t,
                  i = this._window;
                t = this._hashbang
                  ? Yw && this._getBase() + i.location.hash.replace("#!", "")
                  : Yw && i.location.pathname + i.location.search;
                if (t === env.canonicalPath) return;
                this.stop(),
                  (env.handled = !1),
                  Yw && (i.location.href = env.canonicalPath);
              }.call(a, t);
        t.handled = !1;
      }

      i
        ? (function env() {
            var t = a.exits[r++];
            if (!t) return ObjectMethodWrapper();
            t(i, env);
          })()
        : ObjectMethodWrapper();
    }),
// افزودن توابع خروج (exit) به مسیریاب
(qw.prototype.exit = function (env, t) {
  // اگر آرگومان اول یک تابع باشد، آن را به عنوان خروجی برای همه مسیرها (*) اضافه می‌کند
  if ("function" == typeof env) return this.exit("*", env);

  // ایجاد یک مسیر جدید و افزودن میدل‌ویرها (middleware) برای آرگومان‌های ورودی
  for (var i = new Jw(env, null, this), n = 1; n < arguments.length; ++n) {
    this.exits.push(i.middleware(arguments[n]));
  }
}),

// مدیریت رویداد کلیک
(qw.prototype.clickHandler = function (env) {
  // بررسی اینکه دکمه کلیک شده دکمه چپ ماوس است و از کلیدهای کنترلی یا پیشگیری پیش‌فرض استفاده نشده است
  if (
    1 === this._which(env) &&
    !(env.metaKey || env.ctrlKey || env.shiftKey || env.defaultPrevented)
  ) {
    var t = env.target,
      i = env.path || (env.composedPath ? env.composedPath() : null);

    // یافتن لینک (A) در مسیر کلیک
    if (i) {
      for (var n = 0; n < i.length; n++) {
        if (
          i[n].nodeName &&
          "A" === i[n].nodeName.toUpperCase() &&
          i[n].href
        ) {
          t = i[n];
          break;
        }
      }
    }

    // حرکت به سمت بالا در DOM برای یافتن لینک (A)
    for (; t && "A" !== t.nodeName.toUpperCase(); ) t = t.parentNode;

    // پردازش لینک کلیک شده
    if (t && "A" === t.nodeName.toUpperCase()) {
      var r =
        "object" == typeof t.href &&
        "SVGAnimatedString" === t.href.constructor.name;

      // بررسی اینکه لینک برای دانلود یا خارجی نیست
      if (
        !t.hasAttribute("download") &&
        "external" !== t.getAttribute("rel")
      ) {
        var a = t.getAttribute("href");

        // بررسی مسیر و جلوگیری از بارگذاری مجدد صفحه
        if (
          (this._hashbang ||
            !this._samePath(t) ||
            (!t.hash && "#" !== a)) &&
          !(a && -1 < a.indexOf("mailto:")) &&
          (r ? !t.target.baseVal : !t.target) &&
          (r || this.sameOrigin(t.href))
        ) {
          var ObjectMethodWrapper = r
            ? t.href.baseVal
            : t.pathname + t.search + (t.hash || "");

          // اصلاح مسیر در صورت لزوم
          (ObjectMethodWrapper = "/" !== ObjectMethodWrapper[0] ? "/" + ObjectMethodWrapper : ObjectMethodWrapper),
            Xw &&
              ObjectMethodWrapper.match(/^\/[a-zA-Z]:\//) &&
              (ObjectMethodWrapper = ObjectMethodWrapper.replace(/^\/[a-zA-Z]:\//, "/"));

          var CounterVariable = ObjectMethodWrapper,
            RandomGenerator = this._getBase();

          // اگر مسیر جدید متفاوت باشد، مسیر جدید را نمایش می‌دهد
          0 === ObjectMethodWrapper.indexOf(RandomGenerator) && (ObjectMethodWrapper = ObjectMethodWrapper.substr(RandomGenerator.length)),
            this._hashbang && (ObjectMethodWrapper = ObjectMethodWrapper.replace("#!", "")),
            (!RandomGenerator ||
              CounterVariable !== ObjectMethodWrapper ||
              (Yw && "file:" === this._window.location.protocol)) &&
              (env.preventDefault(), this.show(CounterVariable));
        }
      }
    }
  }
}),

// مدیریت تغییرات در تاریخچه مرورگر (popstate)
(qw.prototype._onpopstate =
  ((Hw = !1),
  jw
    ? (Gw && "complete" === document.readyState
        ? (Hw = !0)
        : window.addEventListener("load", function () {
            setTimeout(function () {
              Hw = !0;
            }, 0);
          }),
      function (env) {
        if (Hw)
          if (env.state) {
            // تغییر مسیر با استفاده از state ذخیره‌شده
            var t = env.state.path;
            this.replace(t, env.state);
          } else if (Yw) {
            // نمایش مسیر جدید در صورت استفاده از pushState
            var i = this._window.location;
            this.show(i.pathname + i.search + i.hash, void 0, void 0, !1);
          }
      })
    : function () {})),
    
// تابع کمکی برای یافتن دکمه کلیک‌شده
(qw.prototype._which = function (env) {
  return null == (env = env || (jw && this._window.event)).which
    ? env.button
    : env.which;
}),

// تبدیل یک مسیر به شیء URL
(qw.prototype._toURL = function (env) {
  var t = this._window;
  if ("function" == typeof URL && Yw)
    return new URL(env, t.location.toString());
  if (Gw) {
    var i = t.document.createElement("a");
    return (i.href = env), i;
  }
}),

// بررسی اینکه مسیر مورد نظر از همان منشاء (origin) است
(qw.prototype.sameOrigin = function (env) {
  if (!env || !Yw) return !1;
  var t = this._toURL(env),
    i = this._window.location;
  return (
    i.protocol === t.protocol &&
    i.hostname === t.hostname &&
    i.port === t.port
      );
    }),
    // متد برای تعیین کلید کلیک‌شده یا دکمه ماوس
(qw.prototype._which = function (env) {
  return null == (env = env || (jw && this._window.event)).which
    ? env.button
    : env.which;
}),

// متد برای تبدیل یک رشته به URL
(qw.prototype._toURL = function (env) {
  var t = this._window;
  if ("function" == typeof URL && Yw)
    // اگر API استاندارد URL موجود باشد
    return new URL(env, t.location.toString());
  if (Gw) {
    // در غیر این صورت از عنصر `<a>` برای ساخت URL استفاده می‌کنیم
    var i = t.document.createElement("a");
    return (i.href = env), i;
  }
}),

// بررسی اینکه URL ورودی متعلق به دامنه جاری است یا خیر
(qw.prototype.sameOrigin = function (env) {
  if (!env || !Yw) return !1;
  var t = this._toURL(env),
    i = this._window.location;
  return (
    i.protocol === t.protocol &&
    i.hostname === t.hostname &&
    i.port === t.port
  );
}),

// بررسی اینکه مسیر URL ورودی با مسیر فعلی یکسان است یا خیر
(qw.prototype._samePath = function (env) {
  if (!Yw) return !1;
  var t = this._window.location;
  return env.pathname === t.pathname && env.search === t.search;
}),

// متد برای دی‌کد کردن یک کامپوننت URL که با `encodeURIComponent` کدگذاری شده است
(qw.prototype._decodeURLEncodedURIComponent = function (env) {
  return "string" != typeof env
    ? env
    : this._decodeURLComponents
    ? decodeURIComponent(env.replace(/\+/g, " "))
    : env;
}),

// ذخیره‌سازی وضعیت جدید در تاریخچه مرورگر
(Zw.prototype.pushState = function () {
  var env = this.page,
    t = env._window,
    i = env._hashbang;
  env.len++, // افزایش طول تاریخچه
    Vw &&
      t.history.pushState(
        this.state,
        this.title,
        i && "/" !== this.path ? "#!" + this.path : this.canonicalPath,
      );
}),

// جایگزینی وضعیت جاری در تاریخچه مرورگر
(Zw.prototype.save = function () {
  var env = this.page;
  Vw &&
    "file:" !== env._window.location.protocol &&
    env._window.history.replaceState(
      this.state,
      this.title,
      env._hashbang && "/" !== this.path
        ? "#!" + this.path
        : this.canonicalPath,
    );
}),

// متد برای اجرای یک میان‌افزار بر اساس تطبیق مسیر
(Jw.prototype.middleware = function (i) {
  var n = this;
  return function (env, t) {
    if (n.match(env.path, env.params)) return i(env, t);
    t(); // ادامه اجرای میان‌افزارهای بعدی
  };
}),

// بررسی اینکه مسیر با الگوی مشخص‌شده تطابق دارد
(Jw.prototype.match = function (env, t) {
  var i = this.keys,
    n = env.indexOf("?"),
    r = ~n ? env.slice(0, n) : env, // حذف پارامترهای کوئری از مسیر
    a = this.regexp.exec(decodeURIComponent(r));
  if (!a) return !1;
  for (var ObjectMethodWrapper = 1, CounterVariable = a.length; ObjectMethodWrapper < CounterVariable; ++ObjectMethodWrapper) {
    var RandomGenerator = i[ObjectMethodWrapper - 1],
      HelperFunction = this.page._decodeURLEncodedURIComponent(a[ObjectMethodWrapper]);
    (void 0 === HelperFunction && hasOwnProperty.call(t, RandomGenerator.name)) || (t[RandomGenerator.name] = HelperFunction);
  }
  return !0;
});

// ساختار اصلی مدیریت مسیرها
var Kw = (function env() {
  var t = new qw();

  function i() {
    return Qw.apply(t, arguments);
  }

  return (
    // متدها و خواص مدیریت مسیرها به این شیء اختصاص داده می‌شوند
    (i.callbacks = t.callbacks),
    (i.exits = t.exits),
    (i.base = t.base.bind(t)),
    (i.strict = t.strict.bind(t)),
    (i.start = t.start.bind(t)),
    (i.stop = t.stop.bind(t)),
    (i.show = t.show.bind(t)),
    (i.back = t.back.bind(t)),
    (i.redirect = t.redirect.bind(t)),
    (i.replace = t.replace.bind(t)),
    (i.dispatch = t.dispatch.bind(t)),
    (i.exit = t.exit.bind(t)),
    (i.configure = t.configure.bind(t)),
    (i.sameOrigin = t.sameOrigin.bind(t)),
    (i.clickHandler = t.clickHandler.bind(t)),
    (i.create = env),
    Object.defineProperty(i, "len", {
      get: function () {
        return t.len;
      },
      set: function (env) {
        t.len = env;
      },
    }),
    Object.defineProperty(i, "current", {
      get: function () {
        return t.current;
      },
      set: function (env) {
        t.current = env;
      },
    }),
    (i.Context = Zw),
    (i.Route = Jw),
    i
      );
    })(),
    $w = Kw,
    eT = Kw;
  $w.default = eT;
  var tT,
    iT,
    nT,
    rT = (function (env) {
      function t() {
        var env;
        return (
          es(this, t),
          ((env = ls(this, rs(t).call(this))).clickEvent = document.ontouchstart
            ? "touchstart"
            : "click"),
          (env.keepSearch = !0),
          document.addEventListener(env.clickEvent, env.onClick.bind(StringStorage(StringStorage(env)))),
          env
        );
      }

return (
  // ارث‌بری کلاس t از کلاس ps
  ns(t, ps),
  // تعریف متدها برای کلاس t
  is(t, [
    {
      key: "addRoute",
      value: function (t) {
        var i = this;
        // اضافه کردن یک مسیر جدید و تعیین تابع callback برای تغییر مسیر
        $w(t.url, function (env) {
          i.onRouteChange(t);
        });
      },
    },
    {
      key: "start",
      value: function () {
        // شروع مسیریابی با غیرفعال کردن dispatch و کلیک
        $w.start({ dispatch: !1, click: !1 });
      },
    },
    {
      key: "onRouteChange",
      value: function (env) {
        // انتشار رویداد "change" برای اطلاع دادن به سیستم
        this.emit("change", env);
      },
    },
    {
      key: "gotoHref",
      value: function (env, t) {
        // تغییر مسیر به URL جدید اگر با مسیر فعلی متفاوت باشد
        t !== window.location.pathname && $w.show(t);
      },
    },
    {
      key: "isSameOrigin",
      value: function (env) {
        // بررسی اینکه URL ورودی متعلق به همان دامنه است یا خیر
        var t = location.protocol + "//" + location.hostname;
        location.port && (t += ":" + location.port);
        return env && 0 === env.indexOf(t);
      },
    },
    {
      key: "onClick",
      value: function (env) {
        // هندل کردن رویداد کلیک برای جلوگیری از رویدادهای ناخواسته
        if (
          !(env.metaKey || env.ctrlKey || env.shiftKey || env.defaultPrevented)
        ) {
          var t = env.target,
            i = env.path || (env.composedPath ? env.composedPath() : null);

          // یافتن لینک مناسب در مسیر کلیک
          if (i)
            for (var n = 0; n < i.length; n++)
              if (
                i[n].nodeName &&
                "A" === i[n].nodeName.toUpperCase() &&
                i[n].href
              ) {
                t = i[n];
                break;
              }

          // بالا رفتن در درخت DOM برای یافتن لینک
          for (; t && "A" !== t.nodeName.toUpperCase(); )
            t = t.parentNode;

          // اگر لینک معتبر یافت شد، آن را هندل می‌کنیم
          t && "A" === t.nodeName.toUpperCase() && this.onLinkClick(env, t);
        }
      },
    },
    {
      key: "onLinkClick",
      value: function (env) {
        var t =
          1 < arguments.length && void 0 !== arguments[1]
            ? arguments[1]
            : null;
        // اگر پیش‌فرض رویداد لغو نشده باشد
        if (!env.defaultPrevented) {
          var i = t || env.currentTarget;
          // اگر لینک خاصیت دانلود نداشته باشد
          if (!i.hasAttribute("download")) {
            var n = i.getAttribute("href"),
              r = i.href;
            // اگر لینک معتبر باشد و به دامنه فعلی تعلق داشته باشد
            n &&
              n.length &&
              (-1 < n.indexOf("mailto:") ||
                (this.isSameOrigin(r) &&
                  (i.target ||
                    (env.preventDefault(),
                    this.keepSearch &&
                      window.location.search &&
                      (r += window.location.search),
                    this.gotoHref(r, i.pathname)))));
                }
              }
            },
          },
        ]),
        t
      );
    })(),
    aT = !0;

// تابع oT برای نمایش صفحه جدید با شناسه و ویژگی‌های داده شده
function oT(env) {
  var t = env.id,   // دریافت شناسه صفحه
      i = env.url,  // دریافت URL صفحه
      n = env.element, // دریافت المان HTML صفحه
      r = env.color, // دریافت رنگ صفحه
      a = tT.getScreen(t); // بررسی وجود صفحه با شناسه t
  if (!a) {
    var ObjectMethodWrapper = Qb[t] || Qb.default;
    // در صورتی که صفحه موجود نباشد، صفحه جدیدی ایجاد می‌شود
    a = new ds(ObjectMethodWrapper);
    tT.addScreen(t, a); // صفحه به سیستم اضافه می‌شود
  }
  var CounterVariable = { arguments: [{ id: t, element: n, url: i, color: r, owner: tT }] };
  // نمایش صفحه با ویژگی‌های مشخص شده
  tT.showScreen(t, null, CounterVariable);
}

// تابع sT برای مخفی یا نمایان کردن آیتم انتخاب شده
function sT() {
  aT ? (aT = !1) : (Hb.setSelectedItem(tT.currentItemId), Hb.hide());
}

// تابع lT برای نمایش یا مخفی کردن هشدار بر اساس وضعیت صفحه
function lT(env) {
  env.state === vl.OPEN ? Hb.hide() : Hb.show();
}

// تابع hT برای تغییر وضعیت صفحه و قفل یا باز کردن اسکرول صفحه
function hT(env) {
  yl.setState(env.isVisible ? vl.CLOSE : vl.OPEN),
  env.isVisible
    ? tT.currentScreen.lockScroll() // اگر صفحه بسته شود، اسکرول قفل می‌شود
    : tT.currentScreen.unlockScroll(); // اگر صفحه باز شود، اسکرول آزاد می‌شود
}

// تابع cT برای بروزرسانی اندازه صفحه و تغییرات مرتبط
function cT(env) {
  var t = tT && tT.currentScreen;
  if (
    ((app.windowWidth = window.innerWidth),
    (app.windowHeight = window.innerHeight),
    app.isMobile)
  ) {
    var i = 0.01 * app.windowHeight;
    // تنظیم متغیر --vh برای استفاده در استایل‌ها
    document.documentElement.style.setProperty("--vh", "".concat(i, "px"));
  }
  t && t.resize(env), Hb.resize(env); // تغییر اندازه صفحه و آیتم‌ها
}

// تابع uT برای استفاده از ویژگی‌های خاص در oT
function uT(env) {
  oT({ url: env.url, color: env.color, id: env.name });
}

// تنظیمات اولیه برای ابعاد صفحه و ویژگی‌های دستگاه
(window.app = window.app || {}),
(app.screenXS = 480),
(app.screenS = 600),
(app.screenM = 900),
(app.screenL = 1280),
(app.screenXL = 1400),
(app.screenXXL = 1600),
(app.windowWidth = 0),
(app.windowHeight = 0),
(app.hasTouch = Modernizr.touchevents), // بررسی قابلیت لمس صفحه
(app.urlQuery = window.location.search), // استخراج query از URL
(app.browser = document.documentElement.getAttribute("data-browser")), // استخراج نوع مرورگر
(app.skip =
  app.isDebug &&
  window.location.search &&
  -1 !== window.location.search.indexOf("skip")), // بررسی حالت debug
// تنظیمات سیستم صفحه‌سازی
((tT = new ws()).transitionType = xs.OutAndIn),
tT.on("transitionStart", sT),
yl.on("click", lT),
Hb.on("visibilityChange", hT),
(iT = new rT()).on("change", uT),
// افزودن روت‌های جدید به سیستم
app.routes.forEach(function (env) {
  iT.addRoute(env);
}),
iT.start(),
// راه‌اندازی سیستم آنالیز
app.analyticsId && Ll.init({ id: app.analyticsId }),
// جلوگیری از بازگشت به حالت قبلی در تاریخچه
"scrollRestoration" in window.history &&
  (window.history.scrollRestoration = "manual"),
// گوش دادن به رویداد تغییر اندازه پنجره
window.addEventListener("resize", cT),
cT(),
// نمایش صفحه ابتدایی
oT({
  id: (nT = document.querySelector(".page")).getAttribute("data-page"),
  element: nT,
});

})();
